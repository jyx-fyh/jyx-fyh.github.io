<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>printf底层剖析及可变参数探究 | 极简</title><meta name="keywords" content="printf, 底层, 剖析, Linux, 可变参数"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="printf, 底层, 剖析, Linux, 可变参数">
<meta property="og:type" content="article">
<meta property="og:title" content="printf底层剖析及可变参数探究">
<meta property="og:url" content="http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="printf, 底层, 剖析, Linux, 可变参数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/44.jpg">
<meta property="article:published_time" content="2023-01-07T07:36:00.000Z">
<meta property="article:modified_time" content="2023-03-16T13:19:05.403Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/44.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'printf底层剖析及可变参数探究',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-16 21:19:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">144</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/44.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">printf底层剖析及可变参数探究</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-07T07:36:00.000Z" title="发表于 2023-01-07 15:36:00">2023-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-16T13:19:05.403Z" title="更新于 2023-03-16 21:19:05">2023-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="printf底层剖析及可变参数探究"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文前置内容：<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/">可变参数列表</a>，<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>
本文参考文章：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/3422332/">《你必须知道的495个C语言问题》</a><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1231236/">《Linux内核完全注释》</a>《操作系统真相还原》<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-printf.html">printf-菜鸟教程</a><br>
本节对应分支：<code>printk</code></p>
</blockquote>
<h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3>
<p>相信每一位 C 选手写下的第一句代码都是下面这句经典的 Hello World 吧？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理所应当的，其中的 <code>printf</code> 函数也成为了咋们认识的第一个函数。对笔者个人而言， <code>printf</code> 是一个熟悉而陌生的函数，说熟悉是因为它伴随了我整个 C 语言的学习生涯；说陌生是因为学习过程中一直对它存疑，模模糊糊，始终没能一探究竟，不知道各位读者是否也是像笔者一样呢？记得 C 语言萌新阶段时，我时常吐槽 <code>printf</code> 中的那些格式符，如 <code>%d</code>、<code>%s</code>、<code>%c</code>、<code>%x</code> 等，乱七八糟的，实在是太难记啦！入门阶段时，我赞叹 <code>printf</code> 强大的格式处理能力，比如左右对齐、输出宽度、输出精度等；进阶阶段时，我又开始疑惑 <code>printf</code> 是如何做到参数可变的，但因为基础不足，就暂时搁浅。现在，天时地利人和，让我们对 <code>printf</code> 一网打尽吧！</p>
<p>本文将从以下几个方向逐个击破 <code>printf</code> ：</p>
<ul>
<li><strong><font color='gree'>默认参数提升</font></strong></li>
<li><strong><font color='gree'>可变参数的类型检查</font></strong></li>
<li><strong><font color='gree'>可变参函数实现原理</font></strong></li>
<li><strong><font color='gree'>其他注意事项</font></strong></li>
<li><strong><font color='gree'>printf源码详解</font></strong></li>
</ul>
<h3 id="font-color-red-默认参数提升-font"><font color='red'>默认参数提升</font></h3>
<p><strong><font color='orange'>注意，默认参数提升仅对可变参数列表有效</font></strong> ，其规则是：<strong><font color='orange'>char 和 short 自动提升为 int，float 自动提升为 double</font></strong> 。<br>
比如我们一定知道，<code>%f</code> 用来输出 float，<code>%lf</code> 则用来输出 double；但实际上 <code>%f</code> 可以同时表示 float 和 double 类型，而无需专门指定 <code>%lf</code> 来表示 double（因为 printf 只能看到双精度），如下图：<br>
<img src="/2022/img/image-20230108145958396.png" alt=""></p>
<blockquote>
<p>本操作系统未支持浮点（难度较大，非常麻烦），且笔者对浮点的硬件支持不太了解，所以下面不讨论浮点。</p>
</blockquote>
<p>将 char/short 提升为 int 的原因是：<strong><u>可变参函数的原型无法提供参数个数以及参数类型，所以编译器无法针对各个参数生成相应代码，因此只好统一为 int 类型</u></strong> 。</p>
<blockquote>
<p>比如 <code>printf</code> 的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span></span><br></pre></td></tr></table></figure>
<p>显然，<code>...</code> （即可变参数列表）无法提供参数的个数和类型。值得一提的是，<code>printf</code> 中的 <code>f</code> 就是指的 <code>format</code> 。</p>
</blockquote>
<p>这么说原因大家可能还不太明白什么意思，下面笔者用代码进行解释，先来看普通函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">    test(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该文件生成的反汇编为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line">   4:   83 e4 f0                and    esp,0xfffffff0</span><br><span class="line">   7:   ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line">   a:   55                      push   ebp</span><br><span class="line">   b:   89 e5                   mov    ebp,esp</span><br><span class="line">   d:   51                      push   ecx</span><br><span class="line">   e:   83 ec 14                sub    esp,0x14</span><br><span class="line">  11:   c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">  18:   66 c7 45 f2 02 00       mov    WORD PTR [ebp-0xe],0x2</span><br><span class="line">  1e:   c6 45 f1 03             mov    BYTE PTR [ebp-0xf],0x3</span><br><span class="line">  22:   0f be 55 f1             movsx  edx,BYTE PTR [ebp-0xf]</span><br><span class="line">  26:   0f bf 45 f2             movsx  eax,WORD PTR [ebp-0xe]</span><br><span class="line">  2a:   83 ec 04                sub    esp,0x4</span><br><span class="line">  2d:   52                      push   edx</span><br><span class="line">  2e:   50                      push   eax</span><br><span class="line">  2f:   ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line">  32:   e8 fc ff ff ff          call   33 &lt;main+0x33&gt;</span><br><span class="line">  37:   83 c4 10                add    esp,0x10</span><br><span class="line">  3a:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3f:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">  42:   c9                      leave  </span><br><span class="line">  43:   8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line">  46:   c3                      ret    </span><br><span class="line"></span><br><span class="line">00000047 &lt;test&gt;:</span><br><span class="line">  47:   55                      push   ebp</span><br><span class="line">  48:   89 e5                   mov    ebp,esp</span><br><span class="line">  4a:   83 ec 08                sub    esp,0x8</span><br><span class="line">  4d:   8b 55 0c                mov    edx,DWORD PTR [ebp+0xc]</span><br><span class="line">  50:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">  53:   66 89 55 fc             mov    WORD PTR [ebp-0x4],dx</span><br><span class="line">  57:   88 45 f8                mov    BYTE PTR [ebp-0x8],al</span><br><span class="line">  5a:   c7 45 08 0a 00 00 00    mov    DWORD PTR [ebp+0x8],0xa</span><br><span class="line">  61:   66 c7 45 fc 0b 00       mov    WORD PTR [ebp-0x4],0xb</span><br><span class="line">  67:   c6 45 f8 0c             mov    BYTE PTR [ebp-0x8],0xc</span><br><span class="line">  6b:   90                      nop</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   c3                      ret  </span><br></pre></td></tr></table></figure>
<p>从第 34~36 行就可以看出参数类型的区别：int、short、char 对应的反汇编分别为 DWORD、WORD、BYTE ，也就是说，编译器为不同的类型生成了不同的代码。</p>
<blockquote>
<p>笔者以前想当然地认为函数参数类型影响的是压栈的字节数，比如将 char 压入栈，对应的反汇编就应该为 <code>push BYTE PTR [xxx]</code> ；实际上并非如此，<strong><font color='orange'>不论是 char、short、int 或是 long、long long，编译器都会压入 4 字节（对于 long long 8 字节，分两次压入）</font></strong> ，这点从 15~17 行就能体现。所以参数类型影响的不是压栈，而影响的是从栈中取值或赋值。</p>
</blockquote>
<p>那么对于可变参数列表，默认参数提升是如何体现的呢？待会讲解 <code>printf</code> 源码时再回过头来说这点。</p>
<h3 id="font-color-red-可变参数的类型检查-font"><font color='red'>可变参数的类型检查</font></h3>
<p>还是由于可变参数列表无法提供参数类型，所以编译器无法对参数进行类型检查，换句话说，<strong>编译器不能执行默认的类型转换，通常也不会报错</strong> 。对于普通函数而言，如果实参和形参类型不匹配，编译器会将实参隐式转换为形参类型，如下：<br>
<img src="/2022/img/image-20230108153040201.png" alt=""></p>
<p>而对于可变参数函数，编译器则无法将实参隐式转换为形参类型，如下：<br>
<img src="/2022/img/image-20230108153229945.png" alt=""><br>
所以程序员必须自己确保参数类型的匹配或手动强制转换。</p>
<h3 id="font-color-red-可变参数函数实现原理-font"><font color='red'>可变参数函数实现原理</font></h3>
<p>想要实现可变参数，最重要的是明白其函数的调用方式，如果没有特定的<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>，可变参数将无从谈起。<strong><u>可变参数函数的调用方式必须满足以下两个条件：</u></strong></p>
<ol>
<li>
<p><strong><font color='orange'>从右向左压栈</font></strong></p>
<blockquote>
<p>为什么要从右往左入栈？ 因为如果从左向右，编译器就不知道用户传入了多少实参。参数的信息是由第一个参数 <code>fmt...</code> 确定的（如 <code>printf (“% s % s”,str1 ,str2)</code> 的参数信息是通过检测两个 <code>%s</code> 来获取的）。若从左向右压栈，<code>fmt...</code> 就被放入了栈底，而 esp 由于不清楚参数个数和类型，就无法跨过这些参数来指向 <code>fmt...</code> ，因此无法获取各个参数的信息。相反，若从右向左压栈，<code>fmt...</code> 就存放在栈顶，这样就可以直接通过它得知参数的个数和类型，进而准确从栈中取得各个参数。</p>
</blockquote>
</li>
<li>
<p><strong><font color='orange'>外平栈（调用者平栈）</font></strong></p>
<blockquote>
<p>必须由调用者平栈的原因是：只有调用者才知道压入了几个参数，所以也只能由调用者进行平栈。读者可能感到疑惑，为什么只有调用者才知道压入了几个参数？仍然拿 <code>printf</code> 举例，是这样的：<code>printf</code> 作为库函数，是提前被编译好了的（一般作为动态链接库），最后直接与我们自己编写生成的可重定位文件链接在一起，从而生成可执行文件；所以 <code>printf</code> 完全不知道实际压入了多少个参数（因为压参是由我们的编译器进行的）！因此也就无法由 <code>printf</code> 自己来完成平栈。相反，如果是调用方本身来调用的 <code>printf</code> ，理所应当地，调用方就知道自己向栈中压入了多少个参数，所以调用方就可以承担平栈任务，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d  %c&quot;, 1, 2);</span><br><span class="line">&#125;</span><br><span class="line">//对应汇编：</span><br><span class="line">//......省略</span><br><span class="line">00BF17E1  push        2  </span><br><span class="line">00BF17E3  push        1  </span><br><span class="line">00BF17E5  push        offset string &quot;%d\n&quot; (0BF7BD8h)  </span><br><span class="line">00BF17EA  call        _printf  </span><br><span class="line">00BF17EF  add         esp,0Ch  </span><br><span class="line">//......省略</span><br></pre></td></tr></table></figure>
<p>call 之前，编译器 push 了三次，所以它当然知道平栈需要 add esp,0xC ！而 printf 是已经编好的库，它就不知道 push 了几次。</p>
</blockquote>
</li>
</ol>
<p>而 __cdel 调用约定就符合以上两个规则，所以可变参函数必须使用此方式。值得一提的是，__cdel 是 C/C++ 默认方式。<br>
有了以上两种条件的支持，现在无非就是处理 <code>fmt...</code> 获取参数信息，然后从栈中取得参数即可。这就是咋们接下来要干的事。</p>
<h3 id="font-color-red-其他注意事项-font"><font color='red'>其他注意事项</font></h3>
<p><strong><mark class="hl-label blue">需要打印%咋办？</mark> </strong><br>
这点相信大部分读者都清楚，打印百分号需要再加个百分号，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是百分号%%&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>很多小白会在 <code>%</code> 前加 <code>\</code> ，即 <code>printf(&quot;\%&quot;)</code> 来输出百分号。出现这种想法是因为没有理解转义字符的意义，要知道，<code>\n</code> 是一个 ASCII 码（10），由编译器负责将 <code>\n</code> 转为 10 。而 <code>\%</code> 可不是转义字符，对 <code>%</code> 的处理是由我们的代码负责，而不是由编译器负责！</p>
<p><strong><mark class="hl-label blue">printf实参问题</mark> </strong><br>
很多读者应该都像下面这种方式调用过 printf 吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式有什么不对吗？结果正确，但这种调用方式十分危险。这是因为，<code>110</code> 没有指明类型，所以根据前面的默认参数提升，<code>110</code> 被视为 int，这符合 <code>%d</code> ，所以能够正确输出。但是碰到下面这种情况呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure>
<p>结果就变得诡异，输出如下：<br>
<img src="/2022/img/image-20230110115919374.png" alt=""><br>
这是因为 <code>110</code> 被编译器视为 int（4字节)，但 printf 内部代码根据 <code>%lld</code> 将 <code>110</code> 视为 long long（8字节)，在定位参数时，将 long long* 指针指向 <code>110</code> 所在的位置，那么用该指针解释数据的时候，将会把 <code>110</code> 后面的四字节包含进去，而这四字节中的数据是未定义的，所以造成以上错误。再来看下面的调用：<br>
<img src="/2022/img/image-20230110130458876.png" alt=""><br>
怎么这种情况又能够正确显示呢？这是因为编译器判定 <code>0xfffffffff</code> 无法用 int 装下，所以该值的类型就变为了 long long，因此能够正确输出。正确的调用方式需要加上强制转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)<span class="number">110</span>);</span><br></pre></td></tr></table></figure>
<p>看完 printf 源码后，你会对上述行为有深刻理解。</p>
<h3 id="font-color-red-printf源码剖析-font"><font color='red'>printf源码剖析</font></h3>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>以下源码来自 Linux 0.11 ，也就是 Linus Torvalds 编写的初代 Linux ，所以其功能肯定不如现在的 printf 强大，这点读者需要清楚。</li>
<li>printk（print kernel）和 printf 的功能完全相同，只不过前者是在内核中使用的打印函数，而后者是在用户态中使用的打印函数。</li>
<li>为了契合咋们的操作系统，笔者会将 printk 作轻微修改，使其能够在用户态下使用（此时也就变成了 printf ），这不会影响对 printf 的理解。</li>
</ul>
</blockquote>
<p>以下是原版的 <code>printk</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">	va_end(args);</span><br><span class="line">	__asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;pushl $_buf\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;call _tty_write\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">		::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>提供原版的 printk 只是为了与下面咋们改进后的 printf 形成对比，大家无需纠结上面的代码</u>。以下是我们操作系统的 <code>printf</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> </span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="type">int</span> i = write(buf);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可见，除了第 9 行外，其他完全相同。实际上，第 9 行将最终的字符串传给我们之前实现的系统调用 write，由 write 进行打印。另外，<strong><font color='orange'>正因为 write 是系统调用，所以该 printf 既可以供内核使用，也可以供用户使用</font></strong> 。</li>
<li><code>printf</code> 返回字符个数。</li>
</ul>
<p>接下来重点说明处理可变参数的四个宏： <code>va_list</code> 、<code>va_start</code> 、<code>va_end</code> 和 <code>va_arg</code> 。</p>
<p><strong><mark class="hl-label blue">可变参数宏</mark> </strong><br>
首先要破除大家的先入为主，别以为这四个宏是用来处理可变参数的，就觉得它们高大上，有什么特异功能，实际上这四个家伙的本质就普普通通：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(p, fmt) (p = (char*)&amp;fmt + sizeof(char*))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(p)        (p = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(p, type)  (p += __va_rounded_size(type), *((type*)(p - __va_rounded_size (type))))</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><em><em><code>va_list</code> <u>就是 char</em> 指针类型，该指针（args）用来在栈中依次遍历各个参数</u></em>* 。</p>
</li>
<li>
<p><strong><code>va_start</code> <u>的作用是将 args 指针指向参数列表（即 <code>...</code> ）中的第一个参数</u></strong> 。</p>
<blockquote>
<p><code>p = (char*)&amp;fmt + sizeof(char*)</code> 就是令 p 跳过栈中的 fmt ，指向栈中的下一个参数，即参数列表中的第一个参数。注意必须对 fmt 取地址，得到该指针的地址，也就是该指针在栈中的位置，<code>&amp;fmt</code> 为二级指针，还需要强制转换为一级指针 char* 。</p>
</blockquote>
</li>
<li>
<p><strong><code>va_end</code> <u>的作用是将 args 指针置 NULL</u></strong> 。</p>
</li>
<li>
<p><code>va_arg</code> 出现在下面的 <code>vsprintf</code> 函数中，<strong><u><code>va_arg</code> 的作用是返回当前 args 指向的参数的值，然后 args 向后移动，指向下一个参数</u></strong> 。</p>
<blockquote>
<p><code>__va_rounded_size(type)</code> 也是一个宏，<strong><u>用来得到取整后的 type 类型的大小，是 int 的整数倍</u></strong> ，比如 type 为 char，则返回 4；type 为 long long，则返回 8 ，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __va_rounded_size(type)  \</span></span><br><span class="line"><span class="meta">  (((sizeof (type) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span></span><br></pre></td></tr></table></figure>
<p>注意，va_arg 宏定义是一个逗号表达式，第一个表达式<u>根据目前所指参数 A 的大小</u>，将指针 p 移向了下一个参数 B（+=，p的值已经被改变）；接着将 A 的值返回（逗号表达式中的最后一个式子作为返回值）。顺便提一下，如果按照《操作系统真相还原》中的代码，将无法应对 long long 的情况。</p>
</blockquote>
</li>
</ul>
<p>接着来看 vsprintf 。</p>
<p><strong><mark class="hl-label blue">vsprintf</mark> </strong><br>
<strong>vsprintf 的作用是格式化字符串，也就是将参数列表中的所有参数值填入到 fmt 中的对应位置，并将最终的字符串存入 buf</strong> 。<code>fmt</code> 中的格式符，如 <code>%d</code> 、<code>%s</code> 等都在此函数中进行处理。在讲解该函数代码前，有必要先复习 printf 的用法，否则看代码时将一头雾水。</p>
<p>我们将 <code>%s</code> 这样的格式称之为一个 format 标签，format 标签的完整格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure>
<p>比如下面这样的 printf 调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10ld&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>其中的 <code>-</code> 为 flags，即指明左对齐；<code>10</code> 为 width，即指明输出宽度；<code>l</code> 为长度，对于 <code>d</code> 而言，即输出长整型 long；<code>d</code> 为 specifier，指明输出整型。<br>
具体规则如下：</p>
<table>
<thead>
<tr>
<th><strong>flags</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-</strong></td>
<td>在给定的字段宽度内左对齐，默认是右对齐</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td>
</tr>
<tr>
<td><strong>空格</strong></td>
<td>如果没有写入任何符号，则在该值前面插入一个空格。</td>
</tr>
<tr>
<td><strong>#</strong></td>
<td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。由于本操作系统暂不支持小数，所以不说明 # 对 f、e、g 等说明符的影响。</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>在左边填充零，而不是空格</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>width</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充；如果输出的值长于该数，结果不会被截断。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定宽度。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">.precision（精度）</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>.number</strong></td>
<td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 <br />对于 s：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 <br />对于 c：没有任何影响。 当未指定任何精度时，默认为 1。</td>
</tr>
<tr>
<td style="text-align:left"><strong>.</strong>*</td>
<td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定精度。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>length</strong></th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>h</strong></td>
<td style="text-align:left">参数被解释为短整型或无符号短整型 short（仅适用于整数说明符：i、d、o、u、x 和 X）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>l</strong></td>
<td style="text-align:left">参数被解释为长整型或无符号长整型 long，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>L</strong></td>
<td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。本操作系统不支持。</td>
</tr>
<tr>
<td style="text-align:left"><strong>ll</strong></td>
<td style="text-align:left">本操作系统中，ll 仅被解释为 <strong>无符号 long long</strong>，适用于整数说明符。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">格式字符</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td>
</tr>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">和 d 完全相同</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<td style="text-align:left">x,X</td>
<td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀Ox)</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">以十进制形式输出无符号整数</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">输出单个字符</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">输出字符串</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">输出指针地址</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">到目前为止成功写入缓冲区的字符数，此值存储在指定的整数中，其地址作为参数给出。</td>
</tr>
</tbody>
</table>
<p>下面做几个示范：<br>
<img src="/2022/img/image-20230109092042387.png" alt=""><br>
<img src="/2022/img/image-20230109092442698.png" alt=""><br>
<img src="/2022/img/image-20230109094520482.png" alt="由于安全原因，VS默认禁止使用%n，所以此处用 Bochs 代替"></p>
<p>了解以上格式后，再来看 vsprintf 就十分轻松啦，总的来说，该函数就是在依次处理 flags --&gt; width --&gt; .precision --&gt; length --&gt; specifier 。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成2的倍数,是因为我们将flag变量视为位图,将属性保存到各个二进制位上</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD	1		<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN	2		<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS	4		<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE	8		<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT	16		<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL	32		<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL	64		<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	<span class="type">char</span>* s;</span><br><span class="line">	<span class="type">int</span> *ip;</span><br><span class="line">	<span class="type">int</span> flags;          <span class="comment">// flags to number() </span></span><br><span class="line">	<span class="type">int</span> field_width;    <span class="comment">// width of output field </span></span><br><span class="line">	<span class="type">int</span> precision;      <span class="comment">// min of digits for integers; max number of chars for from string </span></span><br><span class="line">	<span class="type">int</span> qualifier;      <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (str=buf ; *fmt ; ++fmt) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//如果不是format标签,则直接复制到str</span></span><br><span class="line">		<span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*str++ = *fmt;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//处理flags</span></span><br><span class="line">		flags = <span class="number">0</span>;</span><br><span class="line">		repeat:</span><br><span class="line">			++fmt;		</span><br><span class="line">			<span class="keyword">switch</span> (*fmt) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理输出宽度</span></span><br><span class="line">		field_width = <span class="number">-1</span>; <span class="comment">//默认为-1,即未指示宽度,因为 flag | -1 = flag</span></span><br><span class="line">		<span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">			field_width = skip_atoi(&amp;fmt); <span class="comment">//skip_atoi将字符转为数字,后文给出</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">			field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则width由下一个参数给出 </span></span><br><span class="line">			<span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)  <span class="comment">//若宽度参数小于0,则左靠齐,和&#x27;-&#x27;号效果相同</span></span><br><span class="line">			&#123;</span><br><span class="line">				field_width = -field_width;</span><br><span class="line">				flags |= LEFT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理精度</span></span><br><span class="line">		precision = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			++fmt;	</span><br><span class="line">			<span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">				precision = skip_atoi(&amp;fmt);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">				fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">				precision = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则precision由下一个参数给出 </span></span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">				precision = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理长度描述符符</span></span><br><span class="line">		qualifier = <span class="number">-1</span>;  </span><br><span class="line">		<span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			qualifier = *fmt;  <span class="comment">//实际上,后面就没有用到qualifier了,显得鸡肋</span></span><br><span class="line">			++fmt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理格式字符</span></span><br><span class="line">		<span class="keyword">switch</span> (*fmt) </span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; LEFT)) <span class="comment">//如果不是左靠齐,则左边补field_width-1个空格</span></span><br><span class="line">				<span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">					*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			*str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line">			<span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) <span class="comment">//否则后方补空格</span></span><br><span class="line">				*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">			s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">			len = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">				precision = len;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) <span class="comment">//如果字符串长度大于精度,则丢弃超过精度的部分</span></span><br><span class="line">				len = precision;</span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">				<span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">					*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">				*str++ = *s++;</span><br><span class="line">			<span class="keyword">while</span> (len &lt; field_width--)<span class="comment">//如果执行了上面的while,此处就不会再执行</span></span><br><span class="line">				*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:  <span class="comment">//number函数用来将数字转换为字符串</span></span><br><span class="line">			str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="comment">//按十六进制输出指针,宽度为8,宽度不足则补前导0</span></span><br><span class="line">			<span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				field_width = <span class="number">8</span>;</span><br><span class="line">				flags |= ZEROPAD;</span><br><span class="line">			&#125;</span><br><span class="line">			str = number(str,(<span class="type">unsigned</span> <span class="type">int</span>)va_arg(args,<span class="type">void</span>*), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">			flags |= SMALL;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">			str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">			flags |= SIGN;  <span class="comment">//%d和%i都是有符号数</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">			str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">			ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">			*ip = (str - buf); <span class="comment">//返回目前字符串的宽度</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若格式转换符不是&#x27;%,则表示格式字符串有错,直接将一个%写入输出串中;如果格式转换符的位置处还有字符,则也直接将该字符写入输</span></span><br><span class="line">        <span class="comment">//出串中,并返回到107行继续处理格式字符串;否则表示已经处理到格式字符串的结尾处,则退出循环。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">				*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (*fmt)</span><br><span class="line">				*str++ = *fmt;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				--fmt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释得比较清楚，对照之前的规则来看代码就很容易理清其中的逻辑，不再详细说明。提一点，看第 90 行，<code>va_arg(args, int)</code> ，这说明从栈中取字符时，是以 int 大小来取的（ <strong><u><font color='orange'>这里就体现了默认参数提升</font></u></strong> ），然后再被强制转换为 char 。为什么不能 <code>va_arg(args,char)</code> 呢？实际上这样完全能够准确获取栈中字符的值，但如果这样的话，下一次使用 va_arg 宏取参数时，args 指针就指向了该字符的下一字节，但下一个参数应该是在该字符的四字节后，这无疑将引发错误，图示如下：<br>
<img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE35.png" alt=""></p>
<p>代码中还用到了 skip_atoi() 和 number() 函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)	((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//判断是否为数字字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \    <span class="comment">// n=n/base,并返回n%base</span></span></span><br><span class="line"><span class="type">int</span> __res; \                   <span class="comment">//宏定义采用大括号的方式,最后一条语句作为返回值</span></span><br><span class="line">__asm__(<span class="string">&quot;div %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (n),<span class="string">&quot;=d&quot;</span> (__res):<span class="string">&quot;0&quot;</span> (n),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),<span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">__res; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span><span class="comment">//pointer to fmt,即fmt的指针,所以该指针为二级指针</span></span><br><span class="line">&#123;                                      <span class="comment">//为什么要用二级指针?因为咋们要在函数中修改fmt的值(不仅是修改形参,实参也要修改)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;                           <span class="comment">//由于fmt是指针,所以要修改指针的值,就需要用二级指针</span></span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//(*fmtp)++,就是fmt++</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision	,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (type&amp;SMALL) </span><br><span class="line">		digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (type&amp;LEFT) </span><br><span class="line">		type &amp;= ~ZEROPAD; <span class="comment">//如果为左对齐,则无需0填充</span></span><br><span class="line">	<span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>) <span class="comment">//仅支持2~36进制,否则返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		num = -num; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);<span class="comment">//要么+,要么空1格</span></span><br><span class="line">	<span class="keyword">if</span> (sign)</span><br><span class="line">		size--; <span class="comment">//如果有符号或空格,则占一位</span></span><br><span class="line">	<span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">			size -= <span class="number">2</span>; <span class="comment">//0x占两位</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">			size--;    <span class="comment">//0占一位</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 以下开始处理数字</span></span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">		tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">			tmp[i++]=digits[ do_div(num,base) ]; <span class="comment">//依次取得num的最低位数字,并填入tmp,</span></span><br><span class="line">	<span class="keyword">if</span> (i&gt;precision)		                     <span class="comment">//此时顺序是反的,第72行会调整顺序</span></span><br><span class="line">		precision=i; <span class="comment">//如果数字个数大于精度,不会截断,精度成鸡肋</span></span><br><span class="line">	size -= precision;</span><br><span class="line">	<span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">		<span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">			*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (sign)</span><br><span class="line">		*str++ = sign;</span><br><span class="line">	<span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">		<span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">			*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			*str++ = digits[<span class="number">33</span>]; <span class="comment">//&#x27;X&#x27;或&#x27;x&#x27;,取决于digit的指向</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line">		<span class="keyword">while</span>(size--&gt;<span class="number">0</span>) <span class="comment">//如果是右靠齐,则补前导0或前导空格</span></span><br><span class="line">			*str++ = c;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;precision--)<span class="comment">//精度大于数字个数,则补前导0</span></span><br><span class="line">		*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">		*str++ = tmp[i];<span class="comment">//i--,str++,调整数字顺序</span></span><br><span class="line">	<span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">		*str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果67行已经执行,此处就不会再执行</span></span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释详尽，不再说明。<br>
值得一提的是，该版 printf 有许多不足，例如不支持 <code>%hd</code> (short)，<code>%lld</code> (long long) ，下节<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/">printf加强版</a>中我们会增加这两个功能。<br>
<img src="/2022/img/image-20230110134655302.png" alt=""></p>
<p>本文结束。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/44.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/"><img class="prev-cover" src="/2022/img/50.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">printf加强-支持short与long long</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="/2022/img/47.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">实现用户进程-代码详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/" title="C语言中的#和##"><img class="cover" src="/2022/img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">C语言中的#和##</div></div></a></div><div><a href="/2022/06/20/assert-%E4%B8%8Eif/" title="详解assert与if"><img class="cover" src="https://jyxcpp.netlify.app/img/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-20</div><div class="title">详解assert与if</div></div></a></div><div><a href="/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/" title="printf加强-支持short与long long"><img class="cover" src="/2022/img/50.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">printf加强-支持short与long long</div></div></a></div><div><a href="/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/" title="memcpy与memmove的区别"><img class="cover" src="/2022/img/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">memcpy与memmove的区别</div></div></a></div><div><a href="/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/" title="详解函数调用过程和约定"><img class="cover" src="/2022/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">详解函数调用过程和约定</div></div></a></div><div><a href="/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/" title="可变长参数列表"><img class="cover" src="/2022/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">可变长参数列表</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%A6%82%E8%A7%88-font"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%8F%90%E5%8D%87-font"><span class="toc-number">2.</span> <span class="toc-text">默认参数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5-font"><span class="toc-number">3.</span> <span class="toc-text">可变参数的类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-font"><span class="toc-number">4.</span> <span class="toc-text">可变参数函数实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-font"><span class="toc-number">5.</span> <span class="toc-text">其他注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-printf%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-font"><span class="toc-number">6.</span> <span class="toc-text">printf源码剖析</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>