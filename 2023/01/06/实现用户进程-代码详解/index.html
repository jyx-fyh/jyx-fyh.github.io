<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>实现用户进程-代码详解 | 极简</title><meta name="keywords" content="自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布">
<meta property="og:type" content="article">
<meta property="og:title" content="实现用户进程-代码详解">
<meta property="og:url" content="http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/47.jpg">
<meta property="article:published_time" content="2023-01-06T09:17:36.000Z">
<meta property="article:modified_time" content="2023-03-12T11:21:04.354Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="自制操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/47.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '实现用户进程-代码详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:21:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
<script src="/assets/js/DPlayer.min.js"></script></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/47.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">实现用户进程-代码详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-06T09:17:36.000Z" title="发表于 2023-01-06 17:17:36">2023-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:21:04.354Z" title="更新于 2023-03-12 19:21:04">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="实现用户进程-代码详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文前置内容：<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程-进入用户态</a><br>
本节对应分支：<code>userprog</code></p>
</blockquote>
<h3 id="font-color-red-初始化TSS、C语言接管GDT-font"><font color='red'>初始化TSS、C语言接管GDT</font></h3>
<p>下面是 <code>global.h</code> 中添加的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="comment">//=============用户进程的段选择子================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_CODE	   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_DATA	   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span></span><br><span class="line"><span class="comment">// ===============GDT描述符属性=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DESC_G_4K    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DESC_D_32    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_L	     0	<span class="comment">// 64位代码标记，此处标记为0便可。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_AVL     0	<span class="comment">// cpu不用此位，暂置为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_P	     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_1   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_2   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_3   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_CODE	1       <span class="comment">// s为1时表示存储段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_DATA	DESC_S_CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_SYS	0       <span class="comment">// s为0时表示系统段.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_CODE	8	<span class="comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_DATA  2	<span class="comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_TSS   9	<span class="comment">// B位为0,不忙</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ATTR_HIGH		     ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_CODE_ATTR_LOW_DPL3	 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_DATA_ATTR_LOW_DPL3	 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span></span><br><span class="line"><span class="comment">//================ TSS描述符属性===================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_DESC_D  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_LOW ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_TSS ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2 ) + RPL0)</span></span><br><span class="line"><span class="comment">//================ GDT描述符 =====================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit_low_word;</span><br><span class="line">    <span class="type">uint16_t</span> base_low_word;</span><br><span class="line">    <span class="type">uint8_t</span>  base_mid_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  attr_low_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  limit_high_attr_high;</span><br><span class="line">    <span class="type">uint8_t</span>  base_high_byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第 3~5 行定义了用户进程的段选择子，其中代码段选择子索引为 5，即用户代码段的描述符位于 GDT 的第 5 号描述符的位置处；数据段和栈段共享一个描述符，选择子索引为 6 。你可能会疑惑，为什么只定义了一套用户的选择子，万一将来有多个用户进程同时运行，这几个选择子岂不是不够用？实际上只需要一套用户选择子就可以了，<strong><font color='orange'>因为所有用户进程都共享这一套选择子</font></strong> 。为什么可以共享呢？这便体现出虚拟空间下平坦模型的优越性了。<strong><font color='orange'><u>因为每个进程都有自己独立的虚拟地址空间，平坦模型下数据段和代码段描述符的基址直接设为 0，所以执行流只取决于 EIP 而依赖 CS。反观分段模型，由于没有虚拟地址空间，各个用户进程被分配到不同区域的物理内存中，所以为了隔离它们，每个用户进程的段基址都不相同，因此需要为每个用户进程都分配一套段选择子和段描述符</u></font></strong> ，不仅管理繁琐，而且效率低下。<br>
另外，当初咋们在 <code>loader.s</code> 中设计 GDT 表时，并没有为用户和 TSS 预留段描述符，所以现在必须在 <code>loader.s</code> 中加上一行代码以预留空间：<br>
<img src="/2022/img/image-20230103153548106.png" style="zoom:100%;" /></li>
<li>之前是在 <code>loader.s</code> 中直接书写 GDT ，为了方便，现在我们使用 C 语言接管 GDT，以方便在 GDT 中添加和修改段描述符。所以在头文件中定义了段描述符和 TSS 描述符的各个属性以及段描述符的结构体 <code>gdt_struct</code> 。关于各个位的解释，参见<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">GDT</a> 。</li>
</ul>
<p>下面是 <code>tss.c</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">gdt_operand</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> tss_slt;</span><br><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> backlink;</span><br><span class="line">    <span class="type">uint32_t</span>* esp0;</span><br><span class="line">    <span class="type">uint32_t</span> ss0;</span><br><span class="line">    <span class="type">uint32_t</span>* esp1;</span><br><span class="line">    <span class="type">uint32_t</span> ss1;</span><br><span class="line">    <span class="type">uint32_t</span>* esp2;</span><br><span class="line">    <span class="type">uint32_t</span> ss2;</span><br><span class="line">    <span class="type">uint32_t</span> cr3;</span><br><span class="line">    <span class="type">uint32_t</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> ldt;</span><br><span class="line">    <span class="type">uint32_t</span> trace;</span><br><span class="line">    <span class="type">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新tss中esp0字段的值为pthread的0级线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tss_esp</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    tss.esp0 = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建gdt描述符 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gdt_desc <span class="title function_">make_gdt_desc</span><span class="params">(<span class="type">uint32_t</span>* desc_addr, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> attr_low, <span class="type">uint8_t</span> attr_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> desc_base = (<span class="type">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="type">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="type">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在gdt中创建tss并重新加载gdt */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tss_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"><span class="comment">/* gdt基址为0x910,把tss放到第4个位置,也就是0x910+0x20的位置 */</span></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">   *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000930</span>)  = make_gdt_desc((<span class="type">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000940</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    load_xdt(&amp;gdt_operand,<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>,<span class="number">0xc0000910</span>);</span><br><span class="line">    tss_slt = SELECTOR_TSS;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lgdt gdt_operand&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ltr tss_slt&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init and ltr done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第 4~33 行定义了 TSS 结构，这没有太多要说的，有个小问题是，结构体定义不应该放在头文件中吗，这里为什么要放在 C 文件中呢？是不是不太规范？这也是笔者之前的误解，原以为只要是宏定义或者结构体定义一类的都应该放在头文件，而 C 文件中只放函数定义，这样才显得规范。实际上并不是如此，原则应该是：<strong><font color='orange'>如果其可见性超出一个 .c 文件，那么应当放入 .h 中，如果只是某一个 .c 里需要这么一个结构作为辅助，直接放入这个.c中更好一些</font></strong> 。放在 .c 还是 .h 取决于该结构是否要暴露给其他 .c，能放 .c 绝不放 .h 。而 TSS 结构只会在此文件中使用，所以就定义在此 .c 文件中。</li>
<li>第 37 行，update_tss_esp() 用来将 TSS 中 esp0 字段的值更新为 pthread 的内核线。如上节内容所说，所有任务共享一个 TSS，只是在任务切换时更新 ESP0 的值。</li>
<li>第 61 行，将 TSS 的 io_base 字段设置为 TSS 的大小，这表示此 TSS 中没有 IO 位图。</li>
<li>第 62 行，GDT 的基址为 0x910，这是如何确定的？见下面 <code>loader.s</code> 的片段即可知道。<br>
<img src="/2022/img/image-20230105121240944.png" style="zoom:67%;" /></li>
<li>第 69 行的 load_xdt 函数，咋们之前用它设置过 IDTR，定义在 global.h 中。gdt_operand 是加载 GDT 时用的操作数，设置好 gdt_operand 的基址和界限后，第 71 行便使用内联汇编 <code>lgdt</code> 指令加载 GDTR。至于为什么要将 gdt_operand 和 tss_slt 定义为全局静态变量，这在之前的文章中反复提及过，不再赘述。同理，第 72 行使用 <code>ltr</code> 指令将 TSS 的选择子 tss_slt 加载进 TR 寄存器，由于 TSS 只有一个，所以只会加载这一次，以后就不会再修改 TR 了。</li>
</ul>
<h3 id="font-color-red-用户进程的虚拟地址空间-font"><font color='red'>用户进程的虚拟地址空间</font></h3>
<p>在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础篇</a>中，我们划出了三个内存池：内核物理内存池、内核虚拟内存池、用户物理内存池。为了实现用户进程的虚拟地址空间，我们还需要给每个进程设置私有的用户虚拟内存池。见以下步骤。</p>
<p><strong><mark class="hl-label blue">在task_struct中添加虚拟内存池</mark> </strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;	      <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;	              <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       <span class="comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> <span class="comment">// general_tag的作用是用于线程在一般队列中的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span><span class="comment">// all_list_tag的作用是用于线程队列thread_all_list中的结点</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              <span class="comment">// 进程页表</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span>   <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第 14 行即为用户进程的虚拟内存池。</p>
<p><strong><mark class="hl-label blue">用户虚拟内存管理</mark> </strong><br>
在 <a href="">内存管理-进阶</a>中，我们留下了部分内容等到实现用户进程时补充，如下：<br>
<img src="/2022/img/image-20230105154723658.png" style="zoom:67%;" /><br>
第 33 行的作用和其上内核部分的代码相似，都是在申请虚拟内存。以下代码补齐这部分内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct* cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">        <span class="comment">/*0xc0000000-PAGE_SIZE作为3级用户栈已经在start_process中被分配*/</span></span><br><span class="line">        assert((<span class="type">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure>
<p>逻辑清晰，不再解释。另外还添加了几个必要的内存管理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_user_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="type">void</span>* vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将地址vaddr与pf池中的物理地址关联,仅支持一页空间分配 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_a_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="type">int32_t</span> bit_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;pgdir != <span class="literal">NULL</span> &amp;&amp; pf == PF_USER)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;pgdir == <span class="literal">NULL</span> &amp;&amp; pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span></span><br><span class="line">        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        panic(<span class="string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">    <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">    lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址映射到的物理地址 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">addr_v2p</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"><span class="comment">/* (*pte)的值是页表所在的物理页框地址,</span></span><br><span class="line"><span class="comment"> * 去掉其低12位的页表项属性+虚拟地址vaddr的低12位 */</span></span><br><span class="line">    <span class="keyword">return</span> ((*pte &amp; <span class="number">0xfffff000</span>) + (vaddr &amp; <span class="number">0x00000fff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>get_user_pages 和 get_kernel_page 的逻辑完全相同，不再赘述。提一下，笔者在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶</a>中提到过如下内容：</p>
<blockquote>
<p>扫描和设置位图必须连续，中间不能切换线程 。这里和线程切换有关，简单解释：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题 。因此扫描和设置位图必须保证原子操作。需要注意的是，此处代码并没有保证原子性，未来我们会用锁来实现 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p>
</blockquote>
<p>现在咋们已经实现了锁机制，所以这里申请内存时用锁来保证原子性。锁加在 pool 结构体中：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span>                      //管理物理内存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span>	 <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start;	 <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;		     <span class="comment">// 本内存池字节容量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>            <span class="comment">// 保证内存申请时的原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第 13 行定义 get_a_page 函数，该函数与 get_kernel_page 或 get_user_page 的差别在于前者能够申请指定位置的虚拟内存，而后者则无法指定位置。该函数待会用来指定在 0xc0000000 处申请一页虚拟内存作用户栈。</p>
</li>
<li>
<p>addr_v2p 函数，其中 2 和 to 同音，即 addr_v_to_p，功能是将虚拟地址 vaddr 转换为对应的物理地址。下面咋们马上就会用到此函数。</p>
</li>
</ul>
<p><strong><mark class="hl-label blue">创建用户进程</mark> </strong><br>
这部分内容很多，打起精神啦！</p>
<p>在中断栈中构建用户进程的上下文时，需要设置 eflags 寄存器，所以在 global 中定义好 eflags 的属性位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:global.h</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_MBS	(1 &lt;&lt; 1)        <span class="comment">// 该位保留,总是为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_1	(1 &lt;&lt; 9)        <span class="comment">// if为1,开中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_0	0               <span class="comment">// if为0,关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_3	(3 &lt;&lt; 12)   <span class="comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_0	(0 &lt;&lt; 12)   <span class="comment">// IOPL0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_ROUND_UP(X, STEP) ((X + STEP - 1) / (STEP)) <span class="comment">//用于除法的向上取整,如2/3=1</span></span></span><br></pre></td></tr></table></figure>
<p>下面则开始创建用户进程，<strong><font color='orange'>注意上节中的进程创建流程图对比</font></strong> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:process.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">proc_stack</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pagedir_phy_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">intr_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_process</span><span class="params">(<span class="type">void</span>* filename_)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* function = filename_;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);   <span class="comment">//跨过thread_stack,指向intr_stack</span></span><br><span class="line">    proc_stack = (<span class="keyword">struct</span> intr_stack*)cur-&gt;self_kstack; <span class="comment">//可以不用定义成结构体指针</span></span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>;          <span class="comment">// 不允许用户态直接访问显存资源,用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function;	 <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="type">void</span>*)((<span class="type">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,proc_stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;jmp intr_exit&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 击活页表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_dir_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">     * 执行此函数时,当前任务可能是线程。</span></span><br><span class="line"><span class="comment">     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,</span></span><br><span class="line"><span class="comment">     * 否则不恢复页表的话,线程就会使用进程的页表了。</span></span><br><span class="line"><span class="comment">     ********************************************************/</span></span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    pagedir_phy_addr = <span class="number">0x100000</span>;  <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)  <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov eax,pagedir_phy_addr&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov cr3,eax&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 激活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0特权级,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0*/</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建页目录表,将当前页表的表示内核空间的pde复制,</span></span><br><span class="line"><span class="comment"> * 成功则返回页目录的虚拟地址,否则返回-1 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">create_page_dir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页目录表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">&quot;create_page_dir: get_kernel_page failed!&quot;</span>,FT_RED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span>*<span class="number">4</span>), (<span class="type">uint32_t</span>*)(<span class="number">0xfffff000</span>+<span class="number">0x300</span>*<span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_user_vaddr_bitmap</span><span class="params">(<span class="keyword">struct</span> task_struct* user_prog)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_execute</span><span class="params">(<span class="type">void</span>* filename, <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 **/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, DEFUALT_PRIO);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);<span class="comment">//start_process(filename)</span></span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>start_process 中，proc_stack 结构体指向中断栈，并初始化进程上下文。</p>
</li>
<li>
<p>第 9 行，需要说明的是，用户进程一般是硬盘中的一段程序，需要加载到内存，然后再运行，所以进程的定义就是“运行中的程序”。<strong>但目前我们还没有实现硬盘驱动程序和文件系统，所以用户进程只能由一个函数代替</strong> ，实际上，这两者也没有本质区别。</p>
</li>
<li>
<p>第 15 行，由于 <strong><font color='orange'>用户不能直接使用显存</font></strong>，所以将 gs 直接初始化为 0，则用户使用该选择子时，会索引到 GDT 的第 0 号描述符而引发异常。</p>
</li>
<li>
<p>第 20 行，调用 get_a_page() 在指定位置，即用户空间 3GB 顶端处申请一页内存用来作用户栈，这在之前有所提及。</p>
<blockquote>
<p>用户栈只有一页吗？笔者暂不清楚当栈使用超过一页会发生什么，后续补充。</p>
</blockquote>
</li>
<li>
<p>第 23 行，intr_exit 是从 <code>interrupt.s</code> 引入的函数，专门处理中断返回。这没有什么好说的，只是为了复用代码，也可以直接在 23 行处使用内联汇编连续弹栈并 <code>iret</code> 。<code>iret</code> 后执行流就转移到用户进程啦！</p>
</li>
<li>
<p>第 27 行，page_dir_active，页表激活函数。从流程图中可以看见，该函数在 schedule() 中被调用，如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.c</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    process_activate(next);</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<strong><u>每当任务切换(swtich_to)前，都会重新激活页表</u></strong> ，这不禁引发我们的疑惑：不是进程才有独立的地址空间吗？怎么连线程都要激活页表了呢？其实这可以在上节<a href="">进程的实现方式</a>找到答案。在 Linux 中，<strong><u>多个地址空间相同的线程组成了一个进程</u></strong> ，所以线程也需要记录页表。需要注意的是，<strong><font color='gree'>目前我们只实现了内核线程(thread_start) 和用户进程 (process_execute)，还未实现用户线程</font></strong>  (未来看情况按需添加)，所以 task_struct 中的 pgdir 只分为两种情况：NULL 和其他值；如果为 NULL，则说明该任务为内核线程；如果为非 NULL，则说明该任务为用户进程。<br>
另外，<strong>第 40 行加载 cr3 有大坑！</strong> 还记得吗，在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>一文中，笔者将内核的起始虚拟地址设置为了 0x1500，并提醒读者未来这个 0x1500 会留下问题。这个问题就在此处浮现：首次切换页表之前，执行流一直位于内核进程中，而内核进程虚拟空间的低 1MB 和高 3GB 处都是内核（这在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中早有说明，忘记的读者请回头复习）。又因为之前将内核的起始虚拟地址设置为了 0x1500，所以一直以来内核始终运行在低端 1MB 处，而非高 3GB 处。关键来了，当内核执行流运行到第 40 行切换页表时，切换前执行流位于 1MB 下，切换后当然也仍位于 1MB 下（因为代码中的地址都是提前编译好的），但是，切换到用户进程的页表后，低端 1MB 就不再是内核啦（对于用户进程而言，内核只位于高 3GB 处）之前说过，用户进程的低端 128MB 为保留，没有任何东西，所以执行流运行在用户进程虚拟空间的低端 1MB 下将必定出错！因此，为了保证切换页表前后执行流能够统一，我们必须将内核的起始虚拟地址设置为 0xc0001500，这样对于内核进程和用户进程来说，内核都运行在高 3GB 上，切换页表前后执行流就不会改变。修改如下：</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">	ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里也是卡了笔者很久，如果当初不作死修改 Ttext，也不会引发这些问题，但实际上，不就是这些找 Bug 的过程加深了我们对程序的理解吗？</p>
</blockquote>
</li>
<li>
<p>第 51 行，只有用户进程才会更新 TSS 中的 ESP0，因为从内核进入中断不涉及特权级转移，从用户进程进入中断才会切换到对应的内核栈。</p>
</li>
<li>
<p>第 58 行是笔者期待已久的页表创建函数 create_page_dir()，该函数为用户进程创建对应的页目录表，其任务很简单：1）<strong>申请一页内存用来存放页目录表 <strong>；2）</strong><u>将内核页目录的第 768~1022 项复制到用户页目录表的相同位置，从而实现所有用户进程共享内核</u></strong> （这在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中重点提到过）；3）将用户进程页目录表的物理地址写入第 1023 号页目录项，这是为了访问页目录表和页表本身，详细原因仍请参考<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。注意，<strong><u>用户进程的页目录表和页表不能安装在用户空间中，而是安装在内核空间里</u></strong> ，否则用户就可能自己修改页表，映射任意的内存地址，访问任何内存，进程间、内核的隔离保护就失去了意义。</p>
<blockquote>
<p>另外，不知道读者是否和我一样有这样的疑惑：为什么没有为用户程序本身开辟页表？也就是说，现在只映射了 3~4GB 的内核，而没有映射 0~3GB 的用户空间，那用户程序本身运行在哪？笔者从两个方面来解释此问题：<br>
1）由于现在还没有完成硬盘驱动和文件系统，所以只能使用函数（如下面的u_prog_a、u_prog_b）来代替用户程序。而这些函数也是同样定义在 main.c 中，所以它们都会被链接进 kernel.bin，然后载入内核。换句话说，这些函数虽然是用户进程，但也位于 3~4GB 空间中（即使位于内核空间，特权级仍然为 3）。<strong>这只是目前为了演示用户进程而作的妥协</strong> 。<br>
<img src="/2022/img/image-20230106150001512.png" style="zoom:67%;" /></p>
<p>2）真正的用户进程加载是从硬盘读取程序并载入内存，进而运行，大致流程是这样的：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  &gt; graph LR
&gt; A{创建独立的虚拟空间}--&gt;B{读取可执行文件头}--&gt;C{建立虚拟空间和可执行文件的映射关系}--&gt;D{将EIP设置为可执行文件的入口地址，开始运行}
&gt; 
  </pre></div>
<p>啊啥？这不是还没将程序加载进内存吗？怎么就开始运行啦？是这样的，比如入口地址为 <code>0x08048000</code> ，<strong><font color='orange'>当执行流运行到该地址时，发现页面 <code>0x08048000~0x08049000</code> 是空页面，于是陷入缺页异常，异常处理程序通过第三步建立的映射关系找到可执行文件中缺失页面对应的部分代码，然后再将该部分载入内存，最后重新运行</font></strong> 。相关详细内容可参考《链接、装载与库》。<br>
综上两点考虑，当前无需建立其他部分的映射。</p>
</blockquote>
</li>
<li>
<p>第 78 行，create_user_vaddr_bitmap() 函数用来为用户进程创建虚拟内存池，以便管理内存空间。其中 USER_VADDR_START 的值即为 <code>0x08048000</code> 。该函数逻辑清晰，不做说明。</p>
</li>
<li>
<p>第 88 行便是 process_execute() 函数。需要说明的是，该函数是在内核中被调用来创建用户进程的，而 fork 函数则是在用户程序中来创建子进程的，两者有巨大区别，将来实现 fork 时还会提到这一点。</p>
</li>
</ul>
<p>大功告成，了解了具体实现后，再来回顾进程创建的整个过程，思路也许会变得更清晰：</p>
<p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p>
<h3 id="font-color-red-运行用户进程-font"><font color='red'>运行用户进程</font></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> test_var_a = <span class="number">0</span>, test_var_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;argA &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_b&quot;</span>, <span class="number">31</span>, k_thread_b, <span class="string">&quot;argB &quot;</span>);</span><br><span class="line">    process_execute(u_prog_a, <span class="string">&quot;user_prog_a&quot;</span>);</span><br><span class="line">    process_execute(u_prog_b, <span class="string">&quot;user_prog_b&quot;</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_int(test_var_a,FT_RED,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        console_put_int(test_var_b,FT_YELLOW,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而运行结果不尽人意：<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br>
可见，运行一段时间后任务就停止了切换。这个 Bug 目前还没有找到，只知道这是锁引起的问题，没办法，只能将锁改为开关中断了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:console.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//console_acquire();</span></span><br><span class="line">    CLI;</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    STI;</span><br><span class="line">    <span class="comment">//console_release();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure>
<p>再次运行：</p>
<div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro1.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p>现在好多了。关于这个锁的问题，笔者调试了两天还是不知道原因，请知道原因的读者朋友们在评论区留言，感谢！<br>
需要说明的是，print 和 console 系列打印函数只能在内核，即 ring0 下使用，在用户进程中调用则会引发 0xd 号异常：<br>
<img src="/2022/img/image-20230112092402708.png" alt=""><br>
所以这里使用两个变量 test_var_b、test_var_a 来间接反映进程的调度情况。</p>
<p>最后留下一个问题：既然禁止用户直接访问内核，那为什么还要将用户代码段描述符的界限设置为 4GB 呢？这样用户不就能轻松访问高地址的内核了吗？就像下面这样直接在用户态访问显存：<br>
<img src="/2022/img/image-20230112155046604.png" alt=""><br>
既然这样，为什么不将用户代码段的界限设置为 3GB 呢？留给读者思考，笔者将在后续文章给出答案。</p>
<p>本文结束，下节实现系统调用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="/2022/img/44.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">printf底层剖析及可变参数探究</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"><img class="next-cover" src="/2022/img/41.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">实现用户进程—进入用户态</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/" title="32位保护模式概览"><img class="cover" src="/2022/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">32位保护模式概览</div></div></a></div><div><a href="/2022/10/27/bochs%E4%BD%BF%E7%94%A8/" title="bochs虚拟机的使用"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">bochs虚拟机的使用</div></div></a></div><div><a href="/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/" title="对8259a芯片编程"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">对8259a芯片编程</div></div></a></div><div><a href="/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="GDT&amp;段描述符&amp;选择子概述"><img class="cover" src="/2022/img/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">GDT&amp;段描述符&amp;选择子概述</div></div></a></div><div><a href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/" title="内存管理-进阶-分配页内存"><img class="cover" src="/2022/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-08</div><div class="title">内存管理-进阶-分配页内存</div></div></a></div><div><a href="/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理-基础-初始化内存池"><img class="cover" src="/2022/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">内存管理-基础-初始化内存池</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%88%9D%E5%A7%8B%E5%8C%96TSS%E3%80%81C%E8%AF%AD%E8%A8%80%E6%8E%A5%E7%AE%A1GDT-font"><span class="toc-number">1.</span> <span class="toc-text">初始化TSS、C语言接管GDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-font"><span class="toc-number">2.</span> <span class="toc-text">用户进程的虚拟地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E8%BF%90%E8%A1%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-font"><span class="toc-number">3.</span> <span class="toc-text">运行用户进程</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>