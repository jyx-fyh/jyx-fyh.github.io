<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剖析重定位——程序加载器/vstart解析 | 极简</title><meta name="keywords" content="了解重定位本质, vstart的作用"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="什么是重定位，vstart有什么用">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析重定位——程序加载器&#x2F;vstart解析">
<meta property="og:url" content="http://jyxcpp.netlify.app/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="什么是重定位，vstart有什么用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/29.jpg">
<meta property="article:published_time" content="2022-10-23T01:35:22.000Z">
<meta property="article:modified_time" content="2023-03-12T11:21:07.198Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="自制操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/29.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剖析重定位——程序加载器/vstart解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:21:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">144</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/29.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剖析重定位——程序加载器/vstart解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-23T01:35:22.000Z" title="发表于 2022-10-23 09:35:22">2022-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:21:07.198Z" title="更新于 2023-03-12 19:21:07">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剖析重定位——程序加载器/vstart解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文通过汇编来阐述重定位的原理，不了解汇编的同学请先移步 <a target="_blank" rel="noopener" href="https://jyx_aha.gitee.io/hexo/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编语言入门指南</a> 。<br>
本文参考李忠先生的《x86汇编语言：从实模式到保护模式》，若需了解详情，可移步本书（书上的例子较难，本文例子经过了简化）。<br>
另外，本文仅在实模式下，通过汇编来描述重定位的基本过程，实际程序的重定位肯定更加复杂，如果想深刻了解程序的加载过程，请阅读神书《链接，装载与库》。<br>
本文参考：《操作系统真相还原》《汇编语言第四版》《x86汇编语言：从实模式到保护模式》，<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37570820/article/details/79403382">程序的加载</a></p>
</blockquote>
<p>需要注意的是，编译软件必须使用 nasm，不可使用 masm。原因是 nasm 可以生成 .bin 文件，.bin 文件是纯二进制文件，可以直接输入到 CPU 运行，不像 elf 或 pe 文件那样有许多描述信息。 <strong>可执行文件中包含描述信息和指令</strong> ，这些描述信息就是我们重点要说的内容，而 masm 会自动生成描述信息，掩盖了这样过程，不利于我们探究重定位；相反，nasm 可以由我们自己来规划描述信息。废话不多说，让我们开始吧。</p>
<h3 id="font-color-red-vstart-和-section-xxx-start-究竟是什么？-font"><font color='red'>vstart 和 section.xxx.start 究竟是什么？</font></h3>
<p><strong><mark class="hl-label blue">前置结论</mark> </strong><br>
很多朋友学习 nasm 时，都会对这两个关键词产生疑惑，最大的原因在于没有实际的应用场景，无法仔细体会其中的用处。后面当我们手写加载器和用户程序头部时，大家就会明白其中的奥秘。现在先让我们大概理解这两个关键词的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#代码没有意义，仅作演示</span><br><span class="line">section code1 align=16</span><br><span class="line">	mov ax,bx</span><br><span class="line">section code2 align=16</span><br><span class="line">	mov bx,ax</span><br><span class="line">section data align=16</span><br><span class="line">	db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>
<p>使用 <code>align=16</code> 使 section 以 16 位对齐。以上代码生成的二进制文件如下：<br>
<img src="/2022/img/image-20221031090603921.png" alt=""></p>
<p>接着，我们交换 <code>code1</code> 段和 <code>code2</code> 段的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code2 align=16</span><br><span class="line">	mov bx,ax</span><br><span class="line">section code1 align=16</span><br><span class="line">	mov ax,bx</span><br><span class="line">section data align=16</span><br><span class="line">	db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>
<p>对应二进制代码如下：<br>
<img src="/2022/img/image-20221031090709540.png" alt=""><br>
可以发现，第一行二进制代码和第二行互换了位置。由此我们知道， <strong><font color='orange'>.asm 汇编文件和其生成的 .bin 二进制文件是完全一一对应的关系，.bin 中的代码在内存的布局和 .asm 中的代码布局相同</font></strong> 。这是我们得到的第一个结论。下面继续。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">	mov ax,s</span><br><span class="line">section data align=16</span><br><span class="line">s:	db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>
<p>对应代码如下：<br>
<img src="/2022/img/image-20221031090803933.png" alt=""></p>
<p>由 <code>B8 10</code> 可知，标号 S 的地址为 <code>0x10</code> ，恰好能和第二行代码的地址对应。由此我们得到第二个结论： <strong><font color='orange'>编译器给 .bin 程序中各符号分配的地址，就是各符号相对于 .asm 文件开头的偏移量</font></strong> 。</p>
<p><strong><mark class="hl-label blue">vstart</mark> </strong><br>
对代码做如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">	mov ax,s</span><br><span class="line">section data align=16 vstart=0</span><br><span class="line">s:	db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>
<p>对应二进制代码如下：<br>
<img src="/2022/img/image-20221031090858316.png" alt=""><br>
<code>B8 10</code> 变成了 <code>B8 00</code> ，可见，<code>vstart</code> 关键字改变了 S 标号的汇编地址，原本 S 标号的地址是此标号相对于文件开头的偏移量，而现在 S 标号的地址是以 data 段为起点的偏移量。换句话说， <strong><font color='red'><code>vstart</code> 能够使段内所有标号的汇编地址都以此段的开头处计算，而非以整个程序的开头(即.asm文件开头)计算！</font></strong></p>
<p>注意！听完上述 vstart 的作用后，我们很容易认为 vstart 能够告诉编译器将程序加载到某个固定的 <strong>偏移</strong> 地址，这么一看，编译器似乎具备了加载器的功能。其实不然，vstart 的作用仅仅是告诉编译器：“嘿，老兄，请你把我后面定义的 <strong>标号地址</strong> 从xxx为起点开始编址吧”，别无他用。它只负责编址，不负责加载，加载程序是加载器的事。 <strong><font color='orange'>所以，用 vstart 的时机是：我预先知道我的程序将来会被加载到某个偏移地址处</font></strong> 。拿确切的例子来说，BIOS(加载器)会将 MBR 引导程序加载到 <code>0000:7c00</code> 处，所以 MBR 程序段必须用 <code>vstart=7c00</code> 修饰（不用管段地址，段地址由加载器决定，<u>即使是加载到 1100:7c00，一样可以执行</u>）。 <strong>一般情况下使用 <code>vstart=0</code> (利于重定位)，这是因为段在内存中都以 16 位对齐，所以进入段时，偏移地址总是从零开始，如果标号的汇编地址和内存中的偏移地址不一致，就会发生错误</strong>  。来看个简单的例子吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code align=16 vstart=8</span><br><span class="line">s:</span><br><span class="line">	push cs</span><br><span class="line">	push s</span><br><span class="line">	mov bp,sp</span><br><span class="line">	jmp dword [bp]  ;ret</span><br></pre></td></tr></table></figure>
<p>其二进制代码为：<code>0E 68 08 00 89 E5 66 FF 66 00</code> 。将这段程序加载到物理地址 <code>10000</code> 处，内存映像如下图：<br>
<img src="/2022/img/image-20221025162254596-1667178594381-1.png" alt=""></p>
<p>由于 <code>vstart=8</code> ，所以标号 S 代表的偏移地址也为 8，这就导致第 6 行代码 jmp 到错误位置 <code>1000:8</code> 处，然而实际应该 jmp 到 <code>1000:0</code> 处。这就是汇编地址与段内偏移地址不对应的后果。还一头雾水，不急，这个的确很绕，咋们继续，相信看完后面你就可以理解了。</p>
<blockquote>
<p>另外，<code>vstart=xxx</code> 与 <code>org xxx</code> 功能相同。</p>
</blockquote>
<p><strong><mark class="hl-label blue">section.xxx.start</mark> </strong><br>
<code>section.xxx.start</code> 是某段相对于程序开头的偏移量。举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section data align=16 vstart=0</span><br><span class="line">msg	db&#x27;hello world&#x27;</span><br><span class="line">section code align=16 vstart=0</span><br><span class="line">	mov ax,section.code.start</span><br></pre></td></tr></table></figure>
<p><img src="/2022/img/image-20221031091035242.png" alt=""><br>
可见，<code>section.code.start=0x10</code> ，这就是 code 段相对于文件开头的偏移量。你一定会问，这玩意儿有啥用？唯一作用就是用来重定位。怎么个玩法？请继续阅读下文。</p>
<h3 id="font-color-red-什么是程序加载器？-font"><font color='red'>什么是程序加载器？</font></h3>
<p>一个编译好的用户程序，放到磁盘中，是如何被加载到内存并运行的呢？大概的流程是加载器先把磁盘中的应用程序加载到内存并把执行权移交给应用程序。分为以下几个步骤：</p>
<ol>
<li>从磁盘读取应用程序并装入内存（加载器的作用1）。</li>
<li>应用程序被装入内存后需要加载器对内存中的应用程序部分地址进行重定位（加载器的作用2）。</li>
<li>加载器将执行权移交应用程序（加载器的作用3）。</li>
</ol>
<p>一般来说，加载器和用户程序对彼此而言都是黑盒子，它们不了解对方的功能和结构。那加载器如何启动用户程序呢？这就需要加载器和用户程序在事先协商一个接口，加载器通过接口去启动用户程序。实际的做法是，将这个接口放在每个用户程序的开头，即用户程序头部，加载器按约定从头部提取信息并完成加载。 <strong>用户程序头部在源程序中以一个段的形式出现。</strong> 用户程序头部至少要包含如下信息：</p>
<ol>
<li><strong>用户程序的尺寸</strong> ，以字节为单位。加载器需要根据其尺寸来决定读取多少个逻辑扇区。</li>
<li><strong>用户程序的入口</strong> ，包括段地址和偏移地址。注意，这里的段地址并不是真正的段地址，而是 <code>section.xxx.start</code> ，加载器通过这个段地址来计算出内存中真正的逻辑段地址。</li>
<li><strong>段重定位表及其表项个数</strong> 。用户程序中的所有段都会被重定位，并将位置记录在表中。</li>
</ol>
<h3 id="font-color-red-程序加载器的工作流程-font"><font color='red'>程序加载器的工作流程</font></h3>
<p>下面我们以 MBR（加载器） 加载 OBR（用户程序）为例展开讨论。</p>
<blockquote>
<p>MBR 和 OBR 和操作系统相关，概念不难，自行百度。注意，加载器和用户程序是相对概念，对于 BIOS 和 MBR，前者是加载器，后者是用户程序；对于 MBR 和 OBR，前者是加载器，后者是用户程序。可见，这是一种链式加载，各自完成指定的任务，不断交接接力棒。</p>
</blockquote>
<p><strong><mark class="hl-label blue">1.初始化和决定加载位置</mark> </strong><br>
要加载一个程序，需要决定两个事情：1）从哪取：用户程序位于硬盘上的哪个逻辑扇区(<code>START_SECTOR</code>)。2）放在哪：内存中什么地方是空闲的(<code>BASE_ADDR</code>)。</p>
<p>将程序放在哪由操作系统决定；如何知道程序所在扇区，这个笔者暂时不清楚，暂且认为加载器能够通过某种方式获得用户程序所在扇区，我们暂不纠结这个问题，将注意力放在加载过程中。</p>
<p><strong><mark class="hl-label blue">2.将程序加载进内存</mark> </strong><br>
知道用户程序所在硬盘中的位置后，加载器访问硬盘，将用户程序读到内存中指定的位置。不过此时程序还无法运行，因为程序中可能有多个段（代码段或数据段），要从 code_A 段跳转到 code_B 段，或在 code_A 段访问 data_C 段的数据，就必须知道相应段的段地址，这必须经过段的重定位后才能确定。</p>
<p><strong><mark class="hl-label blue">3.重定位</mark> </strong></p>
<p>重定位的操作者是加载器，提供重定位信息的是用户程序。段重定位信息由 <code>section.xxx.start</code> 和 <code>BASE_ADDR</code> 确定。加载器利用此二者计算出各个段在内存中的逻辑段地址，并将其回填到用户程序头部。</p>
<p><strong><mark class="hl-label blue">4.将控制权移交给用户程序</mark> </strong><br>
用户程序取得控制权，接下来便可利用头部中的重定位表跳转于各个段之间。</p>
<p>以上是程序加载器的简单概述，下面我们结合代码来进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">;===============文件说明：用户程序==================================================</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    header_end:                </span><br><span class="line"> ;===============================================================================</span><br><span class="line"> ;code1——清屏并打印hello</span><br><span class="line">SECTION code_1 align=16 vstart=0</span><br><span class="line">printh:           ;打印hello    </span><br><span class="line">	push es</span><br><span class="line">	</span><br><span class="line">	mov ax,0xb800 ;彩色字符模式视频缓冲区</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	mov cx,10</span><br><span class="line">	cld</span><br><span class="line">	rep movsb</span><br><span class="line">	</span><br><span class="line">	pop es</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">start: ;程序入口</span><br><span class="line">	mov ax,ds</span><br><span class="line">	mov es,ax                  ;es作header基准,ds作用户数据段</span><br><span class="line">	mov ax,es:[stack_segment]  ;设置用户的堆栈！</span><br><span class="line">	mov ss,ax                    </span><br><span class="line">	mov sp,stack_end   </span><br><span class="line">	</span><br><span class="line">	mov ax,es:[data_1_segment] ;设置用户的数据段！</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	;清屏</span><br><span class="line">	mov ax,0x600  </span><br><span class="line">	mov bx,0x700  </span><br><span class="line">	mov cx,0  </span><br><span class="line">	mov dx,0x184f    </span><br><span class="line">	int 0x10  </span><br><span class="line">	call printh    ;打印hello</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	push word es:[code_2_segment] ;注意，是word而非dword</span><br><span class="line">	push printw   </span><br><span class="line">	retf                     ;转移到code_2</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">	jmp $          ;在此处循环</span><br><span class="line">	</span><br><span class="line">;===============================================================================</span><br><span class="line"> ;code2——打印&#x27;world&#x27;</span><br><span class="line">SECTION code_2 align=16 vstart=0</span><br><span class="line">printw:</span><br><span class="line"></span><br><span class="line">	mov ax,es:[data_2_segment]</span><br><span class="line">	mov ds,ax </span><br><span class="line">	mov ax,0xb800</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,80;打印world</span><br><span class="line">	mov cx,10</span><br><span class="line">	cld</span><br><span class="line">	rep movsb</span><br><span class="line">	</span><br><span class="line">	push word es:[code_1_segment]</span><br><span class="line">	push stop</span><br><span class="line">	retf           ;返回code_1</span><br><span class="line">	</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_1 align=16 vstart=0 </span><br><span class="line">	db &#x27;h&#x27;,00000111B</span><br><span class="line">	db &#x27;e&#x27;,00000111B</span><br><span class="line">	db &#x27;l&#x27;,00000111B</span><br><span class="line">	db &#x27;l&#x27;,00000111B</span><br><span class="line">	db &#x27;o&#x27;,00000111B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_2 align=16 vstart=0 </span><br><span class="line">	db &#x27;w&#x27;,11000010B</span><br><span class="line">	db &#x27;o&#x27;,11000010B</span><br><span class="line">	db &#x27;r&#x27;,11000010B</span><br><span class="line">	db &#x27;l&#x27;,11000010B</span><br><span class="line">	db &#x27;d&#x27;,11000010B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">	times 256 db 0</span><br><span class="line">stack_end:</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION trail align=16 </span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">         BASE_ADDR     equ 0x10000       ;将用户程序加载到物理位置BASE_ADDR处</span><br><span class="line">         START_SECTOR  equ 100           ;BASE_ADDR的末位必须为0</span><br><span class="line">                                         ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">                                         ;常数的声明不会占用汇编地址                                    </span><br><span class="line">SECTION mbr align=16 vstart=0x7c00                                     </span><br><span class="line">         ;设置堆栈段和栈指针 </span><br><span class="line">         mov ax,0      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,ax</span><br><span class="line">         </span><br><span class="line">         mov eax,BASE_ADDR               ;eax低4位一定为0</span><br><span class="line">         mov cl ,4                       ;移动多位，必须使用cl</span><br><span class="line">         shr eax,cl                      </span><br><span class="line">         mov ds,ax                       ;令DS和ES指向该段以进行操作</span><br><span class="line">         mov es,ax                        </span><br><span class="line">    </span><br><span class="line">         ;以下读取程序的起始部分 </span><br><span class="line">         xor di,di</span><br><span class="line">         mov si,START_SECTOR             ;程序在硬盘上的起始逻辑扇区号 </span><br><span class="line">         xor bx,bx                       ;加载到DS:0x0000处 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">      </span><br><span class="line">         ;以下判断整个程序有多大</span><br><span class="line">         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 </span><br><span class="line">         mov ax,[0]</span><br><span class="line">         mov bx,512                      ;512字节每扇区</span><br><span class="line">         div bx</span><br><span class="line">         cmp dx,0</span><br><span class="line">         jnz @1                          ;未除尽，因此结果比实际扇区数少1 </span><br><span class="line">         dec ax                          ;已经读了一个扇区，扇区总数减1 </span><br><span class="line">   @1:</span><br><span class="line">         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">         jz direct</span><br><span class="line">         </span><br><span class="line">         ;读取剩余的扇区</span><br><span class="line">         push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">         mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line">   @2:</span><br><span class="line">         mov ax,ds</span><br><span class="line">         add ax,0x20                     ;得到下一个以512字节为边界的段地址</span><br><span class="line">         mov ds,ax  </span><br><span class="line">                              </span><br><span class="line">         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 </span><br><span class="line">         inc si                          ;下一个逻辑扇区 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">         loop @2                         ;循环读，直到读完整个功能程序 </span><br><span class="line"></span><br><span class="line">         pop ds                          ;恢复数据段基址到用户程序头部段 </span><br><span class="line">      </span><br><span class="line">         ;计算入口点代码段基址 </span><br><span class="line">   direct:</span><br><span class="line">         mov eax,[0x06]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [0x06],ax                   ;回填修正后的入口点代码段基址 </span><br><span class="line">      </span><br><span class="line">         ;开始处理段重定位表</span><br><span class="line">         mov cx,[0x0a]                   ;需要重定位的项目数量</span><br><span class="line">	     cmp cx,0</span><br><span class="line">	     jz  jmpToLoader                 ;如果为0项，直接跳转</span><br><span class="line">         mov bx,0x0c                     ;重定位表首地址</span><br><span class="line">          </span><br><span class="line"> realloc:</span><br><span class="line">         mov eax,[bx]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [bx],ax                     ;回填段的基址</span><br><span class="line">         add bx,4                        ;下一个重定位项（每项占4个字节） </span><br><span class="line">         loop realloc </span><br><span class="line"></span><br><span class="line"> jmpToLoader:     </span><br><span class="line">         jmp far [0x04]                  ;转移到用户程序  </span><br><span class="line"> </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;      DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line">	</span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base:                       ;计算16位段地址</span><br><span class="line">                                         ;输入：eax低20位有效,最低4位为0</span><br><span class="line">                                         ;返回：AX=16位段基地址 </span><br><span class="line">         add eax,BASE_ADDR</span><br><span class="line">	     mov cl,4</span><br><span class="line">	     shr eax,cl</span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------         </span><br><span class="line"> times 510-($-$$) db 0</span><br><span class="line"> db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">用户程序剖析</mark> </strong></p>
<blockquote>
<p>建议读者赋值粘贴代码到 notepad++，文件格式为 .asm，这样方便代码阅读和定位（双击标号即可定位）。</p>
</blockquote>
<ul>
<li>头部是用户程序和加载器之间的接口，它们遵循事先规定好的约定。头部必须为单独一个 section。</li>
<li>第 4 行，通过 <code>program_end</code> 确定了用户程序的大小。这是如何做到的呢？注意 102 行，段定义没有 <code>vstart=0</code> ，所以该段内标号的汇编地址是从文件头开始算的，所以该标号就是文件尾相对文件的的偏移量，即文件的大小。</li>
<li>第 39 行是易错的地方，务必要将 ds 备份，此时 ds 是用户程序被载入内存的位置，<strong>之后访问头部时，都必须使用此值作为段基址</strong> 。用 es 保存此值，而后 ds 用来充当 data 段的段基址(比如 45 行)。</li>
<li>58 行，分别将 code_2 的段基址和偏移地址压栈后，使用 retf 远转移到 code_2。谁说函数调用必须用 call 或 jmp 的？这里使用 retf 的好处是跳转后不用手动清理栈。</li>
<li><strong><font color='gree'>注意，除了最后一个段外，每个段都必须用 <code>vstart=0</code> 修饰！这样利于段在内存中的浮动装配（重定位），这点非常重要！</font></strong></li>
<li><strong><font color='gree'>为什么段重定位表的表项大小为 dd，即四个字节呢？段寄存器不是才两个字节大小吗？是这样的：还没重定位的时候，这里装的就是 <code>section.xxx.start</code> ，它是 xxx 段相对于文件开头的偏移量，这个偏移量可能大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> ，所以要用 4 个字节，32 位来装。需要注意的是，<code>section.xxx.start</code> 的最低 4 位（二进制下）一定是 0，这是因为我们的每个段都使用 <code>align=16</code> 对齐，所以每个段相对于文件开头的偏移量一定是 16 的整数倍，故最低四位一定是 0。</font></strong></li>
</ul>
<p>其他内容不在赘述，注释已经比较详尽了。</p>
<p><strong><mark class="hl-label blue">加载器剖析</mark> </strong></p>
<ul>
<li>整个文件自成一段。mbr 段使用 <code>vstart=0x7c00</code> 修饰，原因是它知道 BIOS(MBR的加载器) 会将其加载到偏移地址为 0x7c00 的地方(0000:7c00)。</li>
<li>第 2，3 行相当于 C 语言中的宏定义，使用 <code>equ</code> 来进行赋值。可以将这两句放在 <code>boot.inc</code> 文件中，然后在第一行引入该文件：<code>%include 'boot.inc'</code> 。不过引入头文件这用法似乎只有在 linux 下才行。</li>
<li>第 24 行，简单举个例子：用户程序大小为 520 字节，除以 512，商 1 余 8，则该程序仍占用两个扇区。</li>
<li>第 34 行，直接将段地址加上 0x20，即向后移动 512 字节。为什么不用偏移地址加上 512 字节呢？要知道，读取硬盘的数据一般是相对较大的，很多时候都超过了 64KB，一旦超过 64KB，偏移地址就会回卷，将之前的内存覆盖。</li>
<li>第 11 行，实模式下可以使用 32 位寄存器，原因参见 <a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">保护模式概览</a></li>
<li>第 12 行，左移或右移多位，必须将位数用 cl 装载，不能直接 <code>shr eax,4</code> 。</li>
</ul>
<p>本文对硬盘的读取不展开描述，详细请参考《x86汇编：从实模式到保护模式》第137页，《操作系统真相还原》第 131 页。</p>
<h3 id="font-color-red-运行-font"><font color='red'>运行</font></h3>
<blockquote>
<p>不想折腾的同学请使用 windows 平台完成运行。硬盘文件下载：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ycMfrsJCeKlMTki0yAagnA?pwd=gzwb">链接</a>，提取码：gzwb</p>
</blockquote>
<p><strong><mark class="hl-label blue">Windows</mark> </strong><br>
1）将上面的两份代码分别写入 “loader.asm” 和 “app.asm” 中。<br>
2）使用 nasm 生成 .bin 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.asm -o app.bin</span><br><span class="line">nasm -f bin loader.asm -o loader.bin</span><br></pre></td></tr></table></figure>
<p>3）将 .bin 文件写入硬盘。通过上面的链接获取硬盘文件及其写入工具，打开 <code>fixvhdwt</code> ，硬盘选择 <code>LEECHUNG.vhd</code> ，数据文件选择 <code>loader.bin</code> ，然后写入逻辑第 0 扇区即可。重复以上步骤，将 <code>app.bin</code> 写入第 100 扇区。<br>
4）在 bochs 安装目录下找到 bochsdbg.exe，打开后按下图顺序操作：<br>
<img src="/2022/img/image-20221031091508919.png" alt=""><br>
第 7 步点击 Boot Option 后，将 boot Drive1 改成 disk 即可。<br>
5)运行。点击菜单界面右上方的 start，然后在命令行输入 <code>c</code> ，虚拟机屏幕出现 hello world 即成功。</p>
<p><strong><mark class="hl-label blue">Linux</mark> </strong></p>
<p>1）先下载 bochs，参见配置过程参见 <a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/27/bochs%E4%BD%BF%E7%94%A8/">bochs使用</a>。在 bochs 文件夹中打开终端，输入以下命令创建硬盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat ./build/hd.img</span><br></pre></td></tr></table></figure>
<p>2）接着在 <code>bochsrc</code> 中修改如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/hd.img&quot;</span>, mode=flat</span><br></pre></td></tr></table></figure>
<p>3）在 bochs-2.7/build 目录下，将之前的两份代码分别写入 <code>loader.s</code> 和 <code>app.s</code> ，然后使用如下命令分别生成 .bin 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.s -o app.bin</span><br><span class="line">nasm -f bin loader.s -o loader.bin</span><br></pre></td></tr></table></figure>
<p>注意，可能会报错，提示 <code>app.s</code> 中有五行错误，只需将 <code>es:[xxx_segment]</code> 改为 <code>[es:xxx_segment]</code> 即可，这是 nasm 在 LInux 和 Windows 的小差别。<br>
4）使用如下命令将.bin 文件写入硬盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./loader.bin of=./hd.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./app.bin of=./hd.img bs=512 count=1 seek=100 conv=notrunc  //将app写入100扇区</span><br></pre></td></tr></table></figure>
<p>5）在 bochs-2.7 目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc</span><br></pre></td></tr></table></figure>
<p>两次回车，出现如下界面：<br>
<img src="/2022/img/image-20221031091633667.png" alt=""><br>
点击左上方的 continue，出现以下界面即为成功：<br>
<img src="/2022/img/image-20221031091711096.png" alt=""><br>
world 后面的 F 哪来的我也很懵逼。。。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">http://jyxcpp.netlify.app/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/"><img class="prev-cover" src="/2022/img/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">详解函数调用过程和约定</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"><img class="next-cover" src="/2022/img/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">make clean的必要性&amp;&amp;自动找寻头文件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/" title="32位保护模式概览"><img class="cover" src="/2022/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">32位保护模式概览</div></div></a></div><div><a href="/2022/10/27/bochs%E4%BD%BF%E7%94%A8/" title="bochs虚拟机的使用"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">bochs虚拟机的使用</div></div></a></div><div><a href="/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/" title="对8259a芯片编程"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">对8259a芯片编程</div></div></a></div><div><a href="/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="GDT&amp;段描述符&amp;选择子概述"><img class="cover" src="/2022/img/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">GDT&amp;段描述符&amp;选择子概述</div></div></a></div><div><a href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/" title="内存管理-进阶-分配页内存"><img class="cover" src="/2022/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-08</div><div class="title">内存管理-进阶-分配页内存</div></div></a></div><div><a href="/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理-基础-初始化内存池"><img class="cover" src="/2022/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">内存管理-基础-初始化内存池</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-vstart-%E5%92%8C-section-xxx-start-%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-font"><span class="toc-number">1.</span> <span class="toc-text">vstart 和 section.xxx.start 究竟是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F-font"><span class="toc-number">2.</span> <span class="toc-text">什么是程序加载器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-font"><span class="toc-number">3.</span> <span class="toc-text">程序加载器的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E8%BF%90%E8%A1%8C-font"><span class="toc-number">4.</span> <span class="toc-text">运行</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>