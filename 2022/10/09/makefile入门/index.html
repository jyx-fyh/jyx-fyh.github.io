<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>makefile入门 | 极简</title><meta name="keywords" content="makefile教程"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="makefile学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="makefile入门">
<meta property="og:url" content="http://jyxcpp.netlify.app/2022/10/09/makefile%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="makefile学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/21.jpg">
<meta property="article:published_time" content="2022-10-09T05:02:42.000Z">
<meta property="article:modified_time" content="2023-03-12T11:21:39.075Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="makefile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/21.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2022/10/09/makefile%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'makefile入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:21:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/21.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">makefile入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-09T05:02:42.000Z" title="发表于 2022-10-09 13:02:42">2022-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:21:39.075Z" title="更新于 2023-03-12 19:21:39">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/makefile/">makefile</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="makefile入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>文章参考：[陈浩-和我一起学makefile](<a target="_blank" rel="noopener" href="https://seisman.github.io/how-to-write-makefile/introduction.html">makefile介绍 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a>) ，<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1JezArDcTcYFUP8_XNXFYLg?pwd=gzwb">makefile手册</a></p>
</blockquote>
<h3 id="font-color-red-什么是makefile？-font"><font color='red'>什么是makefile？</font></h3>
<p>想必你还听说过 <code>make</code> ，<code>cmake</code> ，<code>gcc</code> 等名词吧？我们先将这些概念区分清楚。</p>
<ul>
<li><code>gcc</code> 原本是 <code>GNU C Compiler</code> ，即 GNU 计划下诞生的 C 语言编译器，随着 gcc 支持的语言越来越多，便将其定义为 <code>GNU Compiler Collection</code> ，即 GNU 编译套件。当程序只有一个或少量的源文件时，我们可以直接使用 gcc 逐个编译。一旦源文件较多，逐个编译就显得异常麻烦了，此时就需要用到 <code>make</code> 。</li>
<li><code>make</code> 是一个命令工具，是一个解释 <code>makefile</code> 中指令的命令工具,它本身并没有编译和链接的功能。<code>make</code> 根据 <code>makefile</code> 中的命令调用 gcc（也可以是别的编译器）去编译指定的源文件。换一句话说，<strong>make 就是一个 gcc/g++ 的调度器，通过读入 Makefile(makefile），执行一组以 gcc/g++ 为主的命令序列，相当于一个智能的批处理工具。</strong></li>
<li><code>makefile</code> 文件中包含了各种源文件的依赖关系和 gcc 编译指令。<code>makefile</code> 是建筑图纸，而 <code>make</code> 是负责调度的包工头，<code>gcc</code> 则是干实事的建筑工人。<code>makefile</code> 在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写 <code>makefile</code> 也是非常麻烦的，如果换了个平台 <code>makefile</code> 又要重新修改，这时候就出现了 <code>cmake</code> 。</li>
<li><code>cmake</code> 可以更加简单的生成 <code>makefile</code> 文件给 <code>make</code> 用。当然 <code>cmake</code> 还有其他更牛X功能，就是可以 <strong>跨平台</strong> 生成对应平台能用的 <code>makefile</code>，我们就不用再自己去修改了。</li>
<li>cmake根据 <code>CMakeLists.txt</code> 生成 <code>makefile</code> 。<code>CMakeLists.txt</code> 由程序员编写。</li>
</ul>
<p><img src="/2022/img/v2-497f031761c929e5c036138f938508c6_1440w.webp" alt="概念关系图"></p>
<h3 id="font-color-red-书写语法-font"><font color='red'>书写语法</font></h3>
<p>makefile 中的一个条目称为一个“规则”。<strong>一个规则告诉“make”两件事： 1. 目标在什么情况下已经过期； 2. 如果需要重建目标时，如何去重建这个目标。</strong><br>
规则的书写语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>command是命令，它说明了如何生成 targets 文件。如果其不与 <code>target:prerequisites</code> 在一行，那么，必须以 <code>Tab</code> 键开头。<strong>Makefile 中第一个规则之后的所有以 [Tab] 开始的的行， make 程序都会将其交给系统 shell 程序去解释执行</strong> 。</p>
<blockquote>
<p>如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>prerequisites 是 targets 文件的依赖文件，也就是说，要生成 targets 文件，则前提是必须有哪些文件。</p>
</li>
<li>
<p>如果依赖文件或命令较多，则可以使用 <code>\</code> 作为换行符。</p>
</li>
<li>
<p>targets 可以是目标文件，也可以是伪目标。伪目标后续再谈。</p>
</li>
<li>
<p>makefile 的注释符为 <code>#</code> ，只有单行注释，没有多行注释。注意，<strong>书写 Makefile 时务必将注释作为一个独立的行，而不要和 Makefile 的有效行放在一行中书写，这将避免很多莫名其妙的错误</strong> 。<strong>另外，以[Tab]字符开始的注释行也会被交给 shell 来处理</strong> 。</p>
</li>
</ul>
<p>举例如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">calc.exe:add.o sub.o calc.c</span></span><br><span class="line">	gcc add.o sub.o calc.c -o calc.exe</span><br><span class="line">	</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o</span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-默认makefile文件-font"><font color='red'>默认makefile文件</font></h3>
<p>默认的情况下， make 会在工作目录（执行 make 的目录）下按照文件名顺序寻找 makefile 文件读取并执行，查找的文件名顺序为：“GNUmakefile”、“ makefile”、“ Makefile”。不推荐 “GNUmakefile”，因为以此命名的文件只有“ GNU make”才可以识别。推荐使用“Mkefile”，其首大写字母比较突出。<strong>当 makefile 文件的命名不是这三个任何一个时，需要通过 make 的“ -f”或者“ --file”选项来指定 make 读取的 makefile 文件</strong> 。</p>
<h3 id="font-color-red-执行顺序-font"><font color='red'>执行顺序</font></h3>
<ol>
<li>依次读取变量“MAKEFILES”定义的 makefile 文件列表</li>
<li>读取工作目录下的 makefile 文件（根据命名的查找顺序“ GNUmakefile”，“ makefile”，“ Makefile”，首先找到那个就读取那个）</li>
<li>依次读取工作目录 makefile 文件中使用指示符“ include”包含的文件</li>
<li>查找重建所有已读取的 makefile 文件的规则（如果存在一个目标是当前读取的某一个 makefile 文件，则执行此规则重建此 makefile 文件，完成以后从第一步开始重新执行）</li>
<li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li>
<li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li>
<li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</li>
<li>执行“终极目标”所在的规则</li>
</ol>
<p><strong>7,8点的含义：如果某个依赖文件（或依赖文件的依赖，一直到依赖链的底层）发生更新，那么执行 make时，目标文件就会被重新编译(执行对应的command)</strong> 。拿上面的例子来说：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make</span></span><br><span class="line">gcc  main.c add.o -o main.exe</span><br><span class="line"><span class="comment">#######改动add.c后</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc  main.c add.o -o main.exe</span><br></pre></td></tr></table></figure>
<p>可见，即使 <code>add.o</code> 没有变动，而 <code>add.o</code> 的依赖文件 <code>add.c</code> 发生变动，最终 <code>calc.exe</code> 也会重新编译。需要注意的是，由于 <code>sub.c</code> 没有改变，所以 <code>sub.o</code> 并不会重新编译。<strong>这样能够保证每次只编译有改动的代码，从而做到第一次编译两小时，第二次编译五分钟。否则的话，仅仅只做小改动，每次也必须要编译两小时，那就太麻烦了。</strong></p>
<h3 id="font-color-red-伪目标-font"><font color='red'>伪目标</font></h3>
<p>最典型的伪目标便是 <code>clean</code> ：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf sub.o add.o </span><br></pre></td></tr></table></figure>
<p>若当前目录下没有 clean 这个文件，则 make clean 将正常执行。如果在当前工作目录下存在文件“clean”，情况就不一样了，同样我们输入 make clean，<strong><font color='orange'>由于这个规则没有任何依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令</font></strong>，因此命令“rm”将不会被执行。<br>
伪目标仅仅只是一个标签，代表着一个动作，它无需依赖关系。“伪目标”的取名不能和文件名重名，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显式地指明一个目标是伪目标，向 make 说明，<strong>不管是否有这个文件，这个目标就是伪目标。</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanObj cleanDiff</span><br><span class="line"></span><br><span class="line">cleanObj :</span><br><span class="line">    rm -rf *.o</span><br><span class="line">cleanDiff :</span><br><span class="line">	rm -rf *.diff</span><br></pre></td></tr></table></figure>
<p>当执行 <code>make clean</code> 时，不管 makefile 中有没有 clean 这个目标，都执行如上的伪目标。<strong>注意，依赖可以是目标，也可以是伪目标；伪目标也可以有依赖</strong> 。<strong><font color='orange'>执行伪目标时，不论伪目标是否有依赖，总是强制执行</font></strong> 。</p>
<blockquote>
<p>一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则时伪目标所定义的命令都会被执行；伪目标可以作其他伪目标的依赖。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">	rm -f program</span><br><span class="line">cleanobj :</span><br><span class="line">	rm -f *.o</span><br><span class="line">cleandiff :</span><br><span class="line">	rm -f *.diff</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><font color='orange'>另外，当一个目标被声明为伪目标后， make 在执行此规则时不会去试图去查找隐含规则来创建它，这样也提高了 make 的执行效率</font></strong> 。</p>
<h3 id="font-color-red-强制目标-font"><font color='red'>强制目标</font></h3>
<p><strong>如果一个规则 (rule_A) 既没有依赖也没有命令，仅有目标 (Targe_A)，并且目标名不冲突，那么，在执行这个规则的时候，目标总被认为是更新过的</strong> 。如果这个目标 (Target_A) 作为另一个规则 (rule_B) 的依赖时，因为依赖总被认为更新过，那么依赖所在的规则中的命令总会被执行，即规则 (rule_B) 中的命令总会被执行。示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: FORCE</span></span><br><span class="line">    gcc force.c -o target</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm target</span><br><span class="line"></span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>
<p><code>FORCE</code> 即为强制目标（目标名不一定为 ‘FORCE’ ，习惯而已），每次执行 target，总会重新编译。</p>
<blockquote>
<p>在使用 GNU make 时，一般使用伪目标来代替这种方式。</p>
</blockquote>
<h3 id="font-color-red-终极目标-font"><font color='red'>终极目标</font></h3>
<p>终极目标就是当没有使用 make 命令行指定具体目标时，make 默认的更新的那一个目标，<strong>即 makefile 文件中第一个规则的目标</strong> 。“终极目标”是执行 make 的唯一目的，其所在的规则作为第一个被执行的规则。而其它的规则是在完成重建“终极目标”的过程中被连带出来的。<strong>所以这些目标所在规则在 Makefile 中的顺序无关紧要</strong> 。可以在命令行指定终极目标，如 <code>make clean</code></p>
<h3 id="font-color-red-通配符-font"><font color='red'>通配符</font></h3>
<p>gcc 支持三种通配符：<code>*</code> ，<code>?</code> ，<code>~</code> 。使用最多的是 <code>*</code> 。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line">	rm -rf *.o</span><br></pre></td></tr></table></figure>
<p>但注意，当通配符应用在 makefile 的变量(后续会讲)中时，情况有所不同：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<p>变量 objects 并不代表所有后缀为 <code>.o</code> 的文件。objects的值就是 <code>*.o</code> (在某些情况下没有意义)！因为 Makefile 中的变量其实相当于 C/C++ 中的宏，仅仅只会在调用处展开。</p>
<p>Makefile 中统配符可以出现在以下两种场合：</p>
<ol>
<li><strong>可以用在规则的目标、依赖中</strong> ， make 在读取 Makefile 时会自动对其进行匹配处理（通配符展开）</li>
<li><strong>可出现在规则的命令中</strong> ，通配符的通配处理是在 shell 在执行此命令时完成的。</li>
</ol>
<p><strong><font color='orange'>除这两种情况之外的其它上下文中(比如定义变量)，不能直接使用通配符 ，而是需要通过函数 wildcard 来实现</font></strong> 。比如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects=<span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"><span class="comment">#而objects=*.o 则表示变量“objects”的值是字符串“*.o”</span></span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-文件搜索-font"><font color='red'>文件搜索</font></h3>
<p>一般情况下，我们会将各个文件分类存放，比如 <code>.h</code> ，<code>.c</code> 文件等，会分别放在 header 目录和 src 目录下。而 makefile 默认只在当前目录中寻找，所以我们需要在文件名前加上路径。但更好的方式是把这些路径告诉 make，让 make 自动去找。</p>
<p><strong><mark class="hl-label blue">VPATH</mark> </strong><br>
Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，<strong>那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH=src:header</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意，<code>VPATH</code> 是大写，它是变量！。</strong></li>
<li><strong>目录之间由 <code>:</code> 分隔。</strong></li>
<li><strong>make 会从左往右依次搜寻。</strong></li>
<li><strong>当前目录永远是最高优先搜索的地方</strong></li>
</ul>
<p><strong><mark class="hl-label blue">vpath</mark> </strong><br>
另一个设置文件搜索路径的方法是使用 make 的 “vpath” 关键字（ <strong>注意，它是全小写的</strong> ），<strong>这不是变量，这是一个make的关键字</strong> 。与 VPATH 相比，它更为灵活。它可以指定不同的文件在不同的搜索目录中。它的使用方法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>
<p>上述方式，优先级依次降低。比如，foo 和 bar 中都有 hello.c ，但只采用 foo 中的 hello.c。也可以像下面这种方式，更清楚明了：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>注意，<code>vpath</code> 后没有冒号或等号，它是关键字！</strong></p>
</li>
<li>
<p><code>*</code> 号是 gcc 的通配符，<code>%</code> 是 makefile 下的模式符（将在模式匹配中说到）。</p>
</li>
<li>
<p><strong><font color='orange'>虽然已经设置了搜索路径，但这仅针对对 command 以外的其他地方，gcc 指令中仍然要加上路径</font></strong> ，如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="keyword">vpath</span> %.h ./header</span><br><span class="line"></span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">	gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">	gcc -c ./src/add.c -o add.o</span><br></pre></td></tr></table></figure>
<p><strong><font color='orange'>依赖文件无需加路径，但 gcc 命令中必须加路径，因为 make 最后是调用的 gcc 来完成这些操作，而 vpath 仅对 make 有效，对 gcc 无效。</font></strong> 显然，这样是很繁琐的，后面我们将用自动变量来解决这个问题。</p>
</li>
</ul>
<h3 id="font-color-red-命令回显-font"><font color='red'>命令回显</font></h3>
<p>当我们执行命令时，一般会回显命令内容：<br>
<img src="/2022/img/image-20221009192826370.png" alt=""><br>
如果不想回显命令内容，则需要在命令前加上抑制符 <code>@</code> ：<br>
<img src="/2022/img/image-20221009193001941.png" alt=""><br>
此后执行命令就不会再回显。</p>
<p>如果只想看命令的内容，而不执行，带上参数 <code>-n</code> 即可：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make -n clean</span></span><br><span class="line">rm -rf *.o</span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-命令并发-font"><font color='red'>命令并发</font></h3>
<p><strong>如果你要让<font color='orange'>上一条命令的结果应用在下一条命令时</font>，你应该使用分号分隔这两条命令，而不能将两个命令分别写在两行：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误写法：</span></span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen</span><br><span class="line">    pwd</span><br><span class="line"><span class="comment">#正确写法：</span></span><br><span class="line">	exec:</span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<img src="/2022/img/image-20221009200032211.png" style="zoom:67%;" />
<p>可见，pwd 打印的路径并非在 header 中。为啥会这样呢？<strong><font color='orange'>这是因为：每行命令在一个单独的shell中执行，两行命令在两个不同的进程执行，这些Shell之间没有继承关系。</font></strong> 同时发现，即使执行 test 后进入了 <code>./header</code> ，但最后命令提示符仍表明我们在 <code>untitiled</code> 目录中！这说明每个命令都是单独开的一个进程来运行的，并不会影响当前进程。如果要用一个 shell 进程实现多条命令，则应该把这两条命令写在一行上，用分号分隔；如果希望把一个完整的 shell 命令行书写在多行上，需要使用反斜杠（ \）来对处于多行的命令进行连接：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo : bar/lose</span><br><span class="line">	cd bar; \</span><br><span class="line">	gobble lose &gt; ../foo</span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-命令并行-font"><font color='red'>命令并行</font></h3>
<p>通常情况下，同一时刻只有一个命令在执行，下一个命令只有在当前命令执行完成之后才能够开始执行。不过可以通过 make 的命令行选项 <code>-j</code> 或者 <code>--job</code> 来告诉 make 在同一时刻可以允许多条命令同时被执行。比如在一台双核的机器上，完全可以用 make -j4，让 make 最多允许4个编译命令同时执行，这样可以更有效的利用CPU资源。<br>
命令并行有如下风险：</p>
<ol>
<li>在同一时刻可能会存在多个命令执行进程同时读取标准输入，但是对于标准输入设备来说，在同一时刻只能存在一个进程访问它。因此在一时刻多个执行命令的进程中只能有一个进程获得标准输入，而其它需要读取标准输入流的进程由于输入流无效而导致致命错误。</li>
<li>会导致make的递归调用出现问题。</li>
</ol>
<h3 id="font-color-red-命令出错-font"><font color='red'>命令出错</font></h3>
<p>每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），<strong>那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行！</strong> 然而，<strong>有些时候，命令的出错并不表示就是错误的</strong> 。例如 mkdir 命令，我们一定需要建立一个目录，如果目录不存在，那么 mkdir 就成功执行，如果目录存在，那么就出错了。我们使用 mkdir 的目的是保证一定要有这样的一个目录，如果已经存在，那么就忽略它的创建。为了做到这一点，忽略命令的出错，我们可以在 Makefile 的命令行前加一个减号 <code>-</code> （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test2: test1</span></span><br><span class="line">	touch demo/calc</span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">	mkdir demo</span><br></pre></td></tr></table></figure>
<p>我们先执行 test1，在执行 test2，得到结果为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test2</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">mkdir: 无法创建目录&quot;demo&quot;: 文件已存在</span></span><br><span class="line"><span class="section">makefile:15: recipe for target &#x27;test1&#x27; failed</span></span><br><span class="line"><span class="section">make: *** [test1] Error 1</span></span><br></pre></td></tr></table></figure>
<p>同时发现 demo 文件夹中没有 calc 文件。将 <code>mkdir</code> 改为 <code>-mkdir</code> ，再执行 test2：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test2</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">mkdir: 无法创建目录&quot;demo&quot;: 文件已存在</span></span><br><span class="line"><span class="section">makefile:15: recipe for target &#x27;test1&#x27; failed</span></span><br><span class="line"><span class="section">make: [test1] Error 1 (ignored)</span></span><br><span class="line">touch demo/</span><br></pre></td></tr></table></figure>
<p>此时虽然提示 demo 目录已经创建，但命令没有终止，test2 继续执行，最后发现 demo 中已有 calc。</p>
<h3 id="font-color-red-override指示符-font"><font color='red'>override指示符</font></h3>
<p>如果定义变量时，用 override 修饰，则通过命令行修改此变量的行为将被忽视：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line">v=world</span><br><span class="line"></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo <span class="variable">$(v)</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1 v=123</span></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line"><span class="keyword">override</span> v=world</span><br><span class="line"></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo <span class="variable">$(v)</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1 v=123</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p><strong>注意，v=123 相当于给make传的参数，并不会实际影响 makefile，且参数不会保存</strong> 。</p>
<h3 id="font-color-red-变量基础-font"><font color='red'>变量基础</font></h3>
<p>当有如下规则时：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">	gcc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>在这个规则中.o 文件列表出现了两次；第一次：作为目标“ edit”的依赖文件列表出现，第二次：规则命令行中作为“ cc”的参数列表。这样做所带来的问题是：如果我们需要为目标“edit”增加一个的依赖文件，我们就需要在两个地方添加（依赖文件列表和规则的命令中）。添加时可能在“ edit”的依赖列表中加入了、但却忘记了给命令行中添加，或者相反。这就给后期的维护和修改带来了很多不方便，添加或修改时出现遗漏。此时，我们就需要用变量来代替这些文件列表。</p>
<p><strong>变量规则如下：</strong></p>
<ul>
<li>
<p><strong><font color='orange'>makefile 中的变量完全是文本展开，与 C 语言中的宏定义无差别。</font></strong></p>
</li>
<li>
<p><strong>Makefile 中，变量可以使用在“目标”，“依赖目标”， “命令”或是 Makefile 的其它部分中。</strong></p>
</li>
<li>
<p><strong>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是<font color='orange'>尾空字符（空格、回车等，前导空格会被忽略）</font>，这点对于路径名尤其重要</strong> ，如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur=.build <span class="comment">#build后有空格</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	rm <span class="variable">$(cur)</span>/mbr.bin</span><br></pre></td></tr></table></figure>
<p>命令行将被展开为：<code>rm build /mbr.bin</code> ，中间的空格也被插进去了，从而导致错误！</p>
</li>
<li>
<p><strong>变量是大小写敏感的。命名时，推荐首字母大写，以便与系统变量区分。</strong></p>
</li>
<li>
<p><strong>变量在声明时需要给予初值，而在使用时，<font color='orange'>需要给在变量名前加上 <code>$</code> 符号( <code>$</code> 代表引用)，且变量名必须用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 包括起来，因为 <code>$</code> 只会引用其后第一个字母：</font></strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误用法</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line">var=hello</span><br><span class="line">v=world</span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo $var</span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1</span></span><br><span class="line">worldar</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正确用法</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o program <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>命令或者文件名中需要使用 <code>$</code> 时则应该用 <code>$$</code> 来表示。</p>
</li>
<li>
<p>定义变量时，可以用其他变量来构造，其实就是一个文本展开，不论递归多少层，依次展开便可。<strong><font color='orange'>注意，使用 <code>=</code> 时(此时为延时变量)，前面的变量定义可以用到后面的变量，只有用到该变量时才确定其值</font></strong> 。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br><span class="line"><span class="comment">#最后echo的值为Huh</span></span><br></pre></td></tr></table></figure>
<p>这种方式会导致两个潜在问题：<br>
1）出现变量的递归定义而导致 make 陷入到无限的变量展开过程中。比如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = <span class="variable">$(x)</span> <span class="variable">$(z)</span></span><br></pre></td></tr></table></figure>
<p>2）这种风格的变量定义中如果使用了函数，那么包含在变量值中的函数总会在变量被引用的地方执行，这导致 make 的效率降低。<br>
<strong>尽量避免使用延时变量。</strong></p>
</li>
<li>
<p><strong><font color='orange'>为了避免循环定义，可以使用 <code>:=</code> (此时为即时变量)，这样，定义变量时，就只能用到之前已经定义过的变量，定义时就已经确定其值</font></strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义空格变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p><code>$(nullstring)</code> 后有一个空格。<strong><font color='orange'>make 忽略前导空格，但不会忽略后置空格，这在路径变量中尤其重要</font></strong>！所以不建议将注释写在 makefile 语句后，因为我们往往会用空格将注释和语句分开。</p>
</li>
<li>
<p><strong><code>A?=B</code> 运算符表示：如果之前没定义过 A，则 A 的值设为 B；如果之前定义过 A，则什么也不做。</strong></p>
</li>
<li>
<p><code>+=</code> 可以为变量追加值：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当引用一个没有定义的变量时， make 默认它的值为空。</p>
</li>
</ul>
<h3 id="font-color-red-变量值替换-font"><font color='red'>变量值替换</font></h3>
<p><code>$(var:a=b)</code> 含义是：将变量 var 中所有的以 a 结尾的部分换成 b，比如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p>bar 的值为：a.c  b.c  c.c</p>
<h3 id="font-color-red-环境变量-font"><font color='red'>环境变量</font></h3>
<p>如果 Makefile  中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。如果 make 指定了 “-e” 参数，那么，系统环境变量将覆盖 Makefile 中定义的变量。注意，系统环境变量对 make 可见，<strong>在 Makefile 中，可以引用任何已定义的系统环境变量</strong> 。这里我们需要区分系统环境变量和 make 的环境变量，系统环境变量是这个系统所有用户所拥有的，而 make 的环境变量只是对于 make 的一次执行过程有效。</p>
<h3 id="font-color-red-目标变量-font"><font color='red'>目标变量</font></h3>
<p>目标变量作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效，而不会影响规则链以外的全局变量的值。因此，目标变量可以与全局变量同名。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在 prog 目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code> 。为了理解它的便利性，我们再来看个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.c</span><br><span class="line">foo : CFLAGS+=-O2</span><br><span class="line">bar : bar.c</span><br><span class="line">bar : CFLAGS+=-g</span><br><span class="line"><span class="variable">$(EXEF)</span> : debug.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(<span class="built_in">addsuffix</span> .c,<span class="variable">$@</span>)</span> –o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这个 Makefile 文件实现了在编译程序 foo 使用优化选项 <code>-O2</code> 但不使用调试选项 <code>-g</code> ，而在编译 bar 时采用了 -g 但没有 <code>-O2</code> 。这就是目标指定变量的灵活之处。</p>
<h3 id="font-color-red-内置变量-font"><font color='red'>内置变量</font></h3>
<p>Make命令提供一系列内置变量，比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性。</p>
<h3 id="font-color-red-条件判断-font"><font color='red'>条件判断</font></h3>
<p>主要关键字有这几个：<code>ifeq</code> (if equal)，<code>ifneq</code>，<code>ifdef</code>，<code>ifndef</code> ，<code>endif</code>，<code>else</code> 。</p>
<ul>
<li>
<p><code>ifeq</code> ：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############语法</span></span><br><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)<span class="comment">#如果arg1与arg2相等，则执行</span></span><br><span class="line">	command</span><br><span class="line"><span class="comment">#############示例</span></span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure>
<p>可见，使用这种方式可移植性更强。</p>
</li>
<li>
<p><code>ifneq</code> 与 <code>ifeq</code> 相反，不相等才执行。</p>
</li>
<li>
<p><code>ifdef</code> ：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############语法</span></span><br><span class="line"><span class="keyword">ifdef</span> &lt;variable/return&gt;<span class="comment">#参数可以为变量，也可以为函数返回值</span></span><br><span class="line"><span class="comment">############示例1</span></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">############示例2</span></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>ifdef</code> 是用来检测参数的值是否为空，而不是检测参数是否定义过，和 C 语言中的 <code>#IFDEF</code> 不一样！示例 1 输出 yes，示例 2 则输出 no。</p>
</li>
<li>
<p><code>ifndef</code> 与 <code>ifdef</code> 相反，不再赘述</p>
</li>
<li>
<p><strong><font color='orange'>特别注意的是，make是在读取Makefile时(第一阶段)就计算条件表达式的值，并根据条件表达式的值来选择语句(相当于预编译)，所以，你最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时(第二阶段)才有的。</font></strong></p>
</li>
</ul>
<h3 id="font-color-red-包含其他-makefile-文件-font"><font color='red'>包含其他 makefile 文件</font></h3>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> FILENAMES</span><br></pre></td></tr></table></figure>
<ul>
<li>可以同时引入多个文件，文件名用空格隔开；文件名支持通配符。</li>
<li>可使用“ -include”来代替“ include”，来忽略由于包含文件不存在或者无法创建时的错误提示。</li>
<li>include 通常用在以下场合：
<ol>
<li>有多个不同的程序，由不同目录下的几个独立的Makefile来描述其重建规则。 <strong>它们需要使用一组通用的变量定义或者模式规则</strong> 。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，在需要使用的 Makefile 中使用指示符“include”来包含此文件。</li>
<li>当根据源文件自动产生依赖文件时；我们可以将自动产生的依赖关系保存在另外一个文件中，主Makefile使用指示符“include”包含这些文件。<strong>这样的做法比直接在主Makefile中追加依赖文件的方法要明智的多</strong> 。</li>
</ol>
</li>
</ul>
<h3 id="font-color-red-make如何解析makefile文件-font"><font color='red'>make如何解析makefile文件</font></h3>
<p><strong><font color='gree'>第一阶段</font></strong> ：读取所有的 makefile 文件（包括“ MAKIFILES”变量指定的、指示符“include”指定的、以及命令行选项“ -f(–file)”指定的 makefile 文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。<br>
<strong><font color='gree'>第二阶段</font></strong> ：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</p>
<p>理解 make 执行过程的两个阶段是很重要的，它能帮助我们更深入的了解执行过程中变量以及函数是如何被展开的。首先，明确以下基本的概念：<strong><font color='orange'>在 make 执行的第一阶段中如果变量和函数被展开，那么称此展开是“立即”的，此时所有的变量和函数被展开在需要构建的结构链表的对应规则中（此规则在建立链表是需要使用）。其他的展开称之为“延后”的，这些变量和函数不会被“立即”展开，而是直到后续某些规则须要使用时或者在 make 处理的第二阶段它们才会被展开。</font></strong> <strong>规则中目标和依赖如果引用其他的变量，则被立即展开，而规则的命令行中的变量引用会被延后展开</strong> 。</p>
<h3 id="font-color-red-read-only依赖-font"><font color='red'>read-only依赖</font></h3>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBS = libtest.a</span><br><span class="line"><span class="section">foo:foo.c | <span class="variable">$(LIBS)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure>
<p>make在执行这个规则时，如果目标文件 foo 已经存在，当 foo.c 被修改以后，目标“foo”将会被重建，但是当 libtest.a 被修改以后，将不执行规则的命令来重建目标 foo 。就是说，规则中依赖文件 $(LIBS) 只有在目标文件不存在的情况下，才会参与规则的执行，当目标文件存在时此依赖不会参与规则的执行过程。</p>
<h3 id="font-color-red-目录搜索机制-font"><font color='red'>目录搜索机制</font></h3>
<h3 id="font-color-red-空文件目标-font"><font color='red'>空文件目标</font></h3>
<h3 id="font-color-red-多目标规则-font"><font color='red'>多目标规则</font></h3>
<p>一个具有多目标的规则相当于多个规则，规则的命令对不同的目标的执行效果不同，因为在规则的命令中可能使用了自动变量 <code>$@</code> :</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mbr.bin loader.bin : common.s</span><br><span class="line">	nasm -f bin common.s -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line"><span class="section">mbr.bin: common.s</span></span><br><span class="line">	nasm -f bin common.s -o mbr.bin</span><br><span class="line"><span class="section">loader.bin: common.s</span></span><br><span class="line">	nasm -f bin common.s -o loader.bin</span><br></pre></td></tr></table></figure>
<p>注意，多目标规则下，每个目标都有相同的依赖，所以遇到以下情况就不好使了：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbr.bin loader.bin : mbr.s loader.s</span><br><span class="line">	nasm -f bin <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>以上代码的意思是，mbr.bin 和 loader.bin 的依赖文件都同时是 mbr.s 和 loader.s，而我们想表达的意思为 mbr.bin 的依赖文件为 mbr.s，loader.bin 的依赖文件为 loader.s 。要解决这个问题，需要用到后面的静态模式。</p>
<blockquote>
<p>虽然在多目标的规则中，可以根据不同的目标使用不同的命令（在命令行中使用自动化变量<code>$@</code> ）；但是，<strong><font color='orange'>多目标规则并不能做到根据目标文件自动改变依赖文件</font></strong> 。</p>
</blockquote>
<h3 id="font-color-red-多规则目标-font"><font color='red'>多规则目标</font></h3>
<p>一个文件可以作为多个规则的目标（多个规则中只能有一个规则定义命令）。<strong>这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标的一个依赖文件列表</strong> ，当其中任何一个依赖文件比目标新时， make 将会执行特定的命令来重建这个目标。</p>
<p><strong><font color='orange'>对于一个多规则的目标，重建此目标的命令只能出现在一个规则中（可以是多条命令）</font></strong> 。<strong>如果多个规则同时给出重建此目标的命令， make将使用最后一个规则中所定义的命令，同时提示错误信息</strong> 。若要对相同的目标使用不同的规则中所定义的命令，则须使用另外一种方式——“双冒号”规则来实现。</p>
<h3 id="font-color-red-双冒号规则-font"><font color='red'>双冒号规则</font></h3>
<p>Makefile 中，一个目标可以出现在多个规则中。<strong>但是这些规则必须是同一类型的规则，要么都是普通规则， 要么都是双冒号规则</strong> ，而不允许一个目<br>
标同时出现在两种不同类型的规则中。双冒号规则的处理和普通规则的处理过程完全不同，表现在以下几个方面：</p>
<ol>
<li>双冒号规则中，当依赖文件比目标更新时，规则将会被执行；<strong><font color='orange'>对于一个没有依赖而只有命令行的双冒号规则，当引用此目标时，规则的命令将会被无条件执行</font>。而普通规则，当规则的目标文件存在时，此规则的命令永远不会被执行（目标文件永远是最新的）</strong> 。</li>
<li>当同一个文件作为多个双冒号规则的目标时，这些不同的规则会被独立的处理，而不是像普通规则那样合并所有的依赖到一个目标文件。<strong><font color='orange'>多个双冒号规则中的某一个的依赖文件被改变之后， make 只执行此规则定义的命令，而其它的以这个文件作为目标的双冒号规则将不会被执行</font></strong> 。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Newprog :: foo.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">Newprog :: bar.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-静态模式-font"><font color='red'>静态模式</font></h3>
<p>静态模式规则是这样一个规则：<strong><font color='orange'>规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件</font></strong> 。静态模式规则比多目标规则更通用，它不需要多个目标具有相同的依赖。<strong>但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的</strong> 。</p>
<p>静态模式的语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGETS... : TARGET-PATTERN:PREREQ-PATTERNS</span><br><span class="line">	COMMANDS</span><br></pre></td></tr></table></figure>
<p><code>TAGET-PATTERN</code> 和 <code>PREREQ-PATTERNS</code> 说明了如何为每一个目标文件生成依赖文件。<strong>从目标模式 <code>TAGET-PATTERN</code> 的目标名字(hello.o)中抽取文件名(hello)，称为“茎”；使用“茎”替代依赖模式 <code>PREREQ-PATTERNS</code> 中的相应部分来产生对应目标的依赖文件</strong> 。举例如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#相当于如下：</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在模式规则的依赖列表中使用不包含模式字符“ %”也是合法的，代表这个文件是所有目标的依赖文件。</p>
</blockquote>
<p>需要强调的是，在使用静态模式规则时，指定的目标必须和目标模式相匹配，否则执行 make 时将会得到一个错误提示。如果存在一个文件列表，其中一部分符合某一种模式而另外一部分符合另外一种模式，这种情况下我们可以使用 filter 函数：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">	emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态模式规则对一个较大工程的管理非常有用，它可以对整个工程的同一类文件的重建规则进行一次定义，而实现对整个工程中此类文件指定相同的重建规则。比如，可以用来描述整个工程中所有的 .o 文件的依赖规则和编译命令。通常的做法是将生成同一类目标的模式定义在一个 make.rules 的文件中，然后在工程各个模块的 Makefile 中包含此文件。</p>
</blockquote>
<h3 id="font-color-red-模式规则-font"><font color='red'>模式规则</font></h3>
<p>模式规则的格式：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c </span><br><span class="line">	COMMAND</span><br></pre></td></tr></table></figure>
<p>对于模式规则 <code>%.o : %.c</code> ，它表示的含义是：所有的 .o 文件依赖于 <strong>对应的</strong> .c 文件。模式规则中依赖文件也可以不包含模式字符“%”。当依赖文件名中不包含模式字符“%”时，其含义是所有符合目标模式的目标文件都依赖于一个指定的文件（例如：%.o : debug.h，表示所有的.o文件都依赖于头文件“debug.h”）。</p>
<blockquote>
<p>要注意的是：模式字符“%”的匹配和替换发生在规则中所有变量和函数引用展开之后，变量和函数的展开一般发生在make读取Makefile时，而模式规则中的 “%” 的匹配和替换则发生在make执行时。</p>
</blockquote>
<p>可以有多个目标模式：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.bin %.o:%.s</span><br><span class="line">	nasm -f bin <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<ul>
<li>模式规则在 Makefile 中的顺序需要注意，当一个目标文件同时符合多个目标模式时， make 将会把第一个目标匹配的模式规则作为重建它的规则。</li>
<li>Makefile中明确指定的模式规则会覆盖隐含模式规则。<strong><font color='orange'>就是说如果在 Makefile 中出现了一个对目标文件合适可用的模式规则，那么 make 就不再为这个目标文件寻找其它隐含规则</font></strong> 。<strong>明确规则永远优先于隐含规则</strong> 。</li>
</ul>
<h3 id="font-color-red-模式匹配-font"><font color='red'>模式匹配</font></h3>
<p>模式规则中依赖文件名的确定过程是：首先根据规则定义的目标模式匹配实际的目标文件，确定“茎”(模式“%.o”所匹配的文件“ test.c”中“ test”就是“茎”)，之后使用“茎”替代规则依赖文件名中的模式字符“%”，生成依赖文件名，这样就产生了一个明确指定了目标和依赖文件的规则。<strong><font color='orange'>注意，当目标模式中包含斜杠（目录部分），在进行目标文件匹配时，文件名中包含的目录字符串在匹配之前被移除，只进行基本文件名的匹配；匹配成功后，再将目录部分加入到匹配之后的字符串之前形成“茎”</font></strong> 。例如目标模式为“e%t”，文件“src/eat”匹配这个模式，那么“茎”就是“src/a”。</p>
<h3 id="font-color-red-隐含规则-font"><font color='red'>隐含规则</font></h3>
<p>某些情况下，make 会自动根据已存在(或者可以被创建)的源文件类型来启动相应的隐含规则，最常见的隐含规则即 .c 文件生成 .o 文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">	cc -o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>即使不给出 foo.o, bar.o 的创建规则，makefile 也会自动根据隐含规则(%.c --&gt; %.o)来创建这些依赖文件。</p>
<p><strong><font color='orange'>每一个内嵌的隐含规则中都存在一个目标模式和依赖模式，而且同一个目标模式可以对应多个依赖模式</font></strong>。例如：一个.o 文件可以由 c 编译器编译对应的.c 源文件得到，也可以由 Pascal 编译器编译 .p 的源文件得到。当一个隐含规则的目标是另外一个隐含规则的依赖时，我们称它们是一个<a href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E9%93%BE">隐含规则链</a>。</p>
<p><strong><font color='orange'>注意：给目标文件指定明确的依赖文件并不会影响隐含规则的搜索！</font></strong> 举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.p</span></span><br><span class="line"><span class="comment">#此规则只说明依赖关系，没有指定命令</span></span><br></pre></td></tr></table></figure>
<p>这个规则指定了 foo 的依赖文件是 foo.p 。但是如果在工作目录下存在同名 .c 源文件 foo.c，执行 make 的结果就不是用 pc 编译 foo.p 来生成 foo ，而是用 cc 编译 foo.c 来生成目标文件。<strong>这是因为在隐含规则列表中对 .c 文件的隐含规则处于 .p 文件隐含规则之前</strong> 。当需要给目标指定明确的重建规则时，规则描述中就不能省略命令行，<strong>这个规则必须提供明确的重建命令来说明目标需要重建所需要的动作</strong> 。为了能够在存在 .c 文件的情况下编译 foo.p ，需要使用如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.p</span></span><br><span class="line">	pc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p><strong><font color='orange'>这一点在多语言实现的工程编译中，需要特别注意！否则编译出来的可能就不是你想要得程序。</font></strong></p>
<p>另外，当我们不想让 make 为一个没有命令行的规则中的目标搜索隐含规则时，我们需要使用 <strong>空命令</strong> 来实现：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#空命令格式： </span></span><br><span class="line"><span class="comment">#target: ;</span></span><br><span class="line"><span class="section">foo.o: foo.p ;</span></span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-隐含规则一览-font"><font color='red'>隐含规则一览</font></h3>
<ol>
<li>
<p><strong>编译C程序</strong> ：<code>N.o</code> 自动由 <code>N.c</code> 生成，执行命令为 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></p>
</li>
<li>
<p><strong>编译C++程序</strong> ：<code>N.o</code> 自动由 <code>N.cc</code> 或者 <code>N.cpp</code> 生成，执行命令为 <code>$(CXX) -c $(CPPFLAGS)$(CFLAGS)</code> 。</p>
</li>
<li>
<p><strong>汇编程序</strong> ：<code>N.o</code> 可自动由 <code>N.s</code> 生成，执行命令是：<code>$(AS) $(ASFLAGS)</code> ；<br>
<code>N.s</code> 可由 <code>N.S</code> 生成， C预编译器 <code>cpp</code> ，执行命令是： <code>$(CPP) $(CPPFLAGS)</code> 。</p>
<blockquote>
<p>N.s 是不需要预处理的汇编源文件，N.S 是需要预处理的汇编源文件。</p>
</blockquote>
</li>
<li>
<p><strong>链接单一的object文件</strong> ：<code>N</code> 自动由 <code>N.o</code> 生成，通过 C 编译器使用链接器（GUN ld），执行命令是：<br>
<code>$(CC) $(LDFLAGS) N.o $(LOADLIBES) $(LDLIBS)</code> 。<br>
<strong>注意，此规则仅适用于由一个源文件直接产生可执行文件的情况</strong> 。当需要有多个源文件共同来创建一个可执行文件时，需要在 Makefile 中增加隐含规则的依赖文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x : y.o z.o <span class="comment">#x和x.c对应，因此隐含规则在进行链接时，自动将x.c作为其依赖文件</span></span><br><span class="line"><span class="comment">#当x.c、y.c和z.c都存在时，规则执行如下命令：</span></span><br><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o y.o z.o</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上规则按顺序排列，<strong>make 查找隐含规则时也是按以上顺序进行</strong> 。其他规则不常用，不再阐述。</p>
<h3 id="font-color-red-隐含变量-font"><font color='red'>隐含变量</font></h3>
<p><strong>隐含变量分为两类：1. 代表一个程序的名字（例如：<code>CC</code> 代表了编译器这个可执行程序）；2. 代表执行这个程序使用的参数（例如：CFLAGS）</strong> 。</p>
<p>我们可以对隐含变量重定义。对这些变量重定义后如果需要整个工程的各个子目录有效，需要使用关键字 <code>export</code> 将他们导出，否则目录间编译命令可能出现不一致。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS=nasm</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">代表命令的变量</mark> </strong></p>
<ul>
<li><strong>AR</strong>：函数库打包程序，可创建静态库.a文档。默认是ar。</li>
<li><strong>AS</strong> ：汇编程序。默认是as。</li>
<li><strong>CC</strong> ：C编译程序。默认是cc。</li>
<li><strong>CXX</strong> ：C++编译程序。默认是g++。</li>
<li><strong>CPP</strong> ：C程序的预处理器（输出是标准输出设备）。默认是 $(CC) -E。</li>
<li><strong>RM</strong> ：删除命令。默认是 <code>rm -f</code></li>
</ul>
<p><strong><mark class="hl-label blue">代表参数的变量</mark> </strong></p>
<ul>
<li>ARFLAGS：执行 AR 命令的命令行参数。默认值是 rv。</li>
<li>ASFLAGS：执行汇编语器 AS 的命令行参数（明确指定 .s 或 .S 文件时）</li>
<li>CFLAGS：执行 CC 编译器的命令行参数（编译.c源文件的选项）。</li>
<li>CXXFLAGS：执行 g++ 编译器的命令行参数（编译.cc源文件的选项）。</li>
<li>CPPFLAGS：执行C预处理器 cc -E 的命令行参数（ C 编译器会用到）。</li>
<li>LDFLAGS：链接器（ld）参数</li>
</ul>
<h3 id="font-color-red-隐含规则链-font"><font color='red'>隐含规则链</font></h3>
<p>创建 .o 文件<u>可能</u>经过如下步骤：N.c → N.s → N.o ；这个过程有两种情况：</p>
<ol>
<li>如果 N.s 存在：make 可以确定出 N.o 可由 N.s 创建；之后 make 试图使用隐含规则来重建 N.s，它会寻找 N.c 这个文件，如果 N.c 存在，则执行隐含规则来重建 N.s 这个文件，之后再由 N.s 重建 N.o 。当不存在 N.c 文件时，直接编译 N.s 生成 N.o 。</li>
<li>如果 N.s 不存在：只要存在 N.c 这个文件，那么 make 也会经过这两个步骤来重建 N.o (N.c → N.s → N.o)；此时，N.s 作为中间文件存在，命令结束将被删除。</li>
</ol>
<h3 id="font-color-red-定义命令包-font"><font color='red'>定义命令包</font></h3>
<p>书写 Makefile 时，可能有多个规则会使用相同的一组命令。为了提高效率，我们想到了将这组命令封装，在要执行的地方进行调用。在 GNU make中，可以使用指示符 <code>define</code> 来完成这个功能：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> frobnicate</span><br><span class="line">	@echo <span class="string">&quot;frobnicating target <span class="variable">$@</span>&quot;</span></span><br><span class="line">	frob-step-1 <span class="variable">$&lt;</span> -o <span class="variable">$@</span>-step-1</span><br><span class="line">	frob-step-2 <span class="variable">$@</span>-step-1 -o <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="comment">#像使用变量一样调用它：</span></span><br><span class="line"><span class="section">frob.out: frob.in</span></span><br><span class="line">	<span class="variable">$(frobnicate)</span></span><br></pre></td></tr></table></figure>
<p>注意，命令前必须有 [Tap] 键。</p>
<h3 id="font-color-red-自动变量-font"><font color='red'>自动变量</font></h3>
<p>从前面的学习中我们能够发现，自动变量是在模式规则的命令行中使用的。自动变量类型如下：</p>
<ul>
<li>
<p><code>$^</code> ：代表所有通过目录搜索得到的 <strong>依赖文件</strong> 的完整路径名(目录+文件名)列表。<code>$</code> 会去掉重复的依赖文件。</p>
</li>
<li>
<p><code>$@</code> ：表示规则的目标文件名(而非目标列表)。在多目标模式规则中，它代表的是哪个触发规则被执行的目标文件名。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEF := foo bar</span><br><span class="line"><span class="variable">$(EXEF)</span> : debug.h <span class="comment">#目标变量</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(<span class="built_in">addsuffix</span> .c,<span class="variable">$@</span>)</span> –o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>$&lt;</code> ：规则的第一个依赖文件名。为什么需要第一个依赖？似乎是个很奇怪的需求。如下例子便可解释：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c defs.h hack.h</span><br><span class="line">	cc -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>$?</code> ：所有比目标文件更新的依赖文件列表，空格分割。这个规则也比较常用：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态库文件libN.a，它由一些.o文件组成。这个规</span></span><br><span class="line"><span class="comment">#则实现了只将更新后的.o文件加入到库中：</span></span><br><span class="line"><span class="section">lib: foo.o bar.o lose.o win.o</span></span><br><span class="line">	ar r lib $</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上为常用自动变量，其他自动变量见手册。</p>
<h3 id="font-color-red-头文件自动产生依赖-font"><font color='red'>头文件自动产生依赖</font></h3>
<h3 id="font-color-red-嵌套执行make-font"><font color='red'>嵌套执行make</font></h3>
<h3 id="font-color-red-函数-font"><font color='red'>函数</font></h3>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数格式</span></span><br><span class="line"><span class="variable">$(FunName ARG)</span></span><br><span class="line"><span class="comment">#比如</span></span><br><span class="line"><span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(x)</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用语法格式中 FUNCTION 是需要调用的函数名，它应该是 make 内嵌的函数名。对于用户自己的函数需要通过 make 的 call 函数来间接调用。</li>
<li>参数和函数名之间使用空格隔开，存在多个参数时，参数之间使用 <code>,</code> 隔开。<strong>注意，一个参数中可能有多个变量或文本</strong> 。</li>
</ul>
<h3 id="font-color-red-动态库-font"><font color='red'>动态库</font></h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2022/10/09/makefile%E5%85%A5%E9%97%A8/">http://jyxcpp.netlify.app/2022/10/09/makefile%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/makefile/">makefile</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"><img class="prev-cover" src="/2022/img/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">make clean的必要性&amp;&amp;自动找寻头文件</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/"><img class="next-cover" src="/2022/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">详解前缀树(字典树)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/" title="make clean的必要性&amp;&amp;自动找寻头文件"><img class="cover" src="/2022/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-09</div><div class="title">make clean的必要性&amp;&amp;自动找寻头文件</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%80%E4%B9%88%E6%98%AFmakefile%EF%BC%9F-font"><span class="toc-number">1.</span> <span class="toc-text">什么是makefile？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%B9%A6%E5%86%99%E8%AF%AD%E6%B3%95-font"><span class="toc-number">2.</span> <span class="toc-text">书写语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%BB%98%E8%AE%A4makefile%E6%96%87%E4%BB%B6-font"><span class="toc-number">3.</span> <span class="toc-text">默认makefile文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-font"><span class="toc-number">4.</span> <span class="toc-text">执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BC%AA%E7%9B%AE%E6%A0%87-font"><span class="toc-number">5.</span> <span class="toc-text">伪目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%BC%BA%E5%88%B6%E7%9B%AE%E6%A0%87-font"><span class="toc-number">6.</span> <span class="toc-text">强制目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%BB%88%E6%9E%81%E7%9B%AE%E6%A0%87-font"><span class="toc-number">7.</span> <span class="toc-text">终极目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%80%9A%E9%85%8D%E7%AC%A6-font"><span class="toc-number">8.</span> <span class="toc-text">通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2-font"><span class="toc-number">9.</span> <span class="toc-text">文件搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%91%BD%E4%BB%A4%E5%9B%9E%E6%98%BE-font"><span class="toc-number">10.</span> <span class="toc-text">命令回显</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%91%BD%E4%BB%A4%E5%B9%B6%E5%8F%91-font"><span class="toc-number">11.</span> <span class="toc-text">命令并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%91%BD%E4%BB%A4%E5%B9%B6%E8%A1%8C-font"><span class="toc-number">12.</span> <span class="toc-text">命令并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99-font"><span class="toc-number">13.</span> <span class="toc-text">命令出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-override%E6%8C%87%E7%A4%BA%E7%AC%A6-font"><span class="toc-number">14.</span> <span class="toc-text">override指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80-font"><span class="toc-number">15.</span> <span class="toc-text">变量基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8F%98%E9%87%8F%E5%80%BC%E6%9B%BF%E6%8D%A2-font"><span class="toc-number">16.</span> <span class="toc-text">变量值替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-font"><span class="toc-number">17.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F-font"><span class="toc-number">18.</span> <span class="toc-text">目标变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F-font"><span class="toc-number">19.</span> <span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-font"><span class="toc-number">20.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8C%85%E5%90%AB%E5%85%B6%E4%BB%96-makefile-%E6%96%87%E4%BB%B6-font"><span class="toc-number">21.</span> <span class="toc-text">包含其他 makefile 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-make%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90makefile%E6%96%87%E4%BB%B6-font"><span class="toc-number">22.</span> <span class="toc-text">make如何解析makefile文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-read-only%E4%BE%9D%E8%B5%96-font"><span class="toc-number">23.</span> <span class="toc-text">read-only依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%9B%AE%E5%BD%95%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6-font"><span class="toc-number">24.</span> <span class="toc-text">目录搜索机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%A9%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E6%A0%87-font"><span class="toc-number">25.</span> <span class="toc-text">空文件目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%99-font"><span class="toc-number">26.</span> <span class="toc-text">多目标规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%A4%9A%E8%A7%84%E5%88%99%E7%9B%AE%E6%A0%87-font"><span class="toc-number">27.</span> <span class="toc-text">多规则目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8F%8C%E5%86%92%E5%8F%B7%E8%A7%84%E5%88%99-font"><span class="toc-number">28.</span> <span class="toc-text">双冒号规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F-font"><span class="toc-number">29.</span> <span class="toc-text">静态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99-font"><span class="toc-number">30.</span> <span class="toc-text">模式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-font"><span class="toc-number">31.</span> <span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99-font"><span class="toc-number">32.</span> <span class="toc-text">隐含规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%80%E8%A7%88-font"><span class="toc-number">33.</span> <span class="toc-text">隐含规则一览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%9A%90%E5%90%AB%E5%8F%98%E9%87%8F-font"><span class="toc-number">34.</span> <span class="toc-text">隐含变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E9%93%BE-font"><span class="toc-number">35.</span> <span class="toc-text">隐含规则链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%8C%85-font"><span class="toc-number">36.</span> <span class="toc-text">定义命令包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F-font"><span class="toc-number">37.</span> <span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%A4%B4%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%BA%A7%E7%94%9F%E4%BE%9D%E8%B5%96-font"><span class="toc-number">38.</span> <span class="toc-text">头文件自动产生依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8Cmake-font"><span class="toc-number">39.</span> <span class="toc-text">嵌套执行make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%87%BD%E6%95%B0-font"><span class="toc-number">40.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%8A%A8%E6%80%81%E5%BA%93-font"><span class="toc-number">41.</span> <span class="toc-text">动态库</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>