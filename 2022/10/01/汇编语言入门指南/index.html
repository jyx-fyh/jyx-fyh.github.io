<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>汇编语言入门 | 极简</title><meta name="keywords" content="汇编语言快速入门"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="汇编语言快速入门">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言入门">
<meta property="og:url" content="http://jyxcpp.netlify.app/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="汇编语言快速入门">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/28.jpg">
<meta property="article:published_time" content="2022-10-01T14:53:43.000Z">
<meta property="article:modified_time" content="2023-03-12T11:21:16.466Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:21:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/28.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-01T14:53:43.000Z" title="发表于 2022-10-01 22:53:43">2022-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:21:16.466Z" title="更新于 2023-03-12 19:21:16">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="font-color-red-什么是汇编语言？-font"><font color='red'>什么是汇编语言？</font></h3>
<p>我们最初学习编程时，一般都是学习高级语言，诸如 C++，Java，Python 等，通过一定语法编写代码，然后运行，代码就能够顺利地在电脑中跑起来。但是，计算机实际上并不认识高级语言，它只认识如 <code>01011001</code> 这样的二进制数字。0，1 虽然简单，但无数个代表着高低电平的 0 和 1 组合却能指挥计算机完成几乎所有你能想到的任务。<br>
早期的程序是由科学家们手工编写二级制代码完成的，面对巨量的，毫无规律的 0 和 1，其工作量可想而知。为了解决这一窘况，汇编语言应运而生。其实， <strong><font color='orange'>汇编语言严格来说并不是一门语言，而仅仅只是一套助记符，它与二进制代码一一对应</font></strong> 。如下图，汇编语言与人类语言更为接近，便于阅读和记忆。<br>
<img src="/2022/img/image-20221001232413430.png" alt="左边是二进制代码的十六进制格式，右边是对应的汇编代码" style="zoom:67%;" /><br>
<strong>汇编语言直接运行于硬件之上</strong> 。<strong>由于 CPU 硬件设计和内部架构的不同，其对应的指令集（机器语言）也不同，每一种 CPU 都有自己的汇编指令集</strong> 。 <strong><font color='orange'>所以，汇编语言依赖于硬件体系，不便于移植</font></strong> 。对于同一个程序，如果在这台机器上可以运行，而到另一台机器上就必须重新改写某些代码以适应机器，那这样就太麻烦了。再之，汇编代码只比机器代码容易阅读了一点而已，理解起来还是很困难。</p>
<h3 id="font-color-red-汇编语言的种类-font"><font color='red'>汇编语言的种类</font></h3>
<p><strong>从汇编格式上：</strong> 分为 <strong>Intel</strong> 和 <strong>AT&amp;T</strong> 两种风格，两者是 X86 架构的不同写法。<strong>Intel 格式和 AT&amp;T 格式的区别只是符号系统的区别</strong> 。前者常见于 Windows，masm 仅支持 Intel；而 AT&amp;T 在 Unix 中更常见，GNU 汇编器的默认格式就是 AT&amp;T。<br>
<strong>从架构体系上：</strong> 分为 <strong>复杂指令集(CISC)</strong> 和 <strong>精简指令集(RISC)</strong> ，前者的代表是 <strong>X86架构</strong> ，后者代表是 <strong>ARM</strong> 架构。RISC 多用于移动端，全世界超过95%的智能手机和平板电脑都采用 ARM 架构；CISC 多用于 PC 端和服务器端，苹果的 PC 机使用的 CPU(M1) 是 ARM 架构。</p>
<h3 id="font-color-red-汇编语言的组成-font"><font color='red'>汇编语言的组成</font></h3>
<ol>
<li><strong>汇编指令</strong> ，如 <code>mov</code> ，有对应的机器码。</li>
<li><strong>伪指令</strong> ，如 <code>segment</code> 和 <code>end</code> ，由汇编器识别，没用机器码，计算机不执行。</li>
<li><strong>其他符号</strong> ，如 <code>+</code> 、 <code>-</code> 等，由汇编器识别，没有机器码。</li>
</ol>
<p><strong>汇编指令是汇编语言的核心。</strong> 其中，伪指令根据编译器的不同而有所变化。</p>
<h3 id="font-color-red-CPU总线-font"><font color='red'>CPU总线</font></h3>
<p>CPU 读写硬件中的数据时，必须经过下面三类信息的交互：</p>
<ol>
<li><strong>地址信息</strong> ：储存单元的地址</li>
<li><strong>控制信息</strong> ：选择器件，读或写的命令.</li>
<li><strong>数据信息</strong> ：读或写的内容。</li>
</ol>
<p>以上三种信息分别由 <strong>地址总线、控制总线、数据总线</strong> 传递。总线将 CPU 与其他芯片连接起来。以下是 CPU 从地址为 3 的内存中读取数据的过程：<br>
<img src="/2022/img/IMG_0463(20221012-154228).PNG" style="zoom:67%;" /></p>
<ol>
<li>CPU 通过地址线将位置信息发送给内存</li>
<li>CPU 通过控制线向内存发送读命令，选中储存器芯片，并通知它将从内存读取数据。</li>
<li>储存器将相应位置的数据通过数据线传送给 CPU。</li>
</ol>
<p><strong>总线的宽度：</strong> 一根导线上只能传送两种状态：低电平与高电平，对应着 0 和 1；那么 32 根导线一次传送的最大数据为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 。总线所包含的导线数目即为总线宽度。<br>
<strong><font color='orange'>地址总线的宽度代表着 CPU 的寻址能力，即最多能用多少内存；数据总线的宽度决定了 CPU 对数据的读写能力，平时我们说的 32/64 位机器，指的就是机器的数据总线宽度(寄存器的宽度)；控制总线的宽度决定了 CPU 对外部器件的控制能力。</font></strong></p>
<p><strong>8080，8088，80286，80386 的地址总线宽度分别为 16，20，24，32，则它们的寻址能力分别为：64KB，1MB，16MB，4GB</strong> 。</p>
<h3 id="font-color-red-硬件概览-font"><font color='red'>硬件概览</font></h3>
<p><strong><mark class="hl-label blue">主板</mark> </strong><br>
主板上有核心器件（CPU，储存器等）和一些主要器件（外围芯片组，扩展插槽等），这些器件通过总线相连。</p>
<p><strong><mark class="hl-label blue">接口卡</mark> </strong><br>
所有可被程序控制的硬件设备都必须受到 CPU 控制。但 CPU 不能直接控制这些设备，直接控制设备的是接口卡，而 CPU 通过总线与接口卡相连，利用接口卡来间接控制设备。简单来说，CPU 通过总线向接口卡发送命令，接口卡根据收到的命令来指挥设备工作。<br>
<strong><mark class="hl-label blue">储存器芯片</mark> </strong><br>
从读写属性上分为两类：</p>
<ol>
<li><strong>ROM (Read Only Memory)</strong> ，随机储存器可写可读，但必须带电储存，关机后数据丢失；</li>
<li><strong>RAM (Random Access Memory)</strong>  ，只读储存器只可读，关机后内容不丢失；</li>
</ol>
<p>从功能上大概分为以下几类：</p>
<ol>
<li><strong><font color='gree'>随机储存器</font></strong> ：用于存放供 CPU 使用的绝大部分程序和数据。<strong>主随机储存器一般由主板上的 RAM 和扩展插槽上的 RAM 组成。</strong></li>
<li><strong><font color='gree'>装有 BIOS (Basic IO System) 的 ROM</font></strong> ：<font color='orange'>BIOS 是由主板和各类插口卡（网卡、显卡等）厂商提供的系统软件，通过它来利用该设备进行最基本的输入输出。主板上的 ROM 存储着系统 BIOS ；显卡上的 ROM 中储存着显卡的 BIOS；网卡中的 ROM 存储着网卡的 BIOS</font>。<strong>机器加电后，启动 BIOS 程序进行一系列的机器初始化动作，然后装入操作系统的初始文件，引导操作系统启动</strong> 。<strong>BIOS是固化在硬件的一种程序</strong> 。BIOS 中包含以下内容：
<ul>
<li>硬件系统的检测和初始化程序。</li>
<li>外部中断和内部中断的中断例程。</li>
<li>对硬件设备进行 I/O 的中断例程。</li>
<li>其他和硬件系统相关的中断例程。</li>
</ul>
</li>
<li><strong><font color='gree'>接口卡</font></strong> ：某些接口卡需要对大批量的输入输出进行储存，其上就会装有 RAM。最典型的就是显卡上的 RAM (显存)。显卡随时将显存中的数据向显示器输出，所以我们才能看见屏幕上的内容。</li>
</ol>
<img src="/2022/img/IMG_0465(20221012-172337).PNG" alt="各类储存器的逻辑连接" style="zoom: 67%;" />
<h3 id="font-color-red-工作模式-font"><font color='red'>工作模式</font></h3>
<p>8086/8088 CPU 为单任务操作系统，可以直接操控内存，是不安全的。Intel 进而推出 80286，具备了对多任务系统的支持，首次提出了保护模式的概念。80286 拥有 24 根地址线，可访问 16 MB 的内存，其 16 位段寄存器中也不再存放段地址，而是存放段选择子，真正的段地址位于描述符高速缓存中；其偏移地址最大仍为 64 KB，这是很大的缺陷。而后来的 80386 是划时代的，拥有 32 根地址线，可访问 4 GB 内存；其段偏移量也是 32 位的，在最典型的情况下，可以将 4GB 当作一个段来使用，即平坦模型。它支持以下三个模式：</p>
<ol>
<li>实模式：相当于一个 8086</li>
<li>保护模式：多任务环境，建立保护机制。</li>
<li>虚拟 8086 模式：可以从保护模式切换到实模式，这种方式方便用户在保护模式下运行 8086 程序。</li>
</ol>
<p>80286 CPU 的缺陷在于，它只提供实模式和保护模式，没有提供虚拟模式，这很不利于用户的工作。</p>
<h3 id="font-color-red-内存地址空间-font"><font color='red'>内存地址空间</font></h3>
<p><strong><font color='red'>利用接口卡与主储存器，CPU 便能够将所有硬件抽象成内存，通过修改内存来完成对各类硬件的控制！</font></strong> 将所有储存器看作一个由若干储存单元组成的逻辑储存器，这个逻辑储存器就是我们常说的内存地址空间。<br>
<img src="/2022/img/IMG_0466(20221012-173407).PNG" style="zoom:67%;" /></p>
<p><strong>每个物理储存器都在这个地址空间中占有一定位置，CPU 在这个位置上读写数据，实际上就在对应的物理储存器中读写数据。</strong></p>
<p>实模式内存分布如下：<br>
<img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70.png" alt=""></p>
<p>一般而言，如果需要向内存空间写入数据的话,要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元向里面写入，这可能导致程序的崩溃。<strong>注意，我们在纯DOS方式(实模式)下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在CPU实模式下的DOS没有能力对硬件系统进行全面、严格的管理。但在Windows 2000、Unix这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操根本不可能的，硬件已被这些操作系统利用CPU保护模式所提供的功能全面而严格地管控</strong> 。<br>
<strong><font color='orange'>在DOS中，<code>0:0200~0:02FF</code> 这段 256 字节的空间一般为空闲，可随意使用。</font></strong></p>
<h3 id="font-color-red-数据表示-font"><font color='red'>数据表示</font></h3>
<ul>
<li>字节：8 bits；字节是计算机的最小操作单元，比特是最小存储单元。</li>
<li>字：2 字节，即 16 bits；由高位字节和低位字节组成，高低位指的是数据的高低位，而非地址的高低。</li>
<li>常用表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20}=1MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{24}=16MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span></li>
<li>一个两位十六进制数可以使用一个字节储存，一个四位十六进制数可以用两个字节存储，以此类推。比如 AX 中存放 0XFFEE，那么 AH 中为 0XFF，AL 中为 0XEE。这种方式可以很容易地看出数据的组成，利于直观分析。</li>
<li>在小端机器中，低地址存放字型数据的低位数据，高地址存放字型数据的高位数据。</li>
</ul>
<h3 id="font-color-red-8086寻址方案-font"><font color='red'>8086寻址方案</font></h3>
<p><strong>8086 CPU有 20 位地址总线，达到 1 MB寻址能力，所以内存空间也只有 1MB</strong> 。但 8086 CPU是 16 位结构，即，其寄存器最大宽度为 16 位 (或者说，其运算器一次最多可以处理16位数据，寄存器和运算器之间的通路为16位) ，所以如果只是简单发出地址，那么只能一次性处理或存储 16 位地址。所以，<strong>8086 使用两个 16 位地址合成一个 20 位物理地址</strong> ，即 <strong><font color='orange'>物理地址=段地址×16+偏移地址，其中，段地址×16又叫做基础地址</font></strong> 。<br>
<img src="/2022/img/IMG_0467(20221012-193401).PNG" style="zoom:67%;" /><br>
有几点需要注意：</p>
<ol>
<li>乘 16 即右移 4 位。</li>
<li>段地址×16 必然是 16 的倍数，所以段起点必然也为 16 的倍数，比如 10010H。</li>
<li>一个物理地址可能由多种运算得到，比如，10010H 可能由 1001H×16+0 得到，也可能由 1000H×16+0010H得到。</li>
<li><strong>由于偏移地址为 16 位，所以一个段的最大长度为 64KB</strong></li>
<li><strong>段始终以 16 字节对齐</strong> ，如果 data 段只有 14 字节，范围为 1001:0 ~ 10001:D，code 段也会从 1002:0 开始。</li>
</ol>
<h3 id="font-color-red-内存定位的多种方式-font"><font color='red'>内存定位的多种方式</font></h3>
<img src="/2022/img/IMG_0471(20221013-163812).PNG" style="zoom:80%;" />
注意：
<ol>
<li>
<p><strong>在 [ ] 中，BX/SI/DI/BP 可以分别单独出现；</strong></p>
</li>
<li>
<p><strong>或只能以四种组合出现：BX 与 SI，BX 与 DI，BP 与 SI，BP 与 DI；</strong></p>
<blockquote>
<p>这样理解：BX 与 BP 为基址寄存器，DI 与 SI 为变址寄存器。</p>
</blockquote>
</li>
<li>
<p><strong>只要含 BP，默认段寄存器就为 SS</strong> ；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#错误方式：</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="font-color-red-指令的执行过程-font"><font color='red'>指令的执行过程</font></h3>
<ol>
<li>
<p>从 CS : IP 指向的内存单元读取指令，将指令送入指令缓冲器。</p>
<blockquote>
<p>指令缓冲器<strong>可防止高速处理器在数据传输序列期间被锁定到慢速 I/O 设备，或减少较快和较慢设备之间的速度不匹配</strong> 。</p>
</blockquote>
</li>
<li>
<p>IP = IP + 所读指令的长度，从而指向下一条指令。</p>
<blockquote>
<p>容易发现，指令的长度是可变的，那么 CPU 如何判断指令的长度呢？对于可变长编码，我们应该可以想到一条思路：每个指令的机器码都不可能是其他机器码的前缀。</p>
</blockquote>
</li>
<li>
<p>执行指令。然后转到步骤一，重复以上过程。</p>
</li>
</ol>
<p>指令从低到高地址依次执行。</p>
<h3 id="font-color-red-中断-font"><font color='red'>中断</font></h3>
<h4 id="font-color-gree-内中断-font"><font color='gree'>内中断</font></h4>
<p><strong>内中断分为软中断和异常</strong> ，指的是 CPU 本身执行当前指令时所发生的中断。内中断具体分为： <strong>1）由软中断指令 int 启动的中断；2）在一定条件下由 CPU 自身启动的中断(异常)</strong> 。当 CPU 内部发生以下情况时，会发出中断信息：</p>
<ol>
<li>
<p>除法错误</p>
</li>
<li>
<p>单步执行</p>
</li>
<li>
<p>执行 into 指令</p>
<blockquote>
<p>本指令检测 OF 标志位,当 OF=1 时,说明已发生溢出，立即产生一个<u>中断类型为 4 的中断</u>,当 OF＝0 时，本指令不起作用。本指令可用于溢出处理，影响 TF 和 IF 标志位。</p>
</blockquote>
</li>
<li>
<p>执行 int 指令</p>
<blockquote>
<p>指令格式为 int N，N 是字节型立即数，为中断码。</p>
</blockquote>
</li>
</ol>
<p><strong><mark class="hl-label blue">中断向量表</mark> </strong><br>
CPU 用中断类型码来标识中断信息，中断码长度为 1 字节，可表示 256 中断信息。<br>
CPU 侦测到中断码后，根据 <strong>中断向量表</strong> ( <strong>IVT</strong> ) 找到中断码对应的中断处理程序入口地址，并放入 CS:IP 中，执行程序。 <strong><font color='orange'>中断向量表在开机时由 BIOS 程序加载进内存，并放在 <code>0000:0000 ~ 0000:03ff</code> 这 1024 个字节中，其中 <code>0000:0200~0000:02ff这256字节一般为空闲</code></font></strong> 。中断向量表是PC系统中最重要的内存区。中断向量表每个表项长 4 字节，所以中断向量表最多有 256 个中断信息。</p>
<blockquote>
<p>DOS 也提供中断例程。BIOS 完成硬件检测和初始化后，调用 int 19h 进行操作系统的引导，从此将计算机交给操作系统。DOS 启动后，将自己提供的中断例程载入内存，并建立响应中断向量表项。<strong>DOS 只有 int 21h 一个例程，但可以根据 ah 中的功能号调用子功能，这就是为什么程序返回指令为 <code>mov ax,4c00和int 21h</code></strong>  。</p>
</blockquote>
<p><strong><mark class="hl-label blue">中断过程</mark> </strong><br>
<strong>用中断码 N 找到中断向量，并用它设置 CS:IP，这个过程由 CPU 硬件自动完成</strong> ，此过程被称为中断过程。由于处理完中断后，之前的程序应该恢复，所以执行中断前需要保存 CPU 现场（保存标志寄存器即可，其他寄存器会在中断处理内部保存）。中断过程如下：</p>
<ol>
<li>取得中断码 N</li>
<li>pushf</li>
<li>TF=0，IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li>IP=N×4，CS=N×4+2</li>
</ol>
<p>以上过程由 cpu 硬件自动完成，无需人为干预。</p>
<p><strong><mark class="hl-label blue">中断处理程序规范</mark> </strong></p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>iret</li>
</ol>
<p><strong><mark class="hl-label blue">响应中断的特殊情况</mark> </strong><br>
有些情况下，CPU 执行完当前指令后，即使发生中断，也不会响应。比如，向 SS 寄存器传送数据后，就算发生单步中断，CPU 也不会响应。原因是 SS:SP 联合指向栈顶，对它们的赋值应该连续完成，即，向 SS 赋值后，应立即向 SP 赋值，否则一旦 SS 赋值后发生中断， SS:SP 就指向了错误的栈顶，将引起错误。</p>
<p><strong><mark class="hl-label blue">int中断</mark> </strong><br>
<code>int n</code> 调用中断码为 n 的中断过程。int 和 call 类似，都是调用一段程序。系统将某些子程序以 int 中断的方式提供给应用程序调用。比如程序返回指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<h4 id="font-color-gree-外中断-font"><font color='gree'>外中断</font></h4>
<p>CPU 通过外中断来处理外设引发的事件。 <strong><font color='orange'>外中断分为可屏蔽中断和不可屏蔽中断，IF 只对外中断有效</font></strong> ：当 IF=1，进入中断程序后，允许转向可屏蔽中断；IF=0则不可。遇上不可屏蔽中断，无论 IF 为多少，都转向不可屏蔽中断。几乎所有外中断都是可屏蔽中断，电源断电等引起不可屏蔽中断。</p>
<h3 id="font-color-red-端口-font"><font color='red'>端口</font></h3>
<p><strong><mark class="hl-label blue">什么是端口</mark> </strong><br>
<strong>CPU 可以直接从以下三个地方直接读取数据：</strong></p>
<ol>
<li><strong>CPU 内部寄存器</strong></li>
<li><strong>内存单元</strong></li>
<li><strong>端口</strong></li>
</ol>
<p>前两者我们已经很清楚，那么端口是什么呢？端口是各种接口芯片上可供 CPU 读写的寄存器。CPU 将不同接口芯片的寄存器映射在内存中，形成统一的端口地址空间，这样就方便了对端口的读写。CPU 通过<font color='orange'>读写端口或内存映射</font>来间接访问硬件。关于端口更详细的讨论，见 <a target="_blank" rel="noopener" href="https://blog.ours1984.top/posts/iomp/#%E8%BE%B9%E9%99%85%E6%95%88%E5%BA%94">端口详解</a> 。</p>
<p><strong><mark class="hl-label blue">读写端口</mark> </strong><br>
使用 <code>in</code> 和 <code>out</code> 指令读写端口，且只能使用 AX 或 AL 存放从端口读入或要输出到端口的指令，访问 8 位端口用 AL，16 位端口用 AX：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#从60h号端口读数据，传送给al寄存器</span><br><span class="line">in al,60h</span><br><span class="line">#向20h号端口输入数据。</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>
<h3 id="font-color-red-寄存器用法总结-font"><font color='red'>寄存器用法总结</font></h3>
<p>8086 CPU 中所有寄存器都是 16 位，而 8086 上一代 CPU 中寄存器都为 8 位， <strong><font color='orange'>为了保证兼容，使基于上一代 CPU 编写的程序稍加修改就能运行于 8086 之上，8086 CPU 中的通用寄存器（AX, BX, CX, DX）都可以分为两个可独立使用的 8 位寄存器。</font></strong></p>
<p><strong><mark class="hl-label blue">通用寄存器</mark> </strong></p>
<p><strong>8 个通用寄存器：<font color='gree'>AX、BX、CX、DX、SI、DI、SP、BP</font></strong> ；下面列出这几个寄存器的名字，以展现其常见用途：<br>
<strong>AX</strong> ：累加器(Accumulator)；<br>
<strong>BX</strong> ：基地址寄存器(Base Register)；<br>
<strong>CX</strong> ：计数寄存器（Count Register）；<br>
<strong>DX</strong> ：数据寄存器（Data Register）；<br>
<strong>SI</strong>  ： 源索引寄存器(Source Index Register)；<br>
<strong>DI</strong>  ：目标索引寄存器(Destination Index Register)；<br>
<strong>BP</strong> ：基址针寄存器(Base Pointer Register)；<br>
<strong>SP</strong> ：栈指针寄存器(Stack Pointer Register)；</p>
<p><strong><font color='gree'>AX , BX , CX , DX</font></strong> 常用来存放一般性数据。<strong>它们可以分为两个独立的寄存器</strong> ，比如 AX 可分为 AH 和 AL，BX 可分为 BH 和 BL，其他同理。<strong>注意，H 指数据高位，L 指数据低位，而非地址的高低</strong> ，实际上寄存器也没有什么地址高低一说。<strong>当数据溢出时，舍弃高位。</strong></p>
<p><strong><font color='gree'>SI , DI , SP , BP</font></strong> 常用于寻址操作。<strong>它们不可分为两个独立的寄存器</strong> 。</p>
<p>其中寄存器的专门用法为：</p>
<ol>
<li>AX：
<ul>
<li><strong>存放被除数</strong> ：如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，<font color='orange'>高位放在 DX 中，低位放在 AX 中</font>。</li>
<li><strong>存放商</strong> ：如果除数为 8 位，则将<font color='orange'>商放入 AL，余数放入 AH</font>；如果除数为 16 位，<font color='orange'>则将商放入 AX，余数放入 DX</font>。</li>
<li><strong>存放乘数与积</strong> ：若为 8 位乘法，其中一个乘数放在 AL 中，结果放在 AX 中；若为 16 位，其中一个乘数放在 AX 中，<font color='orange'>结果高位放在 DX 中，低位放在 AX 中</font>。</li>
<li><strong>常用作累加器和返回值</strong> 。</li>
</ul>
</li>
<li>BX：<strong>[ ] 中只能为立即数、BX、SI 、DI 或 BP</strong> 。利用 Loop 和 [BX/SI/DI/BP] 可以方便地完成对内存的连续操作。 <strong><font color='orange'>但注意 [BX/SI/DI] 的默认段寄存器为 DS；[BP] 默认的段寄存器为 SS；</font></strong></li>
<li>CX：大多与循环或者条件判断相关，比如：
<ul>
<li>Loop 的循环计数器</li>
<li><code>jcxz</code> 指令的条件判断寄存器。</li>
<li>控制 <code>rep</code> 指令的循环次数。</li>
<li>CL 存放 shl 和 shr 的位移。</li>
</ul>
</li>
<li>DX：被用来放整数除法产生的余数，见 AX；</li>
<li>SI ：见 BX；在很多字符串操作指令中, DS:SI 指向源串,而 ES:DI 指向目标串。</li>
<li>DI ：见 BX，SI；用 DI 与 SI 可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</li>
<li>BP：见 BX； <strong>BP 的作用之一就是在栈中找到函数的形参，栈中的局部变量也是通过 BP 来定位的</strong> ；</li>
<li>SP：[SP] 永远指向栈顶， <strong>[SP] 的默认段寄存器为 SS</strong> ；BP 和 SP 都和栈相关。</li>
</ol>
<p><strong><mark class="hl-label blue">段寄存器</mark> </strong><br>
<strong><font color='gree'>CS , DS , SS , ES</font></strong></p>
<ul>
<li>
<p>CS：代码段寄存器，配合 IP 寄存器使用。</p>
</li>
<li>
<p>DS：数据段寄存器，其偏址寄存器只能为：BX，BP，SI，DI。 <strong><font color='orange'>[BX/SI/DI] 的默认段寄存器为 DS</font></strong> ，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>SS：栈段寄存器，配合 SP 寄存器使用。<strong>任意时刻，SS : SP 指向栈顶元素</strong> 。</p>
</li>
<li>
<p>ES：附加段寄存器。作用与 DS 差不多，<strong>DS 偏指数据来源段，ES 偏指数据输出段</strong> ，比如源字符串和目标字符串，详见 movsb 的使用。</p>
</li>
</ul>
<p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器；也不能直接在段寄存器上做运算</font></strong> ；</p>
<p><strong><mark class="hl-label blue">标志寄存器</mark> </strong><br>
flag 寄存器是按位起作用的，其中每一位都有不同的含义：<br>
<img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1665748273693-1.png" alt=""></p>
<ul>
<li>ZF：零标志位。它记录相关指令（ add、sub、mul、div、inc、or、and 操作）执行后，结果是否为0 。ZF = 1结果不为0，ZF = 0结果为0。</li>
<li>PF：奇偶标志位。它记录指令执行后，结果的所有二进制位中 1 的个数是否为偶数，如果为偶数则 PF = 1，为奇数，PF = 0。</li>
<li>SF：符号标志位。它记录指令执行后，结果是否为负（就是看它二进制的第一位是不是1），如果为负数则SF = 1，结果为正，SF = 0。</li>
<li>CF：进位标志位。在进行 <strong><font color='orange'>无符号数运算</font></strong> 的时候，它记录了运算结果的最高有效位是否向更高位进位，或从更高位借位。</li>
<li>OF：溢出标志位。OF记录了 <strong><font color='orange'>有符号数运算</font></strong> 的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。</li>
<li>DF：方向标志位。配合串传送指令 movsb，movsw 等使用。<strong>cld 指令将 DF 置为 0，则正向传送；std 将其置为 1，则反向传送</strong> 。详见后续 movsb 指令的使用。</li>
<li>IF ：用于中断，<strong>仅对可屏蔽中断有效</strong> 。当前中断进行时，若碰上其他可屏蔽中断，如果此时 IF=1，则暂停当前中断，转向其他中断；如果 IF=0，则必须执行完当前中断后，才能执行其他中断。若碰上不可屏蔽中断，则无论 IF 为多少，当前中断暂定，转向其他中断。<strong>sti 指令设置 IF=1，cli 设置 IF=0。</strong></li>
<li>TF：TF=1，机器进入单步工作方式，每条机器指令执行后，显示结果及寄存器状态，若TF=0，则机器处在连续工作方式。此标志为调试机器或调试程序发现故障而设置。</li>
<li>AF：辅助进位标志。在进行算术运算的时候，当两个字节相加减时，如果从第 3 位向第 4 位(从第0位算起)形成了进位或借位，则AF=1，否则AF=0；</li>
</ul>
<p><strong>mov、push、pop等传送指令不修改标志寄存器的信息。</strong> 如何在 debug 中查看标志寄存器，请移步<a href="#%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">工具使用</a>   。</p>
<p><strong><mark class="hl-label blue">指令指针寄存器</mark> </strong><br>
IP 配合 CS 使用，<strong>IP 永远指向<font color='orange'>下一条指令</font>的偏移地址</strong>。任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。</p>
<h3 id="font-color-red-汇编指令用法总结-font"><font color='red'>汇编指令用法总结</font></h3>
<p><strong><mark class="hl-label blue">mov</mark> </strong><br>
<code>mov</code> 指令被称为传送指令，用于修改内存或寄存器的值。 <strong><font color='orange'>注意，<code>mov</code> 指令无法用来设置 CS，IP 的值</font></strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br></pre></td></tr></table></figure>
<p>注意，<code>mov</code> 只能有如下几种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,立即数</span><br><span class="line">mov 寄存器,寄存器</span><br><span class="line">mov 寄存器,内存单元</span><br><span class="line">mov 内存单元,寄存器</span><br><span class="line">mov 段寄存器,寄存器</span><br><span class="line">mov 内存单元,立即数</span><br></pre></td></tr></table></figure>
<p>不能 <code>mov 内存单元,内存单元</code> 和 <code>mov 段寄存器,立即数</code> 。 <strong><font color='orange'>需要说明的是，<code>mov 内存单元,立即数</code> 时，必须指明其数据类型是字还是字节：</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr[0],12h</span><br><span class="line">mov word ptr[0],1234h</span><br></pre></td></tr></table></figure>
<p>其中，<code>ptr</code> 不可省略。以上规则同样适用于 <code>sub</code> ，<code>add</code> 指令。</p>
<p><strong><mark class="hl-label blue">jmp</mark> </strong></p>
<p><code>jmp</code> 指令用于指令的跳转，有以下几种用法：</p>
<ul>
<li>
<p><code>jmp 段:偏移</code> ：同时修改 CS : IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 1000:0012</span><br><span class="line">#5</span><br><span class="line">mov cs,1000h</span><br><span class="line">mov ip,0012h</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>jmp reg</code> ： 修改 IP 为 reg 寄存器中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp ax</span><br><span class="line">#效果等价于</span><br><span class="line">mov ip,ax</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>jmp short 标号/数值</code> ：执行段内短转移，对 IP 的修改范围为 -128~127；此方式是利用<font color='orange'>当前 jmp 指令的下一条指令</font>到标号的偏移量来跳转的，而非利用标号的绝对地址来跳转。实际上 <code>jmp short 标号</code> 的功能为 <code>IP=IP+8位位移</code> ；位移在汇编时期算出，用补码表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">		db 16 dup(0)		</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	start:	</span><br><span class="line">		mov ax,1</span><br><span class="line">	    inc ax</span><br><span class="line">		jmp short start</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>jmp near 标号/数值/寄存器/内存</code> 执行段内近转移；同 <code>jmp short 标号</code> 类似，利用相对移位进行跳转，但对 IP 的修改范围为 -32768~32767，为 16 位位移。</p>
</li>
<li>
<p><code>jmp far 内存/数值</code> 执行段间转移，又称远转移。与前两者不同，此方式利用的是 CS:IP 绝对地址。</p>
</li>
<li>
<p><code>jmp word ptr 内存单元</code> 段内转移。</p>
</li>
<li>
<p><code>jmp dword ptr 内存单元</code> 段间转移，<strong>内存单元中高地址的字存放段地址，低地址的字存放偏移地址。</strong></p>
</li>
</ul>
<p><strong><mark class="hl-label blue">add与sub</mark> </strong><br>
<code>add</code> 与 <code>sub</code> 分别执行加法和减法。所支持格式和 <code>mov</code> 相同。</p>
<p><strong><mark class="hl-label blue">pop与push</mark> </strong><br>
<code>push ax</code> ：（1）<code>SP = SP - 2</code>       （2）<code>mov SS:[SP],ax</code> ；</p>
<p><code>pop ax</code>   ：（1）<code>mov ax,SS:[SP]</code> （2）<code>SP = SP + 2</code> ；</p>
<p><strong>注意以下几点：</strong></p>
<ol>
<li><strong><font color='orange'>8086 的入栈出栈必须以字为单位进行操作</font></strong></li>
<li><strong><font color='orange'>操作数只能为内存或寄存器，不能为立即数，比如：<code>push 12</code> </font></strong></li>
<li><strong><font color='orange'>SS:SP 指向栈顶，没有寄存器自动指向栈底(一般用BP手动指向栈底)，所以必须自己操心栈顶超界的问题，栈顶 SS:SP 超界会导致严重后果。</font></strong></li>
<li><strong>栈顶的变化范围为 0~FFFF，栈满时如果仍继续压栈，会循环覆盖之前的内容。</strong></li>
</ol>
<img src="/2022/img/未命名绘图-1665624319178-11.png" style="zoom:67%;" />
<p><strong><mark class="hl-label blue">pusha与popa</mark> </strong><br>
<code>pusha</code> 指令的作用是把通用寄存器压栈。寄存器的入栈顺序依次是：AX,CX,DX,BX,SP,BP,SI,DI。<code>popa</code> 指令按照相反顺序将同样的寄存器弹出堆栈。<strong>过程用一个或多个寄存器来返回结果时，不应使用 PUSHA 和 POPA，因为其值会被 POPA 覆盖</strong> 。</p>
<p><strong><mark class="hl-label blue">inc与dec</mark> </strong></p>
<p><code>inc</code> 对寄存器自增 1，<code>dec</code> 对寄存器自减 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inc ax</span><br><span class="line">dec bx</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">dec byte ptr [bx]</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">Loop</mark> </strong><br>
<code>loop</code> 的格式为：<code>loop 标号</code> ；进行 Loop 操作时进行如下两步操作：</p>
<ol>
<li>
<p><code>cx = cx - 1</code></p>
</li>
<li>
<p>判断 CX 中的值，不为零则跳转到标号继续循环，为零则往下运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	mov cx,5</span><br><span class="line">s:  </span><br><span class="line">	inc ax</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意，是先减再判断！ <strong>循环指令都是短转移。</strong></p>
<p><strong><mark class="hl-label blue">and与or</mark> </strong><br>
分别是按位与和按位或。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10010010B</span><br><span class="line">and al,11101111B</span><br><span class="line">or  al,11101110B</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">test</mark> </strong><br>
Test 对两个参数 (目标，源) 执行 AND 逻辑操作（&amp;&amp;而非&amp;），并根据结果设置标志寄存器，<strong>结果本身不会保存</strong> 。</p>
<p><code>TEST AX,BX</code> 与 <code>AND AX,BX</code> 命令有相同效果，只是 Test 指令不改变 AX 和 BX 的内容，而 AND 指令会把结果保存到 AX 中。</p>
<p><strong><mark class="hl-label blue">div</mark> </strong><br>
<strong><code>div</code> 指令进行无符号除法操作，<code>idiv</code> 执行有符号除法</strong> 。如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，高位放在 DX 中，低位放在 AX 中。<strong>存放商</strong> ：如果除数为 8 位，则将商放入 AL，余数放入 AH；如果除数为 16 位，则将商放入 AX，余数放入 DX。有以下两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div 十六位/八位寄存器</span><br><span class="line">div word/byte ptr 内存地址</span><br></pre></td></tr></table></figure>
<p>计算 100001 ÷ 100（186A1H ÷ 64H）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1H</span><br><span class="line">mov dx,186AH</span><br><span class="line">mov cx,64H</span><br><span class="line">div cx</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">mul</mark> </strong><br>
<strong><code>mul</code> 为无符号数乘法，<code>imul</code> 为有符号数乘法</strong> 。相乘的数，要么都是 8 位，要么都是 16 位。<br>
8 位：一个默认放在 AL 中，另一个由操作数给出，放在 8 位寄存器或内存中(<u>不能为立即数</u>)；结果默认放在 AX中。</p>
<p>16 位：一个默认放在 AX 中，另一个由操作数给出，放在 16 位寄存器或内存中(<u>不能为立即数</u>)；结果高位放在 DX 中，低位放在 AX 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#8位</span><br><span class="line">mov al,5h</span><br><span class="line">mov bl,15h</span><br><span class="line">mul bl</span><br><span class="line">#16位</span><br><span class="line">mov ax,0fffh</span><br><span class="line">mov dx,1111h</span><br><span class="line">mul dx</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">jcxz</mark> </strong><br>
<code>jcxz</code> 指令为有条件转移指令， <strong><font color='orange'>所有的有条件转移指令都为短转移</font></strong> 。当 CX=0 ，则进行跳转。另外，根据</p>
<p><strong><mark class="hl-label blue">ret与retf</mark> </strong><br>
<code>ret</code>   ：（1）IP = SS:[SP]；（2）SP = SP+2；相当于POP IP；<br>
<code>ret imm</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）SP = SP+imm；相当于 POP IP，SP+=imm；通常用于内平栈。</p>
<p><code>retf</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）CS = SS:[SP]；（4）SP = SP+2；</p>
<p><strong><mark class="hl-label blue">call</mark> </strong><br>
<code>call 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）jmp near 标号；<strong>实现段内转移</strong><br>
<code>call far 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）jmp far 标号；<strong>实现段间转移</strong><br>
<code>call 16位reg</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = reg；<strong>实现段内转移</strong></p>
<p><code>call word ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = 内存单元中的值；<br>
<code>call dword ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）CS = 内存中高地址的字；（6）IP = 内存中低地址的字</p>
<p><strong><mark class="hl-label blue">adc</mark> </strong><br>
带进位加法指令。指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc operand1,operand2</span><br></pre></td></tr></table></figure>
<p>功能：oprand1 = operand1 + operand2 + CF<br>
这个指令的作用看上去比较鸡肋，但实际上对于大数运算很有帮助。首先我们知道这样一个常识：<br>
<strong>加法分两步执行：1）低位相加；2）高位相加再加上低位相加的进位值。</strong> 例如下面的指令与 <code>add ax,bx</code> 有完全相同的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br><span class="line">#结果储存在ax中</span><br></pre></td></tr></table></figure>
<p>16 位 CPU 如何计算 32 位数的运算？比如 <code>11FF89FF33420010</code> + <code>12983476FFAAB444</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,11FF89FF #ax存第一个加数的高位</span><br><span class="line">mov bx,33420010 #bx存第一个加数的低位</span><br><span class="line">add bx,FFAAB444</span><br><span class="line">adc ax,12983476</span><br><span class="line">#结果在ax与bx中，ax存高位，bx见低位</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个指令是字长还只有8位时发明的，当时八位寄存器经常难以承担运算任务，所以 adc 必不可少。现在已经进入 32/64 位时代，除了科学计算，一般都够用了。</p>
</blockquote>
<p><strong><mark class="hl-label blue">sbb</mark> </strong><br>
带位减法指令，原理和 adc 相同，不再解释。</p>
<p><strong><mark class="hl-label blue">cmp</mark> </strong><br>
cmp 指令用来比较大小，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp operand1,operand2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##对于无符号数，通过zf,cf来判断：</span><br><span class="line">如果(ax)=(bx)则(ax)-(bx)=0,所以: zf=1;</span><br><span class="line">如果(ax)≠(bx)则(ax)-(bx)≠0,所以: zf=0;</span><br><span class="line">如果(ax)&lt;(bx)则(ax)-(bx)将产生借位,所以: cf=1;</span><br><span class="line">如果(ax)&gt;=(bx)则(ax)-(bx)不必借位,所以: cf=0;</span><br><span class="line">如果(ax)&gt;(bx)则(ax)-(bx)既不必借位,结果又不为0,所以: cf=0并且zf=0;</span><br><span class="line">如果(ax)&lt;=(bx)则(ax)-(bx)既可能借位,结果可能为0,所以: cf=1或zf=1。</span><br><span class="line">##对于有符号数：通过zf,sf,cf来判断</span><br><span class="line">如果ax&lt;bx则ax-bx&lt;0,所以: (sf=1并且of=0)或(sf=0,of=1)</span><br><span class="line">如果ax=bx则ax-bx=0,所以: zf=1</span><br><span class="line">如果ax&gt;=bx则ax-bx&gt;=0,所以: sf=0并且zf=0</span><br><span class="line">如果ax&gt;bx则ax-bx&gt;0,所以: sf=1并且of=1</span><br></pre></td></tr></table></figure>
<p>要理解这种工作机制背后的思想。</p>
<p><strong><mark class="hl-label blue">根据比较结果进行跳转</mark> </strong><br>
<strong>无符号比较：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测标志位</th>
<th>助记</th>
</tr>
</thead>
<tbody>
<tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
<td>jump if equal</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
<td>jump if not equal</td>
</tr>
<tr>
<td>jb</td>
<td>小于则转移</td>
<td>cf=1</td>
<td>jump if blow</td>
</tr>
<tr>
<td>jnb</td>
<td>不小于则转移</td>
<td>cf=0</td>
<td>jump if not blow</td>
</tr>
<tr>
<td>ja</td>
<td>大于则转移</td>
<td>cf=0且zf=0</td>
<td>jump if above</td>
</tr>
<tr>
<td>jna</td>
<td>不大于则转移</td>
<td>cf=1或zf=1</td>
<td>jump if not above</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx</span><br><span class="line">jne start</span><br></pre></td></tr></table></figure>
<p>其他根据比较结果进行跳转的指令参考<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3567.html">跳转指令汇总</a></p>
<p><strong><mark class="hl-label blue">movsx</mark> </strong></p>
<p>常用的有 movsb，movsw，movsd 。<br>
将源字符串高效地传送到目的地，movsb 相当于以下几步操作：<br>
1）<code>ES:[DI]=DS:[SI]</code><br>
2）如果 DF=0，则 <code>SI++,DI++</code> ；如果 DF=1，则 <code>SI--,DI--</code> ；<br>
movsw 类似，只是每次移动两个字节：如果 DF=0，则 <code>SI+=2,DI+=2</code> ；如果 DF=1，则 <code>SI-=2,DI-=2</code> ；<br>
movsd 则每次移动四个字节。</p>
<p>cld 指令将 DF 置为 0，std 将其置为 1。<br>
movsb 与 movsw 通常和 rep 指令搭配使用，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">###等价于</span><br><span class="line">s:	movsb</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<p>可见，rep 的功能就是根据 CX 中的值重复循环后面的指令。程序演示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db 11h,22h,33h,44h,55h,66h,77h,88h</span><br><span class="line">	db 8 dup(0)</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:</span><br><span class="line">	mov ax,0</span><br><span class="line">	push ax</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,8</span><br><span class="line">	mov cx,8</span><br><span class="line">	rep movsb</span><br><span class="line">	ret		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong><mark class="hl-label blue">pushf与popf</mark> </strong></p>
<p>pushf 的功能是<font color='orange'>标志寄存器</font>的值压栈，popf 从栈中弹出数据，送入标志寄存器中。该指令与中断有关，详见 <a href="#%E4%B8%AD%E6%96%AD">中断</a></p>
<p><strong><mark class="hl-label blue">iret</mark> </strong><br>
功能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>
<p>该指令用于中断程序的返回。</p>
<p><strong><mark class="hl-label blue">shl与shr</mark> </strong><br>
<code>shl</code> 逻辑左移，<code>shr</code> 逻辑右移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl ax,1</span><br><span class="line">mov cl,4</span><br><span class="line">shl ax,cl</span><br></pre></td></tr></table></figure>
<p>当移动位数大于 1 时，必须将移动位数放入 CL；<strong>以上指令将最后移出的一位写入 CF 中</strong> 。</p>
<p><strong><mark class="hl-label blue">seg</mark> </strong></p>
<p>取得某一标号的段地址。</p>
<p><strong><mark class="hl-label blue">程序返回</mark> </strong><br>
使用如下命令进行程序返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>此指令相当于 main() 函数中的 <code>return 0</code> 语句。</p>
<h3 id="font-color-red-伪指令总结-font"><font color='red'>伪指令总结</font></h3>
<blockquote>
<p><strong>以下伪指令为 masm 的格式</strong> ，nasm 与 masm 格式的区别见文末。</p>
</blockquote>
<p>伪指令由汇编器识别并进行相关汇编工作，没有对应的机器码。 <strong><font color='red'>可执行文件由描述信息和程序组成，程序来源于源程序( .asm文件 )中定义的指令和数据；描述信息则来自于 .asm 文件中的伪指令，比如程序入口地址就由伪指令 end 提供</font></strong> 。 <strong><font color='gree'>注意，伪指令的类型随汇编器的种类不同而不同，比如 masm 和 nasm 就不一样，以下伪指令为 masm 的格式。</font></strong><br>
常见伪指令如下：</p>
<ol>
<li>
<p><code>segment</code> 和 <code>ends</code> 是成对出现的伪指令，用来定义一个段；前者说明段的开始，后者说明段的结束。</p>
</li>
<li>
<p><code>end</code> （注意不是 <code>ends</code> ）用来标记整个汇编程序的结束，<strong>其后可以跟标号，指明程序的入口</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:	</span><br><span class="line">	mov ax,ds:[0]</span><br><span class="line">	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><code>end start</code> 指明程序入口为第八行的 <code>start</code> 。</p>
</li>
<li>
<p><code>assume</code> 用来假设某一段寄存器和程序中某个用 <code>segment</code> 和 <code>ends</code> 定义的段相关联。</p>
</li>
<li>
<p><code>+</code> 、<code>-</code> 号等，只能用立即数，在汇编时期就会算出结果。如：<code>mov ax,90-4</code></p>
</li>
<li>
<p><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明段内存空间，即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack1 segment</span><br><span class="line">	dw 0FFFF,0FFFF,0FFFF</span><br><span class="line">stack1 ends</span><br><span class="line"></span><br><span class="line">stack2 segment</span><br><span class="line">	db 11,22,33,44</span><br><span class="line">stack2 ends</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dup</code> 指令用来声明装载重复数据的内存空间，比如上面代码中第 2 行可以写作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   stack1 segment</span><br><span class="line">   	dw 3 dup(0FFFF)</span><br><span class="line">   stack1 ends</span><br><span class="line"></span><br><span class="line">7. `offset` 用来取得标号到段首的偏移量，如下：</span><br><span class="line"></span><br><span class="line">   ```assembly</span><br><span class="line">   codesg segment</span><br><span class="line">   	mov ax,4c00h</span><br><span class="line">   	int 21h</span><br><span class="line">   start:</span><br><span class="line">   	mov bx,offset start</span><br><span class="line">   code ends</span><br></pre></td></tr></table></figure>
<p>bx 中即取得 start 标号地址（实际就是第五行 <code>mov</code> 的地址）到 codesg （第二行 <code>mov</code> 的地址）的偏移量。可以用 offset 求某段的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:</span><br><span class="line">	mov bx,45h</span><br><span class="line">	mov cx,8</span><br><span class="line">	push cx</span><br><span class="line">	push bx</span><br><span class="line">	mov dx,offset s - offset start</span><br><span class="line">s:	nop	</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>汇编中除了汇编指令和伪指令外，还有标号，例如 <code>codesg segment</code> 中的 <code>codesg</code> 。标号是地址的助记符，标号本身即代表地址。如下代码第 9 行。<strong>注意，<code>:</code> 只能在代码段使用</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:	</span><br><span class="line">	mov ax,data</span><br><span class="line">	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据标号：带有单元长度的标号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	a dw 0FFFFh,0EEEEh</span><br><span class="line">	b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:	</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	inc b[0] ##无需word ptr</span><br><span class="line">	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="font-color-red-汇编规则总结-font"><font color='red'>汇编规则总结</font></h3>
<ul>
<li>
<p>注释以分号 <code>;</code> 开头。</p>
</li>
<li>
<p>指令的两个操作对象的位数必须一致，以下是不正确的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bl</span><br><span class="line">add bh,1000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AH 与 AL 是两个独立的寄存器，不要错误地认为 <code>add al,93H</code> 指令产生的进位会储存在 AH 中。</p>
</li>
<li>
<p>数据在内存 21F60 单元中，专业说法应该为：2000:1F60 单元中。</p>
</li>
<li>
<p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器，也不允许直接在段寄存器上做运算</font></strong> ；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">mov ss,1100</span><br><span class="line">#正确</span><br><span class="line">mov ax,1100</span><br><span class="line">mov ss,ax</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>mov 指令中给出 16 位寄存器，就进行 16 位数据传送；若给出 8 位寄存器，则进行 8 位数据传送：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure>
<p><strong>对于没有寄存器参与的内存单元操作指令中，必须要用 <code>word ptr</code> 和 <code>byte ptr</code> 指明操作长度。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [0],0fffh</span><br><span class="line">inc byte [0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><font color='orange'>注意，在编写汇编代码时，如果数字后没H或没有前缀0x，则视为十进制数，汇编过程中自动再转为十六进制。</font></strong></p>
</li>
<li>
<p>为了使程序更加清晰合理，一般将数据、代码、栈放在不同的段中。由于寄存器最大为 16 位，所以一个段的容量最大也为 64KB</p>
</li>
<li>
<p><strong>8086 CPU 的转移指令分为以下几类：1）无条件转移指令(jmp)；2）条件转移指令(jcxz)；3）循环指令(loop)；4）call 与 ret；5）中断</strong></p>
</li>
<li>
<p>如前所述，<code>jmp short 标号</code> ，<code>jmp near 标号</code> ，<code>jcxz 标号</code> ，<code>loop 标号</code> 都是根据相对位移来进行转移的。这样做的好处是方便了程序的整体移动。比如我把这段程序中的某段代码移植到其他程序中，就只需要更改段寄存器。</p>
</li>
<li>
<p>设置 SS 后必须紧接着设置 SP！！！原因见内中断。</p>
</li>
</ul>
<h3 id="font-color-red-程序设计规范-font"><font color='red'>程序设计规范</font></h3>
<p>后续补充、、、先列个目录：</p>
<ul>
<li>10.10 参数和结果的传递</li>
<li>10.11批量数据的传递</li>
<li>10.12寄存器冲突</li>
<li>在子程序内部保存用到的寄存器。</li>
</ul>
<h3 id="font-color-red-代码实验-font"><font color='red'>代码实验</font></h3>
<p>一. 往屏幕中间输出 hello（masm下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;h&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;o&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,1660</span><br><span class="line">	mov cx,10</span><br><span class="line">	cld</span><br><span class="line">	rep movsb</span><br><span class="line">	ret		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>彩色模式详见王爽《汇编语言第四版》第188页。</p>
<h3 id="font-color-red-工具使用-font"><font color='red'>工具使用</font></h3>
<blockquote>
<p>汇编工具下载链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/19TWArrfgDA06_IOYwUUDlg?pwd=gzwb">汇编工具</a><br>
提取码：gzwb</p>
</blockquote>
<p><strong><mark class="hl-label blue">工具的安装和配置</mark> </strong></p>
<p>Debug 是 Dos 和 Windows 都提供的 <strong>实模式 (8086方式)</strong> 程序的调试工具，它可以查看 CPU 中各种寄存器的值和内存的使用情况，并能够在机器码级跟踪程序的运行。参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/plus_re/article/details/60761467">DosBox安装</a> 。DosBox 安装好后直接将 LINK.exe 、masm.exe 和 Debug.exe 放入 DosBox 的根目录中。</p>
<p><strong><mark class="hl-label blue">Debug指令</mark> </strong></p>
<ul>
<li>
<p>R：查看或改变寄存器的值；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r</span><br><span class="line">AX=0000 BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC 073F:0100 																	 0000ADD[BX+SI],ALDS:0000=CD</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r AX</span><br><span class="line">AX 0000</span><br><span class="line">:FFFF</span><br><span class="line">-r </span><br><span class="line">AX=FFFF BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC </span><br><span class="line">073F:0100  0000  ADD[BX+SI],ALDS:0000=CD #下一次要执行的指令</span><br></pre></td></tr></table></figure>
<p>第二行最后八对字母是标志寄存器的状态，含义如下：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>OF</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>SF</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>ZF</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>PF</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>DF</td>
<td>DN</td>
<td>UP</td>
</tr>
<tr>
<td>AF</td>
<td>AC</td>
<td>NA</td>
</tr>
<tr>
<td>IF</td>
<td>EI</td>
<td>DI</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>D：查看内存中的值；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>E：修改内存中的值；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-e 1000:0</span><br><span class="line">1000:0000   00.FF   00.11 #按空格继续修改，回车终止</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   FF 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>U：将内存中的指令翻译成汇编指令。</p>
</li>
<li>
<p>T：执行一条机器指令。</p>
</li>
<li>
<p>A：以汇编指令的形式向内存写入机器指令；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br><span class="line">073F:0100 MOV AX,FF</span><br><span class="line">073F:0103 ADD BX,EE</span><br><span class="line">-u 073F:0100</span><br><span class="line">073F:0100  BBFF00    MOV AX,FF</span><br><span class="line">073F:Θ103  81C3EE00  ADD BX,ΕΕ</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>P：执行指令，不过遇到子程序代码时，直接完成子程序的执行，类似于 VS 调试时使用 F10，而 T 相当于 F11；遇到循环时，直接执行到 CX=0；</p>
</li>
<li>
<p>G： 该命令后面可以跟地址和断点，运行到内存指定位置的代码后暂停，如果不加参数默认是从当前IP运行到程序结束。</p>
</li>
</ul>
<p><strong><font color='orange'>注意，在debug中所有数据被视为十六进制，不能在数据后再加H；而在编写汇编代码时，如果数字后没H，则视为十进制数，汇编过程中再转为十六进制。</font></strong></p>
<p><strong><mark class="hl-label blue">生成可执行文件</mark> </strong><br>
编写 test.asm 后保存，在 DosBox 中输入 <code>masm</code> ，然后输入 <code>test.asm</code> ，连续回车；接着输入 <code>test.obj</code> ，连续回车；最后 <code>debug test.exe</code> 即可。</p>
<h3 id="font-color-red-Dos下exe文件加载过程-font"><font color='red'>Dos下exe文件加载过程</font></h3>
<img src="/2022/img/IMG_0468(20221013-103739).PNG" style="zoom:80%;" />
<p>程序加载后，DS 指向 PSP 的起点，CS 指向程序的入口。PSP 的作用和程序加载器差不多，关于程序加载器，见另一篇文章：<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p>
<h3 id="font-color-red-补充：nasm-的使用-font"><font color='red'>补充：nasm 的使用</font></h3>
<p>后续学习操作系统的过程中我们都会在 Linux 下采用 nasm 。原因 nasm 可以直接生成纯二进制文件，不夹杂其他的文件信息，而 masm 则会自动生成文件信息（利用 assume, start, end 等伪指令生成信息），不利于我们探究其中的细节。</p>
<p><strong><mark class="hl-label blue">命令行语法</mark> </strong><br>
1）将文件进行汇编</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将myfile.s生成bin文件，生成的文件名为myfile</span></span><br><span class="line">nasm -f bin myfile.s</span><br><span class="line"><span class="comment">#将myfile.s生成bin文件，指定生成的文件名为myfile.bin</span></span><br><span class="line">nasm -f bin myfile.s -o myfile.bin</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>汇编文件后缀在 Linux 下以 <code>.s</code> 为主，在 Windows 下以 <code>.asm</code> 为主。</li>
<li><code>.bin</code> 文件是纯二进制文件，其中只包含汇编指令，可以直接给 CPU 使用。而 ELF 或 PE 文件是二进制可执行文件，除了指令外还包含很多文件信息，用来给程序加载器使用。</li>
</ul>
</blockquote>
<p>2）生成列表文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f coff myfile.s -l myfile.lst</span><br></pre></td></tr></table></figure>
<p>列表文件很方便我们对照阅读汇编代码和其对应的二进制代码：<br>
<img src="/2022/img/image-20221030102024363.png" alt=""></p>
<p>3）预包含文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm myfile.s -p myinc.inc</span><br></pre></td></tr></table></figure>
<p>跟在源文件开头写上 <code>%include &quot;myinc.inc&quot;</code> 是等效的。这种包含头文件的方式将在后面我们写加载器时带来很大的方便。</p>
<p><strong><mark class="hl-label blue">伪指令</mark> </strong><br>
<strong>1）段定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section .data [vstart] [align]</span><br></pre></td></tr></table></figure>
<p>masm 的段定义格式为 <code>data segment</code> 。关键字 vstart 很不好理解，关于 vstart 和 align 的详细讨论参见：<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p>
<blockquote>
<p><code>.data</code> ，<code>.code</code> ，<code>.bss</code> ，<code>.text</code> 是标准的段名。<br>
<code>.data</code> ：用来存放程序中已初始化的全局变量的一块内存区域；<br>
<code>.bss</code>   ：用来存放程序中未初始化的全局变量的一块内存区域；<br>
<code>.code\.text</code> ：用来存放程序代码</p>
</blockquote>
<p><strong>2）$ 和 $$</strong><br>
此二者常用来计算偏移量或文件大小。$ 表示当前行的汇编地址， $$ 表示本 section 的起始汇编地址， 它们两都受 vstart 影响。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section .data vstart=0x100</span><br><span class="line">db &quot;hello&quot;</span><br><span class="line">db $-$$</span><br></pre></td></tr></table></figure>
<p>以上 $ 的值为 <code>0x100+5=0x105</code> ，$$ 的值为 0x100 。</p>
<p><strong>3）声明重复内存单元</strong><br>
masm 中使用如下格式声明重复的零内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw 100 dup(0)</span><br></pre></td></tr></table></figure>
<p>nasm 则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 100 db 0</span><br></pre></td></tr></table></figure>
<p><strong>4）段前缀</strong><br>
在 masm 下可以这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[1000]</span><br></pre></td></tr></table></figure>
<p>在 nasm 下则必须这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[ds:1000]</span><br></pre></td></tr></table></figure>
<p><strong>5）指明内存操作数的大小</strong><br>
在 masm 中必须使用 <code>size ptr</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte ptr [1000]</span><br></pre></td></tr></table></figure>
<p>在 nasm 中不需要加 <code>ptr</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte [1000]</span><br></pre></td></tr></table></figure>
<p><strong>6）equ 定义宏</strong><br>
equ 用来为标识符定义一个整型常量，它的作用类似 C 语言中的宏。equ 不占任何内存，编译时会自动替换成相应值。</p>
<p><strong>7）定义数据</strong></p>
<ul>
<li><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明初始化内存空间（用于 .data 段），即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</li>
<li><code>resw</code> ，<code>resb</code> ，<code>resd</code> ，<code>resq</code> 用来声明非初始化内存空间（用于 .bss 段）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">http://jyxcpp.netlify.app/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/"><img class="prev-cover" src="/2022/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">详解前缀树(字典树)</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/"><img class="next-cover" src="/2022/img/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手写加强堆</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9F-font"><span class="toc-number">1.</span> <span class="toc-text">什么是汇编语言？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A7%8D%E7%B1%BB-font"><span class="toc-number">2.</span> <span class="toc-text">汇编语言的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90-font"><span class="toc-number">3.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-CPU%E6%80%BB%E7%BA%BF-font"><span class="toc-number">4.</span> <span class="toc-text">CPU总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%A7%88-font"><span class="toc-number">5.</span> <span class="toc-text">硬件概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-font"><span class="toc-number">6.</span> <span class="toc-text">工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-font"><span class="toc-number">7.</span> <span class="toc-text">内存地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA-font"><span class="toc-number">8.</span> <span class="toc-text">数据表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-8086%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88-font"><span class="toc-number">9.</span> <span class="toc-text">8086寻址方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%86%85%E5%AD%98%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F-font"><span class="toc-number">10.</span> <span class="toc-text">内存定位的多种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-font"><span class="toc-number">11.</span> <span class="toc-text">指令的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%B8%AD%E6%96%AD-font"><span class="toc-number">12.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-gree-%E5%86%85%E4%B8%AD%E6%96%AD-font"><span class="toc-number">12.1.</span> <span class="toc-text">内中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-gree-%E5%A4%96%E4%B8%AD%E6%96%AD-font"><span class="toc-number">12.2.</span> <span class="toc-text">外中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%AB%AF%E5%8F%A3-font"><span class="toc-number">13.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93-font"><span class="toc-number">14.</span> <span class="toc-text">寄存器用法总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93-font"><span class="toc-number">15.</span> <span class="toc-text">汇编指令用法总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BC%AA%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93-font"><span class="toc-number">16.</span> <span class="toc-text">伪指令总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%B1%87%E7%BC%96%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93-font"><span class="toc-number">17.</span> <span class="toc-text">汇编规则总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83-font"><span class="toc-number">18.</span> <span class="toc-text">程序设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C-font"><span class="toc-number">19.</span> <span class="toc-text">代码实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-font"><span class="toc-number">20.</span> <span class="toc-text">工具使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-Dos%E4%B8%8Bexe%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-font"><span class="toc-number">21.</span> <span class="toc-text">Dos下exe文件加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E8%A1%A5%E5%85%85%EF%BC%9Anasm-%E7%9A%84%E4%BD%BF%E7%94%A8-font"><span class="toc-number">22.</span> <span class="toc-text">补充：nasm 的使用</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>