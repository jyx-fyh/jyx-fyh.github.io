<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux入门笔记 | 极简</title><meta name="keywords" content="Linux入门"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="Linux漫漫长路">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux入门笔记">
<meta property="og:url" content="http://jyxcpp.netlify.app/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="Linux漫漫长路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/8.jpg">
<meta property="article:published_time" content="2022-06-16T15:44:28.000Z">
<meta property="article:modified_time" content="2023-03-12T11:21:40.449Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/8.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux入门笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:21:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux入门笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-16T15:44:28.000Z" title="发表于 2022-06-16 23:44:28">2022-06-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:21:40.449Z" title="更新于 2023-03-12 19:21:40">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">46.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>159分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux入门笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><font color='red'>Linux笔记</font></h1>
<h2 id="font-color-orange-1-Linux学前须知-font"><font color='orange'>1.Linux学前须知</font></h2>
<h3 id="font-color-gree-1-1-Linux一切皆文件-font"><font color='gree'>1.1 Linux一切皆文件</font></h3>
<ol>
<li>Linux 中所有内容都是以文件的形式保存和管理的。普通文件，目录，硬件设备，套接字和网络通信等都是文件。</li>
</ol>
<blockquote>
<p>Linux中，文件具体可分为以下类型：</p>
<ul>
<li><code>普通文件</code>：如：mp3，pdf，html等可以直接拿来用的文件。</li>
<li><code>目录文件</code>：Linux系统中，<font color='red'>目录文件包含了此目录中各个文件的文件名以及指向这些文件的指针</font>，打开目录等同于打开目录文件，只要有权限，可以随意访问目录中的任何文件。目录文件的访问权限，同普通文件的执行权限，是一个意思。</li>
<li><code>字符设备文件和块设备文件</code>:磁盘光驱属于块设备文件，串口设备则属于字符设备文件.</li>
<li><code>套接字文件</code>：用于网络通信</li>
<li><code>符号链接文件</code>：类似与 Windows 中的快捷方式，是指向另一文件的简介指针（也就是软链接）。</li>
<li><code>管道文件</code>：主要用于进程间通信。</li>
</ul>
</blockquote>
<ol start="2">
<li>文件化的利弊</li>
</ol>
<blockquote>
<p>好处：开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。比如，Linux 中几乎所有读（读文件，读系统状态，读 socket，读 PIPE）的操作都可以用 read 函数来进行；几乎所有更改（更改文件，更改系统参数，写 socket，写 PIPE）的操作都可以用 write 函数来进行。</p>
<p>坏处：使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。Linux 本身具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</p>
</blockquote>
<hr>
<h3 id="font-color-gree-1-2-挂载-font"><font color='gree'>1.2 挂载</font></h3>
<p>​	Linux系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。同样，<font color='red'>任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）</font>。当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。若不挂载，通过Linux系统中的图形界面系统可查看找到硬件设备，但命令行方式无法找到。</p>
<blockquote>
<p>当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件，但无法通过此目录直接访问 U 盘数据，此目录只会提供此设备的一些基本信息（比如容量）。</p>
</blockquote>
<p>​	<font color='red'>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</font></p>
<blockquote>
<p>并不是根目录下任何一个目录都可以作为挂载点!由于<font color='red'>挂载操作会使得原有目录中文件被隐藏</font>，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃。</p>
</blockquote>
<hr>
<h3 id="font-color-gree-1-3-注意事项-font"><font color='gree'>1.3 注意事项</font></h3>
<ul>
<li>
<p>不同于Windows，Linux严格区分大小写。</p>
</li>
<li>
<p>Windows下的程序无法直接在Linux下使用</p>
</li>
<li>
<p>Linux不靠扩展名区分文件类型</p>
<blockquote>
<p>Linux系统通过权限位标识来确定文件类型。虽然Linux 中的一些特殊文件还是要求写 “扩展名” 的，但并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型，如：</p>
<ul>
<li>压缩包：Linux 下常见的压缩文件名有 <em>.gz、</em>.bz2、<em>.zip、</em>.tar.gz、<em>.tar.bz2、</em>.tgz 等。如果不写清楚扩展名，那么管理员不容易判断压缩包的格式。即使不写扩展名，在 Linux 中一样可以解压缩，不影响使用。</li>
<li>二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用&quot;.rpm&quot;扩展名结尾，目的同样是让管理员一目了然。</li>
<li>程序文件：Shell 脚本一般用 “.sh” 扩展名结尾，其他还有用 “.c” 扩展名结尾的 C 语言文件等。</li>
</ul>
</blockquote>
<p>.gz等扩展名不属于后缀，而成为了文件名的一部分！</p>
</li>
<li>
<p>Linux中所有内容(包括硬件)皆以文件保存</p>
<blockquote>
<p>Linux与Windows完全不同，后者通过设备管理器来管理硬件。</p>
</blockquote>
</li>
<li>
<p>Linux中所有储存设备必须在挂载之后才能使用</p>
</li>
</ul>
<hr>
<h3 id="font-color-gree-1-4-shell与bash-font"><font color='gree'>1.4 shell与bash</font></h3>
<ul>
<li>
<p>Shell就是一个<code>命令行解释器</code>，其作用是按固定语法将输入的命令加以解释并传给系统。它为用户提供了一个向Linux发送请求以便运行程序的接口系统级程序</p>
<blockquote>
<p>Shell相当于是一个翻译，把我们在计算机上的操作或我们的命令，翻译为计算机可识别的二进制命令，传递给内核，以便调用计算机硬件执行相关的操作；同时，计算机执行完命令后，再通过Shell翻译成自然语言，呈现在我们面前。</p>
</blockquote>
<p>其他的shell还有：sh、bash、ksh、rsh、csh等。Ubuntu系统常用的是bash，Bio-linux系统是基于ubuntu定制的，但是却使用了zsh。</p>
<p>sh的全名是Bourne Shell。名字中的玻恩就是这个Shell的作者。</p>
<p>而bash的全名是Bourne Again Shell。最开始在Unix系统中流行的是sh，而bash作为sh的改进版本，提供了更加丰富的功能。</p>
<blockquote>
<p>如何查看当前系统中shell的类型？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>shell命令可以分为以下三类：</p>
<ul>
<li>内建函数 (built-in function)：shell自带的功能（内部命令）。</li>
<li>可执行文件 (executable file)：保存在shell之外的脚本，包括外部命令。</li>
<li>别名(alias) ：给某个命令的简称</li>
</ul>
</li>
</ul>
<h2 id="font-color-orange-2-Linux文件和目录管理-font"><font color='orange'>2.Linux文件和目录管理</font></h2>
<h3 id="font-color-gree-2-1-FHS标准-font"><font color='gree'>2.1 FHS标准</font></h3>
<p>​	FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
<blockquote>
<p>一级目录和二级目录的用途有严格限制，不能按自己的想法划分各目录的用途。一，二级目录中各个文件的名字不能更改！</p>
</blockquote>
<h3 id="font-color-gree-2-2-根目录-font"><font color='gree'>2.2 根目录(/)</font></h3>
<p>​	Linux 系统的根目录（/）最为重要，因为：</p>
<ol>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ol>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件，如下：</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令对应的可执行程序文件，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/usr/</td>
<td>全称为 Unix Software Resource，此目录用于存储系统软件资源。开发者应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。</td>
</tr>
<tr>
<td>/var/</td>
<td>/var/目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。</td>
</tr>
</tbody>
</table>
<p>FHS 建议，/usr 和 /var 目录应具备如下所示的子目录。</p>
<table>
<thead>
<tr>
<th>/usr/子目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>/var子目录</th>
<th>功能（作用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如 <a target="_blank" rel="noopener" href="http://c.biancheng.net/mysql/">MySQL</a> 的数据库保存在 /var/lib/mysql/ 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID（进程 ID）保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis和/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<h3 id="font-color-gree-2-3-绝对路径与相对路径-font"><font color='gree'>2.3 绝对路径与相对路径</font></h3>
<ul>
<li>
<p>绝对路径：绝对路径一定是由根目录 / 开始写起。通过绝对路径可以从某个目录中直接跳转到其他任意目录。</p>
<blockquote>
<p>比如可以直接从/var目录直接跳到/bin目录：/bin 或 …/bin</p>
<p>'.‘表示本目录，’…'表示上级目录</p>
</blockquote>
</li>
<li>
<p>相对路径：相对路径不是从根目录 / 开始写起，而是从当前所在的工作目录开始写起。使用相对路径表明某文件的存储位置时，经常会用到当前目录（用 . 表示）和父目录（用 … 表示）。</p>
<blockquote>
<p>从/root路径切换到/usr路径：</p>
<p>​	绝对路径：cd /usr</p>
<p>​	相对路径：cd …/usr</p>
<p>从/var目录进入子目录/temp：</p>
<p>​	绝对路径：cd /var/temp</p>
<p>​	相对路径：cd temp 或 cd ./temp</p>
</blockquote>
<p>进入本目录下的其他目录时，可以不用加’.'，直接 cd 文件名 就行。</p>
</li>
</ul>
<h3 id="font-color-gree-2-4-文件-目录-命名规则-font"><font color='gree'>2.4 文件(目录)命名规则</font></h3>
<ol>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，不建议使用特殊字符，如&lt;、&gt;、？、* 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。但使用字符大小写来区分不同的文件或目录是不明智的。</li>
<li>Linux 系统并不以文件的扩展名开分区文件类型。例如，<font color='red'>dog.exe 只是一个文件，其扩展名 .exe 并不代表此文件就一定是可执行文件</font>。</li>
</ol>
<h3 id="font-color-gree-2-5-Linux命令行识别文件类型-font"><font color='gree'>2.5 Linux命令行识别文件类型</font></h3>
<ul>
<li>
<p>一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<blockquote>
<p>1、蓝色代表目录<br>
2、白色代表一般性文件，如文本文件、配置文件、源码文件等<br>
3、绿色代表可执行文件<br>
4、浅蓝(绿)色代表链接文件<br>
5、黄色代表设备文件<br>
6、红色代表压缩文件<br>
7、灰色代表其他文件</p>
</blockquote>
<p>颜色并不能准确表示文件属性！</p>
</li>
<li>
<p>通过 ls -l 命令，可以查看当前目录下所有文件和目录各自的准确属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MyFirstVM /]# ls -l</span><br><span class="line">lrwxrwxrwx.   1 root root     7 5月  17 20:10 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   6 root root  4096 5月  17 20:21 boot</span><br><span class="line">drwxr-xr-x.  19 root root  3320 5月  20 22:58 dev</span><br><span class="line">drwxr-xr-x. 144 root root 12288 5月  21 10:23 etc</span><br><span class="line">drwxr-xr-x.   5 root root  4096 5月  20 16:36 home</span><br><span class="line">lrwxrwxrwx.   1 root root     7 5月  17 20:10 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root     9 5月  17 20:10 lib64 -&gt; usr/lib64</span><br></pre></td></tr></table></figure>
<p>每行第一个字符表示的就是文件的类型，其可能的取值以及表示的文件类型，如下表所示。</p>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、<code>硬链接</code>，各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>软链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
<p>上面7列(时间算一列)的含义：</p>
<table>
<thead>
<tr>
<th>第1列</th>
<th>规定了不同的用户对文件所拥有的权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>第2列</td>
<td>引用计数，文件的引用计数代表该文件的 硬链接个数 ，而目录的引用计数代表该目录有多少个一级子目录。</td>
</tr>
<tr>
<td>第3列</td>
<td>所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</td>
</tr>
<tr>
<td>第4列</td>
<td>所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</td>
</tr>
<tr>
<td>第5列</td>
<td>大小，默认单位是字节。</td>
</tr>
<tr>
<td>第6列</td>
<td>文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</td>
</tr>
<tr>
<td>第7列</td>
<td>文件名或目录名。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="font-color-gree-2-6-Linux命令基本格式-font"><font color='gree'>2.6 Linux命令基本格式</font></h3>
<ul>
<li>
<p>命令提示符：</p>
<blockquote>
<p><code>[root@localhost ~]#</code></p>
<ul>
<li>[]：这是提示符的分隔符号，没有特殊含义。</li>
<li>root：显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li>@：分隔符号，没有特殊含义。</li>
<li>localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。</li>
<li>~：代表用户当前所在的目录，<code>~</code>代表当前所在的目录是家目录<a href="%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%B6%E7%9B%AE%E5%BD%95%EF%BC%9A/root,%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%B6%E7%9B%AE%E5%BD%95%EF%BC%9A/home/%E7%94%A8%E6%88%B7%E5%90%8D%E3%80%82">^1</a>。</li>
<li>#：用户提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是 $。</li>
</ul>
</blockquote>
</li>
<li>
<p>命令的基本格式</p>
<blockquote>
<p><code>[root@localhost ~]# 命令 -[选项] [参数]</code></p>
<p>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</p>
</blockquote>
</li>
</ul>
<h3 id="font-color-gree-2-7-常见相关命令-font"><font color='gree'>2.7 常见相关命令</font></h3>
<h4 id="font-color-purple-2-7-1-切换目录-cd-font"><font color='purple'>2.7.1 切换目录(cd)</font></h4>
<ul>
<li>
<p>cd 命令，是 Change Directory 的缩写。cd 命令是 Shell 内置命令，没有执行文件所在路径。</p>
</li>
<li>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td>~用户名</td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td>-</td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td>.</td>
<td>代表当前目录</td>
</tr>
<tr>
<td>…</td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="font-color-purple-2-7-2-显示当前路径-pwd-font"><font color='purple'>2.7.2 显示当前路径(pwd)</font></h4>
<ul>
<li>
<p>pwd 命令 ，是 print working directory 的缩写。</p>
</li>
<li>
<p>pwd 用于确定当前所在的目录，且以 绝对路径 的格式打印。</p>
<blockquote>
<p>虽然命令提示符<code>[root@localhost aha]#</code>中的<code>aha</code>可以提示所在位置，但不同目录下的目录和文件可以相同，所有这个<code>aha</code>的位置也是不确定的，可能在其他地方还要<code>aha</code>。</p>
<p>[demo@localhost aha]# pwd<br>
/var/aha</p>
</blockquote>
</li>
</ul>
<h4 id="font-color-purple-2-7-3-创建空目录-mkdir-font"><font color='purple'>2.7.3 创建空目录(mkdir)</font></h4>
<blockquote>
<p><code>[root@localhost ~]# mkdir -[m\p] 目录名</code></p>
<ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。如<code>[root@localhost ~]# mkdir -m 711 test2</code>，711为权限值。</li>
<li>-p 选项递归创建所有目录，以创建 /home/test/demo 为例，在默认情况下，需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 /home、/home/test 以及 /home/test/demo。</li>
</ul>
</blockquote>
<h4 id="font-color-purple-2-7-4-删除空目录-rmdir-font"><font color='purple'>2.7.4 删除空目录(rmdir)</font></h4>
<blockquote>
<p><code>[root@localhost ~]# rmdir -[p] 目录名</code></p>
<ul>
<li>-p用于递归删除空目录，如<code>[root@localhost ~]# rmdir -p lm/movie/jp/cangls</code>，先从/cangs删起，再删/jp，向上递推。<font color='red'>前提是空目录才能删除！</font></li>
<li>此命令并不常用。rm 命令不但可以删除目录，还可以删除文件，更方便</li>
</ul>
</blockquote>
<h4 id="font-color-purple-2-7-5-创建文件及修改文件时间戳-touch-font"><font color='purple'>2.7.5 创建文件及修改文件时间戳(touch)</font></h4>
<ul>
<li>
<p>touch 命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。</p>
<blockquote>
<p>Linux中，每个文件主要拥有如下3个时间参数（通过 stat 命令进行查看）：</p>
<ul>
<li>访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
</blockquote>
</li>
<li>
<p>注意touch是创建文件，而不是目录！</p>
</li>
<li>
<blockquote>
<p><code>[root@localhost ~]# touch -[选项] 文件名</code></p>
<p>选项：</p>
<ul>
<li>
<p>a：只修改文件的访问时间；</p>
</li>
<li>
<p>c：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。</p>
</li>
<li>
<p>d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</p>
</li>
<li>
<p>m：只修改文件的数据修改时间。</p>
</li>
<li>
<p>t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 <code>“YY-MM-DD hh:mm</code>,如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#touch</span> -d&quot;<span class="number">2017</span>-<span class="number">05</span>-<span class="number">04</span> <span class="number">15</span>:<span class="number">33</span><span class="string">&quot; aha</span></span><br><span class="line"><span class="string">[root@localhost ~]#stat aha</span></span><br><span class="line"><span class="string">最近访问：2017-05-04 15:33:00.000000000 +0800</span></span><br><span class="line"><span class="string">最近更改：2017-05-04 15:33:00.000000000 +0800</span></span><br><span class="line"><span class="string">最近改动：2022-05-21 20:06:53.251283783 +0800 //即状态时间，无法单独改动</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><font color='cornflowerblue'>注意：touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变。</font></p>
</blockquote>
</li>
</ul>
<h4 id="font-color-purple-2-7-6-查看目录内容-ls-font"><font color='purple'>2.7.6 查看目录内容(ls)</font></h4>
<ul>
<li>ls 命令常用选项及功能：</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。</td>
</tr>
<tr>
<td>-A</td>
<td>显示全部的文件，连同隐藏文件，但不包括 . 与 … 这两个目录。</td>
</tr>
<tr>
<td>-d</td>
<td>仅列出目录本身，而不是列出目录内的文件数据。</td>
</tr>
<tr>
<td>-f</td>
<td>ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。</td>
</tr>
<tr>
<td>-F</td>
<td>在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 <a target="_blank" rel="noopener" href="http://c.biancheng.net/socket/">socket</a> 文件，| 代表 FIFO 文件。</td>
</tr>
<tr>
<td>-h</td>
<td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td>
</tr>
<tr>
<td>-i</td>
<td>显示 inode 节点信息。</td>
</tr>
<tr>
<td>-l</td>
<td>使用长格式列出文件和目录信息。“ll&quot;等同于&quot;ls -l”</td>
</tr>
<tr>
<td>-n</td>
<td>以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td>
</tr>
<tr>
<td>-r</td>
<td>将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td>
</tr>
<tr>
<td>-R</td>
<td>连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td>
</tr>
<tr>
<td>-S</td>
<td>以文件容量大小排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>-t</td>
<td>以时间排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>–color=never --color=always --color=auto</td>
<td>never 表示不依据文件特性给予颜色显示。 always 表示显示颜色，ls 默认采用这种方式。 auto 表示让系统自行依据配置来判断是否给予颜色。</td>
</tr>
<tr>
<td>–full-time</td>
<td>以完整时间模式 （包含年、月、日、时、分）输出</td>
</tr>
<tr>
<td>–time={atime,ctime}</td>
<td>输出 access 时间或改变权限属性时间（ctime），而不是内容变更时间。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>上表中的a和l还可以组合使用，既列出了详细信息，又包含’.‘和’…'两个隐藏文件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM home]</span># ls -al</span><br><span class="line">总用量 <span class="number">20</span></span><br><span class="line">drwxr-xr-x.  <span class="number">5</span> root root <span class="number">4096</span> <span class="number">5</span>月  <span class="number">20</span> <span class="number">16</span>:<span class="number">36</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4096</span> <span class="number">5</span>月  <span class="number">17</span> <span class="number">20</span>:<span class="number">20</span> ..</span><br><span class="line">drwx------.  <span class="number">5</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">4096</span> <span class="number">5</span>月  <span class="number">20</span> <span class="number">16</span>:<span class="number">47</span> milan</span><br><span class="line">drwx------.  <span class="number">4</span> fuck fuck <span class="number">4096</span> <span class="number">5</span>月  <span class="number">21</span> <span class="number">19</span>:<span class="number">38</span> test</span><br><span class="line">drwx------. <span class="number">15</span> xuan xuan <span class="number">4096</span> <span class="number">5</span>月  <span class="number">21</span> <span class="number">12</span>:<span class="number">59</span> xuan</span><br></pre></td></tr></table></figure>
<p>其他组合用法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -ld /root/</span><br><span class="line">dr-xr-x---.<span class="number">2</span> root root <span class="number">4096</span> <span class="number">1</span> 月 <span class="number">20</span> <span class="number">12</span>:<span class="number">30</span> /root/</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -lh</span><br><span class="line">总用量<span class="number">44</span>K</span><br><span class="line">-rw-------.<span class="number">1</span> root root <span class="number">1.2</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">18</span> anaconda-ks.cfg</span><br><span class="line">-rw-r-r--.<span class="number">1</span> root root <span class="number">25</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">17</span> install.log</span><br><span class="line">-rw-r-r--.<span class="number">1</span> root root <span class="number">7.6</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">17</span> install.log.syslog   #-l 显示的是字节大小，而-lh显示的是kb，mb，gb...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="font-color-purple-2-7-7-建立软-硬链接-ln-font"><font color='purple'>2.7.7 建立软/硬链接(ln)</font></h4>
<ul>
<li>
<p>ext4文件系统：</p>
<blockquote>
<p>ext4 文件系统会把分区主要分为三大部分：super block, inode , block。</p>
<ul>
<li>
<p>super block：储存inode，block的总量，使用量，剩余量，以及文件系统的格式和相关信息。</p>
</li>
<li>
<p>inode：默认大小为 128 Byte，用来记录文件的权限、<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/752.html">文件的所有者和属组</a>、文件大小、文件的时间参数、对应的 block 编号。每个文件需要占用一个 inode。inode中不记录文件名，而记录在文件所在目录的 block 中。<em><strong>inode即是（目录、档案）文件在一个文件系统中的唯一标识</strong></em>，需要访问这个文件的时候必须先找到并读取这个文件的 inode</p>
</li>
<li>
<p>block 的大小默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。若存放某文件数据最后一个 block 不能占满，但也不能再放入其他文件的数据。<strong>存放同一个文件的多个 block 有可能是连续的，也有可能是分散的</strong>。</p>
<blockquote>
<p>通过以上两点可以得到：</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，<em><strong>就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块</strong></em>；</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>
<p>软连接/硬链接(符号链接)：</p>
<blockquote>
<ul>
<li>硬链接：文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
<li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
</ul>
</blockquote>
</li>
<li>
<p>建立硬链接/软连接：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln <span class="selector-attr">[选项]</span> 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件；</li>
<li>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<p>创建硬链接：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch cangls</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln /root/cangls /tmp</span><br><span class="line">#建立硬链接文件，目标文件没有写文件名，会和原名一致</span><br><span class="line">#也就是/tmp/cangls 是硬链接文件</span><br></pre></td></tr></table></figure>
<p>创建软连接：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch bols</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># In -s /root/bols /tmp</span><br><span class="line">#建立软链接文件</span><br></pre></td></tr></table></figure>
<p>注意：软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求），否则软链接文件会报错！</p>
</li>
</ul>
<h4 id="font-color-purple-2-7-8-剖析软-硬链接-font"><font color='purple'>2.7.8 剖析软/硬链接</font></h4>
<p><em><strong>硬链接剖析：</strong></em></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch test    </span><br><span class="line">#建立源文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln /root/test /tmp/test-hard</span><br><span class="line">#给源文件建立硬链接文件 /tmp/test-hard</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -<span class="selector-tag">i</span> /root/test /tmp/test-hard</span><br><span class="line"><span class="number">262147</span> -rw-r<span class="attr">--r--</span> <span class="number">2</span> root root <span class="number">0</span> <span class="number">6</span>月 <span class="number">19</span> <span class="number">10</span>:<span class="number">06</span> /root/test</span><br><span class="line"><span class="number">262147</span> -rw-r--r-- <span class="number">2</span> root root <span class="number">0</span> <span class="number">6</span>月 <span class="number">19</span> <span class="number">10</span>:<span class="number">06</span> /tmp/test-hard</span><br><span class="line">     ##查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，<span class="string">&quot;ll&quot;</span>等同于<span class="string">&quot;ls -l&quot;</span>。</span><br></pre></td></tr></table></figure>
<p>硬链接示意图：</p>
<img src="/2022/img/20220610214746.png" alt="image-20220522201246373" style="zoom:50%;" />
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中，目录的 block 中记录的是此目录下一级子文件和子目录名及对应的inode；而文件的 block 中记录的才是文件实际的数据。</p>
<blockquote>
<p>当我们查找一个文件，比如 /root/test 时，要经过以下步骤：</p>
<ol>
<li>首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 /root 的文件名及对应的 inode 号。</li>
<li>通过 /root/ 目录的 inode 号，可以查找到 /root/ 目录的 inode 信息，接着判断用户是否有权限访问 /root/ 目录的 block。</li>
<li>如果有权限，则可以从 /root/ 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 /root/test 文件的读取与访问。</li>
</ol>
</blockquote>
<p>硬链接的特点如下：</p>
<ul>
<li>不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。</li>
<li><strong>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。只有删除源文件及所有对应的硬链接文件，文件实体才会被删除。文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</strong></li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。11</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p><code>目录下的'.'和'..'就是硬链接</code></p>
<p><em><strong>软连接剖析：</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch check</span></span><br><span class="line"><span class="comment">#建立源文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /root/check  /tmp/check-soft</span></span><br><span class="line"><span class="comment">#建立软链接文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -id /root/check  /tmp/check-soft</span></span><br><span class="line">262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check</span><br><span class="line">917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -&gt; /root/check</span><br><span class="line"><span class="comment">#软链接和源文件的 inode 号不一致，软链接通过 -&gt; 明显地标识出源文件的位置</span></span><br><span class="line"><span class="comment">#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件</span></span><br></pre></td></tr></table></figure>
<p>软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用</p>
<p><strong>软链接示意图：</strong></p>
<img src="/2022/img/20220610214754.png" alt="image-20220522201204473" style="zoom:50%;" />
<blockquote>
<p>软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
</blockquote>
<p>软链接的特点（ Windows 中的快捷方式完全一致）。</p>
<ul>
<li>不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。软链接就是Windows中的快捷方式</li>
<li><strong>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</strong></li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
<hr>
<h4 id="font-color-purple-2-7-9-复制文件-目录-cp-font"><font color='purple'>2.7.9 复制文件/目录(cp)</font></h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp <span class="selector-attr">[选项]</span> 源文件 目标文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ul>
<li>-a：相当于 -d、-p、-r 选项的集合</li>
<li>-d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；</li>
<li>-i：询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l：把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s：把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；</li>
<li>-r：递归复制，用于复制目录；</li>
<li>-u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p><code>无论是复制软链接还是硬链接，都不是复制源文件</code></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#建立源文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch cangls</span><br><span class="line">#把源文件不改名复制到 /tmp/ 目录下</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls  /tmp/</span><br><span class="line">###########################################</span><br><span class="line">#改名复制</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls  /tmp/bols</span><br></pre></td></tr></table></figure>
<ul>
<li>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为<code>cp 命令默认执行的是“cp -i”的别名</code>，例如：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls /tmp/</span><br><span class="line">cp:是否覆盖<span class="string">&quot;/tmp/cangls&quot;</span>?y</span><br><span class="line">#目标位置有同名文件，所以会提示是否覆盖</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>如果在复制软链接文件时不使用 &quot;-d&quot; 选项，则 cp 命令复制的是源文件，而不是软链接文件；只有加入了 &quot;-d&quot; 选项，才会复制软链接文件。</code>注意，“-d” 选项对硬链接是无效的，对硬链接需要使用&quot;-l&quot;</p>
</li>
<li>
<p>一般而言，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span>  /tmp/</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span></span><br><span class="line">-rw-r-----<span class="number">1</span> root slocate <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span>/var/lib/mlocate/mlocate.db</span><br><span class="line">\#注意源文件的时间和所属组</span><br><span class="line">[root@localhost ~]#ll /tmp/mlocate.db</span><br><span class="line">-rw-r----- <span class="number">1</span> root root <span class="number">6</span> 月 <span class="number">14</span> <span class="number">06</span>:<span class="number">05</span>/tmp/mlocate.db</span><br><span class="line">\#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span><br></pre></td></tr></table></figure>
<p>而当执行备份时，这些文件的时间可能是一个重要的参数，这就需执行 “-p” 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp -<span class="selector-tag">p</span> /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span> /tmp/mlocate<span class="selector-class">.db_2</span></span><br><span class="line">\#使用&quot;-<span class="selector-tag">p</span>&quot;选项</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span> /tmp/mlocate<span class="selector-class">.db_2</span></span><br><span class="line">-rw-r----- root slocate <span class="number">2328027</span> <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span> /tmp/mlocate.db_2</span><br><span class="line">-rw-r----- root slocate <span class="number">2328027</span> <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span> /var/lib/mlocate/mlocate.db</span><br><span class="line">\#源文件和目标文件的所有属性都一致，包括时间</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>&quot;-a&quot; 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 &quot;-a&quot; 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。</code></p>
</li>
<li>
<p>如果使用 “-l” 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 “-s” 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 “-d” 选项是不同的，“d” 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 “-l” 和 “-s” 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接</p>
</li>
</ul>
<hr>
<h4 id="font-color-purple-2-7-10-删除文件-目录-rm-font"><font color='purple'>2.7.10 删除文件/目录(rm)</font></h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm  -<span class="selector-attr">[选项]</span> 文件或目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ul>
<li>f：强制删除（force），和 i 选项相反，使用 f，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>i：和 f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 i 可以有效防止不小心删除有用的文件或目录。</li>
<li>r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
</blockquote>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir -<span class="selector-tag">p</span> /test/lm/movie/jp</span><br><span class="line">\#重新建立测试目录</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /test</span><br><span class="line">\#强制删除，一了百了</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span><span class="selector-id">#rm</span> -rf *</span><br><span class="line">#删除/tmp/目录中的所有数据</span><br></pre></td></tr></table></figure>
<p><code>但是需要注意，数据强制删除之后无法恢复</code></p>
<p>虽然 “-rf” 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 “-rf” 选项。</p>
<hr>
<h4 id="font-color-purple-2-7-11-移动和重命名文件或目录-mv-font"><font color='purple'>2.7.11 移动和重命名文件或目录(mv)</font></h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv 【选项】 源文件 目标文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<ul>
<li>-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）；</li>
<li>-n：如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v：显示文件或目录的移动过程；</li>
<li>-u：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
</blockquote>
<p><code>如果源文件和目标文件在同一目录中，那就是改名</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv bols lmls</span><br><span class="line">\#把 bols 改名为 lmls</span><br></pre></td></tr></table></figure>
<p>目录也可以按照同样的方法改名。</p>
<hr>
<h4 id="font-color-purple-2-7-12-命令自动补全功能-font"><font color='purple'>2.7.12 命令自动补全功能</font></h4>
<ul>
<li>
<p>当输入的前缀唯一时，按下Tab即可自动补全</p>
</li>
<li>
<p>当输入的前缀不唯一时，连续按下两次Tab，会立即显示所有同前缀的文件和目录。</p>
</li>
<li>
<p>shell中的通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配0或任意个字符</td>
</tr>
<tr>
<td>？</td>
<td>匹配任意 一个 字符</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号的字符。例如[a-b]，匹配小写字母，只会匹配集合中的 一个</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除了中括号的 一个 字符。例如<code>[^0-9]</code>，匹配除了数字的字符，只会匹配集合中的一个</td>
</tr>
<tr>
<td>{ab,ba}</td>
<td>匹配其中 一个 字符串。例如匹配ab或ba</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>举例说明：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-tag">a</span>* &lt;--匹配所有以 <span class="selector-tag">a</span> 字符开头的文件名</span><br><span class="line">apple</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls g*t &lt;--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span><br><span class="line">grapefruit</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls *e* &lt;--匹配所有包含 e 字符的文件名</span><br><span class="line">apple grape grapefruit watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls *n* &lt;--匹配所有包含 n 字符的文件名</span><br><span class="line">banana watermelon</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls ????e</span><br><span class="line">apple grape</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls g???e*</span><br><span class="line">grape grapefruit</span><br></pre></td></tr></table></figure>
<p><code>注意，一个？只能代表一个字符！</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[abw]</span>*</span><br><span class="line">apple banana watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[agw]</span>*<span class="selector-attr">[ne]</span></span><br><span class="line">apple grape watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[a-g]</span>*</span><br><span class="line">apple banana grape grapefruit</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-2-8-Linux命令执行过程与别名-font"><font color='gree'>2.8 Linux命令执行过程与别名</font></h3>
<p><strong>1）判断路径</strong></p>
<p>判断用户是否以绝对路径或相对路径的方式输入命令（如 /bin/ls），如果是的话直接执行。</p>
<p><strong>2）检查别名</strong></p>
<p>Linux 系统会检查用户输入的命令是否为“别名命令”。通过 alias 命令可以给现有命令自定义别名。</p>
<blockquote>
<p>例如，我们经常使用的 rm 命令，其实就是 rm -i 这个整体的别名：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#显示rm的别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># alias rm</span><br><span class="line">alias rm=&#x27;rm -<span class="selector-tag">i</span>&#x27;</span><br><span class="line">    </span><br><span class="line">#删除rm的别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># unalias rm</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm <span class="selector-tag">a</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span>#  &lt;--直接删除，不再询问</span><br><span class="line">    </span><br><span class="line">#添加别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># alias rm=&#x27;rm -<span class="selector-tag">i</span>&#x27;  注意单引号</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>3）判断是外部还是内部命令</strong></p>
<p>Linux命令行解释器（又称为 Shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。</p>
<blockquote>
<p><strong>判断一个命令属于内部命令还是外部命令，可以使用 type 命令实现。例如：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># type pwd</span><br><span class="line">pwd is <span class="selector-tag">a</span> shell builtin &lt;-- pwd是内部命令</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># type <span class="attribute">top</span></span><br><span class="line"><span class="attribute">top</span> is /usr/bin/<span class="attribute">top</span> &lt;-- <span class="attribute">top</span>是外部命令</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>4）查找外部命令对应的可执行文件</strong></p>
<p>当用户执行的是 外部命令 时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找 ，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p>
<blockquote>
<p>PATH 环境变量的改变，会直接影响 Shell 查找 Linux 命令的过程。</p>
</blockquote>
<hr>
<h3 id="font-color-gree-2-9-Linux环境变量-font"><font color='gree'>2.9 Linux环境变量</font></h3>
<ul>
<li>
<p><strong>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数</strong>，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。 环境变量一般大写</p>
<p><code>当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到 PATH 中指定的路径去找。</code></p>
</li>
<li>
<p>可以使用 <code>env</code> 命令来查看到 Linux 系统中所有的环境变量，执行命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># env</span><br><span class="line">ORBIT_SOCKETDIR=/tmp/orbit-root</span><br><span class="line">HOSTNAME=livecd<span class="selector-class">.centos</span></span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE_PID=<span class="number">2065</span></span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可使用<code>echo</code>命令来查看 HOME 变量在不同用户身份下都有哪些值：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo $HOME</span><br><span class="line">/root</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># su - user1  &lt;--切换到 user1 用户身份</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ echo $HOME</span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linux中重要的环境变量：</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录（也称家目录）</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>环境变量由固定的变量名与用户或系统设置的变量值两部分组成，可自行创建环境变量来满足工作需求。例如，设置一个名称为 WORKDIR 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir /home/work1</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># WORKDIR=/home/work1</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>
<p>需要注意，上面自定义的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost work1]</span># su user1  &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ echo $WORKDIR</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ exit &lt;--退出user1身份</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># export WORKDIR</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># su user1</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[user1@localhost work1]</span>$ pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linux PATH环境变量</p>
<p>首先了解一下 which 命令，它用于<code>查找某个命令</code>所在的绝对路径。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># which rm</span><br><span class="line">/bin/rm</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># which rmdir</span><br><span class="line">/bin/rmdir</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># which ls</span><br><span class="line">alias ls=&#x27;ls <span class="attr">--color</span>=auto&#x27;</span><br><span class="line">        /bin/ls</span><br></pre></td></tr></table></figure>
<p>由上可见命令所在的路径。那么为什么在使用 rm、rmdir、ls 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？这便是 PATH 环境变量在起作用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin</span><br></pre></td></tr></table></figure>
<p>echo 命令用来输出 PATH 环境变量的值（这里的 $ 是 PATH 的前缀符号），PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开 。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻(根据用户权限)该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。</p>
</blockquote>
<p>如果将 ls 命令移动到 /root 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 ls 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 No such file or directory，示例命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv /bin/ls /root</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">bash: /bin/ls: No such file or directory</span><br></pre></td></tr></table></figure>
<p>此时，如果仍想使用 ls 命令，有 2 种方法， 一种是直接将 /root 添加到 PATH 环境变量中 ，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># PATH=$PATH:/root</span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install.org Templates</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。</p>
</blockquote>
<p>另一种方法是 以绝对路径的方式使用此命令 ，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># /root/ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install<span class="selector-class">.org</span> Templates</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="font-color-orange-3-Linux打包和压缩-font"><font color='orange'>3. Linux打包和压缩</font></h2>
<h3 id="font-color-gree-3-1-打包命令-tar-font"><font color='gree'>3.1 打包命令(tar)</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#tar</span> <span class="selector-attr">[选项]</span>  包名  源文件或目录</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>将多个文件或目录进行打包。</td>
</tr>
<tr>
<td>-A</td>
<td>追加 tar 文件到归档文件。</td>
</tr>
<tr>
<td>-f 包名</td>
<td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr>
<td>-v</td>
<td>显示(解)打包文件过程；</td>
</tr>
<tr>
<td>-z</td>
<td>压缩和解压缩 “.tar.gz” 格式；</td>
</tr>
<tr>
<td>-j</td>
<td>压缩和解压缩 &quot;.tar.bz2&quot;格式。</td>
</tr>
<tr>
<td>-x</td>
<td>对 tar 包做解打包操作。</td>
</tr>
<tr>
<td>-t</td>
<td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td>
</tr>
<tr>
<td>-C 目录名</td>
<td>指定解打包位置。</td>
</tr>
</tbody>
</table>
<p>使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># tar -cvf test<span class="selector-class">.tar</span> ship shit</span><br><span class="line">ship/</span><br><span class="line">shit/</span><br><span class="line">shit/wuwu/</span><br></pre></td></tr></table></figure>
<p>选项 “-cvf” 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 “.tar” 作为扩展名。打包目录也是如此：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -zcvf tmp<span class="selector-class">.tar</span><span class="selector-class">.gz</span>  /tmp/</span><br><span class="line">#把/temp/目录直接打包压缩为&quot;<span class="selector-class">.tar</span><span class="selector-class">.gz</span>&quot;格式</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了直接用tar命令进行打包压缩，也可先用tar打包，在用命令<code>gzip</code>进行压缩。 但这样的话，就不能直接对目录进行压缩，须先打包再压缩.</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -xvf anaconda-ks<span class="selector-class">.cfg</span><span class="selector-class">.tar</span> </span><br><span class="line">#解打包到当前目录下</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -xvf test<span class="selector-class">.tar</span> -C /tmp</span><br><span class="line">#把文件包test<span class="selector-class">.tar</span>解打包到/tmp/目录下</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-purple-3-2-解压-压缩zip文件-font"><font color='purple'>3.2 解压/压缩zip文件</font></h3>
<ul>
<li>
<p>压缩</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#zip</span> <span class="selector-attr">[选项]</span> 压缩包名 源文件或源目录列表</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td>
</tr>
<tr>
<td>-m</td>
<td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的压缩过程信息。</td>
</tr>
<tr>
<td>-q</td>
<td>在压缩的时候不显示命令的执行过程。</td>
</tr>
<tr>
<td>-压缩级别</td>
<td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td>
</tr>
<tr>
<td>-u</td>
<td>更新压缩文件，即往压缩文件中添加新文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zip ana<span class="selector-class">.zip</span> anaconda-ks<span class="selector-class">.cfg</span></span><br><span class="line">adding: anaconda-ks.cfg (deflated <span class="number">37%</span>)</span><br><span class="line">#单个文件压缩</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zip test<span class="selector-class">.zip</span> install<span class="selector-class">.log</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line">adding: install.log (deflated <span class="number">72%</span>)</span><br><span class="line">adding: install.log.syslog (deflated <span class="number">85%</span>)</span><br><span class="line">#同时压缩多个文件到test.zip压缩包中</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解压</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># unzip <span class="selector-attr">[选项]</span> 压缩包名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d 目录名</td>
<td>将压缩文件解压到指定目录下。</td>
</tr>
<tr>
<td>-n</td>
<td>解压时并不覆盖已经存在的文件。</td>
</tr>
<tr>
<td>-o</td>
<td>解压时覆盖已经存在的文件，并且无需用户确认。</td>
</tr>
<tr>
<td>-v</td>
<td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩文件有无损坏，但并不解压。</td>
</tr>
<tr>
<td>-x 文件列表</td>
<td>解压文件，但不包含文件列表中指定的文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># unzip -d /tmp/ ana<span class="selector-class">.zip</span></span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line">#把压缩包解压到指定位置</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="font-color-purple-3-3-解压-压缩gzip文件-font"><font color='purple'>3.3 解压/压缩gzip文件</font></h3>
<ul>
<li>
<p>&quot;gzip&quot;中的’g’代表&quot;gnu&quot;中的’g’。</p>
</li>
<li>
<p>gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。</p>
</li>
<li>
<p><strong>压缩文件</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>将压缩数据输出到标准输出中，并保留源文件。</td>
</tr>
<tr>
<td>-d</td>
<td>对压缩文件进行解压缩。</td>
</tr>
<tr>
<td>-r</td>
<td>递归压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td>-v</td>
<td>对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td>
</tr>
<tr>
<td>-l</td>
<td>对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。</td>
</tr>
<tr>
<td>-数字</td>
<td>用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip install<span class="selector-class">.log</span></span><br><span class="line">#压缩instal<span class="selector-class">.log</span> 文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">anaconda-ks<span class="selector-class">.cfg</span> install<span class="selector-class">.log</span><span class="selector-class">.gz</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line">#压缩文件生成，但是源文件也消失了</span><br></pre></td></tr></table></figure>
<p>在使用 gzip 命令直接压缩文件时，源文件会消失，从而生成压缩文件。用<code>-c</code>可重定向，以保留源文件 ，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-attr">[root@localhost ~]</span># gzip -c test &gt; test<span class="selector-class">.gz</span></span><br><span class="line">  \#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span><br></pre></td></tr></table></figure>
<p><font color='red'>注意：<code>gzip</code>命令不能将多个文件压缩到一个.gz文件中！</font>Linux中很多压缩程序只能针对一个文件进行压缩，所以当要压缩一大堆文件时，得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩。 所以一定要区分压缩和打包两个概念</p>
</li>
<li>
<p><strong>解压缩</strong></p>
<p>对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gunzip <span class="selector-attr">[选项]</span> 文件</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>递归处理，解压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td>-c</td>
<td>把解压缩后的文件输出到标准输出设备。</td>
</tr>
<tr>
<td>-f</td>
<td>强制解压缩文件，不理会文件是否已存在等情况。</td>
</tr>
<tr>
<td>-l</td>
<td>列出压缩文件内容。</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩文件是否正常，但不对其做解压缩操作。</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gunzip install<span class="selector-class">.log</span><span class="selector-class">.gz</span></span><br><span class="line">#解压一个文件</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># ls </span><br><span class="line">aha<span class="selector-class">.gz</span>  wuwu<span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># gunzip -r .</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># ls</span><br><span class="line">aha  wuwu</span><br></pre></td></tr></table></figure>
<p><font color='red'>注意：-r 是对目标目录中的所有.gz文件进行解压。每个.gz文件都只包含一个文件！</font></p>
<p>除了<code>gunzip</code>命令，<code>gzip-d</code>也可以对g.gzip文件进行解压：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip -d test<span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用 <code>zcat</code> 命令在不解压缩的情况下查看这个文本文件中的内容。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zcat anaconda-ks<span class="selector-class">.cfg</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="font-color-gree-3-4-压缩-解压缩bzip2文件-font"><font color='gree'>3.4 压缩/解压缩bzip2文件</font></h3>
<ul>
<li>
<p>压缩</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bzip2 <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。</td>
</tr>
<tr>
<td>-k</td>
<td>bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。</td>
</tr>
<tr>
<td>-f</td>
<td>bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。</td>
</tr>
<tr>
<td>-t</td>
<td>测试压缩包文件的完整性。</td>
</tr>
<tr>
<td>-v</td>
<td>压缩或解压缩文件时，显示详细信息。</td>
</tr>
<tr>
<td>-数字</td>
<td>这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高</td>
</tr>
</tbody>
</table>
<p>注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。</p>
</li>
<li>
<p>解压</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bunzip2 <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-k</td>
<td>解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。</td>
</tr>
<tr>
<td>-f</td>
<td>解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程。</td>
</tr>
<tr>
<td>-L</td>
<td>列出压缩文件内容。</td>
</tr>
</tbody>
</table>
<p>“.bz2” 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bzcat install<span class="selector-class">.log</span><span class="selector-class">.syslog</span><span class="selector-class">.bz2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="font-color-orange-4-vim编辑器-font"><font color='orange'>4. vim编辑器</font></h2>
<h3 id="font-color-gree-4-1-vim的三种模式-font"><font color='gree'>4.1 vim的三种模式</font></h3>
<ul>
<li>
<p><code>命令模式</code></p>
<p>使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。</p>
</li>
<li>
<p><code>输入模式</code></p>
<p>进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令，当编辑文件完成后按 Esc 键即可返回命令模式。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令</td>
</tr>
<tr>
<td>o</td>
<td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td>
</tr>
<tr>
<td>O</td>
<td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td>
</tr>
<tr>
<td>a</td>
<td>在当前光标所在位置之后插入随后输入的文本</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>编辑模式</code></p>
<p>编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。</p>
<blockquote>
<p>指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="font-color-gree-4-2-vim的基本操作-font"><font color='gree'>4.2 vim的基本操作</font></h3>
<ul>
<li>
<p>vim打开文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@itxdl ~]</span># vim /test/vi<span class="selector-class">.test</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Vi 使用的选项</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vim filename</td>
<td>打开或新建一个文件，并将光标置于第一行的首部</td>
</tr>
<tr>
<td>vim -r filename</td>
<td>恢复上次 vim 打开时崩溃的文件</td>
</tr>
<tr>
<td>vim -R filename</td>
<td>把指定的文件以只读方式放入 Vim 编辑器中</td>
</tr>
<tr>
<td>vim + filename</td>
<td>打开文件，并将光标置于最后一行的首部</td>
</tr>
<tr>
<td>vi +n filename</td>
<td>打开文件，并将光标置于第 n 行的首部</td>
</tr>
<tr>
<td>vi +/pattern filename</td>
<td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td>
</tr>
<tr>
<td>vi -c command filename</td>
<td>在对文件进行编辑前，先执行指定的命令</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>vim查找文本</p>
<table>
<thead>
<tr>
<th>/abc</th>
<th>从前往后查找字符串abc</th>
</tr>
</thead>
<tbody>
<tr>
<td>/^abc</td>
<td>查找以 abc 为行首的行</td>
</tr>
<tr>
<td>/abc$</td>
<td>查找以 abc 为行尾的行</td>
</tr>
<tr>
<td>?abc</td>
<td>从后往前查找字符串abc</td>
</tr>
<tr>
<td>n</td>
<td>向同一方向继续查找下一个</td>
</tr>
<tr>
<td>N</td>
<td>向相反方向继续查找上一个</td>
</tr>
</tbody>
</table>
<p>注意：是在命令模式下输入’:'后再输入以上命令。</p>
<p>如果想忽略大小写，则输入命令 “:set ic”；调整回来输入&quot;:set noic&quot;。</p>
<p><code>如果在字符串中出现特殊符号，则需要加上转义字符 &quot;\&quot;。常见的特殊符号有 \、*、?、$ 等。如果出现这些字符，例如，要查找字符串 &quot;10$&quot;，则需要在命令模式中输入 &quot;/10\$&quot;。</code></p>
<p><font color='red'>查找完后，要取消高亮显示，使用命令<code>:noh</code>即可</font></p>
</li>
<li>
<p>vim替换文本</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>替换光标所在位置的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td>
</tr>
<tr>
<td>:s/a1/a2/g</td>
<td>将当前光标所在行中的所有 a1 用 a2 替换</td>
</tr>
<tr>
<td>:$s/a1/a2/g或:%s/a1/a2/g</td>
<td>将文件中所有的 a1 都用 a2 替换</td>
</tr>
<tr>
<td>:n1,n2 s/a1/a2/g</td>
<td>将文件中n1到n2行中所有a1都用a2替换</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>vim删除文本</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在位置的字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行（包括此行）后 n 行文本</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行一直到文件末尾的所有内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标位置到行尾的内容</td>
</tr>
<tr>
<td>:a1,a2d</td>
<td>函数从 a1 行到 a2 行的文本内容</td>
</tr>
</tbody>
</table>
<p>被删除的内容存在剪切板中</p>
</li>
<li>
<p>复制文本</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>将剪贴板中的内容粘贴到光标后</td>
</tr>
<tr>
<td>P（大写）</td>
<td>将剪贴板中的内容粘贴到光标前</td>
</tr>
<tr>
<td>y</td>
<td>复制已选中的文本到剪贴板</td>
</tr>
<tr>
<td>yy</td>
<td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td>
</tr>
<tr>
<td>yw</td>
<td>将光标位置的单词复制到剪贴板</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>退出并保存</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:wq</td>
<td>保存并退出 Vim 编辑器</td>
</tr>
<tr>
<td>:wq!</td>
<td>保存并强制退出 Vim 编辑器</td>
</tr>
<tr>
<td>:q</td>
<td>不保存就退出 Vim 编辑器</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存，且强制退出 Vim 编辑器</td>
</tr>
<tr>
<td>:w</td>
<td>保存但是不退出 Vim 编辑器</td>
</tr>
<tr>
<td>:w!</td>
<td>强制保存文本</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存到 filename 文件</td>
</tr>
<tr>
<td>:x！</td>
<td>保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令</td>
</tr>
<tr>
<td>ZZ</td>
<td>直接退出 Vim 编辑器</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>光标移动快捷键汇总</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>光标向左移动一位</td>
</tr>
<tr>
<td>j</td>
<td>光标向下移动一行（以回车为换行符），也就是光标向下移动</td>
</tr>
<tr>
<td>k</td>
<td>光标向上移动一行（也就是向上移动）</td>
</tr>
<tr>
<td>l</td>
<td>光标向右移动一位</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>w 或 W</th>
<th>光标移动至下一个单词的单词首</th>
</tr>
</thead>
<tbody>
<tr>
<td>b 或 B</td>
<td>光标移动至上一个单词的单词首</td>
</tr>
<tr>
<td>e 或 E</td>
<td>光标移动至下一个单词的单词尾</td>
</tr>
<tr>
<td>nw 或 nW</td>
<td>n 为数字，表示光标向右移动 n 个单词</td>
</tr>
<tr>
<td>nb 或 nB</td>
<td>n 为数字，表示光标向左移动 n 个单词</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>快捷键</th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0 或 ^</td>
<td>光标移动至当前行的行首</td>
</tr>
<tr>
<td>$</td>
<td>光标移动至当前行的行尾</td>
</tr>
<tr>
<td>n$</td>
<td>光标移动至当前行只有 n 行的行尾，n为数字</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>fx</th>
<th>光标移动至当前行中下一个 x 字符处</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fx</td>
<td>光标移动至当前行中下一个 x 字符处</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>gg</th>
<th>光标移动到文件开头</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>光标移动至文件末尾</td>
</tr>
<tr>
<td>nG</td>
<td>光标移动到第 n 行，n 为数字</td>
</tr>
<tr>
<td>:n</td>
<td>编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>%</th>
<th>当光标位置在一对{}中的一个半括号时，按%键可以瞬间跳到另一个半括号上</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>u（小写）</th>
<th>undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+R</td>
<td>Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。</td>
</tr>
<tr>
<td>U（大写）</td>
<td>第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h3 id="font-color-gree-4-3-vim可视化模式-font"><font color='gree'>4.3 vim可视化模式</font></h3>
<p>在 Vim 中，如果想选中目标文本，就需要调整 Vim 进入可视化模式</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>v（小写）</td>
<td>又称字符可视化模式，此模式下目标文本的选择是以字符为单位的，也就是说，该模式下要一个字符一个字符的选中要操作的文本。</td>
</tr>
<tr>
<td>V（大写）</td>
<td>又称行可视化模式，此模式化目标文本的选择是以行为单位的，也就是说，该模式化可以一行一行的选中要操作的文本。</td>
</tr>
<tr>
<td>Ctrl+v（组合键）</td>
<td>又称块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本，以按下 Ctrl+v 位置作为矩形的一角，光标移动的终点位置作为它的对角。</td>
</tr>
</tbody>
</table>
<p>可视化模式支持使用的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>删除选中的部分文本。</td>
</tr>
<tr>
<td>D</td>
<td>删除选中部分所在的行，和 d 不同之处在于，即使选中文本中有些字符所在的行没有都选中，删除时也会一并删除。</td>
</tr>
<tr>
<td>y</td>
<td>将选中部分复制到剪贴板中。</td>
</tr>
<tr>
<td>p（小写）</td>
<td>将剪贴板中的内容粘贴到光标之后。</td>
</tr>
<tr>
<td>P（大写）</td>
<td>将剪贴板中的内容粘贴到光标之前。</td>
</tr>
<tr>
<td>u（小写）</td>
<td>将选中部分中的大写字符全部改为小写字符。</td>
</tr>
<tr>
<td>U（大写）</td>
<td>将选中部分中的小写字符全部改为大写字符。</td>
</tr>
<tr>
<td>&gt;</td>
<td>将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td>
</tr>
<tr>
<td>&lt;</td>
<td>将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td>
</tr>
</tbody>
</table>
<h3 id="font-color-gree-4-4-vim多窗口编辑模式-font"><font color='gree'>4.4 vim多窗口编辑模式</font></h3>
<p>可以使用 Vim 同时打开两个文件，每个文件分别占用一个窗口。</p>
<ol>
<li>先使用 Vim 打开第一个文件，接着输入命 令 <code>:sp/xx/xx</code> 水平切分窗口，然后按回车键；如果想垂直切分窗口则可以输入 <code>:vs/xx/xx</code>;</li>
<li>可以直接执行命令<code>vim -o</code> 第一个文件名 第二个文件名&quot;，也就是 “vim-o /etc/passwd /etc/shadow”。2</li>
</ol>
<p><code>切换到另一个文件窗口，可以按 &quot;Ctrl+WW&quot; 快捷键。</code></p>
<p><code>如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 &quot;:r 被复制的文件名&quot;，即可将导入文件的全部内容复制到当前光标所在行下面。</code></p>
<hr>
<h3 id="font-color-gree-4-5-vim批量注释和自定义注释快捷键-font"><font color='gree'>4.5 vim批量注释和自定义注释快捷键</font></h3>
<ul>
<li>
<p><code>:m,n s/^/#/g</code>表示在m~n行的行首加字符#进行注释，^表示行首。</p>
<p><code>:m,n s/^/\/\//g</code>表示在m~n行的行首加字符<code>\\</code>进行注释，由于\是特殊字符，所以需要转移。</p>
</li>
<li>
<p>上述方法只能用于删除连续的行，而对于非连续的行，就可以采用以下自定义快捷键的方式：</p>
<p><code>:map 快捷键 执行命令</code></p>
<blockquote>
<p>如定义快捷键 “Ctrl+P” 为在行首添加 “#” 注释，可以执行 <code>:map^P I#&lt;Esc&gt;</code>。其中 “^P” 为定义快捷键 “Ctrl+P”。 注意：必须同时按 “Ctrl+V+P” 快捷键生成 “^P” 方可有效，直接输入 “^P” 是无效的。</p>
<p>“I#<Esc>” 就是此快捷键要触发的动作，“I” 为在光标所在行行首插入(a表示当前字符之后)，“#” 为要输入的字符，“<Esc>” 表示退回命令模式。“<Esc>” 要逐个字符输入，不可直接按键盘上的 Esc 键。</p>
<p>设置成功后，直接在任意需要注释的行上按 “Ctrl+P” 快捷键，就会自动在行首加上 “#” 注释。取消此快捷键定义，输入 “:unmap^P” 即可。</p>
<p>有时我们写完脚本等文件，需要在末尾注释中加入自己的邮箱，则可以直接定义每次按快捷键 “Ctrl+E” 实现插入邮箱，定义方法为 “:map^E <a href="mailto:asamlee@itxdl.net">asamlee@itxdl.net</a><Esc>”。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="font-color-gree-4-6-vim显示行号-font"><font color='gree'>4.6 vim显示行号</font></h3>
<p>在命令模式下输入<code>:set nu</code>即可显示行号，输入<code>set nonu</code>即可删除行号。</p>
<p>如果希望每次打开文件都默认显示行号，则可以编辑 Vim 的配置文件。每次使用 Vim 打开文件时，Vim 都会到当前 登录用户 的宿主目录中读取 <code>.vimrc</code> 文件，此文件可以对 Vim 进行一些默认配置设定。</p>
<p>如果 .vimrc 文件存在，就先读取其中对 Vim 的设置；否则就采取默认配置。在默认情况下，用户宿主目录中是没有此文件的，需要在当前用户的宿主目录中手工建立，如<code>vim ~/.vimrc&quot;</code>&quot;~“代表宿主目录。可以直接使用 Vim 编辑生成此文件，并在此文件中添加一行&quot;set nu”，保存并退出。之后此用户登录，每次 Vim 打开文件时，都会默认显示行号。</p>
<hr>
<h3 id="font-color-gree-4-7-vim配置文件-vimrc-font"><font color='gree'>4.7 vim配置文件(.vimrc)</font></h3>
<p>Vim 配置文件分为系统配置文件和用户配置文件：</p>
<ul>
<li>系统配置文件位于 Vim 的安装目录（默认路径为 /etc/.vimrc）；</li>
<li>用户配置文件位于主目录 ~/.vimrc，即通过执行 <code>vim ~/.vimrc</code> 命令即可对此配置文件进行合理修改。通常情况下，Vim 用户配置文件需要自己手动创建。</li>
</ul>
<p><code>注意，Vim 用户配置文件比系统配置文件的优先级高，换句话说，Vim 启动时，会优先读取 Vim 用户配置文件（位于主目录中的）！！！所以我们只需要修改用户配置文件即可（不建议直接修改系统配置文件）。</code></p>
<p>可在vim编辑器命令模式中输入<code>:set all</code>来查询vim提供的环境配置参数。</p>
<p>通过以上方式，可以对用户配置文件（~/.vimrc）进行编辑，进而实现对 Vim 的 永久自定义 。</p>
<hr>
<h3 id="font-color-gree-4-8-在vim中执行Linux命令-font"><font color='gree'>4.8 在vim中执行Linux命令</font></h3>
<p>在命令模式下，按下<code>!!</code>（不要按<code>:</code>），这时在窗口的左下角会出现<code>:.!</code>的提示信息，这就表明我们可以输入 Linux 命令了。</p>
<p>窗口左下角的<code>:.!</code>表示操作文本的范围，其中<code>.</code>表示从光标所在行开始,<code>!</code>表示后续会执行 Linux 命令，整体表示命令的执行结果将插入到光标所在行的位置，因此， 如果光标所在位置处有数据，就会被命令的执行结果直接覆盖掉 。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:!命令</td>
<td>直接运行一个 Linux 命令，运行完毕之后，即可返回到 Vim 中。</td>
</tr>
<tr>
<td>:w!命令</td>
<td>将 Vim 中所有的文本内容作为指定命令的输入。但命令的执行结果不会写入到当前文件中。</td>
</tr>
<tr>
<td>:r!命令</td>
<td>将命令执行的结果写入到当前 Vim 中，例如 :!ls 表示将 ls 的执行结果输入到 Vim 中。</td>
</tr>
<tr>
<td>:nr!命令</td>
<td>其中 n 为数字，表示将命令的执行结果写入到 Vim 第 n 行的位置。例如，:3r!date 表示将 date 命令的执行结果写入到第 3 行文本处。</td>
</tr>
<tr>
<td>:n,m!命令</td>
<td>其中 n 表示起始行号，m为结束行号，功能是将 Vim 中指定的部分文本作为某个命令的输入，同时将命令的输出也插入到当前指定的位置。</td>
</tr>
<tr>
<td>:n,m w!命令</td>
<td>其中 n 表示起始行号，m为结束行号，其功能是 Vim 中指定的部分文本作为某个命令的输入，但命令的执行结果不会写入到文件中。</td>
</tr>
<tr>
<td>!!date</td>
<td>向 Vim 中插入当前时间。</td>
</tr>
</tbody>
</table>
<h2 id="font-color-orange-5-文本处理-font"><font color='orange'>5. 文本处理</font></h2>
<h3 id="font-color-gree-5-1-连接文件并打印-cat命令-font"><font color='gree'>5.1 连接文件并打印(cat命令)</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cat <span class="selector-attr">[选项]</span> 文件名   </span><br><span class="line">#用于显示文件内容</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cat 文件<span class="number">1</span> 文件<span class="number">2</span> &gt; 文件<span class="number">3</span></span><br><span class="line">#用于连接两个文件</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>相当于 -vET 选项的整合，用于列出所有隐藏符号(换行符$等)；</td>
</tr>
<tr>
<td>-E</td>
<td>列出每行结尾的回车符 $；</td>
</tr>
<tr>
<td>-n</td>
<td>打印行号</td>
</tr>
<tr>
<td>-b</td>
<td>同 -n 不同，此选项表示只对非空行进行编号。</td>
</tr>
<tr>
<td>-T</td>
<td>把 Tab 键 ^I 显示出来；</td>
</tr>
<tr>
<td>-V</td>
<td>列出特殊字符；</td>
</tr>
<tr>
<td>-s</td>
<td>当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="font-color-gree-5-2-分屏显示文件内容-more命令-font"><font color='gree'>5.2 分屏显示文件内容(more命令)</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># more <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>计算行数时，以实际的行数，而不是自动换行过后的行数。</td>
</tr>
<tr>
<td>-p</td>
<td>不以卷动的方式显示每一页，而是先清除屏幕后再显示内容。</td>
</tr>
<tr>
<td>-c</td>
<td>跟 -p 选项相似，不同的是先显示内容再清除其他旧资料。</td>
</tr>
<tr>
<td>-s</td>
<td>当遇到有连续两行以上的空白行时，就替换为一行的空白行。</td>
</tr>
<tr>
<td>-u</td>
<td>不显示下引号（根据环境变量 TERM 指定的终端而有所不同）。</td>
</tr>
<tr>
<td>+n</td>
<td>从第 n 行开始显示文件内容，n 代表数字。</td>
</tr>
<tr>
<td>-n</td>
<td>一次显示的行数，n 代表数字。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>交互指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>h 或 ？</td>
<td>显示 more 命令交互命令帮助。</td>
</tr>
<tr>
<td>q 或 Q</td>
<td>退出 more。</td>
</tr>
<tr>
<td>v</td>
<td>在当前行启动一个编辑器。</td>
</tr>
<tr>
<td>:f</td>
<td>显示当前文件的文件名和行号。</td>
</tr>
<tr>
<td>!&lt;命令&gt; 或 :!&lt;命令&gt;</td>
<td>在子Shell中执行指定命令。</td>
</tr>
<tr>
<td>回车键</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>空格键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>刷新屏幕。</td>
</tr>
<tr>
<td>=</td>
<td>显示当前行的行号。</td>
</tr>
<tr>
<td>’</td>
<td>转到上一次搜索开始的地方。</td>
</tr>
<tr>
<td>Ctrf+f</td>
<td>向下滚动一页。</td>
</tr>
<tr>
<td>.</td>
<td>重复上次输入的命令。</td>
</tr>
<tr>
<td>/ 字符串</td>
<td>搜索指定的字符串。</td>
</tr>
<tr>
<td>d</td>
<td>向下移动半页。</td>
</tr>
<tr>
<td>b</td>
<td>向上移动一页。</td>
</tr>
</tbody>
</table>
<p>显示文件 anaconda-ks.cfg 的内容，每 10 行显示一屏，同时清楚屏幕，使用以下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># more -c -<span class="number">10</span> anaconda-ks<span class="selector-class">.cfg</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-5-3-显示文件开头内容-head命令-font"><font color='gree'>5.3 显示文件开头内容(head命令)</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># head <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n K</td>
<td>这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 “-K” 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。</td>
</tr>
<tr>
<td>-c K</td>
<td>这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 “-K”，则表示除了文件最后 K 字节的内容，显示剩余全部内容。</td>
</tr>
<tr>
<td>-v</td>
<td>显示文件名；</td>
</tr>
</tbody>
</table>
<p>注意，如不设置显示的具体行数，则默认显示 10 行的文本数据。</p>
<hr>
<h3 id="font-color-gree-5-4-显示文件内容-less命令-font"><font color='gree'>5.4 显示文件内容(less命令)</font></h3>
<p>与 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。</p>
<p>为了方面用户浏览文本内容，less 命令还提供了以下几个功能：</p>
<ul>
<li>使用光标键可以在文本文件中前后（左后）滚屏；</li>
<li>用行号或百分比作为书签浏览文件；</li>
<li>提供更加友好的检索、高亮显示等操作；</li>
<li>兼容常用的字处理程序（如 Vim、Emacs）的键盘操作；</li>
<li>阅读到文件结束时，less 命令不会退出；</li>
<li>屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># less <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-N</td>
<td>显示每行的行号。</td>
</tr>
<tr>
<td>-S</td>
<td>行过长时将超出部分舍弃。</td>
</tr>
<tr>
<td>-e</td>
<td>当文件显示结束后，自动离开。</td>
</tr>
<tr>
<td>-g</td>
<td>只标志最后搜索到的关键同。</td>
</tr>
<tr>
<td>-Q</td>
<td>不使用警告音。</td>
</tr>
<tr>
<td>-i</td>
<td>忽略搜索时的大小写。</td>
</tr>
<tr>
<td>-m</td>
<td>显示类似 more 命令的百分比。</td>
</tr>
<tr>
<td>-f</td>
<td>强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td>
</tr>
<tr>
<td>-s</td>
<td>显示连续空行为一行。</td>
</tr>
<tr>
<td>-b &lt;缓冲区大小&gt;</td>
<td>设置缓冲区的大小。</td>
</tr>
<tr>
<td>-o &lt;文件名&gt;</td>
<td>将 less 输出的内容保存到指定文件中。</td>
</tr>
<tr>
<td>-x &lt;数字&gt;</td>
<td>将【Tab】键显示为规定的数字空格。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>交互指令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>/字符串</td>
<td>向下搜索“字符串”的功能。</td>
</tr>
<tr>
<td>?字符串</td>
<td>向上搜索“字符串”的功能。</td>
</tr>
<tr>
<td>n</td>
<td>重复*前一个搜索（与 / 成 ? 有关）。</td>
</tr>
<tr>
<td>N</td>
<td>反向重复前一个搜索（与 / 或 ? 有关）。</td>
</tr>
<tr>
<td>b</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>d</td>
<td>向下移动半页。</td>
</tr>
<tr>
<td>h 或 H</td>
<td>显示帮助界面。</td>
</tr>
<tr>
<td>q 或 Q</td>
<td>退出 less 命令。</td>
</tr>
<tr>
<td>y</td>
<td>向上移动一行。</td>
</tr>
<tr>
<td>空格键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>回车键</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>【PgDn】键</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>【PgUp】键</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>向上移动一页。</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>向下移动一页。</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>向上移动半页。</td>
</tr>
<tr>
<td>j</td>
<td>向下移动一行。</td>
</tr>
<tr>
<td>k</td>
<td>向上移动一行。</td>
</tr>
<tr>
<td>G</td>
<td>移动至最后一行。</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一行。</td>
</tr>
<tr>
<td>ZZ</td>
<td>退出 less 命令。</td>
</tr>
<tr>
<td>v</td>
<td>使用配置的编辑器编辑当前文件。</td>
</tr>
<tr>
<td>[</td>
<td>移动到本文档的上一个节点。</td>
</tr>
<tr>
<td>]</td>
<td>移动到本文档的下一个节点。</td>
</tr>
<tr>
<td>p</td>
<td>移动到同级的上一个节点。</td>
</tr>
<tr>
<td>u</td>
<td>向上移动半页。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="font-color-gree-5-5-显示文件结尾-tail-font"><font color='gree'>5.5 显示文件结尾(tail)</font></h3>
<p>tail 命令和 head 命令正好相反，它用来查看文件末尾的数据，其基本格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tail <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n K</td>
<td>这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。</td>
</tr>
<tr>
<td>-c K</td>
<td>这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。</td>
</tr>
<tr>
<td>-f</td>
<td>输出文件变化后新增加的数据。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="font-color-gree-5-6-Linux重定向-font"><font color='gree'>5.6 Linux重定向</font></h3>
<p>输入重定向：</p>
<table>
<thead>
<tr>
<th>命令符号格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &lt; 文件</td>
<td>将指定文件作为命令的输入设备</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符</td>
<td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td>
</tr>
<tr>
<td>命令 &lt; 文件 1 &gt; 文件 2</td>
<td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td>
</tr>
</tbody>
</table>
<p>一般用输出重定向较多</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ls &lt; /tmp &gt; aha</span><br><span class="line">#/tmp 的内容输出到aha文件中</span><br></pre></td></tr></table></figure>
<p>输出重定向：</p>
<table>
<thead>
<tr>
<th>命令符号格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令 &gt; 文件</td>
<td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td>
</tr>
<tr>
<td>命令 2&gt; 文件</td>
<td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td>
</tr>
<tr>
<td>命令 2&gt;&gt; 文件</td>
<td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td>
<td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2&gt;&amp;1 是一体的，可以认为是固定写法。</td>
</tr>
</tbody>
</table>
<p>输出重定向还可以细分为标准输出重定向和错误输出重定向两种技术。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch demo1<span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -l demo1<span class="selector-class">.txt</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> root root <span class="number">0</span> Oct <span class="number">12</span> <span class="number">15</span>:<span class="number">02</span> demo1.txt   &lt;--标准输出信息</span><br><span class="line">[root@localhost ~]# ls -l demo2.txt    &lt;-- 不存在的文件</span><br><span class="line">ls: cannot access demo2.txt: No such file or directory  &lt;--错误输出信息</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-5-7-grep命令和正则表达式-font"><font color='gree'>5.7 grep命令和正则表达式</font></h3>
<blockquote>
<p><font color='red'>正则表达式</font></p>
<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取<code>@</code>前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>
<p>正则表达式是一种用来 =匹配字符串 的强有力的武器。它的设计思想是用一种 描述性的语言 来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
</blockquote>
<p>grep命令能够在一个或多个文件中，搜索 某一特定的字符模式 （也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p>
<p><strong>正则表达式的通配符</strong></p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>c*</td>
<td>将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td>
</tr>
<tr>
<td>.</td>
<td>将匹配任何一个字符，且只能是一个字符。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>匹配方括号中的任意一个字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>匹配除方括号中字符外的所有字符。</td>
</tr>
<tr>
<td>^</td>
<td>锁定行的开头。</td>
</tr>
<tr>
<td>$</td>
<td>锁定行的结尾。</td>
</tr>
</tbody>
</table>
<p><code>需要注意的是，在基本正则表达式中，如通配符 *、+、&#123;、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 \*、\+、\&#123;、\|、\( 和 \)。</code></p>
<p><strong>grep 命令的基本格式如下：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep <span class="selector-attr">[选项]</span> 模式 文件名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的模式，要么是字符（串），要么是正则表达式。</p>
</blockquote>
<p>详细见<a target="_blank" rel="noopener" href="https://linux.cn/article-6941-1.html">grep与正则表达式</a>和<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">菜鸟教程-正则表达式</a></p>
<hr>
<h3 id="font-color-gree-5-8-sed命令-font"><font color='gree'>5.8 sed命令</font></h3>
<h2 id="font-color-orange-6-Linux软件安装-font"><font color='orange'>6. Linux软件安装</font></h2>
<h3 id="font-color-gree-6-1-Linux软件包-font"><font color='gree'>6.1 Linux软件包</font></h3>
<p>Linux下的软件包可细分为两种，分别是 源码包 和 二进制包 。</p>
<ul>
<li>
<p><strong>源码包</strong></p>
<p>源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。而因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也高。</p>
<blockquote>
<p>源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理，Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为Tarball。</p>
<p>Tarball 是 Linux 系统的一款打包工具，可以对源码包进行打包压缩处理，人们习惯上将最终得到的打包压缩文件称为 Tarball 文件。</p>
<p>包中通常包含以下内容：</p>
<ul>
<li>源代码文件。</li>
<li>配置和检测程序（如 configure 或 config 等）。</li>
<li>软件安装说明和软件说明（如 INSTALL 或 README）。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>二进制包</strong></p>
<p>由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快，且安装过程报错几率大大减小。</p>
<p>二进制包是 Linux 下默认的软件安装包 。目前主要有以下 2 大主流的二进制包管理系统：</p>
<ul>
<li>RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。</li>
<li>DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="font-color-gree-6-2-RPM包统一命名规则-font"><font color='gree'>6.2 RPM包统一命名规则</font></h3>
<p><strong>RPM(RedHat Package Manager)一种通过资料库管理的方式将所需要的软件安装到主机上的管理程序。</strong> RPM(Red hat Package Manage) 是事实的业界标准，是red hat开发的标准，优点是管理软件方便简单,类似于DEB包(debain组织的宝管理方式)。</p>
<p>Linux是通过rpm来管理和实现软件的安装、查看、删除的。</p>
<p>RPM 二进制包命名的一般格式如下：</p>
<p>包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名</p>
<blockquote>
<p>比如：<code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code></p>
<ul>
<li>注意，<code>httpd</code>是包名，而以上所有是<code>全包名</code>。包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名</li>
<li>2.2.15：包的版本号，版本号的格式通常为<code>主版本号.次版本号.修正号</code></li>
<li>15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。</li>
<li>el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。</li>
<li>centos：表示此包适用于 CentOS 系统。</li>
<li>i686：表示此包使用的硬件平台</li>
<li>rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用<code>rpm</code>命令直接安装。此外，还有以<code>src.rpm</code>作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。</li>
</ul>
</blockquote>
<hr>
<h3 id="font-color-gree-6-3-RPM包安装、卸载和升级（rpm命令）-font"><font color='gree'>6.3 RPM包安装、卸载和升级（rpm命令）</font></h3>
<p><em><strong>安装</strong></em></p>
<p>RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到如下所示的目录中。</p>
<table>
<thead>
<tr>
<th>安装路径</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
<p>除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，<strong>所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别）</strong></p>
<blockquote>
<p>与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 /usr/local/ 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。</p>
</blockquote>
<p>安装 RPM 的命令格式为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -ivh 包全名    #注意是全包名！</span><br></pre></td></tr></table></figure>
<p>此命令中各选项参数的含义为：</p>
<ul>
<li><code>-i</code>：安装（install）;</li>
<li><code>-v</code>：显示更详细的信息（verbose）;</li>
<li><code>-h</code>：打印 #，显示安装进度（hash）;</li>
</ul>
<blockquote>
<p>例如，使用此命令安装 apache 软件包，如下所示：</p>
<p>[root@localhost ~]# rpm -ivh <br>
/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm<br>
Preparing…<br>
####################<br>
[100%]<br>
1:httpd<br>
####################<br>
[100%]</p>
<p>注意， 直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作 。</p>
</blockquote>
<p>其他安装要求（比如强制安装某软件而不管它是否有依赖性），可以通过以下选项进行调整：</p>
<ul>
<li><code>-nodeps</code>：不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。<font color='red'>注意，这样不检测依赖性安装的软件基本上是不能使用的</font>，所以不建议这样做。</li>
<li><code>-replacefiles</code>：替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报&quot;某个文件已经存在&quot;的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。</li>
<li><code>-replacepkgs</code>：替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。</li>
<li><code>-force</code>：强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合。</li>
<li><code>-test</code>：测试安装。不会实际安装，只是检测一下依赖性。</li>
<li><code>-prefix</code>：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。</li>
</ul>
<p><em><strong>升级</strong></em></p>
<p>使用如下命令即可实现 RPM 包的升级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Uvh 包全名       #注意是全包名！</span><br></pre></td></tr></table></figure>
<p><code>-U</code>选项的含义是：如果该软件安装过则直接升级；若安装过则直接安装最新版本。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Fvh 包全名       #注意是全包名！</span><br></pre></td></tr></table></figure>
<p><code>-F</code>选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。</p>
<p><em><strong>卸载</strong></em></p>
<p><font color='red'>RPM 软件包的卸载要考虑包之间的依赖性</font>。例如，若先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。</p>
<p>如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误</p>
<p>卸载使用如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -e 包名         #注意是包名！</span><br></pre></td></tr></table></figure>
<p><code>-e</code> 选项表示卸载，也就是 erase 的首字母。</p>
<p>RPM 软件包的卸载命令支持使用<code>-nocteps</code>选项，即可以不检测依赖性直接卸载，但此方式不推荐使用，因为此操作很可能导致其他软件也无法使用。</p>
<hr>
<h3 id="font-color-gree-6-4-rpm命令查询软件包-font"><font color='gree'>6.4 rpm命令查询软件包</font></h3>
<p>rpm 命令还可用来对 RPM 软件包做查询操作，具体包括：</p>
<ul>
<li>查询软件包是否已安装；</li>
<li>查询系统中所有已安装的软件包；</li>
<li>查看软件包的详细信息；</li>
<li>查询软件包的文件列表；</li>
<li>查询某系统文件具体属于哪个 RPM 包;</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm 选项 查询对象</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>
<p>查询软件包是否安装</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -<span class="selector-tag">q</span> 包名</span><br></pre></td></tr></table></figure>
<p>-q 表示查询，是 query 的首字母。</p>
<p>注意是包名！已安装的软件包只需给出包名！</p>
</li>
<li>
<p>查询所以已安装的软件包</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa 包名</span><br></pre></td></tr></table></figure>
<p>还可以使用管道符查找出需要的内容，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa | grep httpd</span><br><span class="line">httpd-devel-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br><span class="line">httpd-tools-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br><span class="line">httpd-manual-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.noarch</span></span><br><span class="line">httpd-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br></pre></td></tr></table></figure>
<p>相比<code>rpm -q 包名</code>命令，采用这种方式可以找到含有包名的所有软件包。</p>
</li>
<li>
<p>查询软件包的详细信息</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qi 包名</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询软件包的文件列表</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -ql 包名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>rpm 软件包采用默认路径安装，各安装文件会分门别类安放在适当的目录文件下。使用 rpm 命令可以查询到已安装软件包中包含的所有文件及各自安装路径</p>
</blockquote>
<p>rpm 命令还可以查询未安装软件包中包含的所有文件以及打算安装的路径，命令格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qlp 包全名</span><br></pre></td></tr></table></figure>
<p>-p 选项表示查询未安装的软件包信息，是 package 的首字母。</p>
<p>注意，由于软件包还未安装，因此需要使用<code>“绝对路径+包全名”</code>的方式才能确定包。</p>
</li>
<li>
<p>查询系统文件属于哪个RPM包</p>
<p>rpm -ql 命令是通过软件包查询所含文件的安装路径，rpm 还支持反向查询，即查询某系统文件所属哪个 RPM 软件包。其命令格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qf 系统文件名</span><br></pre></td></tr></table></figure>
<p>比如查询命令<code>ls</code>所属的软件包：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># rpm -qf /bin/ls</span><br><span class="line">coreutils-<span class="number">8.22</span>-<span class="number">23</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询软件包依赖关系</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qR 包名</span><br></pre></td></tr></table></figure>
<p>-R（大写）选项的含义是查询软件包的依赖性，是 requires 的首字母。</p>
<p>在此命令的基础上增加 -p 选项，即可实现查找未安装软件包的依赖性。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qRp 包全名</span><br></pre></td></tr></table></figure>
<p>由于软件包还未安装，因此也需要使用<code>“绝对路径+包全名”</code>的方式才能确定包，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qRp /mnt/cdrom/Packages/bind-<span class="number">9.8</span>.<span class="number">2</span>-<span class="number">0.10</span><span class="selector-class">.rc1</span><span class="selector-class">.el6</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="font-color-gree-6-5-RPM包验证和数字证书-font"><font color='gree'>6.5 RPM包验证和数字证书</font></h3>
<p>执行 <code>rpm -qa</code> 命令可以看到，Linux 系统中装有大量的 RPM 包，且每个包都含有大量的安装文件。因此， 为了能够及时发现文件误删、误修改文件数据、恶意篡改文件内容等问题 ，Linux 提供了以下两种监控（检测）方式：</p>
<ul>
<li>RPM 包校验：其实就是 将已安装文件和 /var/lib/rpm/ 目录下的数据库内容 进行比较，确定文件内容是否被修改。</li>
<li>RPM 包数字证书校验：用来校验 RPM 包本身是否被修改。</li>
</ul>
<p><strong>RPM包校验</strong>：</p>
<p>RPM 包校验可用来判断已安装的软件包（或文件）是否被修改，此方式可使用的命令格式分为以下 3 种。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Va</span><br></pre></td></tr></table></figure>
<p>-Va 选项表示校验系统中已安装的所有软件包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -V 已安装的包名</span><br></pre></td></tr></table></figure>
<p>-V 选项表示校验指定 RPM 包中的文件，是 verity 的首字母。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure>
<p>-Vf 选项表示校验某个系统文件是否被修改。</p>
<p>执行后无任何提示信息，表明所有用 apache 软件包安装的文件均未改动过，还和从原软件包安装的文件一样。</p>
<p>如果出现以下信息，则表示被修改过：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -V httpd</span><br><span class="line">S.<span class="number">5</span>...<span class="selector-class">.T</span>. c /etc/httpd/conf/httpd<span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果显示了文件被修改的信息。该信息可分为以下 3 部分：</p>
<ol>
<li>最前面的 8 个字符 （S.5…T）都属于验证信息，各字符的具体含义如下：</li>
</ol>
<ul>
<li>S：文件大小是否改变。</li>
<li>M：文件的类型或文件的权限（rwx）是否改变。</li>
<li>5：3。</li>
<li>D：设备的主从代码是否改变。</li>
<li>L：文件路径是否改变。</li>
<li>U：文件的属主（所有者）是否改变。</li>
<li>G：文件的属组是否改变。</li>
<li>T：文件的修改时间是否改变。</li>
<li>.：若相关项没发生改变，用 . 表示。</li>
</ul>
<ol start="2">
<li>第九个字符属于被修改文件类型，大致可分为以下几类：
<ul>
<li>c：配置文件（configuration file）。</li>
<li>d：普通文档（documentation）。</li>
<li>g：&quot;鬼&quot;文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。</li>
<li>l：授权文件（license file）。</li>
<li>r：描述文件（read me）。</li>
</ul>
</li>
<li>被修改文件所在绝对路径（包含文件名）。</li>
</ol>
<blockquote>
<p>由此，S.5…T. c S.5…T. c /etc/httpd/conf/httpd.conf 表达的完整含义是：配置文件 httpd.conf 的大小、内容、修改时间被人为修改过。</p>
</blockquote>
</blockquote>
<p><strong>RPM数字整数验证</strong></p>
<p><strong>RPM 包校验方法只能用来校验已安装的 RPM 包及其安装文件，如果 RPM 包本身就被动过手脚，此方法将无法解决问题，需要使用 RPM 数字证书验证方法。</strong></p>
<blockquote>
<p>简单的理解，RPM 包校验其实就是将现有安装文件与最初使用 RPM 包安装时的初始文件进行对比，如果有改动则提示给用户，因此这种方式无法验证 RPM 包本身被修改的情况。</p>
</blockquote>
<p><font color='gree'>数字证书</font>，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，<font color='red'>若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。</font></p>
<p>使用数字证书验证 RPM 包的方法具有如下 2 个特点：</p>
<ol>
<li>必须找到原厂的公钥文件，然后才能进行安装。</li>
<li>安装 RPM 包会提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。</li>
</ol>
<p>安装数字证书的命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm <span class="attr">--import</span> /efc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>–import表示导入数字证书</p>
<p>数字证书安装完成后，可使用如下命令进行验证：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa|grep gpg-pubkey</span><br><span class="line">gpg-pubkey-c105b9de-<span class="number">4</span>e0fd3a3</span><br></pre></td></tr></table></figure>
<p>可以看到，数字证书已成功安装。 在装有数字证书的系统上安装 RPM 包时，系统会自动验证包的数字证书，验证通过则可以安装，反之将无法安装（系统会报错） 。</p>
<p>数字证书本身也是一个 RPM 包 ，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。</p>
<hr>
<h3 id="font-color-gree-6-6-提取RPM包-cpio-font"><font color='gree'>6.6 提取RPM包(cpio)</font></h3>
<p>cpio 命令用于从归档包中存入和读取文件。</p>
<blockquote>
<p>归档包，也可称为文件库，其实就是 cpio 或 tar 格式的文件，该文件中包含其他文件以及一些相关信息（文件名、访问权限等）。归档包既可以是磁盘中的文件，也可以是磁带或管道。</p>
</blockquote>
<p>cpio 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档库，也可以利用 cpio 文档库对数据进行恢复。</p>
<p>使用 cpio 命令备份或恢复数据，需注意以下几点：</p>
<ul>
<li>使用 cpio 备份数据时如果使用的是绝对路径，那么还原数据时会自动恢复到绝对路径下并覆盖原有数据！；同理，如果备份数据使用的是相对路径，那么数据会还原到相对路径下。最好使用相对路径。</li>
<li>cpio 命令无法自行指定备份（或还原）的文件，需要目标文件（或目录）的完整路径才能成功读取，因此此命令常与 find 命令配合使用。</li>
<li>cpio 命令恢复数据时不会自动覆盖同名文件，也不会创建目录（直接解压到当前文件夹）。</li>
</ul>
<p>cpio 命令主要有以下 3 种基本模式：</p>
<ol>
<li>“-o” 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &gt; <span class="selector-attr">[文件丨设备]</span></span><br></pre></td></tr></table></figure>
<p>各选项含义如下：</p>
<ul>
<li>-o：copy-out模式，备份；</li>
<li>-v：显示备份过程；</li>
<li>-c：使用较新的portable format存储方式；</li>
<li>-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes；</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#find</span> /etc -print | cpio -ocvB &gt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">#利用find命令指定要备份/etc/目录，使用&gt;导出到etc<span class="selector-class">.cpio</span>文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># II -h etc<span class="selector-class">.cpio</span></span><br><span class="line">-rw<span class="attr">--r--r--</span>.<span class="number">1</span> root root <span class="number">21</span>M <span class="number">6</span>月<span class="number">5</span> <span class="number">12</span>:<span class="number">29</span> etc.cpio</span><br><span class="line">#etc.cpio文件生成</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><code>-o</code> 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &gt; <span class="selector-attr">[文件丨设备]</span></span><br></pre></td></tr></table></figure>
<p>各选项含义如下：</p>
<ul>
<li>-o：copy-out模式，备份；</li>
<li>-v：显示备份过程；</li>
<li>-c：使用较新的portable format存储方式；</li>
<li>-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes；</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#find</span> /etc -print | cpio -ocvB &gt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">\#利用find命令指定要备份/etc/目录，使用&gt;导出到etc<span class="selector-class">.cpio</span>文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># II -h etc<span class="selector-class">.cpio</span></span><br><span class="line">-rw<span class="attr">--r--r--</span>.<span class="number">1</span> root root <span class="number">21</span>M <span class="number">6</span>月<span class="number">5</span> <span class="number">12</span>:<span class="number">29</span> etc.cpio</span><br><span class="line">\#etc.cpio文件生成</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>-i</code> 模式：指的是 copy-in 模式，就是把数据从文件库中恢复，命令格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &lt; <span class="selector-attr">[文件|设备]</span></span><br></pre></td></tr></table></figure>
<p>各选项的含义为：</p>
<ul>
<li>-i：copy-in 模式，还原；</li>
<li>-v：显示还原过程；</li>
<li>-c：较新的 portable format 存储方式；</li>
<li>-d：还原时自动新建目录；</li>
<li>-u：自动使用较新的文件覆盖较旧的文件；</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio -idvcu &lt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">\#还原etc的备份</span><br></pre></td></tr></table></figure>
<p><font color='red'>\査看一下当前目录/root/，就会发现没有生成/etc/目录。这是因为备份时/etc/目录使用的是绝对路径，所以数据直接恢复到/etc/系统目录中，而没有生成在/root/etc/目录中</font></p>
</li>
<li>
<p><code>-p</code> 模式：指的是复制模式，使用 -p 模式可以从某个目录读取所有文件，但并不将其备份到 cpio 库中，而是直接复制为其他文件。</p>
<p>例如，使用 -p 将 /boot/ 复制到 /test/boot 目录中可以执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="selector-attr">[root@localhost ~]</span># cd /tmp/</span><br><span class="line">   \#进入/tmp/目录</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span><span class="selector-id">#rm</span> -rf *</span><br><span class="line">   \#删除/tmp/目录中的所有数据</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># mkdir test</span><br><span class="line">   \#建立备份目录</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># find /boot/ -print | cpio -<span class="selector-tag">p</span> /tmp/test</span><br><span class="line">   \#备份/boot/目录到/tmp/test/目录中</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># ls test/boot</span><br><span class="line">   \#在/tmp/test/目录中备份出了/boot/目录</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em><strong>使用 cpio 命令提取 RPM 包中指定文件</strong></em></p>
<p>在服务器使用过程，如果系统文件被误修改或误删除，<strong>可以考虑使用 cpio 命令提取出原 RPM 包中所需的系统文件，从而修复被误操作的源文件</strong>。</p>
<p>RPM 包允许逐个提取包中文件，使用的命令格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm2cpio 包全名|cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该命令中，rpm2cpio 就是将 RPM 包转换为 cpio 格式（rpm to(two) cpio）的命令，通过 cpio 命令即可从 cpio 文件库中提取出指定文件。</p>
</blockquote>
<p>举个例子，假设我们不小心把 /bin/ls 命令删除了，通常有以下 2 种方式修复：</p>
<ol>
<li>将 coreutils-8.4-19.el6.i686 包（包含 ls 命令的 RPM 包）通过 -f 选项再安装一遍；</li>
<li>使用 cpio 命令从 coreutils-8.4-19.el6.i686 包中提取出 /bin/ls 文件，然后将其复制到相应位置；</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qf /bin/ls</span><br><span class="line">coreutils-<span class="number">8.4</span>-<span class="number">19</span><span class="selector-class">.el6</span><span class="selector-class">.i686</span></span><br><span class="line">#查看ls文件属于哪个软件包</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv /bin/ls /root/</span><br><span class="line">#把/bin/ls命令移动到/root/目录下，造成误删除的假象</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">-bash: ls: command not found</span><br><span class="line">#这时执行ls命令，系统会报<span class="string">&quot;命令没有找到&quot;</span>错误</span><br><span class="line">[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-<span class="number">8.4</span>-<span class="number">19</span>.el6.i686.rpm</span><br><span class="line">|cpio -idv ./bin/ls</span><br><span class="line">#提取ls命令文件到当前目录下</span><br><span class="line">[root@localhost ~]# cp /root/bin/ls /bin/</span><br><span class="line">#把提取出来的ls命令文件复制到/bin/目录下</span><br><span class="line">[root@localhost ~]#ls</span><br><span class="line">anaconda-ks.cfg bin inittab install.log install.log.syslog ls</span><br><span class="line">#可以看到，ls命令又可以正常使用了</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-6-7-SRPM源码包-font"><font color='gree'>6.7 SRPM源码包</font></h3>
<p>SRPM 包中不再是经过编译的二进制文件，都是源代码文件。</p>
<p>RPM 包与 SRPM 包的几点不同：</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>文件名格式</th>
<th>直接安装与否</th>
<th>内含程序类型</th>
<th>可否修改参数并编译</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPM</td>
<td>xxx.rpm</td>
<td>可</td>
<td>已编译</td>
<td>不可</td>
</tr>
<tr>
<td>SRPM</td>
<td>xxx.src.rpm</td>
<td>不可</td>
<td>未编译的源代码</td>
<td>可</td>
</tr>
</tbody>
</table>
<p>SRPM 包是未经编译的源码包，无法直接用来安装软件，需要经过以下 2 步：</p>
<ol>
<li>将 SRPM 包编译成二进制的 RPM 包；</li>
<li>使用编译完成的 RPM 包安装软件；</li>
</ol>
<p>而使用 SRPM 包安装软件（编译 SRPM 包）的方式有以下 2 种：</p>
<ol>
<li>
<p>利用 <code>rpmbuild</code> 命令可以直接使用 SRPM 包安装软件，也可以先将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</p>
<blockquote>
<p><code>rpmbuild</code>命令需要安装才能使用</p>
</blockquote>
</li>
<li>
<p>利用 *.spec 文件可实现将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</p>
</li>
</ol>
<p><strong>利用rpmbuilt命令安装：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpmbuild <span class="selector-attr">[选项]</span> 包全名</span><br></pre></td></tr></table></figure>
<p>可使用如下 2 个选项：</p>
<ul>
<li>-rebuild：编译 SRPM 包生成 RPM 二进制包；</li>
<li>-recompile：编译 SRPM 包，同时安装。</li>
</ul>
<p>注意，SRPM 本质上仍属于 RPM 包，所以安装时仍需考虑包之间的依赖性，要先安装它的依赖包，才能正确安装。</p>
<p><font color='cornflowerblue'>SRPM 包编译完成后，会在当前目录生成 rpmbuild 目录，整个编译过程生成的文件（软件包）都存在这里。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls /root/rpmbuild/</span><br><span class="line">BUILD RPMS SOURCES SPECS SRPMS</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>BUILD</td>
<td>编译过程中产生的数据保存位置</td>
</tr>
<tr>
<td>RPMS</td>
<td>编译成功后，生成的 RPM 包保存位置</td>
</tr>
<tr>
<td>SOURCES</td>
<td>从 SRPM 包中解压出来的源码包（*.tar.gz）保存位置</td>
</tr>
<tr>
<td>SPECS</td>
<td>生成的设置文件的安装位置。第二种安装方法就是利用这个文件进行安装的</td>
</tr>
<tr>
<td>SRPMS</td>
<td>放置 SRPM 包的位置</td>
</tr>
</tbody>
</table>
<p>实际上，使用 rpmbuild命令编译 SRPM 包经历了以下 3 个过程：</p>
<ol>
<li>先把 SRPM 包解开，得到源码包；</li>
<li>对源码包进行编译，生成二进制文件；</li>
<li>把二进制文件重新打包生成 RPM 包。</li>
</ol>
<p><em><em>利用</em>.spec文件安装：</em>*</p>
<p>想利用 .spec 文件安装软件，需先将 SRPM 包解开。当然，我们可以使用 rpmbuild 命令解开 SRPM 包，但这里选择另一种方式，即使用 <code>rpm -i</code> 命令，如下所示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -<span class="selector-tag">i</span> httpd-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">5</span><span class="selector-class">.el6</span><span class="selector-class">.src</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure>
<p><font color='red'>-i 选项用于安装 rpm 包时表示安装，但对于 SRPM 包的安装来说，这里只会将 .src.rpm 包解开后将个文件放置在当前目录下的 rpmbuild 目录中，并不涉及安装操作。</font></p>
<p><font color='red'>通过此命令，也可以在当前目录下生成 rpmbuild 目录，但与rpmrebuild命令不同，此 rpmbuild 目录中仅有 SOURCES 和 SPECS 两个子目录。其中，SOURCES 目录中放置的是源码，SPECS 目录中放置的是设置文件。</font></p>
<p>然后使用 SPECS 目录中的设置文件生成 RPM 包，命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpmbuild -ba /root/rpmbuild/SPECS/httpd<span class="selector-class">.spec</span></span><br></pre></td></tr></table></figure>
<p>其中，-ba 选项的含义是编译，会同时生成 RPM 二进制包和 SRPM 源码包。还可以使用 -bb 选项用来仅生成 RPM 二进制包。</p>
<p>命令执行完成，会在 /root/rpmbuild/ 目录下生成 BUILD、RPMS和 SRPMS 目录，RPM 包放在 RPMS 目录中，SRPM 包生成在 SRPMS 目录中。</p>
<hr>
<h3 id="font-color-gree-6-8-重建RPM数据库-font"><font color='gree'>6.8 重建RPM数据库</font></h3>
<p><font color='red'>安装到系统中的各 RPM 包，其必要信息都会保存到 RPM 数据库中，以便用户使用 rpm 命令对软件包执行查询、安装和卸载等操作。</font></p>
<p>若RPM包在升级过程被强行退出、RPM 包安装意外中断等误操作，都可能使 RPM 数据库出现故障，后果是当安装、删除、査询软件包时，请求无法执行。</p>
<p>这时就需要重建 RPM 数据库，执行如下 2 步操作：</p>
<ol>
<li>
<p>删除当前系统中已损坏的RPM数据库，执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -f /<span class="selector-tag">var</span>/lib/rpm/_db.*</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重建 RPM 数据库，执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost -]</span># rpm -rebuilddb</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="font-color-gree-6-9-RPM包的依赖性及其解决方案-font"><font color='gree'>6.9 RPM包的依赖性及其解决方案</font></h3>
<p>Linux 系统中，RPM 包之间的依赖关系大致可分为以下 3 种：</p>
<ol>
<li>树形依赖（A-B-C-D） ：要想安装软件 A，必须先安装 B，而安装 B 需要先安装 C…….解决此类型依赖的方法是从后往前安装，即先安装 D，再安装 C，然后安装 B，最后安装软件 A。</li>
<li>环形依赖（A-B-C-D-A） ：各个软件安装的依赖关系构成“环状”。解决此类型依赖的方法是用一条命令同时安装所有软件包，即使用 <code>rpm -ivh 软件包A 软件包B ...</code>。</li>
<li>模型依赖 ：软件包的安装需要借助其他软件包的某些文件（比如库文件），解决模块依赖最直接的方式是通过 <a target="_blank" rel="noopener" href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站找到包含此文件的软件包，安装即可。</li>
</ol>
<p>以上 3 种 RPM 包的依赖关系，给出的解决方案都是手动安装，比较麻烦。一般使用yum 命令进行查询、安装、升级和卸载软件包</p>
<blockquote>
<p>yum，全称&quot;Yellow dog Updater,Modified&quot;，CentOS 系统上的软件包管理器，它能够自动下载 RPM 包并安装，更重要的是，它可以自动处理软件包之间的依赖性关系，一次性安装所有依赖的软件包，无需一个个安装。</p>
</blockquote>
<hr>
<h3 id="6-10-font-color-gree-yum原配置-font">6.10 <font color='gree'>yum原配置</font></h3>
<p>使用 SRPM 源码包和 RPM 二进制包来安装软件都比较繁琐，需要手动解决包之间具有依赖性的问题，尤其是库文件依赖，需要自行去 <a target="_blank" rel="noopener" href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站上查找相关的 RPM 包。而yum可以自动解决以上问题。</p>
<p><code>yum</code>，全称“Yellow dog Updater, Modified”， 是一个专门为了解决包的依赖关系而存在的软件包管理器 。就好像 Windows 系统上可以通过软件管家实现软件的一键安装、升级和卸载，Linux 系统也提供有这样的工具，就是 yum。</p>
<p>yum是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。<font color='orange'>yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。</font>1</p>
<p>使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源 。</p>
<p>使用 yum 安装软件时至少需要一个 yum 源。yum 源既可以使用 网络 yum 源 ，也可以将 本地光盘作为 yum 源 。</p>
<hr>
<p>###<font color='gree'>6.11 yum命令</font></p>
<ul>
<li>
<p><strong>查询命令</strong></p>
<ul>
<li><code>yum list</code>：查询所有已安装和可安装的软件包</li>
<li><code>yum list 包名</code>：查询执行软件包的安装情况</li>
<li><code>yum search 关键字</code>：从 yum 源服务器上查找与关键字相关的所有软件包。</li>
<li><code>yum info 包名</code>：查询执行软件包的详细信息。</li>
</ul>
</li>
<li>
<p><strong>安装命令</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost yum.repos.d]</span># yum -y install 包名</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>install：表示安装软件包。</li>
<li>-y：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 yes；</li>
</ul>
</li>
<li>
<p><strong>升级命令</strong></p>
<p>使用 yum 升级软件包，需确保 yum 源服务器中软件包的版本比本机安装的软件包版本高。</p>
<ul>
<li><code>yum -y update</code>：升级所有软件包。不过考虑到服务器强调稳定性，因此该命令并不常用。</li>
<li><code>yum -y update 包名</code>：升级特定的软件包。</li>
</ul>
</li>
<li>
<p><strong>卸载命令</strong></p>
<p>*** 使用 yum 卸载软件包时，会同时卸载所有与该包有依赖关系的其他软件包，即便有依赖包属于系统运行必备文件，也会被 yum 无情卸载，带来的直接后果就是使系统崩溃。 ***</p>
<p>除非能确定卸载此包以及它的所有依赖包不会对系统产生影响，否则不要使用 yum 卸载软件包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost yum.repos.d]</span># yum remove 包名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="font-color-gree-6-12-yum管理软件组-font"><font color='gree'>6.12 yum管理软件组</font></h3>
<p>软件组指功能相对集中的软件包集合。例如，Linux图形界面软件组（X Window System 和 Desktop）。</p>
<ul>
<li>
<p>查询软件组包含的软件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> groupinfo &quot;软件组名&quot;</span><br></pre></td></tr></table></figure>
<p>注意，软件组名需要加引号！</p>
</li>
<li>
<p>安装软件组：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> groupinstall &quot;软件组名&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询软件组：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> grouplist</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>卸载软件组：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># yum groupremove &quot;软件组名&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="font-color-gree-6-13-源码包安装和卸载-font"><font color='gree'>6.13 源码包安装和卸载</font></h3>
<p><em><strong>注意，本节使用的源码包，指的是<font color='red'>软件所有源代码的压缩包</font>，其后缀名为 “.tar.gz” 或 “.tar.bz2”；而 SRPM 源码包本质上属于 RPM 包，也就是源码的RPM包，其文件后缀为 “.src.rpm”。虽然都叫源码包，但不是一码事。</strong></em></p>
<p>Linux 系统中，绝大多数软件的源代码都是用 C 语言编写的，少部分用C++编写。因此要想安装源码包，必须安装 gcc 编译器。</p>
<p>除了安装编译器，还需要安装 make 编译命令。Linux编译源码包不像编译一个 hello.c 文件那样轻松，包中含大量的源码文件，且文件之间有着非常复杂的关联，直接决定着各文件编译的先后顺序，因此手动编译费时费力，而使用 make 命令可以完成对源码包的自动编译。</p>
<p><strong>源码包安装流程(以apache为例)：</strong></p>
<ol>
<li>
<p>下载源码包（tarball）。得到的源码包格式为压缩包（ “.tar.gz” 或 “.tar.bz2” ）。</p>
<blockquote>
<p>将各种文件分门别类保存在对应的目录中，应该成为合格 Linux 管理员约定俗成的习惯。Linux 系统中用于保存源代码的位置主要有 2 个，分别是 “/usr/src” 和 “/usr/local/src”， <font color='red'>其中 “/usr/src” 用来保存内核源代码，“/usr/local/src” 用来保存用户下载的源代码。</font></p>
</blockquote>
</li>
<li>
<p>将源码包进行解压缩，使用命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#tar</span> -zxvf httpd-<span class="number">2.2</span>.<span class="number">9</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>|more</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入解压目录，执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls </span><br><span class="line">anaconda-ks<span class="selector-class">.cfg</span> httpd-<span class="number">2.2</span>.<span class="number">9</span> httpd-<span class="number">2.2</span>.<span class="number">9</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span> install<span class="selector-class">.log</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd httpd-<span class="number">2.2</span>.<span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>./configure 软件配置与检查。这一步主要完成以下 3 项任务：</p>
<ul>
<li>
<p>检测系统环境是否符合安装要求。</p>
</li>
<li>
<p>定义需要的功能选项。通过 <code>./configure--prefix=安装路径</code> 可以指定安装路径。注意， <code>configure </code>不是系统命令，而是源码包软件自带的一个脚本程序 ，所以必须采用 <code>./configure</code> 方式执行。</p>
<p><code>./configure</code> 支持的功能选项较多，可执行 <code>./configure--help</code> 命令查询其支持的功能，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span>#./configure <span class="attr">--help</span>|more</span><br><span class="line">#查询apache支持的选项功能（不是必需步骤）</span><br></pre></td></tr></table></figure>
<p>把系统环境的检测结果和定义好的功能选项写入 Makefile 文件，因为后续的编译和安装需要依赖这个文件的内容。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># ./configure <span class="attr">--prefix</span>=/usr/local/apache2</span><br><span class="line">checking for chosen layout..<span class="selector-class">.Apache</span></span><br><span class="line">checking for working mkdir -<span class="selector-tag">p</span>…yes</span><br><span class="line">checking build system type..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">checking host system type..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">checking target system typa..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>–prefix 选项的含义为指定安装目录。</p>
<p>此命令没有加载其他功能，只是指定安装目录。需要说明的是，“/usr/local/apache2” 目录不需要手工建立，安装完成后会自动建立（这个目录是否生成也是检测软件是否正确安装的重要标志）。</p>
</li>
<li>
<p>make 编译。make 会调用 gcc 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make install</span><br></pre></td></tr></table></figure>
<p>注意，如果在 “./configure” 或 “make” 编译中报错，则在重新执行命令前一定要执行 <code>make clean</code> 命令，它会清空 Makefile 文件或编译产生的 “.o” 头文件。</p>
</li>
<li>
<p>卸载</p>
<p>源码包的卸载，只需要找到软件的安装位置，直接删除所在目录即可，不会遗留任何垃圾文件。执行如下命令即可：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /usr/local/apache2/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="font-color-gree-6-14-源码包升级与补丁-font"><font color='gree'>6.14 源码包升级与补丁</font></h3>
<p>Linux 系统中更新用源码包安装的软件，除了卸载重装外，还可以下载补丁文件更新源码包，用新的源码包重新编译安装软件。</p>
<blockquote>
<p>使用补丁文件更新源码包，省去了用 <code>./configured</code> 生成新的 Makefile 文件，还省去了大量的编译工作，因此效率更高。学完本节会对比有更深入的理解。</p>
</blockquote>
<p><strong>Linux补丁文件的生成和使用</strong></p>
<p>diff 命令基本格式为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># diff 选项 old new</span><br></pre></td></tr></table></figure>
<p>#比较old和new文件的不同</p>
<p>此命令中可使用如下几个选项：</p>
<ul>
<li>-a：将任何文档当作文本文档处理；</li>
<li>-b：忽略空格造成的不同；</li>
<li>-B：忽略空白行造成的不同；</li>
<li>-I：忽略大小写造成的不同；</li>
<li>-N：当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件；</li>
<li>-r：当比较目录时，递归比较子目录；</li>
<li>-u：使用同一输出格式；</li>
</ul>
<ol>
<li>
<pre><code class="language-css">[root@localhost test]# diff -Naur /root/test/old.txt  /root/test/new.txt  &gt; txt. patch
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```css</span><br><span class="line">   [root@localhost test]# patch -pn &lt; 补丁文件</span><br></pre></td></tr></table></figure>

&gt; -pn 选项中，n 为数字（例如 p1、p2、p3 等），pn 表示按照补丁文件中的路径，指定更新文件的位置。
&gt;
&gt; 这里对 -pn 选项的使用做一下额外说明。我们知道，补丁文件是要打入旧文件的，但是当前所在目录和补丁文件中记录的目录不一定是匹配的，需要 &quot;-pn&quot; 选项来同步两个目录。
&gt;
&gt; 例如，当前位于 &quot;/root/test/&quot; 目录下（要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为 &quot;/root/test/dd.txt&quot;，如果写入 &quot;-p1&quot;（在补丁文件目录中取消一级目录），那么补丁文件会打入 &quot;root/test/root/test/old.txt&quot; 文件中，这显然是不对的；如果写入的是 &quot;-p2&quot;（在补丁文件目录中取消二级目录），补丁文件会打入 &quot;/root/test/test/old.txt&quot; 文件中，这显然也不对。如果写入的是 &quot;-p3&quot;（在补丁文件目录中取消三级目录），补丁文件会打入 &quot;/root/test/old.txt&quot; 文件中，old.txt 文件就在这个目录下，所以应该用 &quot;-p3&quot; 选项。
&gt;
&gt; 如果当前所在目录是 &quot;/root/&quot; 目录呢？因为补丁文件中记录的文件目录为 &quot;/root/test/old.txt&quot;，所以这里就应该用 &quot;-p2&quot; 选项（代表取消两级目录），补丁打在当前目录下的 &quot;test/old.txt&quot; 文件上。
&gt;
&gt; 因此，-pn 选项可以这样理解， 即想要在补丁文件中所记录的目录中取消几个 &quot;/&quot; ，n 就是几。去掉目录的目的是和当前所在目录匹配。

</code></pre>
</li>
<li>
<pre><code class="language-css">[root@localhost test]# patch -p3 &lt; txt.patch
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &lt;font color=&#x27;red&#x27;&gt;打补丁需要注意：&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">   1. 给旧文件打补丁依赖的不是新文件，而是补丁文件，所以即使新文件被删除也没有关系。</span><br><span class="line">   2. 补丁文件中记录的目录和当前所在目录需要通过 &quot;-pn&quot; 选项实现同步，否则更新可能失败。</span><br><span class="line"></span><br><span class="line">4. 重新编译 apache 源码包，执行如下命令：</span><br><span class="line"></span><br><span class="line">   ```css</span><br><span class="line">   [root@localhost httpd-2.2.9]# make</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>安装 apache，执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="font-color-gree-6-15-Linux函数库（静态函数库和动态函数库-font"><font color='gree'>6.15  Linux函数库（静态函数库和动态函数库)</font></h3>
<p>Linux 系统中存在大量的函数库。函数库中的函数并不是以源代码的形式存在的，而是经过编译后生成的二进制文件，，只有链接到我们编写的程序中才可以运行。</p>
<p>Linux 系统中的函数库分为 2 种，分别是 静态函数库（简称静态库） 和 动态函数库 （也称为共享函数库，简称动态库或共享库），两者的主要区别在于，程序调用函数时，将函数整合到程序中的时机不同：</p>
<ul>
<li>静态函数库在程序编译时就会整合到程序中。这样做的好处是程序运行时不再需要调用外部函数库，可直接执行；缺点也很明显，所有内容都整合到程序中，编译文件会比较大，且一旦静态函数库改变，程序就需要重新编译。</li>
<li>动态函数库在程序运行时才被加载，程序中只保存对函数库的指向（程序编译仅对其做简单的引用）。使用动态函数库的好处是，程序生成的可执行程序体积比较小，且升级函数库时无需对整个程序重新编译；缺点是，如果程序执行时函数库出现问题，则程序将不能正确运行。</li>
</ul>
<blockquote>
<p>Linux 系统中，<font color='red'>静态函数库文件扩展名是 “.a”</font>，文件通常命令为 libxxx.a（xxx 为文件名）；<font color='red'>动态函数库扩展名为 “.so”</font>，文件通常命令为 libxxx.so.major.minor（xxx 为文件名，major 为主版本号，minor 为副版本号）。</p>
</blockquote>
<p>Linux <font color='orange'>系统中大多数都是动态函数库（主要考虑到软件的升级方便）</font>，其中被系统程序调用的函数库主要存放在 “/usr/lib” 和 “/lib” 中；Linux 内核所调用的函数库主要存放在 “/lib/modules” 中。</p>
<ul>
<li>
<p>安装函数库：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装 curses 函数库命令如下：</span><br><span class="line"><span class="selector-attr">[root@Linux ~]</span># yum install ncurses-devel</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看可执行程序调用了哪些函数库:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldd -v 可执行文件名</span><br></pre></td></tr></table></figure>
<p>-v 选项的含义是显示详细版本信息（非必须）</p>
</li>
<li>
<p>如果函数库安装后仍无法使用，这时就需要对函数库的配置文件进行手动调整，需进行如下操作：</p>
<ol>
<li>将函数库文件放入指定位置（通常放在 “/usr/lib” 或 “/lib” 中），然后把函数库所在目录写入 “/etc/ld.so.conf” 文件 。例如：</li>
</ol>
   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp  *<span class="selector-class">.so</span>  /usr/lib/</span><br><span class="line">\#把函数库复制到/usr/lib/目录中</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># vi /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span></span><br><span class="line">\#修改函数库配置文件</span><br><span class="line">include ld<span class="selector-class">.so</span><span class="selector-class">.conf</span><span class="selector-class">.d</span><span class="comment">/*.conf</span></span><br><span class="line"><span class="comment">/usr/lib</span></span><br><span class="line"><span class="comment">#写入函数库所在目录（其实/usr/lib/目录默认已经被识别）</span></span><br></pre></td></tr></table></figure>
<p>注意，这里写入的是函数库所在的目录，而不单单是函数库的文件名。另外，如果自己在其他目录中创建了函数库文件，这里也可以直接在 “/etc/ld.so.conf” 文件中写入函数库文件所在的完整目录。</p>
<ol start="2">
<li>
<p>使用 <code>ldconfig</code> 命令重新读取 /etc/ld.so.conf 文件，把新函数库读入缓存。命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldconfig</span><br><span class="line">#从/etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span>文件中把函数库读入缓存</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldconfig -<span class="selector-tag">p</span></span><br><span class="line">#列出系统缓存中所有识别的函数库</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="font-color-orange-7-用户和用户组管理-font"><font color='orange'>7. 用户和用户组管理</font></h2>
<h3 id="font-color-gree-7-1-UID和GID-font"><font color='gree'>7. 1 UID和GID</font></h3>
<p>Linux 并不认识你的用户名称，<font color='red'>它只认识用户名对应的 ID 号</font>。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 /etc/passwd 文件中。</p>
<p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（UID）和组 ID（GID），这与文件有拥有者和拥有群组两种属性相对应。</p>
<blockquote>
<p>既然 Linux 系统不认识用户名，文件是如何判别和显示它的拥有者名称和群组名称的呢？</p>
<p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 /etc/passwd 和 /etc/group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来。</p>
</blockquote>
<p>使用 root 账号登陆并 Vim /etc/passwd，在该文件中找到xuan账户并将其 UID 随意改一个数字，这时当你查看普通账户拥有的文件时，你会发现所有文件的拥有者不再是xuan，而是数字。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@livecd ~]</span><span class="selector-id">#grep</span> &#x27;xuan&#x27; /etc/passwd</span><br><span class="line">xuan:x:<span class="number">500</span>:<span class="number">500</span>:xuan:/home/centoslive:/bin/bash</span><br><span class="line">[root@livecd ~]#ll -d /home/centoslive</span><br><span class="line">drwx------. <span class="number">23</span> c.xuan centoslive <span class="number">4096</span> Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">37</span> /home/centoslive</span><br><span class="line">[root@livecd ~]#vim /etc.passwd</span><br><span class="line">#修改xuan账户中的UID（第一个 <span class="number">500</span>）为 <span class="number">2000</span></span><br><span class="line">[root@livecd ~]#ll -d /home/centoslive</span><br><span class="line">drwx------. <span class="number">23</span> <span class="number">500</span> centoslive <span class="number">4096</span> Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">37</span> /home/centoslive</span><br><span class="line">#可以看到，之前的 xuan 变为了 <span class="number">500</span>，因为修改了UID，导致 <span class="number">500</span> 找不到对应的账号，因此显示数字</span><br><span class="line">#记得最后将其再手动改正过来</span><br><span class="line">[root@livecd ~]#vim /etc.passwd</span><br><span class="line">#修改xuan账户中的UID从 <span class="number">2000</span> 改为 <span class="number">500</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-7-2-etc-passwd内容详解-font"><font color='gree'>7.2 /etc/passwd内容详解</font></h3>
<p>/etc/passwd目录中，绝大多数的<font color='gree'>系统用户</font>(伪用户)。<font color='red'>系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</font></p>
<p>每行用户信息都以 “：” 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**用户名：**用户名仅是为了方便用户记忆，Linux是通过 UID 来识别用户身份，分配用户权限的。/etc/passwd 文件中就定义了用户名和 UID 之间的对应关系。</p>
</li>
<li>
<p><strong>密码：</strong>“x” 表示此用户设有密码，但不是真正的密码，真正的密码保存在 /etc/shadow 文件中。</p>
</li>
<li>
<p><strong>UID:</strong> UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份.</p>
<table>
<thead>
<tr>
<th>UID 范围</th>
<th>用户身份</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了.</td>
</tr>
<tr>
<td>1~499</td>
<td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1~99 用于系统自行创建的账号；100~499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td>
</tr>
<tr>
<td>500~65535</td>
<td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 2^32^ 个 UID 了。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>**GID:**全称“Group ID”，表示用户初始组的组 ID 号。</p>
<ul>
<li>
<p>初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。</p>
</li>
<li>
<p>附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p>
</li>
</ul>
<p>举例来说，lamp 用户除属于初始组 lamp 外，又把它加入了 users 组，那么 lamp 用户同时属于 lamp 组和 users 组，其中 lamp 是初始组，users 是附加组。</p>
<blockquote>
<p>当然，初始组和附加组的身份是可以修改的，但是我们在工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u UID</td>
<td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td>
</tr>
<tr>
<td>-d 主目录</td>
<td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td>
</tr>
<tr>
<td>-c 用户说明</td>
<td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td>
</tr>
<tr>
<td>-g 组名</td>
<td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td>
</tr>
<tr>
<td>-G 组名</td>
<td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td>
</tr>
<tr>
<td>-s shell</td>
<td>手工指定用户的登录 Shell，默认是 /bin/bash；</td>
</tr>
<tr>
<td>-e 曰期</td>
<td>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</td>
</tr>
<tr>
<td>-o</td>
<td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td>
</tr>
<tr>
<td>-m</td>
<td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td>
</tr>
<tr>
<td>-r</td>
<td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td>
</tr>
</tbody>
</table>
<p>需要注意的是，<font color='red'>在 /etc/passwd 文件的第四个字段中看到的 ID 是这个用户的初始组。</font></p>
</blockquote>
</li>
<li>
<p>**描述性信息：**没有什么大用处</p>
</li>
<li>
<p>**默认shell：**通常情况下，Linux 系统默认使用的命令解释器是 bash（/bin/bash），当然还有其他命令解释器，例如 sh、csh 等。</p>
</li>
</ul>
<hr>
<h3 id="font-color-gree-7-3-etc-shadow文件-font"><font color='gree'>7.3 /etc/shadow文件</font></h3>
<p>/etc/shadow 文件，用于存储 Linux 系统中用户的密码信息.</p>
<p>/etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p>
<blockquote>
<p><font color='red'>注意，如果这个文件的权限发生了改变，则需要注意是否是恶意攻击。</font></p>
</blockquote>
<p>同 /etc/passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br><span class="line">root:$<span class="number">6</span>$jEbqPBcV$AgML24pnFYJZmc6kTNenqNT0w6.COYDcI6/yXjzuU0Hf2CNuqvxUW6trscC.zy69rAWaZcdVaabEHvp2R5/<span class="number">9</span>a.:<span class="number">19132</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**加密密码：**目前 Linux 的密码采用的是 SHA512 散列加密算法。所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的</p>
</li>
<li>
<p>**最后修改时间：**Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间。显示 15775 天则表示此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。</p>
<blockquote>
<p>可以使用如下命令进行换算：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># date -d &quot;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">15775</span> days&quot;</span><br><span class="line"><span class="number">2013</span>年<span class="number">03</span>月<span class="number">11</span>日 星期一 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>**最小修改密码时间间隔：**如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p>
</li>
<li>
<p>**密码有效期：**Linux用户密码需要经常更改才能最大限度地保证安全。管理服务器时，通过这个字段强制用户定期修改密码。</p>
</li>
<li>
<p>**密码过期后的宽限天数：**若此字段是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效</p>
</li>
<li>
<p>**密码变更前的警告天数：**该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p>
</li>
<li>
<p>**账号失效时间：**该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！该字段通常被使用在具有收费服务的系统中。</p>
</li>
<li>
<p>**保留：**待使用的字段</p>
</li>
</ul>
<hr>
<h3 id="font-color-gree-7-4-etc-group-font"><font color='gree'>7.4 /etc/group</font></h3>
<p>/ect/group 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。此文件是记录组 ID（GID）和组名相对应的文件。</p>
<p>各用户组中，还是以 “：” 作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组名：密码：GID：组用户</span><br><span class="line">root: x : <span class="number">0</span> :</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**组密码：**和 /etc/passwd 文件一样，这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 /etc/gshadow 文件中</p>
<blockquote>
<p>用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。</p>
</blockquote>
</li>
<li>
<p>**组ID：**Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。/etc/passwd 文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p>
</li>
<li>
<p>**组用户：**此字段列出每个群组包含的所有用户。<font color='red'>如果该用户组是这个用户的初始组，则该用户不会写入这个字段</font>，即：<font color='orange'>该字段显示的用户都是这个用户组的附加用户。</font></p>
<blockquote>
<p><font color='orange'>每个用户都可以加入多个附加组，但是只能属于一个初始组</font>。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让 lamp 也加入 root 这个群组，那么只需要在第一行的最后一个字段加入 lamp。</p>
<p>root 管理员使用 useradd 命令创建新用户时， 若未明确指定该命令所属的初始组，useradd 命令会默认创建一个同用户名相同的群组，作为该用户的初始组。</p>
</blockquote>
</li>
</ul>
<p>关系：先在 /etc/group 文件中查询用户组的 GID 和组名；然后在 /etc/passwd 文件中查找该 GID 是哪个用户的初始组，同时提取这个用户的用户名和 UID；最后通过 UID 到 /etc/shadow 文件中提取和这个用户相匹配的密码。</p>
<hr>
<h3 id="font-color-gree-7-5-etc-gshadow-font"><font color='gree'>7.5 /etc/gshadow</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root : : :</span><br><span class="line">组名：加密密码：组管理员：组附加用户列表</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**组密码：**对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为 “!”，指的是该群组没有组密码，也不设有群组管理员。</p>
</li>
<li>
<p>**组管理员：**从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。那么，什么是群组管理员呢？</p>
<blockquote>
<p>考虑到 Linux 系统中账号太多，而超级管理员 root 可能比较忙碌，因此当有用户想要加入某群组时，root 或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦 root 了。不过，由于有 sudo 之类的工具，因此此功能已经很少使用了。</p>
</blockquote>
</li>
<li>
<p>**附加用户：**该字段显示这个用户组中有哪些附加用户，和 /etc/group 文件中附加组显示内容相同。</p>
</li>
</ul>
<hr>
<h3 id="font-color-gree-7-6-etc-login-defs-font"><font color='gree'>7.6 /etc/login.defs</font></h3>
<p><strong>/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。</strong></p>
<p><font color='red'>需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。</font></p>
<p>使用 <code>vim /etc/login.defs</code> 命令查看该文件中的内容</p>
<table>
<thead>
<tr>
<th>MAIL_DIR /var/spool/mail</th>
<th><font color='red'>创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是 /var/spool/mail/lamp。</font></th>
</tr>
</thead>
<tbody>
<tr>
<td>PASS_MAX_DAYS 99999</td>
<td>密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。</td>
</tr>
<tr>
<td>PASS_MIN_DAYS 0</td>
<td>表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。</td>
</tr>
<tr>
<td>PASS_MIN_LEN 5</td>
<td>指定密码的最小长度，默认不小于 5 位，<font color='red'>但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。</font></td>
</tr>
<tr>
<td>PASS_WARN_AGE 7</td>
<td>指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。</td>
</tr>
<tr>
<td>UID_MIN 500</td>
<td>指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的 UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID 没有使用。</td>
</tr>
<tr>
<td>UID_MAX 60000</td>
<td>指定用户最大的 UID 为 60000。</td>
</tr>
<tr>
<td>GID_MIN 500</td>
<td>指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。</td>
</tr>
<tr>
<td>GID_MAX 60000</td>
<td>用户 GID 最大为 60000。</td>
</tr>
<tr>
<td>CREATE_HOME yes</td>
<td>指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。</td>
</tr>
<tr>
<td>UMASK 077</td>
<td>用户主目录的权限默认设置为 077。</td>
</tr>
<tr>
<td>USERGROUPS_ENAB yes</td>
<td>指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。</td>
</tr>
<tr>
<td>ENCRYPT_METHOD SHA512</td>
<td>指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="font-color-gree-7-7-useradd命令-font"><font color='gree'>7.7 useradd命令</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#useradd</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u UID</td>
<td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td>
</tr>
<tr>
<td>-d 主目录</td>
<td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td>
</tr>
<tr>
<td>-c 用户说明</td>
<td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td>
</tr>
<tr>
<td>-g 组名</td>
<td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td>
</tr>
<tr>
<td>-G 组名</td>
<td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td>
</tr>
<tr>
<td>-s shell</td>
<td>手工指定用户的登录 Shell，默认是 /bin/bash；</td>
</tr>
<tr>
<td>-e 曰期</td>
<td><font color='gree'>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</font></td>
</tr>
<tr>
<td>-o</td>
<td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td>
</tr>
<tr>
<td>-m</td>
<td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td>
</tr>
<tr>
<td>-r</td>
<td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td>
</tr>
</tbody>
</table>
<p><strong><font color='red'>创建用户lamp时进行的流程：</font></strong></p>
<ol>
<li>
<p>在 /etc/passwd 文件中创建一行与 lamp 用户相关的数据：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/passwd</span><br><span class="line">lamp:x:<span class="number">500</span>:<span class="number">500</span>::/home/lamp:/bin/bash</span><br></pre></td></tr></table></figure>
<p>可以看到，用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为 /home/lamp/，用户的登录 Shell 为 /bin/bash。</p>
</li>
<li>
<p>在 /etc/shadow 文件中新增了一行与 lamp 用户密码相关的数据：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/shadow</span><br><span class="line">lamp:!!:<span class="number">15710</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br></pre></td></tr></table></figure>
<p>当然，这个用户还没有设置密码，所以密码字段是 “!!”，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段，例如密码有效期有 99999 天，距离密码过期 7 天系统会提示用户“密码即将过期”等。</p>
</li>
<li>
<p>在 /etc/group 文件中创建一行与用户名一模一样的群组：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/group</span><br><span class="line">lamp:x:<span class="number">500</span>:</span><br></pre></td></tr></table></figure>
<p>该群组会作为新建用户的初始组。</p>
</li>
<li>
<p>在 /etc/gshadow 文件中新增一行与新增群组相关的密码信息：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/gshadow</span><br><span class="line">lamp:!::</span><br></pre></td></tr></table></figure>
<p>当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</p>
</li>
<li>
<p>默认创建用户的主目录和邮箱：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#ll</span> -d /home/lamp/</span><br><span class="line">drwx------ <span class="number">3</span> lamp lamp <span class="number">4096</span> <span class="number">1</span>月<span class="number">6</span> <span class="number">00</span>:<span class="number">19</span> /home/lamp/</span><br><span class="line">[root@localhost ~]#ll /var/spod/mail/lamp</span><br><span class="line">-rw-rw---- <span class="number">1</span> lamp mail <span class="number">0</span> <span class="number">1</span>月<span class="number">6</span> <span class="number">00</span>:<span class="number">19</span> /var/spool/mail/lamp</span><br></pre></td></tr></table></figure>
<p>注意这两个文件的权限，都要让 lamp 用户拥有相应的权限。</p>
</li>
<li>
<p>将 /etc/skel 目录中的配置文件复制到新用户的主目录中</p>
</li>
</ol>
<p><font color='orange'>useradd 命令在添加用户时参考的默认值文件主要有两个，分别是<code>/etc/default/useradd</code>和<code>/etc/login.defs</code>。</font></p>
<p>后者在上节已做说明，下面对前者进行说明：</p>
<p><code>/etc/default/useradd</code>中的内容：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GR0UP=100</td>
<td>这个选项用于建立用户的默认组，也就是说，在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组。<font color='red'>但 CentOS 并不是这样的，而是在添加用户时会自动建立和用户名相同的组作为此用户的初始组。也就是说这个选项并不会生效。</font>  Linux 中默认用户组有两种机制：<font color='orange'>一种是私有用户组机制，系统会创建一个和用户名相同的用户组作为用户的初始组；</font><font color='gree'>另一种是公共用户组机制，系统用 GID 是 100 的用户组作为所有新建用户的初始组</font>。目前我们采用的是私有用户组机制。</td>
</tr>
<tr>
<td>HOME=/home</td>
<td>指的是用户主目录的默认位置，所有新建用户的主目录默认都在 /home/下，刚刚新建的 lamp1 用户的主目录就为 /home/lamp1/。</td>
</tr>
<tr>
<td>INACTIVE=-1</td>
<td>指的是密码过期后的宽限天数，也就是 /etc/shadow 文件的第七个字段。<font color='pink'>这里默认值是 -1，代表所有新建立的用户密码永远不会失效。</font></td>
</tr>
<tr>
<td>EXPIRE=</td>
<td>表示密码失效时间，也就是 /etc/shadow 文件的第八个字段。默认值是空，代表所有新建用户没有失效时间，永久有效。</td>
</tr>
<tr>
<td>SHELL=/bin/bash</td>
<td>表示所有新建立的用户默认 Shell 都是 /bin/bash。</td>
</tr>
<tr>
<td>SKEL=/etc/skel</td>
<td>在创建一个新用户后，你会发现，该用户主目录并不是空目录，而是有 .bash_profile、.bashrc 等 隐藏 文件， 这些文件都是从 /etc/skel/ 目录中自动复制过来的。因此，更改 /etc/skel 目录下的内容就可以改变新建用户默认主目录中的配置文件信息。</td>
</tr>
<tr>
<td>CREATE_MAIL_SPOOL=yes</td>
<td>指的是给新建用户建立邮箱，默认是创建。也就是说，对于所有的新建用户，系统都会新建一个邮箱，放在 /var/spool/mail/ 目录下，和用户名相同。例如，lamp1 的邮箱位于 /var/spool/mail/lamp1。</td>
</tr>
</tbody>
</table>
<p>此文件中各选项值的修改方式有 2 种，一种是通过 Vim 文本编辑器手动修改，另一种是使用 useradd 命令。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -D <span class="selector-attr">[选项]</span> 参数</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项+参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b HOME</td>
<td>设置所创建的主目录所在的默认目录，只需用目录名替换 HOME 即可，例如 useradd -D -b /gargae。</td>
</tr>
<tr>
<td>-e EXPIRE</td>
<td>设置密码失效时间，EXPIRE 参数应使用 YYYY-MM-DD 格式，例如 useradd -D -e 2019-10-17。</td>
</tr>
<tr>
<td>-f INACTIVE</td>
<td>设置密码过期的宽限天数，例如 useradd -D -f 7。</td>
</tr>
<tr>
<td>-g GROUP</td>
<td>设置新用户所在的初始组，例如 useradd -D -g bear。</td>
</tr>
<tr>
<td>-s SHELL</td>
<td>设置新用户的默认 shell，SHELL 必须是完整路径，例如 useradd -D -s /usr/bin/csh。</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># useradd -D -s /bin/csh</span><br></pre></td></tr></table></figure>
<p><em><strong>useradd 命令创建用户的过程是这样的:系统首先读取 /etc/login.defs 和 /etc/default/useradd，根据这两个配置文件中定义的规则添加用户，也就是向 /etc/passwd、/etc/group、/etc/shadow、/etc/gshadow 文件中添加用户数据，接着系统会自动在 /etc/default/useradd 文件设定的目录下建立用户主目录，最后复制 /etc/skel 目录中的所有文件到此主目录中，由此，一个新的用户就创建完成了。</strong></em></p>
<hr>
<h3 id="font-color-gree-7-8-passwd命令-font"><font color='gree'>7.8 passwd命令</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#passwd</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-S：查询用户密码的状态，也就是 /etc/shadow 文件中此用户密码的内容。仅 root 用户可用；</li>
<li>-l：暂时锁定用户，<font color='red'>该选项会在 /etc/shadow 文件中指定用户的加密密码串前添加 “!”，使密码失效。仅 root 用户可用；</font></li>
<li>-u：解锁用户，和 -l 选项相对应，也是只能 root 用户使用；</li>
<li>–stdin：可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用；</li>
<li>-n 天数：设置该用户修改密码后，多长时间不能再次修改密码，也就是修改 /etc/shadow 文件中各行密码的第 4 个字段；</li>
<li>-x 天数：设置该用户的密码有效期，对应 /etc/shadow 文件中各行密码的第 5 个字段；</li>
<li>-w 天数：设置用户密码过期前的警告天数，对于 /etc/shadow 文件中各行密码的第 6 个字段；</li>
<li>-i 日期：设置用户密码失效日期，对应 /etc/shadow 文件中各行密码的第 7 个字段。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># passwd -l yuhan</span><br><span class="line">Locking password for user yuhan.</span><br><span class="line">passwd: Success</span><br><span class="line">[root@MyFirstVM ~]# grep <span class="string">&quot;yuhan&quot;</span> /etc/shadow</span><br><span class="line">yuhan:!!$<span class="number">6</span>$YV/txtAo$<span class="number">4</span>zJ8yJM/dhu9DG4FYT2lXewiKxYdGIE5sis4hIJoevAy7XRxZ0dlnXPTFb3ov1ewwnYuAhCS60Nk1:<span class="number">19140</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">9</span>:::</span><br><span class="line">#!!说明密码已经被锁定，无法登入</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#调用管道符，给 lamp 用户设置密码 &quot;<span class="number">123</span>&quot;</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo &quot;<span class="number">123</span>&quot; | passwd <span class="attr">--stdin</span> lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<p>使用此方式批量给用户设置初始密码，方便快捷，<font color='red'>但需要注意的是，这样设定的密码会把密码明文保存在历史命令中，如果系统被攻破，别人可以在 /root/.bash_history 中找到设置密码的这个命令，存在安全隐患。</font></p>
<hr>
<h3 id="font-color-gree-7-9-usermod命令-font"><font color='gree'>7.9 usermod命令</font></h3>
<p>修改用户的信息，办法有两个，一个是使用 Vim 文本编辑器手动修改涉及用户信息的相关文件（/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow），另一个方法就是使用本节介绍了 usermod 命令，该命令专门用于修改用户信息。</p>
<p>这里一定要分清 useradd 命令和 usermod 命令的区别，前者用于添加用户。</p>
<p>usermod 命令的基本格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#usermod</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 用户说明：修改用户的说明信息，即修改 /etc/passwd 文件目标用户信息的第 5 个字段；</li>
<li>-d 主目录：修改用户的主目录，即修改 /etc/passwd 文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径；</li>
<li>-e 日期：修改用户的失效曰期，格式为 “YYYY-MM-DD”，即修改 /etc/shadow 文件目标用户密码信息的第 8 个字段；</li>
<li>-g 组名：修改用户的初始组，即修改 /etc/passwd 文件目标用户信息的第 4 个字段（GID）；</li>
<li>-u UID：修改用户的UID，即修改 /etc/passwd 文件目标用户信息的第 3 个字段（UID）；</li>
<li>-G 组名：修改用户的附加组，其实就是把用户加入其他用户组，即修改 /etc/group 文件；</li>
<li>-l 用户名：修改用户名称；</li>
<li>-L：临时锁定用户（Lock）；</li>
<li>-U：解锁用户（Unlock），和 -L 对应；</li>
<li>-s shell：修改用户的登录 Shell，默认是 /bin/bash。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># usermod -G root lamp</span><br><span class="line">#把用户加入root组</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-7-10-chage命令-font"><font color='gree'>7.10 chage命令</font></h3>
<p>chage 命令可以显示更加详细的用户密码信息，并且和 passwd 命令一样，提供了修改用户密码信息的功能。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chage</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure>
<ul>
<li>-l：列出用户的详细密码状态;</li>
<li>-d 日期：修改 /etc/shadow 文件中指定用户密码信息的第 3 个字段，也就是最后一次修改密码的日期，格式为 YYYY-MM-DD；</li>
<li>-m 天数：修改密码最短保留的天数，也就是 /etc/shadow 文件中的第 4 个字段；</li>
<li>-M 天数：修改密码的有效期，也就是 /etc/shadow 文件中的第 5 个字段；</li>
<li>-W 天数：修改密码到期前的警告天数，也就是 /etc/shadow 文件中的第 6 个字段；</li>
<li>-i 天数：修改密码过期后的宽限天数，也就是 /etc/shadow 文件中的第 7 个字段；</li>
<li>-E 日期：修改账号失效日期，格式为 YYYY-MM-DD，也就是 /etc/shadow 文件中的第 8 个字段。</li>
</ul>
<p><font color='red'> chage 命令除了修改密码信息的功能外，还可以强制用户在第一次登录后，必须先修改密码，并利用新密码重新登陆系统，此用户才能正常使用。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建新用户 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#useradd</span> lamp</span><br><span class="line">#设置用户初始密码为 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#echo</span> &quot;lamp&quot; | passwd <span class="attr">--stdin</span> lamp</span><br><span class="line">#通过chage命令设置此账号密码创建的日期为 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日（<span class="number">0</span> 就表示这一天），这样用户登陆后就必须修改密码</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chage</span> -d <span class="number">0</span> lamp</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-7-11-userdel命令-font"><font color='gree'>7.11 userdel命令</font></h3>
<p>userdel 用来删除用户的相关数据。<font color='orange'>此命令只有 root 用户才能使用。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># userdel -r 用户名</span><br><span class="line">-r 选项表示在删除用户的同时删除用户的家目录。</span><br></pre></td></tr></table></figure>
<p><font color='red'>注意，在删除用户的同时如果不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。但一般而言，删除用户时不会直接删除其家目录，因为其家目录中可能存在重要数据！</font></p>
<p>删除用户可以很方便地用userdel，也可以删除之前叙述的相关文件中的相关信息来彻底删除某个用户。</p>
<ul>
<li>/etc/passwd</li>
<li>/etc/shadow</li>
<li>/etc/group</li>
<li>/etc/gshadow</li>
<li>/var/spool/mail/username</li>
<li>/home/username</li>
</ul>
<hr>
<h3 id="font-color-gree-7-12-id命令-font"><font color='gree'>7.12 id命令</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id 命令可以查询用户的UID、GID 和附加组的信息。命令比较简单，格式如下：</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># id 用户名</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1007</span>(shanbi)</span><br><span class="line"><span class="selector-id">#yuhan</span>的初始组为root，附加组为root和shanbi</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># usermod -G sonofhan  yuhan</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1007</span>(shanbi),<span class="number">1013</span>(sonofhan)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-7-13-临时切换用户-su-font"><font color='gree'>7.13 临时切换用户 su</font></h3>
<blockquote>
<p>普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># su <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-：当前用户不仅切换为指定用户的身份，<font color='orange'>同时所用的工作环境也切换为此用户的环境（包括 PATH 变量、MAIL 变量等）</font>，使用 - 选项可省略用户名，默认会切换为 root 用户。</li>
<li>-l：同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。</li>
<li>-p：表示切换为指定用户的身份，<font color='red'>但不改变当前的工作环境（不使用切换用户的配置文件）。</font></li>
<li>-m：和 -p 一样；</li>
<li>-c 命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</li>
</ul>
<p><font color='red'>注意，su 和 -su有很大区别！</font></p>
<blockquote>
<p>举个例子，普通用户 lamp 通过 su 命令切换成 root 用户，但没有使用 - 选项，这样情况下，虽然看似是 root 用户，但系统中的 PATH 环境变量依然是 lamp 的（而不是 root 的），因此当前工作环境中，并不包含 /sbin、/usr/sbin等超级用户命令的保存路径，这就导致很多管理员命令根本无法使用。不仅如此，当 root 用户接受邮件时，会发现收到的是 lamp 用户的邮件，因为环境变量 $MAIL 也没有切换。</p>
</blockquote>
<hr>
<h3 id="font-color-gree-7-14-whoami-和who-am-i-font"><font color='gree'>7.14 whoami 和who am i</font></h3>
<p>whoami 命令和 who am i 命令是不同的 2 个命令，<font color='orange'>前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># whoami</span><br><span class="line">root</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># who am <span class="selector-tag">i</span></span><br><span class="line">root     pts/<span class="number">2</span>        <span class="number">2022</span>-<span class="number">05</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span> (<span class="number">192.168</span>.<span class="number">232.1</span>)</span><br><span class="line">[root@MyFirstVM ~]# su yuhan</span><br><span class="line">[yuhan@MyFirstVM root]$ whoami</span><br><span class="line">yuhan</span><br><span class="line">[yuhan@MyFirstVM root]$ who am i</span><br><span class="line">root     pts/<span class="number">2</span>        <span class="number">2022</span>-<span class="number">05</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span> (<span class="number">192.168</span>.<span class="number">232.1</span>)</span><br></pre></td></tr></table></figure>
<p>也就是说，使用 su 或者 sudo 命令切换用户身份，骗得过 whoami，但骗不过 who am i。要解释这背后的运行机制，需要搞清楚什么是<code>实际用户（UID）</code>和<code>有效用户（EUID)</code>(即 Effective UID）。</p>
<p>所谓实际用户，指的是登陆 Linux 系统时所使用的用户，因此在整个登陆会话过程中，实际用户是不会发生变化的；而有效用户，指的是当前执行操作的用户，也就是说真正决定权限高低的用户，这个是能够利用 su 或者 sudo 命令进行任意切换的。</p>
<hr>
<h3 id="font-color-gree-7-15-groupadd命令-font"><font color='gree'>7.15 groupadd命令</font></h3>
<p>添加用户组的命令是 groupadd，命令格式如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd <span class="selector-attr">[选项]</span> 组名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-g GID：指定组 ID；</li>
<li>-r：创建系统群组。<br>
使用 groupadd 命令创建新群组非常简单，例如：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group1</span><br><span class="line">\#添加group1组</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;group1&quot; /etc/group</span><br><span class="line">/etc/group:group1:x:<span class="number">502</span>:</span><br><span class="line">/etc/gshadow:group1:!::</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-7-16-groupmod命令-font"><font color='gree'>7.16 groupmod命令</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupmod <span class="selector-attr">[选现]</span> 组名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-g GID：修改组 ID；</li>
<li>-n 新组名：修改组名；</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupmod -n testgrp group1</span><br><span class="line">#把组名group1修改为testgrp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;testgrp&quot; /etc/group</span><br><span class="line">testgrp:x:<span class="number">502</span>:</span><br><span class="line">#注意GID还是<span class="number">502</span>，但是组名已经改变</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</p>
</blockquote>
<hr>
<h3 id="font-color-gree-7-17-groupdel命令-font"><font color='gree'>7.17 groupdel命令</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#groupdel</span> 组名</span><br></pre></td></tr></table></figure>
<p>使用 groupdel 命令删除群组，其实就是删除 /etc/gourp 文件和 /etc/gshadow 文件中有关目标群组的数据信息。</p>
<p><font color='red'>注意，不能使用 groupdel 命令随意删除群组。此命令仅适用于删除那些 “不是任何用户初始组” 的群组，</font>换句话说，如果有群组还是某用户的初始群组，则无法使用 groupdel 命令成功删除。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># useradd temp</span><br><span class="line">#运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 <span class="number">505</span>）</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;temp&quot; /etc/passwd /etc/group /etc/gshadow</span><br><span class="line">/etc/passwd:temp:x:<span class="number">505</span>:<span class="number">505</span>::/home/temp:/bin/bash</span><br><span class="line">/etc/group:temp:x:<span class="number">505</span>:</span><br><span class="line">/etc/gshadow:temp:!::</span><br><span class="line">#下面尝试删除 temp 群组</span><br><span class="line">[root@localhost ~]# groupdel temp</span><br><span class="line">groupdel:cannot remove the primary group of user <span class="string">&#x27;temp&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，groupdel 命令删除 temp 群组失败，且提示“不能删除 temp 用户的初始组”。如果一定要删除 temp 群组，要么修改 temp 用户的 GID，也就是将其初始组改为其他群组，要么先删除 temp 用户。</p>
</blockquote>
<p>胡乱地删除群组可能会给其他用户造成不小的麻烦，因此更改文件数据要格外慎重。</p>
<hr>
<h3 id="font-color-gree-7-18-gpasswd命令-font"><font color='gree'>7.18 gpasswd命令</font></h3>
<p>为了避免系统管理员（root）太忙碌，无法及时管理群组，可以使用 <code>gpasswd</code> 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。</p>
<p>gpasswd 命令的基本格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gpasswd 选项 组名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>选项为空时，表示给群组设置密码，仅 root 用户可用。</td>
</tr>
<tr>
<td>-A user1,…</td>
<td>将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员，仅 root 用户可用。</td>
</tr>
<tr>
<td>-M user1,…</td>
<td>将 user1,… 加入到此群组中，仅 root 用户可用。</td>
</tr>
<tr>
<td>-r</td>
<td>移除群组的密码，仅 root 用户可用。</td>
</tr>
<tr>
<td>-R</td>
<td>让群组的密码失效，仅 root 用户可用。</td>
</tr>
<tr>
<td>-a user</td>
<td>将 user 用户加入到群组中。</td>
</tr>
<tr>
<td>-d user</td>
<td>将 user 用户从群组中移除。</td>
</tr>
</tbody>
</table>
<p><font color='red'>非本用户组的用户想切换到本用户组身份时，可以通过密码保证安全性。如果没有设置组密码，则只有属于本用户组的用户能够切换到本用户组的身份。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建新群组 group1，并将群组交给 lamp 管理</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group1  &lt;-- 创建群组</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># gpasswd group1   &lt;-- 设置密码</span><br><span class="line">Changing the password for group group1</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">[root@localhost ~]# gpasswd -A lamp group1  &lt;加入群组管理员为 lamp</span><br><span class="line">[root@localhost ~]# grep <span class="string">&quot;group1&quot;</span> /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:<span class="number">506</span>:</span><br><span class="line">/etc/gshadow:group1:$<span class="number">1</span>$I5ukIY1.$o5fmW.cOsc8.K.FHAFLWg0:lamp:</span><br></pre></td></tr></table></figure>
<p><font color='red'>使用 <code>usermod -G</code> 命令也可以将用户加入群组，但会产生一个问题，即使用此命令将用户加入到新的群组后，该用户之前加入的那些群组都将移除该用户。例如：</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#新创建一个群组group2</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group2</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># usermod -G group2 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;group2&quot; /etc/group</span><br><span class="line">group2:x:<span class="number">509</span>:lamp</span><br><span class="line">[root@localhost ~]# grep <span class="string">&quot;group1&quot;</span> /etc/group</span><br><span class="line">group1:x:<span class="number">506</span>:lamp1</span><br></pre></td></tr></table></figure>
<p>可以发现，虽然使用 usermod 命令成功地将 lamp 用户加入在 group2 群组中，但 lamp 用户原本在 group1 群组中，此时却被移出，这就是使用 usermod 命令造成的。因此，将用户加入或移出群组，最好使用 gpasswd 命令。</p>
<hr>
<h3 id="font-color-gree-7-19-newgrp命令-font"><font color='gree'>7.19 newgrp命令</font></h3>
<p>每个用户可以属于一个初始组，也可以属于多个附加组。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？</p>
<p><font color='red'>当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份</font>。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。</p>
<p>命令<code>newgrp</code>能改变用户的初始组。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># newgrp 组名</span><br></pre></td></tr></table></figure>
<p>使用 newgrp 命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是 newgrp 所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[yuhan@MyFirstVM tmp]</span>$ touch fuckme</span><br><span class="line"><span class="selector-attr">[yuhan@MyFirstVM tmp]</span>$ ll fuckme</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> yuhan root <span class="number">0</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">11</span> fuckme</span><br><span class="line">[yuhan@MyFirstVM tmp]$ id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1013</span>(sonofhan),<span class="number">1007</span>(shanbi)</span><br><span class="line">[yuhan@MyFirstVM tmp]$ newgrp shanbi</span><br><span class="line">[yuhan@MyFirstVM tmp]$ touch shitbro</span><br><span class="line">[yuhan@MyFirstVM tmp]$ ll shitbro</span><br><span class="line">-rw-r--r--. <span class="number">1</span> yuhan shanbi <span class="number">0</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">12</span> shitbro</span><br><span class="line">[yuhan@MyFirstVM tmp]$ id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1013</span>(sonofhan),<span class="number">1007</span>(shanbi)</span><br></pre></td></tr></table></figure>
<p><font color='red'>注意，<code>newgrp</code>不会真正改变初始组，只是在执行命令(如创建文件)时以new group的身份创建，从上面代码就可以看出。</font>1</p>
<p><font color='orange'>newgrp的原理：其实，newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。</font></p>
<p>通过添加 shell 内置命令 <code>echo $$</code> 就可以发现，每次使用 <code>newgrp</code> 命令，都会切换到一个新的进程。如果你想回到原本的环境，需要通过 <code>exit</code> 命令不断回退到当前进程的父进程，最终才能回到初始组为 group1 时的 user1 运行的 shell 中。</p>
<hr>
<h2 id="font-color-orange-8-Linux权限管理-font"><font color='orange'>8. Linux权限管理</font></h2>
<h3 id="font-color-gree-8-1-chgrp命令-font"><font color='gree'>8.1 chgrp命令</font></h3>
<p>chgrp 命令用于修改文件（或目录）的所属组。</p>
<p>基本格式为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chgrp -R 所属组 文件名（目录名）</span><br></pre></td></tr></table></figure>
<p>-R（注意是大写）选项表示更改连同子目录中所有文件的所属组信息。</p>
<hr>
<h3 id="font-color-gree-8-2-chown命令-font"><font color='gree'>8.2 chown命令</font></h3>
<p><code>chown</code> 命令主要用于修改文件（或目录）的所有者，也可以修改文件（或目录）的所属组。</p>
<p>当只需要修改所有者时，可使用如下 chown 命令的基本格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chown -R 所有者 文件或目录</span><br><span class="line"><span class="selector-id">#-R</span>（注意大写）选项表示连同子目录中的所有文件，都更改所有者。</span><br></pre></td></tr></table></figure>
<p>如果需要同时更改所有者和所属组，chown 命令的基本格式为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chown -R 所有者:所属组 文件或目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>chown 命令也支持单纯的修改文件或目录的所属组，例如 <code>chown :group install.log</code> 就表示修改 install.log 文件的所属组，但修改所属组通常使用 chgrp 命令，因此并不推荐大家使用 chown 命令。</p>
</blockquote>
<p><strong>通过修改文件的所有者，用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</strong></p>
<hr>
<h3 id="font-color-gree-8-3-Linux权限位-font"><font color='gree'>8.3 Linux权限位</font></h3>
<p>Linux常见的文件权限有 3 种，即对文件的读（r）、写（w）和执行（x，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 ll 命令即可看到。</p>
<blockquote>
<p>除此之外，<font color='red'>s（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）和 t（针对目录，任何用户都可以在此目录中创建文件，但只能删除自己的文件）</font>，文件设置 s 和 t 权限，会占用 x 权限的位置。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll readme</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> shanbi shanbi <span class="number">5</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">47</span> readme</span><br><span class="line">    </span><br><span class="line">[root@MyFirstVM tmp]# ll /bin/ls</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">117681</span> May <span class="number">26</span> <span class="number">11</span>:<span class="number">39</span> /bin/ls</span><br></pre></td></tr></table></figure>
<p>每行的第一大列表示的就是各文件针对不同用户设定的权限，一共  11 位 ，<strong>但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理</strong></p>
<p>因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符。</p>
<p>各权限位的含义如图：</p>
<p><img src="/2022/img/20220610214832.gif" alt="文件权限位"></p>
<p><font color='red'>Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。</font></p>
<p>从此图可看出，文件所有者拥有对文件的读和写权限，但是没有执行权限(对可执行文件才有执行权限)；所属群组中的用户只拥有读权限，也就是说，这部分用户只能读取文件内容，无法修改文件；其他人也是只能读取文件。</p>
<p><strong>rwx对文件的作用：</strong></p>
<table>
<thead>
<tr>
<th>rwx 权限</th>
<th>对文件的作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。</td>
</tr>
<tr>
<td>w</td>
<td>表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。</td>
</tr>
<tr>
<td>x</td>
<td>表示该文件具有被系统执行的权限。在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。</td>
</tr>
</tbody>
</table>
<p><font color='gree'>对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。</font></p>
<p><font color='cornflowerbl'>对目录来说，如果只赋予 r 权限，则此目录是无法使用的。只有 r 权限的目录，用户只能查看目录结构(查看目录中有什么文件)，无法进入目录（需要用 x 权限），更不用说使用了。</font>如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll -d /tmp</span><br><span class="line">drwxrwxrwt. <span class="number">10</span> root root <span class="number">4096</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">47</span> /tmp</span><br></pre></td></tr></table></figure>
<p>因此，对于目录来说，常用来设定目录的权限其实只有 0（—）、5（r-x）、7（rwx）这 3 种。</p>
<h3 id="font-color-gree-8-4-修改文件或目录权限（chmod）-font"><font color='gree'>8.4 修改文件或目录权限（chmod）</font></h3>
<p>chmod 命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。</p>
<p><strong>使用数字修改权限：</strong></p>
<p>各个权限与数字的对应关系如下：</p>
<p><font color='red'>r --&gt; 4   w --&gt; 2    x --&gt; 1</font></p>
<p>由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），<strong>通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</strong></p>
<blockquote>
<p>以 <code>rwxrw-r-x</code> 为例，所有者、所属组和其他人分别对应的权限值为：</p>
<p>所有者 = rwx = 4+2+1 = 7<br>
所属组 = rw- = 4+2 = 6<br>
其他人 = r-x = 4+1 = 5</p>
<p><font color='red'>所以，此权限对应的权限值就是 765。</font></p>
</blockquote>
<p>使用数字修改文件权限的 chmod 命令基本格式为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod -R 权限值 文件名</span><br></pre></td></tr></table></figure>
<p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p>
<p>例如，使用如下命令，即可完成对 .bashrc 目录文件的权限修改：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod <span class="number">777</span> <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rwxrwxrwx. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br></pre></td></tr></table></figure>
<p><strong>使用字母修改权限：</strong></p>
<p><font color='red'>chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）</font>。chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p>
<p>格式：</p>
<p><img src="/2022/img/20220610214841.gif" alt="chmod 命令基本格式"></p>
<p>如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u=rwx,go=rx <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-5-默认权限（umask）-font"><font color='gree'>8.5 默认权限（umask）</font></h3>
<p>Windows 中，新建的文件和目录时通过继承上级目录的权限获得的初始权限，而Linux是通过使用 <code>umask</code> 默认权限来给所有新建的文件和目录赋予初始权限的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0022</span></span><br></pre></td></tr></table></figure>
<p><em><strong><font color='red'>root用户默认是0022，普通用户默认是 0002</font></strong></em></p>
<p><font color='red'> umask 默认权限确实由 4 个八进制数组成，但第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）。也就是说，后 3 位数字 “022” 才是真正要用到的 umask 权限值，将其转变为字母形式为 — -w- -w-。</font></p>
<p><strong>虽然 umask 默认权限是用来设定文件或目录的初始权限，但并不是直接将 umask 默认权限作为文件或目录的初始权限，还要对其进行 “再加工”。</strong></p>
<p>文件和目录的真正初始权限，可通过以下的计算得到：</p>
<p><code>文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</code></p>
<blockquote>
<p><font color='orange'>按照官方的标准算法，需要将 umask 默认权限使用二进制并经过逻辑与和逻辑非运算后，才能得到最终文件或目录的初始权限，计算过程比较复杂，且容易出错，用上面的计算更方便</font></p>
<p>以二进制方式换算：</p>
<p>先将最大默认权限（目录777，文件666）和umask值都转换为2进制，然后对umask取反，再将两个二进制值做与运算，得到的二进制值再转换十进制，即为权限，</p>
</blockquote>
<p><strong>最大默认权限：</strong></p>
<p>在 Linux 系统中，文件和目录的最大默认权限是不一样的：</p>
<ul>
<li><font color='orange'>对文件来讲，其可拥有的最大默认权限是 666</font>，即 rw-rw-rw-。也就是说，使用文件的任何用户都没有执行（x）权限。原因很简单，<font color='red'>执行权限是文件的最高权限</font>，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。</li>
<li><font color='orange'>对目录来讲，其可拥有的最大默认权限是 777</font>，即 rwxrwxrwx。</li>
</ul>
<p>以 umask 值为 022 为例，分别计算新建文件和目录的初始权限：</p>
<ul>
<li>
<p><font color='red'>文件的最大默认权限是 666</font>，<font color='orange'>换算成字母</font>就是 “-rw-rw-rw-”，umask 的值是 022，换算成字母为 “-----w–w-”。把两个字母权限相减，得到 (-rw-rw-rw-) - (-----w–w-) = (-rw-r–r–)，这就是新建文件的初始权限。我们测试一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0022</span></span><br><span class="line">\#默认umask的值是<span class="number">0022</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch file &lt;--新建file空文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -d file</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">0</span> Apr <span class="number">18</span> <span class="number">02</span>:<span class="number">36</span> file</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><font color='red'>目录的默认权限最大可以是 777</font>，<font color='orange'>换算成字母</font>就是 “drwxrwxrwx”，umask 的值是 022，也就是 “-----w–w-”。把两个字母权限相减，得到的就是新建目录的默认权限，即 (drwxrwxrwx) - (-----w–w-) = (drwxr-xr-x)。我们再来测试一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line">  <span class="number">0022</span></span><br><span class="line">  <span class="selector-attr">[root@localhost ~]</span># mkdir catalog &lt;--新建catalog目录</span><br><span class="line">  <span class="selector-attr">[root@localhost ~]</span># ll -d catalog</span><br><span class="line">  drwxr-xr-x. <span class="number">2</span> root root <span class="number">4096</span> Apr <span class="number">18</span> <span class="number">02</span>:<span class="number">36</span> catalog</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em><strong><font color='red'>注意！必须要换算成字母再相减！！</font></strong></em></p>
<blockquote>
<p>例如，若 umask 默认权限的值为 033，按照数字形式计算文件的初始权限，666-033=633，但我们按照字母的形式计算会得到 （rw-rw-rw-) - (----wx-wx) = (rw-r–r–)，换算成数字形式是 644。</p>
</blockquote>
<blockquote>
<p>这里的减法，其实是“遮盖”的意思，也就是说，最大默认权限中和 umask 权限公共的部分，通过减法运算会被遮盖掉，最终剩下的“最大默认权限”，才是最终赋予文件或目录的初始权限。</p>
</blockquote>
<p><strong>修改umask：</strong></p>
<p>可以通过如下命令直接修改：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask <span class="number">002</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0002</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask <span class="number">033</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0033</span></span><br></pre></td></tr></table></figure>
<p>不过，这种方式只是临时有效，一旦重启或重新登陆系统，就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件 /etc/profile。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># vim /etc/profile</span><br><span class="line">...省略部分内容...</span><br><span class="line">if <span class="selector-attr">[ $UID -gt 199]</span>&amp;&amp;<span class="selector-attr">[ <span class="string">&quot;&#x27;id -gn&#x27;&quot;</span> = <span class="string">&quot;&#x27;id -un&#x27;&quot;</span> ]</span>; then</span><br><span class="line">  umask <span class="number">002</span></span><br><span class="line">  \#如果UID大于<span class="number">199</span>（普通用户），则使用此umask值</span><br><span class="line">else</span><br><span class="line">  umask <span class="number">022</span></span><br><span class="line">  \#如果UID小于<span class="number">199</span>（超级用户），则使用此umask值</span><br><span class="line">fi</span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-6-ACL权限-font"><font color='gree'>8.6 ACL权限</font></h3>
<p><strong><font color='red'>ACL，是 Access Control List（访问控制列表）的缩写，在 Linux 系统中， ACL 可实现对单一用户设定访问文件的权限。</font></strong></p>
<blockquote>
<p>若有一个 /project 目录，这是班级的项目目录。班级中的每个学员都可以访问和修改这个目录，老师需要拥有对该目录的最高权限，其他班级的学员当然不能访问这个目录。</p>
<p>可如此划分权限：老师使用 root 用户，作为这个目录的属主，权限为 rwx；班级所有的学员都加入 tgroup 组，使 tgroup 组作为 /project 目录的属组，权限是 rwx；其他人的权限设定为 0（也就是 —）。</p>
<p>有一天，班里来了一位试听的学员 st，她必须能够访问 /project 目录，所以必须对这个目录拥有 r 和 x 权限；但是她又没有学习过以前的课程，所以不能赋予她 w 权限，怕她改错了目录中的内容，所以学员 st 的权限就是 r-x。可是如何分配她的身份呢？变为属主？当然不行，要不 root 该放哪里？加入 tgroup 组？也不行，因为 tgroup 组的权限是 rwx，而我们要求学员 st 的权限是 r-x。如果把其他人的权限改为 r-x 呢？这样一来，其他班级的所有学员都可以访问 /project 目录了。</p>
<p>显然，普通权限的三种身份不够用了，无法实现对某个单独的用户设定访问权限，这种情况下，就需要使用 ACL 访问控制权限。</p>
</blockquote>
<p><strong>开启ACL权限：</strong></p>
<p>CentOS 6.x 系统中，ACL 权限默认处于开启状态，无需手工开启。但如果你的操作系统不是 CentOS 6.x，可以通过如下方式查看ACL权限是否开启：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># mount</span><br><span class="line">/dev/sda1 on /boot type ext4 (rw)</span><br><span class="line">/dev/sda3 on <span class="selector-tag">I</span> type ext4 (rw)</span><br><span class="line">…省略部分输出…</span><br><span class="line">\<span class="selector-id">#dumpe2fs</span>是查询指定分区文件系统详细信息的命令</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># dumpe2fs -h /dev/sda3</span><br><span class="line">…省略部分输出…</span><br><span class="line">Default mount options: user_xattr acl</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>可以看到，ACL 权限是 /dev/sda3 分区的默认挂载选项，所以不需要手工挂载。</p>
<p>如果 Linux 系统如果没有默认挂载，可以执行如下命令实现手动挂载：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mount -o remount,acl /</span><br><span class="line">\#重新挂载根分区，并加入ACL权限</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-7-设定ACL权限-font"><font color='gree'>8.7 设定ACL权限</font></h3>
<p>设定 ACl 权限，常用命令有 2 个，分别是 <code>setfacl</code> 和 <code>getfacl</code> 命令，前者用于给指定文件或目录设定 ACL 权限，后者用于查看是否配置成功。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># getfacl 文件名</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># setfacl 选项 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-m</td>
<td>设定 ACL 权限。如果是给予用户 ACL 权限，参数则使用 <code>u:用户名:权限</code> 的格式，例如 <code>setfacl -m u:st:rx /project</code> 表示设定 st 用户对 project 目录具有 rx 权限；如果是给予组 ACL 权限，参数则使用 “g:组名:权限” 格式，例如 <code>setfacl -m g:tgroup:rx /project</code> 表示设定群组 tgroup 对 project 目录具有 rx 权限；<code>setfacl -m m:rx /project</code>表示设定mask值为r-x</td>
</tr>
<tr>
<td>-x</td>
<td>删除指定用户（参数使用 <code>u:用户名</code>）或群组（参数使用 <code>g:群组名</code>）的 ACL 权限，例如 <code>setfacl -x u:st /project</code> 表示删除 st 用户对 project 目录的 ACL 权限。</td>
</tr>
<tr>
<td>-b</td>
<td>删除所有的 ACL 权限，例如 <code>setfacl -b /project</code> 表示删除有关 project 目录的所有 ACL 权限。</td>
</tr>
<tr>
<td>-d</td>
<td>设定默认 ACL 权限，命令格式为 “<code>setfacl -m d:u:用户名:权限 文件名</code>”（如果是群组，则使用 <code>d:g:群组名:权限</code>），只对目录生效，指目录中新建立的文件拥有此默认权限，例如 <code>setfacl -m d:u:st:rx /project</code> 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。</td>
</tr>
<tr>
<td>-R</td>
<td>递归设定 ACL 权限，指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 “<code>setfacl -m u:用户名:权限 -R 文件名</code>”（群组使用 g:群组名:权限），例如 <code>setfacl -m u:st:rx -R /project</code> 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。</td>
</tr>
<tr>
<td>-k</td>
<td>删除默认 ACL 权限。</td>
</tr>
</tbody>
</table>
<p>给用户组设置ACL权限：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># touch textbook</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll textbook</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">15</span>:<span class="number">55</span> textbook</span><br><span class="line">[root@MyFirstVM tmp]# setfacl -m g:myson:rwx /tmp/textbook</span><br><span class="line">[root@MyFirstVM tmp]# ll textbook</span><br><span class="line">-rw-rwxr--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">15</span>:<span class="number">55</span> textbook</span><br><span class="line">#查询时会发现，在权限位后面多了一个<span class="string">&quot;+&quot;</span>，表示此目录拥有ACL权限</span><br></pre></td></tr></table></figure>
<p>给用户设置ACL权限：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m u:myson:r-x /tmp/textbook</span><br><span class="line">[root@MyFirstVM tmp]# getfacl textbook</span><br><span class="line"># file: textbook</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">user:myson:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:myson:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
<p><strong>默认ACL权限：</strong></p>
<p>若对某个目录设定了 ACL 权限，那么，如果在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？执行以下命令进行验证：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#假设已经对project目录设定了ACL权限</span><br><span class="line"><span class="selector-attr">[root@localhost /]</span># cd project</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span># touch abc</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span># mkdir d1</span><br><span class="line">\#在/project目录中新建了abc文件和d1目录</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span><span class="selector-id">#ll</span></span><br><span class="line">总用量<span class="number">4</span></span><br><span class="line">-rw-r<span class="attr">--r--</span> <span class="number">1</span> root root <span class="number">01</span>月<span class="number">19</span> <span class="number">05</span>:<span class="number">20</span> abc</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root <span class="number">4096</span> <span class="number">1</span>月<span class="number">19</span> <span class="number">05</span>:<span class="number">20</span> d1</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个新建立的文件权限位后面并没有 “+”，表示它们没有继承 ACL 权限。这说明，后建立的子文件或子目录，并不会继承父目录的 ACL 权限。</p>
<p><strong>默认 ACL 权限的作用是，如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。<font color='red'>需要注意的是，默认 ACL 权限只对目录生效。</font></strong></p>
<p>如下设置默认ACL权限：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># mkdir demo</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m d:u:myson:rwx demo  #别忘了u之前还有d:</span><br><span class="line">[root@MyFirstVM tmp]# touch ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll ./demo/pro</span><br><span class="line">-rw-rw-r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> ./demo/pro</span><br></pre></td></tr></table></figure>
<p>可见，demo目录下的pro文件也对用户myson有ACL权限</p>
<p><strong>递归设置ACL权限 ：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># mkdir aha</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># touch ./aha/shit</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m u:myson:rwx -R /tmp/aha/</span><br><span class="line">[root@MyFirstVM tmp]# ll ./aha/shit</span><br><span class="line">-rw-rwxr--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">23</span> ./aha/shit</span><br></pre></td></tr></table></figure>
<p><strong>先创建aha目录，接着在aha中创建shit文件，然后再修改aha目录的ACL权限，发现shit也具有了ACL权限。设置默认ACL权限不同于设置递归ACL权限，前者是先设置了目录的ACL权限后，而后在其中创建的文件也具有相应权限；而后者是目录和文件都已经建好后再设置ACL权限</strong></p>
<p><strong>删除指定的ACL权限 -x：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setfacl -x u:myson ./aha/shit</span><br><span class="line">[root@MyFirstVM tmp]# ll  ./aha/shit</span><br><span class="line">-rw-r--r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">23</span> ./aha/shit</span><br><span class="line">[root@MyFirstVM tmp]# getfacl ./aha/shit</span><br><span class="line"># file: aha/shit</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
<p><strong>删除指定文件的所有ACL权限 -b：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll demo/pro</span><br><span class="line">-rw-rw-r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# setfacl -b ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll demo/pro</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll demo</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> pro</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-8-mask有效权限-font"><font color='gree'>8.8 mask有效权限</font></h3>
<p><strong>mask 权限，指的是用户或群组能拥有的最大 ACL 权限，也就是说，给用户或群组设定的 ACL 权限不能超过 mask 规定的权限范围，超出部分做无效处理。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost /]</span># getfacl project</span><br><span class="line"><span class="selector-id">#file</span>: project  &lt;-文件名</span><br><span class="line">#owner: root    &lt;-文件的属主</span><br><span class="line">#group: tgroup  &lt;-文件的属组</span><br><span class="line">user::rwx       &lt;-用户名栏是空的，说明是所有者的权限</span><br><span class="line">group::rwx      &lt;-组名栏是空的，说明是所属组的权限</span><br><span class="line">other::---      &lt;-其他人的权限</span><br><span class="line">[root@localhost ~]# setfacl -m u:st:rx /project</span><br><span class="line">#给用户st设定针对project目录的rx权限</span><br><span class="line">[root@localhost /]# getfacl project</span><br><span class="line">#file: project </span><br><span class="line">#owner: root</span><br><span class="line">#group: tgroup </span><br><span class="line">user::rwx </span><br><span class="line">user:st:r-x     #&lt;-用户 st 的权限</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx       #&lt;-mask 权限</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>
<p>对比添加 ACL 权限前后 getfacl 命令的输出信息，后者多了 2 行信息，一行是我们对 st 用户设定的 r-x 权限，另一行就是 mask 权限。</p>
<p><font color='gree'>给 st 用户赋予访问 project 目录的 r-x 权限，此时并不能说明 st 用户就拥有了对该目录的读和访问权限，还需要和 mask 权限对比，r-x 确实是在 rwx 范围内，这时才能说 st 用户拥有 r-x 权限。</font></p>
<blockquote>
<p>需要注意的是，这里将权限进行对比的过程，实则是将两权限做“按位相与”运算，最终得出的值，即为 st 用户有效的 ACL 权限。这里以读（r）权限为例，做相<font color='red'>与</font>操作的结果如下所示：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>其实是进行掩码运算，mask翻译过来就是掩码。</p>
</blockquote>
<p>但是，如果把 mask 权限改为 r–，再和 st 用户的权限 r-x 比对（r-- 和 r-w 做与运算），由于 r-w 超出 r-- 的权限范围，因此 st 用户最终只有 r 权限，手动赋予的 w 权限无效。这就是在设定 ACL 权限时 mask 权限的作用。</p>
<p>mask 权限可以使用 setfacl 命令手动更改，比如，更改 project 目录 mask 权限值为 r-x，可执行如下命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># setfacl -m m:rx /project</span><br><span class="line">#设定mask权限为r-x，使用<span class="string">&quot;m:权限&quot;</span>格式</span><br><span class="line">[root@localhost ~]# getfacl /project</span><br><span class="line">#file：project</span><br><span class="line">#owner：root</span><br><span class="line">#group：tgroup</span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::r-x &lt;--mask权限变为r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，我们一般不更改 mask 权限，只要赋予 mask 最大权限（也就是 rwx），则给用户或群组设定的 ACL 权限本身就是有效的。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m m:rw ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# getfacl ./demo/pro</span><br><span class="line"># file: demo/pro</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">user:myson:rwx			#effective:rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
<p>虽然user:myson的权限还是rwx，但其后的<code>effective:rw-</code>才表示myson的实际权限。</p>
<hr>
<h3 id="font-color-gree-8-9-SetUID-SUID-font"><font color='gree'>8.9 SetUID(SUID)</font></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root <span class="number">22984</span> Jan <span class="number">7</span> <span class="number">2007</span> /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>可以看到，原本表示文件 所有者 权限中的 x 权限位，却出现了 s 权限，此种权限通常称为 SetUID，简称 SUID 特殊权限。</p>
<p><font color='orange'>SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。</font></p>
<p>Linux 系统中所有用户的密码数据都记录在 /etc/shadow 这个文件中，通过 ll /etc/shadow 命令可以看到，此文件的权限是 0（---------），也就是说，普通用户对此文件没有任何操作权限。</p>
<p>这就会产生一个问题，为什么普通用户可以使用 passwd 命令修改自己的密码呢？</p>
<p>本节开头已经显示了 passwd 命令的权限配置，可以看到，此命令拥有 SUID 特殊权限，而且其他人对此文件也有执行权限，<font color='red'>这就意味着，任何一个用户都可以用文件所有者，也就是 root 的身份去执行 passwd 命令。</font></p>
<p>换句话说，<font color='red'>当普通用户使用 passwd 命令尝试更改自己的密码时，实际上是在以 root 的身份执行passwd命令，正因为 root 可以将密码写入 /etc/shadow 文件，所以普通用户也能做到。只不过，一旦命令执行完成，普通用户所具有的 root身份也随之消失。</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u-s /usr/bin/passwd</span><br><span class="line">#属主取消SetUID权限</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/passwd</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">30768</span> Feb <span class="number">22</span> <span class="number">2012</span> /usr/bin/passwd</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># su - lamp</span><br><span class="line"><span class="selector-attr">[lamp@localhost ~]</span>$ passwd</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">Changing password for user.</span><br><span class="line">(current) UNIX password:</span><br><span class="line">#看起来没有什么问题</span><br><span class="line">New passwor:</span><br><span class="line">Retype new password:</span><br><span class="line">password:Authentication token manipulation error  &lt;--鉴定令牌操作错误</span><br><span class="line">#最后密码没有生效</span><br></pre></td></tr></table></figure>
<p>显然，虽然用户有执行 passwd 命令的权限，但无修改 /etc/shadow 文件的权限，因此最终密码修改失败。</p>
<p>由此，我们可以总结出，SUID 特殊权限具有如下特点：</p>
<ul>
<li>只有可执行文件才能设定 SetUID 权限，对目录设定 SUID，是无效的。</li>
<li>用户要对该文件拥有 x（执行）权限。</li>
<li>用户在执行该文件时，会以文件所有者的身份执行。</li>
<li>SetUID 权限只在文件执行过程中有效，一旦执行完毕，身份的切换也随之消失。</li>
</ul>
<p><font color='red'>SetUID权限设置不当，会给 Linux 系统造成重大安全隐患</font></p>
<p>如果我们手动给默认无 SetUID 权限的系统命令赋予 SetUID 权限，会出现什么情况呢？</p>
<p>尝试给 Vim 赋予 SetUID 权限：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u+s /usr/bin/vim</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/vim</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root <span class="number">1847752</span> Apr <span class="number">5</span> <span class="number">2012</span> /usr/bin/vim</span><br></pre></td></tr></table></figure>
<p>此时你会发现，即便是普通用户使用 vim 命令，都会暂时获得 root 的身份和权限，例如，很多原本普通用户不能查看和修改的文件，竟然可以查看了，以 /etc/passwd 和 /etc/shadow 文件为例，普通用户也可以将自己的 UID 手动修改为 0，这意味着，此用户升级成为了超级用户。除此之外，普通用户还可以修改例如 /etc/inittab 和 /etc/fstab 这样重要的系统文件，可以轻易地使系统瘫痪。</p>
<hr>
<h3 id="font-color-gree-8-10-SetGID-SGID-font"><font color='gree'>8.10 SetGID(SGID)</font></h3>
<p>当 s 权限位于所属组的 x 权限位时，就被称为 SetGID，简称 SGID 特殊权限。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/locate</span><br><span class="line">-rwx<span class="attr">--s--x</span>. <span class="number">1</span> root slocate <span class="number">35612</span> <span class="number">8</span>月<span class="number">24</span> <span class="number">2010</span> /usr/bin/locate</span><br></pre></td></tr></table></figure>
<p>与 SUID 不同的是，SGID 既可以对文件进行配置，也可以对目录进行配置。</p>
<p><strong>SGID对文件的作用：</strong></p>
<p>同 SUID 类似，对于文件来说，SGID 具有如下几个特点：</p>
<ul>
<li><font color='red'>SGID 只针对可执行文件有效</font></li>
<li>用户需要对此可执行文件有 x 权限；</li>
<li>用户在执行具有 SGID 权限的可执行文件时，用户的群组身份会变为文件所属群组；</li>
<li>SGID 权限赋予用户改变组身份的效果，只在可执行文件运行过程中有效；</li>
</ul>
<blockquote>
<p>其实，SGID 和 SUID 的不同之处就在于，SUID 赋予用户的是文件所有者的权限，而 SGID 赋予用户的是文件所属组的权限</p>
</blockquote>
<p><strong>SGID对目录的作用：</strong></p>
<p><font color='red'>当一个目录被赋予 SGID 权限后，进入此目录的普通用户，其有效群组会变为该目录的所属组，会就使得用户在创建文件（或目录）时，该文件（或目录）的所属组将不再是用户的所属组，而使用的是目录的所属组。</font></p>
<p>也就是说，只有当普通用户对具有 SGID 权限的目录有 rwx 权限时，SGID 的功能才能完全发挥。比如说，如果用户对该目录仅有 rx 权限，则用户进入此目录后，虽然其有效群组变为此目录的所属组，但由于没有 w 权限，用户无法在目录中创建文件或目录，SGID 权限也就无法发挥它的作用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd /tmp</span><br><span class="line">#进入临时目录做此实验。因为只有临时目录才允许普通用户修改</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># mkdir dtest</span><br><span class="line">#建立测试目录</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># chmod g+s dtest</span><br><span class="line">#给测试目录赋予SetGID权限</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># ll -d dtest</span><br><span class="line">drwxr-sr-x <span class="number">2</span> root root <span class="number">4096</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">04</span> dtest</span><br><span class="line">#SetGID权限已经生效</span><br><span class="line">[root@localhost tmp]# chmod <span class="number">777</span> dtest</span><br><span class="line">#给测试目录赋予<span class="number">777</span>权限，让普通用户可以写</span><br><span class="line">[root@localhost tmp]# su - lamp</span><br><span class="line">[lamp@localhost ~]# grep lamp /etc/passwd /etc/group</span><br><span class="line">/etc/passwd:lamp:x:<span class="number">501</span>:<span class="number">501</span>::/home/lamp:/bin/bash</span><br><span class="line">/etc/group:lamp:x:<span class="number">501</span>:</span><br><span class="line">#切换成普通用户lamp，此用户的所属群组为 lamp</span><br><span class="line">[lamp@localhost ~]$ cd /tmp/dtest/</span><br><span class="line">#普通用户进入测试目录</span><br><span class="line">[lamp@localhost dtest]$ touch abc</span><br><span class="line">[lamp@localhost dtest]$ mkdir zimulu</span><br><span class="line">#在此目录中创建新的文件 abc 和子目录 zimulu</span><br><span class="line">[lamp@localhost dtest]$ ll</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> lamp root <span class="number">0</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">07</span> abc</span><br><span class="line">drwxrwsr-x. <span class="number">2</span> lamp root <span class="number">40</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">07</span> zimulu</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-11-Stick-BIT（SBIT）-font"><font color='gree'>8.11 Stick BIT（SBIT）</font></h3>
<p><strong>SBIT 权限仅对目录有效，一旦目录设定了 SBIT 权限，则用户在此目录下创建的文件或目录，就只有自己和 root 才有权利修改或删除该文件。</strong></p>
<p>Linux 系统中，<font color='orange'>存储临时文件的 /tmp 目录就设定有 SBIT 权限：</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -d /tmp</span><br><span class="line">drwxrwxrwt. <span class="number">4</span> root root <span class="number">4096</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">17</span> /tmp</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="font-color-gree-8-12-特殊权限的值与设置-font"><font color='gree'>8.12 特殊权限的值与设置</font></h3>
<p>给文件或目录设定特殊权限，只需在这 3 个数字之前增加一个数字位，用来放置给文件或目录设定的特殊权限</p>
<p>SUID、SGID、SBIT 分别对应的数字，如下所示：</p>
<p>4 --&gt; SUID<br>
2 --&gt; SGID<br>
1 --&gt; SBIT</p>
<p>如果要将一个文件权限设置为 <code>-rwsr-xr-x</code>，怎么办呢？此文件的普通权限为 755，另外，此文件还有 SUID 权限，因此只需在 755 的前面，加上 SUID 对应的数字 4 即可。也就是说，只需执行<code>chmod 4755 文件名</code>命令，就完成了<code>-rwsr-xr-x</code> 权限的设定。</p>
<blockquote>
<p>关于 -rwsr-xr-x 的普通权限是 755，你可以这样理解，标记有 s 和 t 的权限位，隐藏有 x 权限</p>
</blockquote>
<p>同样的道理，如果某文件拥有 SUID 和 SGID 权限，则只需要给 chmod 命令传递 6—（- 表示数字）即可；如果某目录拥有 SGID 和 SBIT，只需要给 chmod 命令传递 3— 即可。</p>
<p>注意，不同的特殊权限，作用的对象是不同的，<font color='red'>SUID 只对可执行文件有效；SGID 对可执行文件和目录都有效；SBIT 只对目录有效。</font></p>
<p>除了赋予 chmod 命令 4 个数字设定特殊权限，还可以使用字母的形式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chmod</span> u+s, g+s, o+t ftest</span><br><span class="line">\#设置特殊权限</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll ftest</span><br><span class="line">-rwsr-sr-t. <span class="number">1</span> root root Apr <span class="number">19</span> <span class="number">23</span>:<span class="number">54</span> ftest</span><br><span class="line">[root@localhost ~]# chmod u-s, g-s, o-t ftest</span><br><span class="line">\#取消特殊权限</span><br><span class="line">[root@localhost ~]# ll ftest</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root Apr <span class="number">19</span> <span class="number">23</span>:<span class="number">54</span> ftest</span><br></pre></td></tr></table></figure>
<p>使用 chmod 命令给文件或目录赋予特殊权限时，原文件或目录中存在的 x 权限会被替换成 s 或 t，而当我们使用 chmod 命令消除文件或目录的特殊权限时，原本消失的 x 权限又会显现出来。<font color='red'>这是因为，无论是 SUID、SGID 还是 SBIT，它们只针对具有 x 权限的文件或目录有效</font>。没有 x 权限的文件或目录，即便赋予特殊权限，也无法发挥它们的功能，没有任何意义。</p>
<hr>
<h3 id="font-color-gree-8-13-修改文件系统的权限属性chattr-font"><font color='gree'>8.13 修改文件系统的权限属性chattr</font></h3>
<p>chattr 命令，专门用来修改文件或目录的隐藏属性，<font color='red'>只有 root 用户可以使用</font></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr <span class="selector-attr">[+-=]</span> <span class="selector-attr">[属性]</span> 文件或目录名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td>
</tr>
<tr>
<td>a</td>
<td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td>
</tr>
<tr>
<td>u</td>
<td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td>
</tr>
<tr>
<td>s</td>
<td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复</td>
</tr>
</tbody>
</table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch ftest</span><br><span class="line">\#建立测试文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr +<span class="selector-tag">i</span> ftest</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf ftest</span><br><span class="line">rm:cannot remove <span class="string">&#x27;ftest&#x27;</span>:Operation not permitted</span><br><span class="line">\#无法删除<span class="string">&quot;ftesr&quot;</span>，操作不允许</span><br><span class="line">\#被赋予i属性后，root不能删除</span><br><span class="line">[root@localhost ~]# echo <span class="number">111</span>&gt;&gt;ftest</span><br><span class="line">bash:ftest:Permission denied</span><br><span class="line">\#权限不够，不能修改文件中的数据</span><br></pre></td></tr></table></figure>
<p>可以看到，设置有 i 属性的文件，即便是 root 用户，也无法删除和修改数据。</p>
<p>演示 a 属性的作用。假设有这样一种应用，我们每天自动实现把服务器的日志备份到指定目录，备份目录可设置 a 属性，变为只可创建文件而不可删除。命令如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir -<span class="selector-tag">p</span> /back/log</span><br><span class="line">\#建立备份目录</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr +<span class="selector-tag">a</span> /back/log</span><br><span class="line">\#赋予<span class="selector-tag">a</span>属性</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp /<span class="selector-tag">var</span>/log/messages /back/log</span><br><span class="line">\#可以复制文件和新建文件到指定目录中</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /back/log/messages</span><br><span class="line">rm: cannot remove <span class="string">&#x27;/back/log/messages&#x27;</span>: Permission denied</span><br><span class="line">\#无法删除 /back/log/messages，操作不允许</span><br></pre></td></tr></table></figure>
<p>注意，通常情况下，不要使用 chattr 命令修改 /、/dev/、/tmp/、/var/ 等目录的隐藏属性，很容易导致系统无法启动。另外，chatrr 命令常与 lsattr 命令合用，前者修改文件或目录的隐藏属性，后者用于查看是否修改成功。</p>
<hr>
<h3 id="font-color-gree-8-14-查看文件系统属性lasttr-font"><font color='gree'>8.14 查看文件系统属性lasttr</font></h3>
<p>使用 chattr 命令配置文件或目录的隐藏属性后，可以使用 lsattr 命令查看。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># lsattr <span class="selector-attr">[选项]</span> 文件或目录名</span><br></pre></td></tr></table></figure>
<p>常用选项有以下 3 种：</p>
<ul>
<li>-a：后面不带文件或目录名，表示显示所有文件和目录（包括隐藏文件和目录）</li>
<li>-d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息；</li>
<li>-R：和 -d 恰好相反，作用于目录时，会连同子目录的隐藏信息数据也一并显示出来。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">http://jyxcpp.netlify.app/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/06/18/%E6%A8%A1%E6%9D%BF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E5%8C%85/"><img class="prev-cover" src="/2022/img/20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++11模板可变参数扩展包</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Linux笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-1-Linux%E5%AD%A6%E5%89%8D%E9%A1%BB%E7%9F%A5-font"><span class="toc-number">1.1.</span> <span class="toc-text">1.Linux学前须知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-1-1-Linux%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6-font"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Linux一切皆文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-1-2-%E6%8C%82%E8%BD%BD-font"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-1-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-font"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-1-4-shell%E4%B8%8Ebash-font"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 shell与bash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-2-Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86-font"><span class="toc-number">1.2.</span> <span class="toc-text">2.Linux文件和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-1-FHS%E6%A0%87%E5%87%86-font"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 FHS标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-2-%E6%A0%B9%E7%9B%AE%E5%BD%95-font"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 根目录(&#x2F;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-3-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84-font"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 绝对路径与相对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-4-%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99-font"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 文件(目录)命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-5-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-font"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Linux命令行识别文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-6-Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F-font"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 Linux命令基本格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-7-%E5%B8%B8%E8%A7%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 常见相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-1-%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95-cd-font"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">2.7.1 切换目录(cd)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-2-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84-pwd-font"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.7.2 显示当前路径(pwd)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-3-%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%9B%AE%E5%BD%95-mkdir-font"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">2.7.3 创建空目录(mkdir)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-4-%E5%88%A0%E9%99%A4%E7%A9%BA%E7%9B%AE%E5%BD%95-rmdir-font"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">2.7.4 删除空目录(rmdir)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-5-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%8F%8A%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3-touch-font"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">2.7.5 创建文件及修改文件时间戳(touch)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-6-%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9-ls-font"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">2.7.6 查看目录内容(ls)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-7-%E5%BB%BA%E7%AB%8B%E8%BD%AF-%E7%A1%AC%E9%93%BE%E6%8E%A5-ln-font"><span class="toc-number">1.2.7.7.</span> <span class="toc-text">2.7.7 建立软&#x2F;硬链接(ln)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-8-%E5%89%96%E6%9E%90%E8%BD%AF-%E7%A1%AC%E9%93%BE%E6%8E%A5-font"><span class="toc-number">1.2.7.8.</span> <span class="toc-text">2.7.8 剖析软&#x2F;硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-9-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-cp-font"><span class="toc-number">1.2.7.9.</span> <span class="toc-text">2.7.9 复制文件&#x2F;目录(cp)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-10-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-rm-font"><span class="toc-number">1.2.7.10.</span> <span class="toc-text">2.7.10 删除文件&#x2F;目录(rm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-11-%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95-mv-font"><span class="toc-number">1.2.7.11.</span> <span class="toc-text">2.7.11 移动和重命名文件或目录(mv)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-color-purple-2-7-12-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD-font"><span class="toc-number">1.2.7.12.</span> <span class="toc-text">2.7.12 命令自动补全功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-8-Linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%88%AB%E5%90%8D-font"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 Linux命令执行过程与别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-2-9-Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-font"><span class="toc-number">1.2.9.</span> <span class="toc-text">2.9 Linux环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-3-Linux%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9-font"><span class="toc-number">1.3.</span> <span class="toc-text">3. Linux打包和压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-3-1-%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4-tar-font"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 打包命令(tar)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-purple-3-2-%E8%A7%A3%E5%8E%8B-%E5%8E%8B%E7%BC%A9zip%E6%96%87%E4%BB%B6-font"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 解压&#x2F;压缩zip文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-purple-3-3-%E8%A7%A3%E5%8E%8B-%E5%8E%8B%E7%BC%A9gzip%E6%96%87%E4%BB%B6-font"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 解压&#x2F;压缩gzip文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-3-4-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9bzip2%E6%96%87%E4%BB%B6-font"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 压缩&#x2F;解压缩bzip2文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-4-vim%E7%BC%96%E8%BE%91%E5%99%A8-font"><span class="toc-number">1.4.</span> <span class="toc-text">4. vim编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-1-vim%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F-font"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 vim的三种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-2-vim%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-font"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 vim的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-3-vim%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A8%A1%E5%BC%8F-font"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 vim可视化模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-4-vim%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F-font"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 vim多窗口编辑模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-5-vim%E6%89%B9%E9%87%8F%E6%B3%A8%E9%87%8A%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A%E5%BF%AB%E6%8D%B7%E9%94%AE-font"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 vim批量注释和自定义注释快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-6-vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7-font"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 vim显示行号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-7-vim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-vimrc-font"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7 vim配置文件(.vimrc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-4-8-%E5%9C%A8vim%E4%B8%AD%E6%89%A7%E8%A1%8CLinux%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.4.8.</span> <span class="toc-text">4.8 在vim中执行Linux命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-5-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-font"><span class="toc-number">1.5.</span> <span class="toc-text">5. 文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-1-%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%93%E5%8D%B0-cat%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 连接文件并打印(cat命令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-2-%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-more%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 分屏显示文件内容(more命令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-3-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E5%86%85%E5%AE%B9-head%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 显示文件开头内容(head命令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-less%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 显示文件内容(less命令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-5-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE-tail-font"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 显示文件结尾(tail)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-6-Linux%E9%87%8D%E5%AE%9A%E5%90%91-font"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 Linux重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-7-grep%E5%91%BD%E4%BB%A4%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-font"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 grep命令和正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-5-8-sed%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.5.8.</span> <span class="toc-text">5.8 sed命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-6-Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-font"><span class="toc-number">1.6.</span> <span class="toc-text">6. Linux软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-1-Linux%E8%BD%AF%E4%BB%B6%E5%8C%85-font"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 Linux软件包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-2-RPM%E5%8C%85%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99-font"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 RPM包统一命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-3-RPM%E5%8C%85%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E5%92%8C%E5%8D%87%E7%BA%A7%EF%BC%88rpm%E5%91%BD%E4%BB%A4%EF%BC%89-font"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 RPM包安装、卸载和升级（rpm命令）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-4-rpm%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85-font"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 rpm命令查询软件包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-5-RPM%E5%8C%85%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-font"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 RPM包验证和数字证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-6-%E6%8F%90%E5%8F%96RPM%E5%8C%85-cpio-font"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 提取RPM包(cpio)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-7-SRPM%E6%BA%90%E7%A0%81%E5%8C%85-font"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7 SRPM源码包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-8-%E9%87%8D%E5%BB%BARPM%E6%95%B0%E6%8D%AE%E5%BA%93-font"><span class="toc-number">1.6.8.</span> <span class="toc-text">6.8 重建RPM数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-9-RPM%E5%8C%85%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-font"><span class="toc-number">1.6.9.</span> <span class="toc-text">6.9 RPM包的依赖性及其解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-font-color-gree-yum%E5%8E%9F%E9%85%8D%E7%BD%AE-font"><span class="toc-number">1.6.10.</span> <span class="toc-text">6.10 yum原配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-12-yum%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%BB%84-font"><span class="toc-number">1.6.11.</span> <span class="toc-text">6.12 yum管理软件组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-13-%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD-font"><span class="toc-number">1.6.12.</span> <span class="toc-text">6.13 源码包安装和卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-14-%E6%BA%90%E7%A0%81%E5%8C%85%E5%8D%87%E7%BA%A7%E4%B8%8E%E8%A1%A5%E4%B8%81-font"><span class="toc-number">1.6.13.</span> <span class="toc-text">6.14 源码包升级与补丁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-6-15-Linux%E5%87%BD%E6%95%B0%E5%BA%93%EF%BC%88%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E5%BA%93-font"><span class="toc-number">1.6.14.</span> <span class="toc-text">6.15  Linux函数库（静态函数库和动态函数库)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-7-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86-font"><span class="toc-number">1.7.</span> <span class="toc-text">7. 用户和用户组管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-1-UID%E5%92%8CGID-font"><span class="toc-number">1.7.1.</span> <span class="toc-text">7. 1 UID和GID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-2-etc-passwd%E5%86%85%E5%AE%B9%E8%AF%A6%E8%A7%A3-font"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 &#x2F;etc&#x2F;passwd内容详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-3-etc-shadow%E6%96%87%E4%BB%B6-font"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 &#x2F;etc&#x2F;shadow文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-4-etc-group-font"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 &#x2F;etc&#x2F;group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-5-etc-gshadow-font"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 &#x2F;etc&#x2F;gshadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-6-etc-login-defs-font"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 &#x2F;etc&#x2F;login.defs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-7-useradd%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7 useradd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-8-passwd%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.8 passwd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-9-usermod%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.9.</span> <span class="toc-text">7.9 usermod命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-10-chage%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.10.</span> <span class="toc-text">7.10 chage命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-11-userdel%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.11.</span> <span class="toc-text">7.11 userdel命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-12-id%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.12.</span> <span class="toc-text">7.12 id命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-13-%E4%B8%B4%E6%97%B6%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7-su-font"><span class="toc-number">1.7.13.</span> <span class="toc-text">7.13 临时切换用户 su</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-14-whoami-%E5%92%8Cwho-am-i-font"><span class="toc-number">1.7.14.</span> <span class="toc-text">7.14 whoami 和who am i</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-15-groupadd%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.15.</span> <span class="toc-text">7.15 groupadd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-16-groupmod%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.16.</span> <span class="toc-text">7.16 groupmod命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-17-groupdel%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.17.</span> <span class="toc-text">7.17 groupdel命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-18-gpasswd%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.18.</span> <span class="toc-text">7.18 gpasswd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-7-19-newgrp%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.7.19.</span> <span class="toc-text">7.19 newgrp命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#font-color-orange-8-Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-font"><span class="toc-number">1.8.</span> <span class="toc-text">8. Linux权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-1-chgrp%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 chgrp命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-2-chown%E5%91%BD%E4%BB%A4-font"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 chown命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-3-Linux%E6%9D%83%E9%99%90%E4%BD%8D-font"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 Linux权限位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-4-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%EF%BC%88chmod%EF%BC%89-font"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 修改文件或目录权限（chmod）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-5-%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90%EF%BC%88umask%EF%BC%89-font"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 默认权限（umask）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-6-ACL%E6%9D%83%E9%99%90-font"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 ACL权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-7-%E8%AE%BE%E5%AE%9AACL%E6%9D%83%E9%99%90-font"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7 设定ACL权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-8-mask%E6%9C%89%E6%95%88%E6%9D%83%E9%99%90-font"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.8 mask有效权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-9-SetUID-SUID-font"><span class="toc-number">1.8.9.</span> <span class="toc-text">8.9 SetUID(SUID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-10-SetGID-SGID-font"><span class="toc-number">1.8.10.</span> <span class="toc-text">8.10 SetGID(SGID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-11-Stick-BIT%EF%BC%88SBIT%EF%BC%89-font"><span class="toc-number">1.8.11.</span> <span class="toc-text">8.11 Stick BIT（SBIT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-12-%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E7%9A%84%E5%80%BC%E4%B8%8E%E8%AE%BE%E7%BD%AE-font"><span class="toc-number">1.8.12.</span> <span class="toc-text">8.12 特殊权限的值与设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-13-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7chattr-font"><span class="toc-number">1.8.13.</span> <span class="toc-text">8.13 修改文件系统的权限属性chattr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-gree-8-14-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7lasttr-font"><span class="toc-number">1.8.14.</span> <span class="toc-text">8.14 查看文件系统属性lasttr</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>