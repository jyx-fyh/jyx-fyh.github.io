<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>线程-进阶-任务调度 | 极简</title><meta name="keywords" content="线程, 操作系统, 任务调度, 自制操作系统, 真相还原"><meta name="author" content="极简"><meta name="copyright" content="极简"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="线程, 操作系统, 任务调度, 自制操作系统, 真相还原">
<meta property="og:type" content="article">
<meta property="og:title" content="线程-进阶-任务调度">
<meta property="og:url" content="http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="极简">
<meta property="og:description" content="线程, 操作系统, 任务调度, 自制操作系统, 真相还原">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jyxcpp.netlify.app/2022/img/27.jpg">
<meta property="article:published_time" content="2022-12-16T08:50:00.000Z">
<meta property="article:modified_time" content="2023-03-12T11:20:59.873Z">
<meta property="article:author" content="极简">
<meta property="article:tag" content="自制操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jyxcpp.netlify.app/2022/img/27.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"本篇文章于","messageNext":"天前发表，某些内容可能已经过时，请注意甄别。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 极简","link":"链接: ","source":"来源: 极简","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程-进阶-任务调度',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 19:20:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- 谷歌的html标记--><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="极简" type="application/atom+xml">
<script src="/assets/js/DPlayer.min.js"></script></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">137</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/img/27.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">极简</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">线程-进阶-任务调度</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-16T08:50:00.000Z" title="发表于 2022-12-16 16:50:00">2022-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-12T11:20:59.873Z" title="更新于 2023-03-12 19:20:59">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="线程-进阶-任务调度"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>前置内容：<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a><br>
本节分支：<code>thread-schedule</code></p>
</blockquote>
<h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3>
<ul>
<li><strong><font color='gree'>任务链表</font></strong><br>
通常使用链表来维护任务队列。链表本身不是本节的重点，所以笔者将其放在文末。</li>
<li><strong><font color='gree'>任务调度基础</font></strong><br>
基于上节内容对 <code>thread.c</code> 和 <code>thread.h</code> 进行改进。</li>
<li><strong><font color='gree'>任务切换</font></strong><br>
改进时钟中断，添加任务调度器，开始任务切换。</li>
</ul>
<h3 id="font-color-red-任务调度基础-font"><font color='red'>任务调度基础</font></h3>
<p><strong><mark class="hl-label blue">thread.h</mark> </strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;	      </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;	              </span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              </span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>thread.h 中只对 <code>task_struct</code>  添加了一些成员：</p>
<ul>
<li><strong>ticks：</strong> 时间片，任务刚被调度时，时间片被初始化为 priority，随后每发生一次时钟中断 ticks 就减 1，减到 0 后被换下 CPU 。</li>
<li><strong>elapsed_ticks：</strong> 记录该任务一共被运行了多少 CPU 滴答数。它和 ticks 的区别是：ticks 减到 0 时任务被换下 CPU，但此时任务可能还未执行完毕，所以重新加入到任务队列等待下一次被调度。所以，elapsed_ticks 记录的是从任务初次被调度到任务执行结束所经过的总滴答数，而 ticks 只是任务的一次倒计时。</li>
<li><strong>general_tag：</strong> <font color='orange'>当任务处于<u>就绪或其他等待状态</u>时，需要把该 tag 添加到 thread_ready_list 或其他相应等待队列中</font>。将 tag 加入到队列就相当于将 task_struct 加入到队列吗？是的，可以通过 tag 来定位 task_struct，原因很简单，因为这些 tag 本来就位于 task_struct 内存中，只需要根据成员的偏移量就能反向推断出 task_struct 的地址。文末会演示这一过程。<br>
<img src="/2022/img/image-20221217171337120.png" alt="通过tag将各个PCB连接成队列" style="zoom:67%;" /></li>
<li><strong>all_list_tag：</strong> thread_all_list 用来管理所有任务，所有任务的 all_list_tag 都需要加入到 thread_all_list 中。</li>
<li><strong>pgdir：</strong> 上节提到过，对于进程，pgdir 指向自己的页目录表；对于线程，pgdir 被初始化为 NULL 。注意，pgdir 中装的是虚拟地址，经过手动转换变成物理地址后才会加载进 CR2 ，这是后话。</li>
</ul>
<p><strong><mark class="hl-label blue">thread.c</mark> </strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">main_thread</span>;</span>    <span class="comment">// 主线程PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span>	    <span class="comment">// 就绪队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span>	    <span class="comment">// 所有任务队列</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">thread_tag</span>;</span><span class="comment">// 用于保存队列中的线程结点</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> tmp_esp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前线程pcb指针 */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">running_thread</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov tmp_esp,esp&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">/* 取esp整数部分即pcb起始地址 */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> task_struct*)(tmp_esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由kernel_thread去执行function(func_arg) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">    intr_enable();</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程栈thread_stack,将待执行的函数和参数放到thread_stack中相应的位置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再留出线程栈空间,可见thread.h中定义 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread)</span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    </span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;	  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">/* 加入就绪线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">/* 加入全部线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将kernel中的main函数完善为主线程 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_main_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 因为main线程早已运行,咱们在guide.S中进入内核时mov esp,0xc009f000,</span></span><br><span class="line"><span class="comment">已经为其预留了pcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/</span></span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">&quot;main&quot;</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数就是当前线程,当前线程不在thread_ready_list中,</span></span><br><span class="line"><span class="comment"> * 所以只将其加在thread_all_list中. */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务调度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING)    <span class="comment">// 若当前线程只是时间片到了,将其加入到就绪队列尾,等待重新被调度</span></span><br><span class="line">    &#123;  </span><br><span class="line">        assert(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">        cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">        cur-&gt;status = TASK_READY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前线程是被阻塞了,则不需要将其加入到就绪队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!list_empty(&amp;thread_ready_list));</span><br><span class="line">    thread_tag = <span class="literal">NULL</span>;	  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu.</span></span><br><span class="line">    thread_tag = list_pop(&amp;thread_ready_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;thread_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    list_init(&amp;thread_ready_list);</span><br><span class="line">    list_init(&amp;thread_all_list);</span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">    make_main_thread();</span><br><span class="line">    put_str(<span class="string">&quot;thread_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老规矩，讲解以上代码前先理理脉络：</p>
<ol>
<li><strong>开启线程机制前需要调用 <code>thread_init()</code> 来初始化线程环境，内容包括初始化就绪任务链表和所有任务链表、创建 main 线程。</strong></li>
<li><strong>初始化线程环境后即可调用 <code>thread_start()</code> 创建线程。在此函数中进入如下动作：</strong><br>
<strong>1）调用 <code>init_thread()</code> 初始化线程信息，</strong><br>
<strong>2）调用 <code>thread_create()</code> 将线程函数及其参数写入到线程栈中。</strong><br>
<strong>3）将该线程加入到 thread_ready_list 和 thread_all_list 中。</strong></li>
<li><strong>随后等待调度。</strong></li>
</ol>
<p>下面进行代码讲解：</p>
<ul>
<li>
<p>第 12 行，使用内联汇编取得当前 esp 的值。和之前一样，内联汇编中用到的 C 变量必须是全局或者全局静态变量，因此使用全局静态变量 tmp_esp 中转。</p>
</li>
<li>
<p>第 14 行，因为栈位于 PCB 中，而 PCB 大小为一页，所以将 esp 向下取页框，即得 PCB 起始地址。</p>
</li>
<li>
<p>第 21 行，进入线程函数 <code>function()</code> 前需要先打开中断，这里需要重点说明其原因：任务切换是由时钟中断驱动的，也就是说，<code>schedule()</code> 是在时钟中断里被调用的，任务调度后直接进入 <code>function()</code> 执行任务 ，<strong><u>并不会返回中断（iret）</u></strong> ，这样一来，就相当于任务的调度和执行都发生在中断里。咋们之前说过，进入中断后 <code>IF</code> 位自动置 0，也就是屏蔽外部中断，如此一来，进入该任务后就无法发生时钟中断来调度其他任务啦，于是，该任务独占了 CPU 控制权！为了防止这种情况发生，<strong><font color='orange'>我们需要在进入任务前手动开启中断</font></strong> ！！！</p>
</li>
<li>
<p>第 68 行，<strong>只有将该任务加入到 thread_ready_list 队列中，才会被 CPU 调度</strong> ；目前还没有体现到 thread_all_list 的作用，后续才会用到该队列。</p>
</li>
<li>
<p>第 77 行，从 CPU 被启动的那一刻，执行流就一直在按我们的代码运行。现在，<strong>我们要将该执行流也包装成线程（即kernel_main线程）并加入到队列中，否则调度其他任务后就没法回到主线程了</strong> 。注意 <code>guide.s</code> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[BITS 32]</span><br><span class="line">extern kernel_main</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov esp, 0xc009f000</span><br><span class="line">    jmp kernel_main</span><br></pre></td></tr></table></figure>
<p>第 6 行，<strong>进入内核前必须将 esp 指向主线程 PCB 的顶端，即 0xc009f00 处，否则无法根据 esp 定位到 PCB</strong> 。</p>
</li>
<li>
<p>第 92 行，<code>schedule()</code> 函数可能在时钟中断里被调用，也可能被后续将要说到的 <code>thread_block()</code> 函数调用。<strong><font color='orange'>因此，在 <code>schedule()</code> 中需要考虑当前线程是出于什么原因才被换下 CPU 的，是因为时间片到期？还是说被阻塞了？所以必须针对不同的状态做出相应的应对措施</font></strong> 。另外，最下方调用的 <code>switch_to</code> 是汇编函数，下文会重点讲解。</p>
</li>
<li>
<p>第 109 行，由于我们还未实现 idle 线程，所以就绪队列可能为空，为了避免无线程可调度的情况，暂用 assert 来保障。</p>
</li>
<li>
<p>第 114 行，<code>elem2entry()</code> 是宏函数，用来将 general_tag 或 all_list_tag 转换为对应的 task_strcut 指针。此函数在文末介绍链表时会谈到。</p>
</li>
</ul>
<p>其他就没什么好说的了，下面进入正题。</p>
<h3 id="font-color-red-任务切换-font"><font color='red'>任务切换</font></h3>
<p>我们采用的调度方式是 <strong><font color='red'>轮询（Round-Robin，RR）</font></strong> ，这是一种基础的调度方式。轮询，说白了就是按先进先出（FIFO）的顺序一个一个调度。切换任务时，从 thread_ready_list 弹出队首，并将其调度上 CPU 。注意，正在执行的任务的状态是 RUNNING，该任务不在 thread_ready_list 中，而在 thread_all_list 中。</p>
<p><strong>完整的任务调度分为三个大步：</strong></p>
<ol>
<li><strong>进入时钟中断</strong></li>
<li><strong>时钟中断调用 <code>schedule()</code></strong></li>
<li><strong><code>schedule()</code> 调用 <code>switch_to()</code></strong></li>
</ol>
<p><strong><mark class="hl-label blue">1.进入时钟中断</mark> </strong><br>
还记得吗？在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加入中断</a>一文中，我们将每个中断处理函数都统一初始化为 <code>general_intr_handler()</code> ，这是一般化函数，只是用来告诉我们发生了什么中断，以便于排错。现在咋们就需要将时钟中断专门化了，见以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idt.c</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_handler</span><span class="params">(<span class="type">uint8_t</span> vector_no, intr_handler function)</span></span><br><span class="line">&#123;</span><br><span class="line">    interrupt_handler_table[vector_no] = function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> ticks;          <span class="comment">// ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"><span class="comment">/* 时钟的中断处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intr_timer_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line"></span><br><span class="line">    assert(cur_thread-&gt;stack_magic == <span class="number">0x19870916</span>);  <span class="comment">// 检查栈是否溢出</span></span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;elapsed_ticks++;                    <span class="comment">// 记录此线程占用的cpu时间嘀</span></span><br><span class="line">    ticks++;	  <span class="comment">//从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_thread-&gt;ticks == <span class="number">0</span>)                     <span class="comment">// 若进程时间片用完就开始调度新的进程上cpu</span></span><br><span class="line">        schedule();</span><br><span class="line">    <span class="keyword">else</span>                                            <span class="comment">// 将当前进程的时间片-1</span></span><br><span class="line">        cur_thread-&gt;ticks--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;timer_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);</span><br><span class="line">    register_handler(<span class="number">0x20</span>, intr_timer_handler);  </span><br><span class="line">    put_str(<span class="string">&quot;timer_init done: Clock interrupt frequency increased to 100Hz\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>全局变量 ticks 用来记录自中断开启后经历的总滴答数，类似于系统运行时长的概念。该变量当前保留，未来可能会用到。</li>
<li>第 14 行，<strong>cur_thread-&gt;ticks == 0 意味着<u>该任务还未结束，但时间片已经到期</u></strong> ，所以进入 <code>schedule()</code> ，将该任务重新放入队尾等待下一次调度。</li>
<li>第 25 行，注册专门的时钟中断。</li>
</ul>
<p><strong><mark class="hl-label blue">进入schedule()</mark> </strong></p>
<p>上文已作讲解，不再说明。</p>
<p><strong><mark class="hl-label blue">进入switch_to</mark> </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">section .text</span><br><span class="line">global switch_to</span><br><span class="line">switch_to:</span><br><span class="line">   ;栈中此处是返回地址</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ebx</span><br><span class="line">   push ebp</span><br><span class="line"></span><br><span class="line">   mov eax, [esp + 20]     ; 得到栈中的参数cur, cur = [esp+20]</span><br><span class="line">   mov [eax], esp          ; 保存栈顶指针esp</span><br><span class="line">                           </span><br><span class="line">                           </span><br><span class="line">;------------------  以上是保存当前线程的栈，下面是恢复下一个线程的栈  ----------------</span><br><span class="line">   mov eax, [esp + 24]     ; 得到栈中的参数next, next = [esp+24]</span><br><span class="line">   mov esp, [eax]          ; 恢复esp</span><br><span class="line">                           </span><br><span class="line">   pop ebp</span><br><span class="line">   pop ebx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret                     ;第一次执行时会返回到kernel_thread</span><br><span class="line">                           ;后续执行则会返回到schedule函数</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 esi、edi、ebx、ebp 的压栈问题已在<a target="_blank" rel="noopener" href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a>中阐述。</li>
<li>参数 cur 和 next 分别是当前任务和下个任务的 task_struct 指针，需要强调的是，<strong>由于 task_struct 的首个成员是 self_kstack，所以可以认为 cur 和 next 指针也是指向 self_kstack</strong> ！这样一来，<strong><font color='orange'>self_kstack 的真正作用便清晰了——记录线程被换下瞬间的 esp 值</font></strong> 。</li>
</ul>
<p><strong><code>switch_to</code> 是任务调度的核心，它向我们直接展示了操作系统是如何通过栈切换来完成任务调度的</strong> 。不过，大家可能还是很迷糊，不急，让我们看看实际的调度过程：</p>
<p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE28-1671258856847-2.png" alt="以下解析的步骤和上图的序号相对应"></p>
<ol>
<li>
<p>当前执行流位于 kernel_main() 主线程，esp 当然也位于 kernel_main 的 PCB 顶端。某一时刻，时钟中断发生，<strong>中断压栈保护任务现场</strong> ，接着进入 <code>schedule()</code> ，进而到 <code>switch_to()</code> 。<code>switch_to()</code> 前半段将当前 esp 的值保存到 kernel_main 的 self_kstack 中。</p>
<blockquote>
<p>为什么 cur 和 中断栈之间还有个省略号？这只是想告诉大家，实际的线程栈情况和 <code>thread_stack</code> 结构体并不能一一对应，比如，调用 <code>schedule()</code> 函数还需要将返回地址压栈呢，而这个并没有考虑进 <code>thread_stack</code> 或 <code>intr_stack</code> ，所以栈中的数据实际上是错位的！不能通过该结构体取得栈内对应的值。<code>intr_stack</code> 也同样不能对应，比如，在 kernel_main() 中调用了一个函数，执行此函数时发生中断，此时的 esp 就不是从 0xc009f000 开始的啦！</p>
</blockquote>
</li>
<li>
<p>执行 <code>mov esp,[eax]</code> 后即完成栈切换。<strong><font color='orange'>注意，这个新任务是首次被调度的，它的线程栈已经在 <code>thread_create()</code> 中被我们设计好了</font></strong> 。</p>
<blockquote>
<p>为啥没省略号了？因为现在对齐啦！！！要知道，在 <code>thread_create()</code> 中，我们跳过了中断栈和线程栈，将 self_kstack 不偏不倚地指向了线程栈的起点，所以这里是完全对齐了的，也是基于这一点，下面的 pop 和 ret 才能正确执行。</p>
</blockquote>
</li>
<li>
<p>四次 pop 并 ret，成功进入 eip 对应的 <code>kernel_thread()</code> ，进而 <code>function()</code> ，任务开始执行。</p>
</li>
<li>
<p>某时刻，中断再次发生，中断压栈，再一路来到 <code>switch_to()</code> 上半部分，即保存当前栈。<strong><font color='orange'>注意，由图可见，此时中断压栈是发生在线程栈中而非中断栈中！</font></strong></p>
<blockquote>
<p><strong><font color='orange'>注意步骤 3 和步骤 4 的栈中的 eip 差异，这点差异非常重要！步骤 3 中的 eip 是我们设计好的，指向 <code>kernel_thread()</code> ；而步骤 4 中的 eip 是 <code>schedule()</code> 中调用 <code>switch_to()</code> 时留下的返回地址，也就是说将来会通过这个 eip 回到 <code>schedule()</code></font></strong> 。<br>
另外再次强调，中断之所以能够再次发生，是因为我们进入 <code>function()</code> 前手动打开了中断，这并不是 <code>iret</code> 的功劳。</p>
</blockquote>
</li>
<li>
<p>执行 <code>switch_to()</code> 的下半部分，<code>mov esp,[eax]</code> ，切换任务栈。</p>
</li>
<li>
<p>接着 pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复 kernel_main() 的任务。</p>
</li>
<li>
<p>一段时间后，中断发生，保存当前栈。</p>
</li>
<li>
<p>恢复之前的栈。此时的 eip 是 <code>schedule()</code> 留下的返回地址（而非 kernel_thread 的地址）。</p>
</li>
<li>
<p>pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复线程任务。</p>
<blockquote>
<p>可见，该线程的线程栈栈底将一直存留这三个参数，这并不重要。问题是，当任务结束后，<code>kernel_thread()</code> 该如何返回呢？这个占位符原本应该是 <code>switch_to</code> 调用 <code>kernel_thread()</code> 留下的返回地址，但现在它仅是一个占位符，<strong><font color='orange'>这意味着任务结束后 kernel_thread() 将无法正常返回！</font></strong> 所以，<strong><u>在我们的操作系统中，线程返回不能通过普通 return 的方式进行</u></strong> ，而要专门调用一个线程退出函数（ <code>thread_exit()</code> ）来结束任务，这是后话，目前我们的策略是强制要求在任务末端放一个 <code>while(1)</code> ，以避免任务结束。关于这点的实验演示见以下视频。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>为什么使用 <code>ret</code> 来调用 kernel_thread() ？</strong><br>
从上面的过程你可以发现，<code>switch_to</code> 的最后一句 <code>ret</code> ，在线程首次被调度时，是进入 <code>kernel_thread()</code> ；后续被调度时，则是返回到主调函数 <code>schedule()</code> 中。<strong><font color='orange'>所以此处的 <code>ret</code> 有双重作用！而你可以通过 ret 调用 kernel_thread，也可以使用 ret 来返回 schedule，但你可不能使用 call 来返回 schedule 吧？这也是为什么要使用 <code>ret</code> 而非 <code>call</code> 来调用 <code>kernel_thread()</code> 的原因！</font></strong></p>
</blockquote>
<div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_exit.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p>可见，一旦任务退出，就引发缺页异常。不知道有没有眼尖的小伙伴看见 while 语句中，打印语句上下的 <code>STI</code> 和 <code>CLI</code> ？为什么要在 <code>put_str()</code> 的上下分别放置这两条语句呢？先让我们看看，如果去掉这两条语句会发生什么：</p>
<div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p>看见了吗？若去掉 <code>STI</code> 和 <code>CLI</code> ，则会发生 0xd 号异常。这涉及到锁相关的内容，将在下节内容详细介绍。</p>
<p>另外，说说笔者在这里遇见的一个大坑，看下面的 <code>interrupt.s</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的interrupt.s</span></span><br><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>			   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret				   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure>
<p>上面是修改后的 <code>interrupt.s</code> ，也就是现在的版本。而之前，笔者是像下面这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>			   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret				   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure>
<p>嗯？只是处理 EOI 的代码改变了位置，有什么影响吗？影响可大了！前文已经强调，任务调度在时钟中断处理函数(第11行)中进行的，调度完成后直接开始执行任务，并不会返回到中断内并执行末尾的 <code>iret</code> 指令；而中断发生后 CPU 会自动将 IF 位置零来屏蔽外部中断，因此，为了防止任务独占 CPU，任务（即<code>function()</code>)正式开始前还要手动开中断。问题来了，<strong><font color='orange'>8259A 芯片发送中断信号后，必须要收到 CPU 发来的 EOI 结束命令后才会继续发送中断，否则即使你开了中断也没用！</font></strong> 所以，按上面的写法，进入第 11 行时钟中断处理函数后，压根不会执行后面的 EOI 发送代码，时钟中断无法产生，后续的任务调度也就没法进行了！这里坑了笔者两天之久！</p>
<h3 id="font-color-red-链表-font"><font color='red'>链表</font></h3>
<p>双向链表是用来维护任务队列的核心数据结构。数据结构不是本系列博客的重点，所以就不详细展开了，仅强调几个要点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset(struct_type,member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line"><span class="meta">        (struct_type*)((int)elem_ptr - offset(struct_type, struct_member_name))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">prev</span>;</span>  <span class="comment">// 前躯结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">next</span>;</span>  <span class="comment">// 后继结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span>   <span class="comment">//头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span>   <span class="comment">//尾节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数类型function,用于在list_traversal中做回调函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">bool</span> <span class="params">(function)</span><span class="params">(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_iterate</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>offset</code> 宏用来计算结构体内的某成员相对于该结构体起始处的偏移量。这个操作很骚，可以说将指针运用得炉火纯青了：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)(&amp;((struct_type*)<span class="number">0</span>)-&gt;member)</span><br></pre></td></tr></table></figure>
<p>将 0 强制转换为 struct_type* 指针，换句话说，<strong><u>该指针指向 struct_type 类型的结构体，而该结构体位于地址 0x0000 处</u></strong> 。如此一来，由于是以地址 0x0000 为基准，所以该结构体中成员的地址即为此成员相对于该结构体的偏移量。</p>
</li>
<li>
<p><code>elem2entry</code> 宏就好说了，用 tag 指针减去 tag 偏移量即得结构体的起始地址。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag); <span class="comment">//thread.c第114行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么，为什么这两个操作设计成宏而非函数呢？留给读者自己思考。</p>
</blockquote>
</li>
<li>
<p>注意，list 中的 head 是头节点，而非首元节点；尾节点同理；节点只会插在 head 与 tail 之间。</p>
<blockquote>
<p>头节点是一个不存放任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，<strong>它的作用只是为了方便解决某些实际问题</strong> ；<br>
首元节点是链表中第一个存有数据的节点；首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p>
</blockquote>
</li>
<li>
<p>第 19 行，自定义函数类型，该类型在 <code>list_traversal()</code> 中作为回调函数的类型。如果不使用 typedef，那么第 30 行声明就需改成：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="type">bool</span> (func)(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>), <span class="type">int</span> arg)</span>;</span><br></pre></td></tr></table></figure>
<p>显然，这种方式没有上一种方式好看。<code>list_traversal()</code> 函数当前还未使用，后续用到了再介绍。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="comment">/* 初始化双向链表list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = &amp;<span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.prev = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把链表元素elem插入在元素before之前 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    before-&gt;prev-&gt;next = elem;</span><br><span class="line">    elem-&gt;prev = before-&gt;prev;</span><br><span class="line">    elem-&gt;next = before;</span><br><span class="line">    before-&gt;prev = elem;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加元素到列表队首 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(plist-&gt;head.next, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 追加元素到链表队尾 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(&amp;plist-&gt;tail, elem); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使元素pelem脱离链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    pelem-&gt;prev-&gt;next = pelem-&gt;next;</span><br><span class="line">    pelem-&gt;next-&gt;prev = pelem-&gt;prev;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将链表第一个元素弹出并返回,类似栈的pop操作 */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    list_remove(elem);</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == obj_elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把列表plist中的每个元素elem和arg传给回调函数func,</span></span><br><span class="line"><span class="comment"> * arg给func用来判断elem是否符合条件.</span></span><br><span class="line"><span class="comment"> * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的元素返回元素指针,否则返回NULL. */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(plist))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(elem, arg))   </span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        elem = elem-&gt;next;     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回链表长度 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断链表是否为空,空时返回true,否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (plist-&gt;head.next == &amp;plist-&gt;tail ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数都是常规的链表操作，不再解释。</p>
<p>本文结束。经过这两节的煎熬，想必读者朋友们也憔悴了吧？哈哈，休息再战！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app">极简</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jyxcpp.netlify.app" target="_blank">极简</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">自制操作系统</a></div><div class="post_share"><div class="social-share" data-image="/2022/img/27.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="/2022/img/30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浅谈锁机制</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/"><img class="next-cover" src="/2022/img/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">内存管理-进阶-分配页内存</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/" title="32位保护模式概览"><img class="cover" src="/2022/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">32位保护模式概览</div></div></a></div><div><a href="/2022/10/27/bochs%E4%BD%BF%E7%94%A8/" title="bochs虚拟机的使用"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">bochs虚拟机的使用</div></div></a></div><div><a href="/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/" title="对8259a芯片编程"><img class="cover" src="/2022/img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">对8259a芯片编程</div></div></a></div><div><a href="/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/" title="GDT&amp;段描述符&amp;选择子概述"><img class="cover" src="/2022/img/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">GDT&amp;段描述符&amp;选择子概述</div></div></a></div><div><a href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/" title="内存管理-进阶-分配页内存"><img class="cover" src="/2022/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-08</div><div class="title">内存管理-进阶-分配页内存</div></div></a></div><div><a href="/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理-基础-初始化内存池"><img class="cover" src="/2022/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">内存管理-基础-初始化内存池</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E6%A6%82%E8%A7%88-font"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80-font"><span class="toc-number">2.</span> <span class="toc-text">任务调度基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2-font"><span class="toc-number">3.</span> <span class="toc-text">任务切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E9%93%BE%E8%A1%A8-font"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 极简</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ppICFLHVi3M0o7XY5Cntsens-gzGzoHsz',
      appKey: '6qgu3NQ0HfB3CGG9ruP46nAm',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>