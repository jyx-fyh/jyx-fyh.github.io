<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极简</title>
  
  <subtitle>用时间去沉淀</subtitle>
  <link href="http://jyxcpp.netlify.app/atom.xml" rel="self"/>
  
  <link href="http://jyxcpp.netlify.app/"/>
  <updated>2023-04-02T13:59:44.590Z</updated>
  <id>http://jyxcpp.netlify.app/</id>
  
  <author>
    <name>极简</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RST情况汇总</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/RST%E6%83%85%E5%86%B5%E6%B1%87%E6%80%BB/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/RST%E6%83%85%E5%86%B5%E6%B1%87%E6%80%BB/</id>
    <published>2023-04-02T13:19:50.000Z</published>
    <updated>2023-04-02T13:59:44.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/qq_35238352/article/details/106051090">什么时候出现RST</a></p><ol><li><strong><font color='orange'>TCP 接收缓冲区<em>中存在未处理的</em>数据时关闭连接，会向对端发送RST报文。</font></strong></li></ol><p>下面进行实验验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn;</span><br><span class="line">    sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">//等待10秒,确保接收缓冲区已收到100000字节</span></span><br><span class="line">    close(sock_conn);<span class="comment">//不read,直接关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//发送100000字节</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先后运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="../../public/2022/img/image-20230402215357889.png" alt=""></p><p>直接看倒数第二项，server 回复的 ACK = 100001，说明 server 端的缓冲区已经接收了这 100000 字节，但由于没有读取（read）缓冲区就关闭（close）套接字，因此向 client 发出了 RST，即最后一项。</p><p>那么我们为 server 加上 read，读取这 100000 字节后再 close，结果如下：<br><img src="../../public/2022/img/image-20230402215925109.png" alt=""><br>这次就是标准的四次挥手啦！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用socket选项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/</id>
    <published>2023-04-02T12:38:14.000Z</published>
    <updated>2023-04-07T06:37:51.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-获取和设置socket选项-font"><font color='red'>获取和设置socket选项</font></h2><p>使用 <code>getsockopt()</code> 和 <code>setsockopt</code> 来获取和设置 socket 的各种选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(bufsize);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span> <span class="params">(<span class="type">int</span> socket,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">void</span> *option_val,</span></span><br><span class="line"><span class="params">                <span class="type">socklen_t</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</span><br></pre></td></tr></table></figure><ul><li><strong>以上两个函数，成功时均返回 0，出错则返回 -1</strong> 。</li><li>关于第二个和第三个参数，参见《UPN》第 151 页。</li></ul><p>注意，细心的朋友可能已经注意到：上面的例子中，作用的套接字是 sock_listen，即监听套接字。那么，能不能作用于已连接套接字呢？好问题！是这样的，<strong><font color='orange'>以下几个选项是由已连接套接字从监听套接字继承而来：</font></strong> <strong><font color='red'>SO_KEEPALIVE、SO_LINGER、SO_RECVBUF、SO_SNDBUF、SO_RCVLOWAT、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY</font></strong> 、SO_DEBUF、SO_DONTROUTE、SO_OBBINLINE （红色标记为重点选项）。所以，在这几个选项上设置监听套接字，将影响后面的所有已连接套接字。<u>作为对比，getpeername() 函数就必须要作用于已连接套接字</u>。</p><h2 id="font-color-red-SO-RCVBUF-和-SO-SNDBUF-font"><font color='red'>SO_RCVBUF 和 SO_SNDBUF</font></h2><p>这是两个重要的选项。要弄清楚这两个选项，就必须先搞明白 Socket 的缓冲区机制。下面总结了 Socket 缓冲区的关键特性：<br><img src="/2022/img/IMG_0579(20230406-190556).PNG" alt=""></p><ul><li><strong><font color='gree'>每个套接字都有独立的输入/输出缓冲区。</font></strong></li><li><strong><font color='gree'>创建套接字时，自动生成缓冲区。</font></strong></li><li><strong><font color='gree'>如果要写（write）的数据大于发送（输出）缓冲区的最大长度，那么将分批写入。</font></strong></li><li><strong><font color='gree'>如果发送缓冲区全满（分批写入也不能进行），则进程被阻塞（假设套接字是阻塞模式）。</font></strong></li><li><strong><font color='gree'>发送缓冲区的数据将一直保存（以便重发），直到接收到相应 ACK。</font></strong></li><li><strong><font color='gree'>接收（输入）缓冲区的数据将一直保存，直到应用层读取（read）。</font></strong></li><li><strong><font color='gree'>接收缓冲区若满，则直接抛弃新数据（不发送其他任何信息，等待对面重传）。</font></strong></li><li><strong><font color='gree'>TCP 接收窗口大小 &lt;= 接收缓冲区大小。</font></strong></li></ul><blockquote><p>以上几个特性的实验，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">网络数据读取的常见问题</a> ，建议浏览，加深理解。</p></blockquote><p><strong><font color='red'>SO_RCVBUF 直接限制本端 TCP 接收窗口的大小</font></strong> 。下面进行实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF,(<span class="type">void</span>*)&amp;recv_size,&amp;optlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server recv buffer size: %d\n&quot;</span>,recv_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不read,不close</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行运行 server 和 client 后，server 的接收缓冲区的大小为 6000：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server recv buffer size: <span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将 recv_size 设置的为 3000，而实际反馈为 6000，<strong>说明 recv_size 只是一个建议值，操作系统会根据一定条件进行修改（×2）</strong> 。在笔者操作系统上，接收缓冲区最小为 2304 。</p></blockquote><p>然后我们使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230403111812767.png" alt=""></p><p>看第二项，server 发送的 SYN 报文中，<strong>win 为 3000，和我们设置的 SO_RECVBUF 大小相同</strong> ，但这并不意味着窗口大小就一定等于 SO_RECVBUF。<strong><u><font color='gree'>接收窗口会随着网络状况而不断调整，但肯定不会超过缓冲区的大小</font></u></strong> 。</p><blockquote><p>在本机上实验多次发现，<strong>接收窗口始终不会超过接收缓冲区的一半大小</strong> 。</p></blockquote><p>还有以下几点需要注意：</p><ol><li>上面说过，这两个选项是由监听套接字继承而来，<strong><u><font color='orange'>所以对于 server，必须在 listen 前设置选项；对于 client，必须在 connect 前设置选项</font></u></strong> 。对已连接套接字（在 accept 返回之后）设置选项没有任何作用，因为 accept 只是从已连接队列中取出一个连接而已（参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a>）。</li><li>为了避免潜在的缓冲区空间浪费，接收缓冲区大小应该为 MSS 的整数倍，且至少为 MSS 的 4 倍，参见《UNP》P163。</li><li><strong><font color='orange'>为了最大化性能，缓冲区大小应该约等于带宽-延迟积</font></strong> ，参见《UNP》P164 。</li></ol><h2 id="font-color-red-SO-RCVLOWAT-和-SO-SNDLOWAT-font"><font color='red'>SO_RCVLOWAT 和 SO_SNDLOWAT</font></h2><p>这两个选项作用于 select/poll/epoll，目的在于减少网络 I/O 的次数。<code>SO_RCVLOWAT</code> 指定接收缓冲区中的数据量必须达到多少时，才会唤醒 select/poll/epoll 去读取数据；<code>SO_SNDLOWAT</code> 指定当发送缓冲区的<u>空闲空间</u>大于低水平位标记时，将唤醒 select/poll/epoll 写数据到socket 。</p><h2 id="font-color-red-SO-REUSEADDR-font"><font color='red'>SO_REUSEADDR</font></h2><p>这是服务器最常用的选项之一。该选项有以下几个作用：</p><ol><li><p>可以在 TIME_WAIT 期间重新绑定该端口，这对服务器崩溃重启并快速恢复有至关重要的作用，避免了几十秒甚至几分钟的等待。</p><blockquote><p>需要注意的是，如果没有开启时间戳选项（默认开启），则 TIME_WAIT 期间重新绑定<u>可能</u>失败，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT探究</a>。</p></blockquote></li><li><p>允许在已连接的状态下重新绑定该端口，常见情景如下：<br>a）启动监听进程<br>b）连接请求到达，派生一个子进程处理该连接<br>c）监听进程崩溃，子进程仍在运行<br>d）重启监听进程，并绑定之前的端口</p></li><li><p>运行在同一个端口启动多个监听程序，前提是每个程序绑定的本地 IP 不同（IP 别名）</p><blockquote><p>笔者在本机上实验，分别绑定环回地址 <code>127.0.0.1</code> 和本机地址，两者可以同时绑定同一个端口。如果未开启 SO_REUSEADDR，则无法同时绑定。</p></blockquote></li><li><p>其他作用不常见，详见《UNP》P166</p></li></ol><p><strong><font color='orange'>另外注意，不论是否开启该选项，不同传输层协议是可以同时绑定到同一端口的，比如 TCP 和 UDP 程序就能够同时绑定到一个端口。</font></strong></p><p><strong><font color='red'>注意，对于所有 TCP 服务器，都应该在 bind 前开启 SO_REUSEADDR ！</font></strong></p><blockquote><p>另外，还有一个 <code>SO_REUSEPORT</code> 选项，不常用，参见《UNP》P165</p></blockquote><h2 id="font-color-red-SO-LINGER-font"><font color='red'>SO_LINGER</font></h2><p><code>SO_LINGER</code> 用来控制 close 的行为：<br><img src="/2022/img/image-20230407141037746.png" alt=""><br><img src="/2022/img/image-20230407141059416.png" alt=""><img src="/2022/img/IMG_0580(20230407-134909).PNG" alt=""></p><p><strong><u>注意缓冲区的各种情况。前三种情况须熟记于心！</u></strong> 另外，书中提供了一种有效办法，使发送端能够确认接收端的<u>应用层</u>已收到数据，详见《UPN》P161。</p><p><strong>另外有个细节，上图中 SHUT_RD 后，接收到的任何数据都会被丢弃，这里的丢弃是先确认再丢弃，也就是说，这不会引发对方的重传。</strong></p><h2 id="font-color-red-TCP-NODELAY-font"><font color='red'>TCP_NODELAY</font></h2><p>此选项用来禁止 Nagle 算法。关于 Nagle 算法，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">TCP流量控制</a> 。 有时候我们必须要关闭 Nagle 算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>]]></content>
    
    
    <summary type="html">常用socket选项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>wireshark入门笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-02T03:35:43.000Z</published>
    <updated>2023-04-02T11:13:00.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>学习 wireshark 前需要先了解 tcpdump，<strong>许多情况下我们使用 tcpdump 抓包（更快速、更方便），然后使用 wireshark 进行分析</strong> 。可参见 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump实操</a><br>环境：Ubuntu 16.04 LTS</p></blockquote><hr><h2 id="font-color-red-安装-wireshark-font"><font color='red'>安装 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install wireshark-qt</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-启动-wireshark-font"><font color='red'>启动 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wireshark</span></span><br></pre></td></tr></table></figure><p>启动后显示如下界面：<br><img src="/2022/img/image-20230402115238469.png" alt=""></p><p>发现没有我们想要的网卡。如何知道哪块网卡是我们想要的？打开命令行终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4331 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3064 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2400943 (2.4 MB)  TX bytes:462038 (462.0 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1249 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1249 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:121848 (121.8 KB)  TX bytes:121848 (121.8 KB)</span><br></pre></td></tr></table></figure><p><code>ens33</code> 就是可用网卡（<code>lo</code> 是环回接口，不用管）。</p><p>没有显示 <code>ens33</code> 是因为操作权限问题。重新以管理员身份运行 wireshark：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo wireshark</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230402115430627.png" alt=""></p><p>成功显示 <code>ens33</code> ，<strong><u>双击该选项</u></strong> ，进入 wireshark 抓包页面。</p><hr><h2 id="font-color-red-捕获过滤器-font"><font color='red'>捕获过滤器</font></h2><p>捕获过滤和显示过滤器是 wireshark 的两种主要过滤方式，但二者机制完全不同。前者是指示 wireshark 只捕获满足一定要求的报文，而后者则是在已经捕获到的报文中筛选出满足进一步要求的报文。捕获过滤器在打开 wireshark 时设置：</p><p><img src="/2022/img/image-20230402151407256.png" alt=""></p><p>或者打开 wireshark 后，在设置页面操作：<br><img src="/2022/img/image-20230402151634036.png" alt="注意，需要先停止捕获才可设置"></p><p>配置捕获规则的语法和 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump</a> 相同，这里不再赘述。</p><blockquote><p>建议：某些时候无需设置太过具体的条件，以免不利于网络错误排查。比如你要求只接收 TCP 报文，但 TCP 连接出错时可能会产生 ICMP 报文来传达错误信息，而这却被你给屏蔽了…</p></blockquote><hr><h2 id="font-color-red-显示过滤器-font"><font color='red'>显示过滤器</font></h2><p>显示过滤在捕获网络报文后进行：<br><img src="/2022/img/image-20230402152619594.png" alt=""></p><p>显示过滤的语法和 tcpdump 完全不同。详细语法参见<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html">wireshark manual</a></p><hr><h2 id="font-color-red-名称解析-font"><font color='red'>名称解析</font></h2><p><img src="/2022/img/image-20230402163513811.png" alt=""><br><img src="/2022/img/image-20230402163636148.png" alt=""></p><ul><li>选项 1：将 MAC 地址解析为名称。</li><li>选项 2：将著名端口号解析为协议名，如，将端口号 80 解析为 http 。</li><li>选项 3：将 IP 解析为域名。</li><li>选项 4：如果将 IP 解析为域名，则只利用已经抓到的包来解析，不另外专门进行 DNS 查询。</li><li>选项 5：如果无法从已抓到的报文解析 IP，则另外进行 DNS 查询。这会影响速度，一般不开。</li></ul><p>已经解析的名字可以通过以下方式找到：<br><img src="/2022/img/image-20230402165754095.png" alt=""></p><p>另外，你也可以自己命名一些 IP 地址：<br><img src="/2022/img/image-20230402165953271.png" alt=""><br>自己命名的 IP 也会被加入到上面的 Resolved Address 栏目中。</p><hr>]]></content>
    
    
    <summary type="html">wireshark入门笔记</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump实操</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/tcpdump/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/tcpdump/</id>
    <published>2023-03-21T08:34:40.000Z</published>
    <updated>2023-04-02T05:37:33.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-tcpdump-font"><font color='red'>tcpdump</font></h2><blockquote><p><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man</a></p></blockquote><p>tcpdump 须在管理员权限下运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump</span></span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><ul><li>输出结果表明 tcpdump 的监听网卡为 <code>ens33</code> 。</li><li>默认截断大小为 262144 字节（随版本而改变），超过该数字报文会被截断。</li></ul><p>使用 <code>ifconfig</code> 查看其他网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12058 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4911 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:9115911 (9.1 MB)  TX bytes:577567 (577.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1110 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1110 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:1022006 (1.0 MB)  TX bytes:1022006 (1.0 MB)</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-i 指定网卡</mark> </strong></p><p>上面默认监听网卡是 <code>ens33</code> ，我们也可以指定为 <code>lo</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump -i lo</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><p><code>-i any</code> 可以监听所有网卡。</p><hr><p><strong><mark class="hl-label blue">-nn 直接显示IP和端口号</mark> </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcpdump -i lo</span></span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">01:12:54.640796 IP localhost.44438 &gt; localhost.12345: Flags [S], <span class="built_in">seq</span> 1028792545, win 65495, options [mss 65495,sackOK,TS val 1381449987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640834 IP localhost.12345 &gt; localhost.44438: Flags [S.], <span class="built_in">seq</span> 3925511357, ack 1028792546, win 65483, options [mss 65495,sackOK,TS val 1381449987 ecr 1381449987,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640870 IP localhost.44438 &gt; localhost.12345: Flags [.], ack 1, win 512, options [nop,nop,TS val 1381449987 ecr 1381449987], length 0</span><br></pre></td></tr></table></figure><p>监听环回网卡时，我们运行自己编写的简易 TCP 服务器端和客户端的回射程序，结果输出以上三次握手内容。其中主机地址为 <code>localhost</code> ，由于 server 和 client 都在一台主机，所以都为 <code>localhost</code> 。如果服务器的端口为著名端口（如 ssh 为 22 号端口），那么 22 也会显示为 ssh。若想直接显示 IP 和端口号，则使用 <code>-nn</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn</span></span><br><span class="line">01:14:54.615811 IP 127.0.0.1.44438 &gt; 127.0.0.1.12345: Flags [P.], seq 1028792546:1028792548, ack 3925511358, win 512, options [nop,nop,TS val 1381569983 ecr 1381449987], length 2</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-n 不将IP转换为域名</mark> </strong></p><p>不讲 IP 转为域名，则可以省去 DNS 查询，输出速度会快很多。</p><hr><p><strong><mark class="hl-label blue">过滤主机</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源地址是 192.168.1.1 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定源地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定目的地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>也可直接指定域名：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dest host <span class="string">&quot;baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">过滤端口</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源端口是 25 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定源端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定目的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure><ul><li><p>指定端口范围：portrange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo portrange 10000-20000</span></span><br></pre></td></tr></table></figure></li><li><p>对于著名端口，可直接用应用层协议替代，相当于宏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump port http</span> </span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">网段过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst net 192.168.0.0/16</span>  </span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">协议过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump arp</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump ip</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump tcp</span>  </span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不能直接过滤协议,如下</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump http</span>  </span><br></pre></td></tr></table></figure><p>而应该</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump port http</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">常用表达式</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非 : ! 或 not </span><br><span class="line">且 : &amp;&amp; 或 and  </span><br><span class="line">或 : || 或 or</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp &amp;&amp; dst port 12345 &amp;&amp; src host 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp and dst port 12345 and src host 127.0.0.1</span></span><br></pre></td></tr></table></figure><p>有时条件比较复杂的需要用括号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 <span class="string">&#x27;((tcp) and (! port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))&#x27;</span></span></span><br><span class="line">抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200,并且端口不是80的TCP数据</span><br></pre></td></tr></table></figure><p><strong>如果使用括号，则整个表达式需要用 <code>''</code> 或 <code>&quot;&quot;</code> 包住。</strong></p><hr><p><strong><mark class="hl-label blue">包头过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（从第0字节开始）</span><br><span class="line">proto[x:y] &amp; z = 0  : proto[x:y]和z的与操作为0</span><br><span class="line">proto[x:y] &amp; z !=0  : proto[x:y]和z的与操作不为0</span><br></pre></td></tr></table></figure><p><strong>IP报头格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    0                   1                   2                   3</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1   \bit</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0   |Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4   |         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">12  |  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16  |                       Source Address                          |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20  |                    Destination Address                        |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24  |                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">28  |                            DATA ...                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><p><strong>TCP报头格式：</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   0                   1                   2                   3</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \bit</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0  |          Source Port          |       Destination Port        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4  |                        Sequence Number                        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">8  |                    Acknowledgment Number                      |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">12 | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">   |       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16 |           Checksum            |         Urgent Pointer        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20 |                    Options                    |    Padding    |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24 |                             data                              |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;tcp[2:2]=12345&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的报文</span><br></pre></td></tr></table></figure><p><strong>TCP标记定义在TCP头的第 13 个字节：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;src port 12345 &amp;&amp; tcp[13]&amp;1 = 1&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的FIN报文</span><br></pre></td></tr></table></figure><p>TCP标记宏可以替代数值：</p><p><code>tcpflags</code> , <code>tcp-fin</code> , <code>tcp-syn</code> , <code>tcp-rst</code> , <code>tcp-push</code> , <code>tcp-push</code> , <code>tcp-ack</code> , <code>tcp-urg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;dst port 12345 &amp;&amp; tcp[tcpflags]&amp;tcp-fin=tcp-fin&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-w 输出到文件、-r 读取文件</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -w test.cap</span></span><br></pre></td></tr></table></figure><p>把信息输出到 test.cap 文件。将文件保存为 <code>cap</code> 或 <code>pcap</code> 类型就能方便地使用 wireshark 打开并分析：<br><img src="/2022/img/image-20230401192959234.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap</span></span><br></pre></td></tr></table></figure><p>读取 <code>test.cap</code> 文件并打印在终端，同时也可以使用过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap port 12345</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">输出时间</mark> </strong></p><ul><li><code>-t</code>：在每行的输出中不输出时间</li><li><code>-tt</code>：在每行的输出中会输出时间戳</li><li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li><li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -t dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1650, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">1680352032.093467 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1662, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -ttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line"> 00:00:00.000000 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1672, length 64</span><br><span class="line"> 00:00:01.002438 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1673, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">2023-04-01 05:27:30.131073 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1680, length 64</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-v 展示详细信息</mark> </strong></p><p><code>-v</code>：产生详细的输出。比如包的TTL，id标识，数据包长度，以及IP包的一些选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/butcher/Documents# tcpdump -v dst  &quot;baidu.com&quot;</span><br><span class="line">tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">05:36:46.543701 IP (tos 0x0, ttl 64, id 44013, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 12115, seq 7, length 64</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-c 指定接收报文个数</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -v -c 3</span> </span><br><span class="line">05:46:32.275269 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.248.2 tell 192.168.248.1, length 46</span><br><span class="line">05:46:32.276545 IP (tos 0x0, ttl 64, id 50690, offset 0, flags [DF], proto UDP (17), length 72)</span><br><span class="line">    192.168.248.128.34566 &gt; 192.168.248.2.domain: 39118+ PTR? 2.248.168.192.in-addr.arpa. (44)</span><br><span class="line">05:46:32.280758 IP (tos 0x0, ttl 128, id 35219, offset 0, flags [none], proto UDP (17), length 127)</span><br><span class="line">    192.168.248.2.domain &gt; 192.168.248.128.34566: 39118 NXDomain 0/1/0 (99)</span><br><span class="line">3 packets captured</span><br></pre></td></tr></table></figure><p>抓满指定数量的报文后自动停止。</p><p><strong><mark class="hl-label blue">-C -W 分文件写入</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -C 1 -W 4 -w <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>-C 和 -w 配套使用，后者将抓包情况写入文件，前者指定每个文件的最大大小，单位为 1MB（小文件利于分析）。</p><ul><li><code>-C 1</code> ：指定单个文件最大为 1MB</li><li><code>-W</code> ：指定最多写 4 个文件</li><li><code>-w</code> ：写入文件</li></ul><p>每个文件会依次添加后缀：test1、test2、test3、test4 。<strong><u>注意，如果写满这 4 个文件后，数据还在持续，那么会重新覆盖这 4 个文件并继续写入，而不会新建文件。</u></strong></p><hr><p><strong><mark class="hl-label blue">-Q 指定方向</mark> </strong></p><ul><li>-Q in ：只显示收到的数据</li><li>-Q out ：只显示发出的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -Q <span class="keyword">in</span></span></span><br><span class="line">06:04:34.157713 IP 192.168.248.1.50277  &gt; 239.255.255.250.1900: UDP, length 175</span><br><span class="line">06:04:34.163603 IP 192.168.248.2.domain &gt; 192.168.248.128.34566: 27092 NXDomain 0/1/0 (103)</span><br><span class="line">06:04:35.003369 IP 180.101.49.186.https &gt; 192.168.248.128.33644: Flags [.], ack 769671203, win 64240, length 0</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-s 指定截取大小</mark> </strong></p><p><code>-s</code> 指定每个包捕获的长度、单位是 byte，而不是默认的 262144 字节；如果超过了设定的大小限制，包就会被截断，并在打印行出现[|proto]这种标识，这个proto就是被截断的报文的协议名字。但是抓取越长，包的处理时间越长，并且会减少 tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好，<strong><u>一般只抓报头</u></strong> ，抓 80 个字节一般就能包含 TCP 层、IP 层、链路层。</p><p><code>-s 0</code> 使用默认长度 262144。</p><p><strong><mark class="hl-label blue">-e 显示链路层信息</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump  -e</span> </span><br><span class="line">06:49:36.315000 00:0c:29:48:09:a9 (oui Unknown) &gt; 00:50:56:fb:6d:e0 (oui Unknown), ethertype IPv4 (0x0800), length 54: 192.168.248.128.33644 &gt; 180.101.49.186.https: Flags [.], ack 565954419, win 65535, length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-F 指定过滤过滤表达式文件</mark> </strong></p><p>有些过滤表达式经常用，但又很冗长，每次输入都很麻烦。所以可以保存为文件，每次 tcpdump 时指定该文件为过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -F filter_file</span></span><br></pre></td></tr></table></figure><p>该命令行中的其他命令会被忽略。</p><hr><p><strong><mark class="hl-label blue">less，greater 指定大小</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump less 100</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-X 打印数据内容</mark> </strong><br><code>-X</code> 除了打印每个数据包的头之外，还可以用十六进制和ASCII打印每个数据包的数据（不包括链路级头，<code>-XX</code> 可包含）：<br><img src="/2022/img/image-20230402084531352.png" alt=""></p>]]></content>
    
    
    <summary type="html">常用网络命令和抓包工具</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>多种I/O函数分析&amp;网络数据读取的常见问题</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-21T08:31:41.000Z</published>
    <updated>2023-04-03T11:41:16.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《UNIX网络编程》《UNIX环境高级编程》《TCP/IP编程》、<a href="http://c.biancheng.net/view/2349.html">socket阻塞模式</a></p></blockquote><h2 id="font-color-red-read-font"><font color='red'>read</font></h2><p><img src="/2022/img/IMG_0576(20230325-120322).PNG" alt=""></p><blockquote><p><code>ssize_t</code> 是有符号整型 long；<code>size_t</code> 是无符号整型 unsigned long</p></blockquote><p>对于 read 和 write 这类 <strong>低速系统调用（即可能使进程永远阻塞下去的系统调用）</strong> ，当执行期间捕捉到信号，则该系统调用就会被中断不再执行，且返回 -1，并将 errno 设置为 -1。为什么呢？有这样一个常见的场景：网络中，由于不知道对端网络具体会发来多大的包，所以我们会让 read 尽可能多地接收数据，即把其第三个参数设置大些。那么问题来了，对端只发送了 1000 字节的数据，而你却指定本端的 read 读取 10000 字节，那怎么办？总不能一直阻塞下去吧？所以此时就需要用到信号，来中断 read 使其结束。</p><blockquote><p>至于 read 在读取数据时是被什么信号中断的，笔者也没有查到相关资料，知晓的读者还请在评论区指点一二。</p></blockquote><p><strong><font color='orange'>需要注意的是，TCP 套接字上的 IO 表现的行为不同于通常的磁盘 IO。</font></strong> <strong><u>磁盘 IO 一般不会被信号打断而终止，因为磁盘 IO 与网络 IO 的区别在于：前者的 IO 量是可以确定的，虽然可能会暂时阻塞调用者，但只要把指定量的数据处理掉就 OK，任务很明确；而网络 IO 一般不知道具体的 IO 量，就像上面的场景一样，所以必须在某个时刻终止 IO（终端 IO 也是如此，计算机不知道用户可能会输入多少数据）。除非发生硬件错误，否则磁盘 IO 总会很快返回</u></strong> 。</p><p>对于被中断的 read，<u>早期实现</u>是：如果 read 已接收部分数据到应用缓冲区，但还未接收到应用程序请求的所有数据（即 read 的第三个参数），则操作系统会认为本次 read 调用失败，返回 -1，errno 被设置为 EINTR 。<strong><font color='orange'>目前的 POSIX 标准采用的方式是：如果 read 只接收了部分数据就被信号中断，那么也算成功，且返回已接收的字节数，errno 不修改</font></strong> 。</p><blockquote><p><strong><font color='gree'>这就是为什么在 Socket 编程中，往往将 read 函数放在循环中的原因！</font></strong> 大多数书籍将其归咎于 Socket 的缓冲机制，实际上这只是原因之一。也有许多人认为 read 只将接收缓冲区读一次就返回，当请求的数据量大于接收缓冲区时，read 返回值就当然会小于请求的字节数，这种说法更不准确。做个实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> rcv_buf=<span class="number">1000</span>; <span class="comment">//系统会调整接收缓冲区大小,本例中被调整为2304</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server rcv_buf : %d\n&quot;</span>,rcv_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">int</span> snd_buf =<span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client snd_buf : %d\n&quot;</span>,snd_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后 server 的结果如下：<br><img src="/2022/img/image-20230324152945053.png" alt=""></p><p>你看，server 的接收缓冲区大小被修改为 2304 字节，但却 read 了 65482 字节，大于 2304，说明不止读取一次缓冲区；小于请求值 100000，说明 read 还没有读完对面发送的 10000 字节就被信号中断。</p></blockquote><p>所以得出一个重要结论：如果 read 返回值小于请求值，说明有两种情况：</p><ol><li><strong>提前收到了 EOF。</strong></li><li><strong>被信号中断。</strong></li></ol><p>第一种情况说明数据已经接收完，第二种情况则还需要重新调用 read 才能将数据接收完毕。我们可以使用自己的包裹函数 readn 一次性将数据读完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* tmp = buf;</span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, tmp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nread == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">//被信号打断,则继续循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        tmp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不过需要注意，readn 可能会一直阻塞</font>，因为正常情况下它只会在接收到 EOF 或者读满 n 字节才会返回；而 read 不同，read 收到 EOF 、读满 n 字节或者被信号中断（没读满）时就能返回</strong> 。所以当发送的字节数小于请求的字节数时，readn 就会被阻塞，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    writen(sock_clnt,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//while停住,以免关闭套接字发送EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上程序时，服务器不会显示客户端发来的消息，因为 readn 要求读满 1000 或者读到 EOF。当把 readn 改成 read，就能成功显示消息了。解决这个问题的办法之一是设计应用层协议，比如在包头说明本包的大小，这方面内容后续补充。</p><p><strong>recv 的第四个参数可以选 MSG_WAITALL 标志来阻止这种行为，当 flags 为 MSG_WAITALL 时，recv 会阻塞直到所指定的长度 nbytes 字节的数据全部返回，recv 才会返回。</strong></p><h2 id="font-color-red-write-font"><font color='red'>write</font></h2><p><strong>不同于 read，作用于字节流套接字时，输出字节比请求的字节少这种情况仅在非阻塞前提下才会发生</strong> 。</p><p>调用 write 时，如果套接字的发送缓冲区容不下请求量，那么 write 被阻塞，直到缓冲区中的数据被发送到对端，腾出足够的空间，才唤醒 write 函数继续写入数据。有以下几个要点需要注意：</p><ol><li><strong>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</strong></li><li><strong>发送缓冲区中的数据必须保留，直到对端回复相应的 ACK（这是由内核自动完成的）。</strong></li><li><strong>接收缓冲区的数据将一直保留，直到应用层读取（read）。</strong></li><li><strong>write 函数的返回只说明应用层的数据已经全部转移到输出缓冲区，这不代表对方已经收到所有数据。</strong></li></ol><p>让我们做几个实验来验证上面的结论。</p><p><strong><mark class="hl-label blue">实验一</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">100000</span>; <span class="comment">//设置接收缓冲区,系统会调节该值,可能为200000</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">1000</span>; <span class="comment">//系统会调节该值,可能为3000左右</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> size = write(sock_clnt,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，<strong>立刻</strong> 输出结果，client 发送 100000 字节，server 接收 100000 字节。这说明即使我们将 client 的发送缓冲区设置为 1000，数据也会分批发送。结论一得证。</p><p><strong><mark class="hl-label blue">实验二</mark> </strong></p><p>将上面代码 server 的接收缓冲区改为 1000，运行程序，<strong>等待几秒后</strong> 输出结果，两方仍是 100000 字节。这说明接收缓存区虽小，但由于应用层一直在读取数据（readn），所以接收缓冲区可以不断地丢弃旧数据、接收新数据，直到收到所有数据。</p><p>继续，修改 14~22 行代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf_size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//循环,不close套接字</span></span><br></pre></td></tr></table></figure><p>即，不从接收缓冲区读取数据，同时不 close 套接字。close 套接字可能导致缓冲区的一系列动作，不利于我们进行实验。</p><p>运行程序，<strong>两端都陷入阻塞</strong> 。这说明由于接收缓冲区没有被 read，数据一直积压，因此无法接收 client 发来的数据，也就不能回复 ACK；而 client 因为没有收到 server 回复的 ACK ，所以发送缓冲区不能接收应用层的新数据，以至于在 write 中阻塞。结论 2、3 得证。</p><p><strong><mark class="hl-label blue">实验三</mark> </strong></p><p>在实验二的基础上，把 client 的发送缓冲区改为 100000 字节，运行程序。client 立刻输出 <code>100000</code> 。表明 client 成功向发送缓冲区写入 100000 字节，并立刻从 write 返回。但 server 的接收缓冲区只有 1000 字节的大小，不可能接收完这 100000 字节。因此，结论 4 得证。</p><hr>]]></content>
    
    
    <summary type="html">网络数据读取的常见问题</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三握四挥异常处理</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2023-03-21T01:24:17.000Z</published>
    <updated>2023-04-07T06:12:05.921Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">全连接与半连接队列</a> 、<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪</a></p></blockquote><p><strong><mark class="hl-label blue">什么情况下会丢弃SYN报文？</mark> </strong></p><p>有两种情况是可以确定的：</p><ol><li><strong>半连接队列已满，且没有开启 SYN-Cookie</strong></li><li><strong>全连接队列已满</strong></li></ol><p><strong><font color='orange'>情况一验证：</font></strong></p><blockquote><p><strong>在笔者环境下（Ubuntu 16.04），半连接队列的长度等于全连接长度，即为 <code>min(somaxconn,backlog)</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>); <span class="comment">//backlog为5,则全连接队列容量为6,半连接队列为5</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将 SYN-Cookie 设置为 0（默认为 1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//须在管理员身份下运行</span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/tcp_syncookies </span><br></pre></td></tr></table></figure><blockquote><p>0 值，表示关闭该功能；<br>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；<br>2 值，表示无条件开启功能；</p></blockquote></li><li><p>运行 server 端。</p></li><li><p>运行 hping3，发起 SYN 洪水攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机,即伪造</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><p>发送了 1000 个<u>虚假</u> SYN 报文，而半连接队列中只有 5 个连接（满），说明其他 SYN 确实是被服务端丢弃了。那么如果开启了 SYN-Cookie 会怎么样呢？继续实验：</p><ol><li><p>将 SYN-Cookie 设置为 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>运行 server 端和 hping3</p></li><li><p>查看 SYN_RECV 状态的个数，仍然为 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>查看 ESTABLISHED 状态的个数，为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | wc -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>运行客户端，并查看 ESTABLISHED 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p>这里显示为 12，实际上为 6，这是因为服务器端和客户端都在一个主机上，netstat 命令分别以服务器和客户端的角度进行了输出，所以算重复了一次。<br>已连接状态数为 6 的原因请参见前置文章，这里不再赘述。</p></blockquote></li></ol><p><strong><font color='gree'>所以，若半连接队列已满，且没有开启 SYN-Cookie ，则丢弃 SYN 报文。开启 SYN Cookies 后，就可以在不经过半连接队列的情况下成功建立连接：</font></strong><br><img src="/2022/img/39-1679303729834-1-1679373170821-1.jpg" alt=""></p><p><strong><font color='orange'>情况二验证</font></strong></p><ol><li><p>先后运行服务器端和客户端</p></li><li><p>分别查看 ESTABLISH 和 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>可见，当全连接队列满了后，半连接队列也不再接受 SYN</strong> 。</p></li></ol><p>追问：如果全连接队列仅还有一个空位，那么半连接队列也只会接收一个 SYN 吗？继续实验：</p><ol><li><p>修改 client 的第 23 行代码，将 10 改为 5，即发起 5 次连接（全队列容量为 6，这样就能余下一个空位）</p></li><li><p>先后运行 server 和 client</p></li><li><p>查看 ESTABLISHED 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>即，有 5 个连接已经完成建立，全队列余下一个空位。</p></li><li><p>运行 hping3，并查看 SYN_RECV 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>发现半连接队列也已经满员。</p></li></ol><p>综合以上两种情况，得到下面的流程图：<br><img src="/2022/img/aha.png" alt=""></p><hr><ul><li>主机崩溃</li><li>主机关机</li><li>进程崩溃</li></ul><p>其他情况后续补充。</p><ul><li><p>《UNP》p160</p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/293731">https://bbs.huaweicloud.com/blogs/293731</a></p></li></ul>]]></content>
    
    
    <summary type="html">三次握手和四次挥手的异常处理</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>半连接与全连接队列</title>
    <link href="http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
    <id>http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</id>
    <published>2023-03-20T10:39:37.000Z</published>
    <updated>2023-03-21T04:08:03.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《UNIX网络编程》、<a href="https://blog.csdn.net/qq_42877870/article/details/105027743">hping3命令使用</a>、<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">小林网络</a>、<a href="https://www.51cto.com/article/687595.html">51CTO</a></p></blockquote><p><strong>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</strong> 。前者又称半连接队列、SYN队列，后者又称全连接队列、accept 队列。</p><p>半连接队列：服务器收到客户端发来的 SYN 报文后，将该连接存入此队列中。这些连接处于 SYN_RCVD 状态。<br>全连接队列：服务端收到第三次握手的 ACK 后，该连接被内核从半连接队列转移到全连接队列，此时已经完成三次握手，处于  ESTABLISHED 状态。当调用 accept 函数时，该连接将从全连接队列中移除。</p><hr><p><strong><mark class="hl-label blue">backlog</mark> </strong></p><p><strong>“backlog的含义从未有过正式的定义”，不同的 UNIX 操作系统对其有不同的实现</strong> 。这里只以笔者的环境 Ubuntu 16.04 进行说明。</p><blockquote><p>其他版本的相关说明请参见《UNP》第 3 版 84 页。</p></blockquote><p><strong>先说结论：</strong></p><p><strong><font color='orange'>在 Linux 内核 2.2 之后，<code>backlog</code> 参数影响全连接队列的长度， <code>tcp_max_syn_backlog</code> 作为系统变量则影响半连接队列的长度</font></strong> 。</p><blockquote><p>为什么说“影响”而不是“决定”？因为两个队列长度的具体定义是采用的如下方式：</p><ul><li><strong><code>全连接队列长度 = min(somaxconn, backlog)+1</code></strong></li><li>半连接队列的长度计算较为复杂，且不同版本的操作系统实现不一样，故没有必要掌握其计算方法。<strong><font color='orange'>只需要知道，半连接队列长度可能同时取决于 <code>backlog</code> 、<code>somaxconn</code> 和 <code>tcp_max_syn_backlog</code> ，这三者越大，则半连接队列容量越大</font></strong> 。</li></ul><p><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值。</p></blockquote><p><strong>下面就全连接队列进行 <code>backlog</code> 的实验。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意,没有accept和close</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个客户进程并发送连接请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">            close(sock_clnt);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行以上代码，结果如下：<br><img src="/2022/img/image-20230319223902516.png" alt=""></p><p><strong><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可</strong> 。可以看到，10 条连接中，只有 6 条是 ESTABLISHED 状态，剩下 4 条是 SYN_SENT 。很奇怪，我们指定的 <code>backlog</code> 是 5，所以不应该只有 5 条是 ESTABLISHED 状态吗？嗯，这里挺坑的，<u><strong>这是因为大多数操作系统的实现都为 <code>backlog</code> 引入了 <font color='orange'>模糊因子</font></strong></u> ，我们这里的模糊因子就是 +1，也就是说，<code>实际全连接队列容量 = backlog + 1</code> 。其他操作系统的模糊因子参考：<br><img src="/2022/img/IMG_0575(20230319-224643).PNG" alt=""></p><blockquote><p>关于更多模糊因子的描述，参见《UNP》85~87 页。</p></blockquote><p>接着我们查看 <code>somaxconn</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /prog/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure><p>将其修改为 3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//必须在管理员权限下才能修改</span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /prog/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p>然后再运行服务器和客户端，得到以下结果：<br><img src="/2022/img/image-20230321093637098.png" alt=""><br>可见，有 4 条连接处于已建立状态，比我们指定的 <code>somaxconn</code> 还要多 1 。</p><p><strong><font color='orange'>综上，我们得出结论：全连接队列长度 = min(somaxconn, backlog) + 1</font></strong></p><p><strong><mark class="hl-label blue">当全连接队列满了怎么办</mark> </strong><br>默认行为是直接丢弃，我们也可通过指定 <code>tcp_abort_on_overflow</code> 参数来调整其行为：</p><ul><li>0 ：直接忽略客户端发过来的 ACK ；</li><li>1 ：回复 RST 给客户端，表示终止本次连接；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /prog/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>一般情况下默认为 0 即可，这是更合理的方式，因为全连接队列已满的状态只是暂时的，客户端会因迟迟未收到 ACK 重发报文，期待不久就能等到全连接队列腾出可用空间。</p><hr><p><strong>半连接队列的长度受多方面影响，且不同操作系统版本的实现方式各不相同</strong> ，所以无需掌握具体计算方式。这里笔者简单演示如何间接查看半连接队列的长度。</p><p>半连接队列中的状态为 SYN_RCV ，所以我们可以发起 SYN 泛洪，向端口发送大量虚假的 SYN 报文，然后查看该端口上最多时有多少个连接处于 SYN_RCV 状态，此时就是半连接队列的最大长度。</p><ol><li><p>下载 hping3 ，用来发起 SYN-flood 攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install hping3</span><br></pre></td></tr></table></figure></li><li><p>修改系统配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_max_syn_backlog = 128</span><br><span class="line">somaxconn = 150</span><br></pre></td></tr></table></figure><p>笔者将 backlog 设置为 9（那么全连接队列的容量就为 10），读者随意。</p></li><li><p>运行服务器端</p></li><li><p>发起攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>可见，半连接队列长度等于 backlog</strong></p></li><li><p>再将 backlog 设置为 200，重复以上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">150</span><br></pre></td></tr></table></figure><p><strong>可见，在笔者环境下（Ubuntu 16.04） ，<font color='orange'>如果 backlog 小于 <code>somaxconn</code> ，则半连接队列容量为 backlog，反之则为 <code>somaxconn</code> ，与 <code>tcp_max_syn_backlog</code> 无关。</font></strong></p></li></ol><p>综上， <strong><font color='orange'>半连接队列容量<u>可能</u>同时受 <code>tcp_max_syn_backlog</code> 、<code>somaxconn</code> 和 <code>backlog</code> 的影响，想要增大半连接队列的长度，就需要同时增大这三个参数，仅增大 <code>tcp_max_syn_backlog</code>  是无效的</font></strong> 。</p><p>对于半连接队列，更多的是需要掌握它与 SYN 泛洪的关系。关于 SYN 泛洪，详细可参见博主另一篇文章-<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪攻击</a></p><hr><p>另外，还可以从 <code>ss</code> 命令直接观察全连接队列的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*       </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59492              </span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59496              </span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>-n 不解析服务名称<br>-t 只显示 tcp sockets<br>-l 显示正在监听(LISTEN)的 sockets</p></blockquote><p><strong>对于 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：当前全连接队列的中的连接个数，即已完成三次握手等待应用程序 accept 的 TCP 连接</strong></li><li><strong>Send-Q：全连接队列的容量</strong></li></ul><p><strong>对于非 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：已收到 <u><font color='gree'>但未被应用程序读取</font></u> 的字节数</strong></li><li><strong>Send-Q：已发送 <u><font color='gree'>但未收到确认</font></u> 的字节数</strong></li></ul><p>注意上面的输出，LISTEN 状态下的 Recv-Q ，即全连接队列中的连接个数为 11；但 Send-Q，即全连接的最大长度才为 10，这是怎么回事？这可能是因为 Send-Q 没有包含模糊因子，直接等同于 backlog 。</p><p><strong><font color='orange'>另外注意，<code>ss</code> 命令和 <code>netstat</code> 命令对 LISTEN 状态输出的 Recv-Q 和 Send-Q 的含义不相同</font></strong> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -at</span><br><span class="line">Proto    Recv-Q     Send-Q   Local Address           Foreign Address         State </span><br><span class="line">tcp      0          0        *:12345                 *:*                     LISTEN</span><br><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*  </span><br></pre></td></tr></table></figure><p>这两条命令是在同一次网络请求下进行的，但两者的 Recv-Q 和 Send-Q 却不相同。个人猜测 <code>netstat</code> 下的 Recv-Q 和 Send-Q 就是单纯的收发字节数，不再表示连接个数或队列长度。</p><p>本文结束。</p>]]></content>
    
    
    <summary type="html">半连接与全连接队列, backlog</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>错误处理与包裹函数</title>
    <link href="http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-18T15:24:21.000Z</published>
    <updated>2023-03-23T10:56:14.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考书籍：《UNIX网络编程》《UNIX环境高级编程》</p></blockquote><p>##<font color='red'>errno</font></p><p>只要一个 UNIX 函数中有错误发生，<strong>全局变量 errno</strong> 就会被自动设置为一个特定的正值，用来反馈具体错误，而函数本身则会返回 -1，以说明函数发生了错误；如果函数返回正值，即没有错误发生，则 errno 没有定义。errno 包含在 <code>errno.h</code> 中。</p><ul><li><p>如果函数没有出错，则之前的 errno 可能不会被清除（未定义）；只有发生错误时，才会覆盖之前的错误。</p></li><li><p>errno 不会为 0，这与多线程的 errno 处理有关。</p><blockquote><p><strong>这是因为：线程函数（以 pthread_ 开头的函数）遇到错误时不会设置标准 Unix 的 errno 变量，而是将 errno 的值以函数返回值的形式交给调用者。也就是说，返回值大于 0 则说明发生了错误，那没有发生错误呢？自然也就是返回 0 了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(&amp;ndoen_mutex))!=<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这意味着我们每次调用 pthread_ 函数时，都要事先分配一个整形来保存错误值，这很麻烦，所以我们可以把错误处理和 pthread_ 函数包裹起来以简化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> <span class="keyword">if</span>((n=pthread_mutex_lock(mptr))!=<span class="number">0</span>)</span><br><span class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>对于多线程下的 errno 后续补充。</p></li></ul><h2 id="font-color-red-perror、strerror-font"><font color='red'>perror、strerror</font></h2><p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr，其中 str 是自定义内容。该函数先输出 str，再输出错误描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="comment">//连接错误则输出以下结果：</span></span><br><span class="line">connect: Connection refused</span><br></pre></td></tr></table></figure><p>C 库函数 <strong>char *strerror(int errnum)</strong> 从内部数组中搜索错误号 <strong>errnum</strong>，并返回一个指向错误消息字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = strerror(errno);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-包裹函数-font"><font color='red'>包裹函数</font></h2><p>网络编程很多时候都会遇到一些网络问题，并通过函数返回值或 errno 反馈错误，因此绝不能忽略对错误的处理。包裹函数一般用来处理致命性错误，此时能干的也就只有打印错误然后退出，对于非致命性错误，比如 EINTR 错误，就需要我们自己来处理失败情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sock_conn=accept(sock_listen,<span class="literal">NULL</span>,<span class="literal">NULL</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要自己重启被中断的系统调用。关于中断的系统调用，参见《APUE》第 260 页。</p><p>一些包裹函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bind(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (connect(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他包裹函数可参考<a href="https://github.com/jyx-fyh/unp-source-code/blob/master/lib/wrapsock.c">UNP-sockwarp.c</a></p></blockquote>]]></content>
    
    
    <summary type="html">错误处理与包裹函数</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT与SO_REUSEADDR</title>
    <link href="http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/"/>
    <id>http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/</id>
    <published>2023-03-16T10:08:32.000Z</published>
    <updated>2023-04-07T03:31:58.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>运行环境：Ubuntu 16.0.4</p></blockquote><ul><li><p>无论是否开启 SO_REUSEADDR ，客户端主动断开连接后，无需等待 TIME_WAIT 即可重连，因为客户端每次 bind 的端口都不一样。由此可见， <strong>TIME_WAIT 是对端口而言</strong> 。</p><blockquote><p>不管是服务器还是客户端，只要是主动断开连接的，都会有 TIME_WAIT 。</p></blockquote></li><li><p>如不开启 SO_REUSEADDR，服务器端主动断开连接，则必须等待 TIME_WAIT 后才可重新 bind 该端口，原因见下文。</p></li><li><p><strong><font color='red'>注意，必须是要在 accept 或 connect 成功返回后（即连接成功后）断连或终止程序，才会有 TIME_WAIT ；仅仅 bind 但未连接成功，终止程序后是不会 TIME_WAIT 的</font></strong> 。</p></li><li><p><strong><font color='red'>注意，如果 bind 指定端口不成功，则会自动 bind 其他任意端口；</font></strong></p></li><li><p><code>SO_REUSEADDR</code> 生效的前提条件是开启时间戳，即令 <code>/proc/sys/net/ipv4/tcp_timestamps</code> 为 1（默认也为1）。</p><blockquote><p>实操发现即使关闭时间戳，服务器也能立刻重新绑定端口，原因尚不明确。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>; <span class="comment">//SO_REUSEADDR默认也是0</span></span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR, &amp;opt, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server failed to bind\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> != (sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>)))&#123;</span><br><span class="line">        <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">        size = write(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server sent %ld bytes\n=====================&quot;</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(3);  //stop 3s so that client could send FIN first</span></span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> in_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">99</span>;i++)</span><br><span class="line">        out_buf[i]=<span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="keyword">sizeof</span>(out_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    size = read(sock_clnt, in_buf, <span class="keyword">sizeof</span>(in_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">//stop 3s so that server could send FIN first</span></span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编译上述代码，先运行 server 端，再运行 client 端（注意，最好运行可执行文件，不要直接在编译器中运行），结果如下：<br><img src="/2022/img/image-20230316190258629.png" alt="server"><br><img src="/2022/img/image-20230316190325197.png" alt="client"><br>由于客户端 close 前调用了 sleep，所以可以判断一定是 server 主动断开连接，如下图：<br><img src="/2022/img/image-20230316190534357.png" alt=""><br><code>localhost:12345</code> 是本端地址信息，<code>localhost:53188</code> 是对端地址信息，后面的状态是描述本端状态的，因此可知 server 主动发送 FIN 并断开连接后，进入了 TIME_WAIT 状态。此时我们马上重启服务器，则输出以下内容：<br><img src="/2022/img/image-20230316191622035.png" alt=""><br>在 TIME_WAIT 内重启服务器，则报错绑定失败。注意，绑定指定端口失败后，会随机绑定其他端口，如下：<br><img src="/2022/img/image-20230316191842098.png" alt=""><br>第三行的 <code>46937</code> 便是服务器端随机绑定的端口。不过这已经失去意义，因为服务器是通过知名端口来被客户端认识的，客户端根本不认识这些随机端口，所以 server 会一直处于监听状态，不会有 client 来连接。因此，对于服务端，如果 bind 失败，应该直接终止程序或等待 TIME_WAIT 后重新 bind。</p><p>下面我们让 client 主动关闭连接——加上 server 的 sleep ，去掉 client 的 sleep 即可。结果如下：<br><img src="/2022/img/image-20230316193318143.png" alt="server"><br><img src="/2022/img/image-20230316193335972.png" alt="client"><br><img src="/2022/img/image-20230316193425965.png" alt=""><br>本端为 <code>localhost:53200</code> ，可见确实是 client 发起的 FIN 。因为 client 无需 bind 特定端口，即 client 每次运行绑定的端口都不同，所以不用担心会因为 TIME_WAIT 而连接失败。</p><p>接下来我们使用 SO_REUSEADDR 选项来修改 TIME_WAIT 的限制——将 server 代码第 7 行的 opt 赋值为 1 即可，这样就可以无视 TIME_WAIT 直接复用端口。下面是连续两次运行 server 和 client 的结果：<br><img src="/2022/img/image-20230316204302114.png" alt=""><br><img src="/2022/img/image-20230316204349584.png" alt="">你看，即使服务器处于处于 TIME_WAIT 状态，还是可以直接绑定端口并进行通信。</p><p><strong><font color='red'>注意，即使将 SO_REUSEADDR 置 1，TIME_WAIT 状态也依旧存在，只是可以无视该状态直接 bind 而已。</font></strong></p><p>待补充</p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1-time-wait-%E7%8A%B6%E6%80%81">https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#为什么要设计-time-wait-状态</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#先说结论</a></p>]]></content>
    
    
    <summary type="html">TIME_WAIT与SO_REUSEADDR实操</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程重点</title>
    <link href="http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-05T10:30:46.000Z</published>
    <updated>2023-03-26T14:28:39.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li><li>本文只记录重点内容和个人理解，系统学习请移步《UNIX网络编程》</li></ul></blockquote><h3 id="font-color-red-轮廓-font"><font color='red'>轮廓</font></h3><h5 id="服务器端">服务器端</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>“门卫”</font>套接字，注意，此时仅指定了该套接字的类型（TCP/UDP）</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='red'>“门卫”套接字，即监听套接字，该套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong><font color='red'>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</font></strong> 。<strong>注意，区分监听套接字和已连接套接字非常重要！</strong> 一个服务器端口通常只创建一个监听套接字，而当服务器完成客户端的服务时，相应已连接套接字就会关闭。下图可看到监听套接字和已连接套接字的描述符是不同的，以说明这两个套接字的差异：</p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><p><strong><mark class="hl-label blue">socket</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>该函数返回主动套接字，经过 listen 函数转换后才会成为监听套接字。</li><li><strong>protocol 敲定最终协议</strong> 。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；</li></ul><p><strong><mark class="hl-label blue">bind</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png" alt=""></p><ul><li><p>该函数将 addr 地址结构所包含的信息绑定到 sockfd 套接字上，相当于为套接字办理身份证。</p></li><li><p><strong>bind 可以手动指定 IP 地址或端口，可以两者都指定，也能两者都不指定，如果不手动指定，则按以下方式处理：</strong></p>  <img src="../../public/2022/img/image-20230308162549530.png" style="zoom:80%;" />  **<font color='red'>对于 IPv4，通配地址为宏 INADDR_ANY；对于 IPv6，为 in6addr_any</font>** ：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servSock.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//INADDR_ANY一般为0,可以不用htonl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果绑定 INADDR_ANY，此时服务器自己的所有 IP 上（如果是多宿）监听，等到客户发来的 SYN 报文时，再绑定到该报文指定的服务器端 IP</strong> 。</p></li><li><p><strong><u>注意，对于 TCP 而言，如果不手动指定端口，<font color='orange'>则在调用 listen (server) 或 connect (client) 时</font>，内核会选择一个临时端口</u></strong> 。对于客户端，我们一般让内核来绑定套接字的端口（除非需要预留端口）；<strong><u><font color='orange'>对于服务器端，很少让内核自行决定端口，因为服务器是通过它们的总所周知端口而被外界认识的</font></u></strong> 。</p></li><li><p><strong><u>对于 TCP 客户端，由内核绑定 IP 地址；对于 TCP 服务器端，如果没有手动绑定，则内核就把客户发送的 SYN 报文中的目的IP地址作为绑定的 IP 地址。</u></strong></p></li><li><p><strong><font color='red'>不论是服务器还是客户端，如果绑定指定端口失败，则随机分配一个端口</font></strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p><strong>如果服务器的某个端口刚断开连接，处于 TIME_WAIT 状态，则默认情况下不能立即再次绑定该端口，否则返回 EADDRINUSE 错误</strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p>注意 bind 与 accept 参数类型的差异。</p></li></ul><p><strong><mark class="hl-label blue">listen</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li><strong>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</strong></li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同，可参见<a href="https://blog.csdn.net/yangbodong22011/article/details/60399728">深入探索 Linux listen() 函数 backlog 的含义</a> ；另外，<strong><u>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</u></strong> ，详见<a href="https://jyx-fyh.github.io/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/">socket等待队列</a> 。</li></ul><p><strong><mark class="hl-label blue">accept</mark> </strong></p><p><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li><p>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度。<strong><font color='orange'>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</font></strong> 。</p></li><li><p><strong><font color='red'>accept 从已完成队列中取出一个连接；仅仅只是取出一个完成了三次握手的连接，并返回绑定此连接的套接字</font></strong> 。</p></li><li><p><strong><font color='orange'>上面这句话说明了一个很重要的事实：accept 与三次握手无关！三次握手是底层网络协议栈自动完成的（当然，第一次握手是 connect 发起的）！换句话说，即使没有 accept 也能完成三次握手！</font></strong></p><blockquote><p>做个实验便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_lsn.sin_family = AF_INET;</span><br><span class="line"> Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> Listen(sock_lsn, <span class="number">20</span>);</span><br><span class="line"> <span class="comment">//注意,没有accept和close</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line"> addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"> addr_clnt.sin_family = AF_INET;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个进程并发送连接</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">         Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">         sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">         close(sock_clnt);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行，结果如下：</p><p><img src="../../public/2022/img/image-20230319221140308.png" alt=""><br><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可。显然，即使服务器端没有调用 accept，两端仍然建立了连接。<strong><font color='orange'>这再次说明，accept 只是从全连接队列中取出一个四元组，并绑定到一个新的套接字描述符而已</font></strong> 。<br>——<strong>四元组：即本端 IP、本端端口、对端 IP、对端端口，用来唯一确定一个 TCP 连接</strong> 。</p></blockquote></li></ul><p><strong><mark class="hl-label blue">connect</mark> </strong></p><ul><li><p>connect 函数中，内核会为客户端绑定套接字，端口随机，这个过程相当于 bind。</p></li><li><p>connect 会激发三次握手，只在连接成功或出错时返回。出错有以下三种情况：</p><ol><li><p>客户端迟迟未收到对 SYN 报文的 ACK，此时返回 ETIMEDOUT 错误。</p><blockquote><p>“迟迟”是多久？SYN 重传次数由 <code>tcp_syn_retries</code> 控制。<u><strong>通常</strong></u> ，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后。即，每次超时的时间是上一次的 2 倍。</p></blockquote></li><li><p>对 SYN 报文的回复是 RST，表明服务端在我们指定的端口上没有套接字处于监听状态，返回 ECONNREFUSED 错误。</p></li><li><p>SYN 报文在某个中间路由器上引发了“目的地不可达”的 ICMP 错误，重复发送几次 SYN 后，如果在规定时间内仍无响应，则返回错误。</p></li></ol></li><li><p><strong><font color='red'>如果 connect 失败，则该套接字不能再重新调用 connect，只能生成新的套接字再 connect 。</font></strong></p><blockquote><p>为什么不能对其重调用 connect 呢？其实如果联想到上文中的 TIME_WAIT ，那么这个问题就有思路了。考虑这样一种情况：当发送 SYN 后，由于网络拥堵，在 MSL(报文最大生存时间) 的前一刻到达了服务器，然后服务器发送 ACK 报文，然后 ACK 也在 MSL 前到达客户端；但是，将近 2MSL 已经挺久了，客户端没有等到这么久就返回 connect 错误，同时重新在该套接字上发起 connect 并发送新的 SYN；问题来了，此时上一个 ACK 刚好到达客户端！换句话说，第二次发送的 SYN 得到的回复是第一次的 ACK，这可能被时间戳机制判定为非法。关于时间戳，参见<a href="https://jyx-fyh.github.io/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">时间戳与序列号回绕</a> 。<br>以上只是本人的猜想，仅作为一种思路。</p></blockquote></li></ul><p><strong><mark class="hl-label blue">close</mark> </strong></p><ul><li>调用 close 后会给对端发送 FIN 报文。</li><li>close 函数的默认操作是立刻关闭套接字并返回，但如果发送缓冲区中还有数据残留，则内核会将这些数据继续发送给对端。</li><li></li></ul><p><strong><mark class="hl-label blue">各类地址转换函数</mark> </strong></p><ul><li>不可重入</li></ul><p><strong><font color='orange'>常错点总结：</font></strong></p><ul><li><p>将 sockaddr_in 敲成 sockaddr</p></li><li><p>忘记 memset</p></li><li><p>accept 的第三个参数不同于 bind，须要对 size 取地址</p></li><li><p>别忘了 close</p></li><li><p>对于Linux，socket函数都是<code>&lt;sys/socket.h&gt;</code> ，某些宏，如<code>IPPROTO_XXX</code> 则是<code>&lt;apar/inet.h&gt;</code> 。</p></li><li><p>通过getsockname()获取套接字的信息。</p></li><li><p><strong>猜想：似乎每次回收套接字都需要一定时间？因为如果不调用close，一定时间内重启程序，客户端并不能再次直接连接。</strong><br>似乎和 TIME_WAIT 有关</p></li><li><p>memset 清零的目的是将 sockaddr_in 的成员 sin_zero 字段清零；该字段没有用，只是为了占位，以便和通用</p></li><li><p>一个socket能同时进行多个连接吗？</p></li><li><p>为什么要sockaddr_in --&gt; sockaddr</p></li></ul><h3 id="font-color-red-网络序-font"><font color='red'>网络序</font></h3><ul><li><strong>端口号就是在同一操作系统下为区分不同套接字而设置的，所以不能将一个端口号分配给不同套接字。但注意，tcp和udp不会共用端口号，所以允许重复，比如。。。</strong></li><li><a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_cookies">SYN cookie</a>是一种用于对抗<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_flood">SYN flood</a>攻击的技术，可以避免在incomplete connection queue被填满时无法建立新的TCP连接。对于使用SYN Cookie的服务来说， 当incomplete connection queue被填满时，<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>会表现得像SYN队列扩大了一样。对于队列填满后的新TCP连接，服务器会返回适当的SYN+ACK响应包，但会丢弃对应的SYN队列条目（因为队列已经满了）。如果服务器收到客户端随后的ACK响应，<strong>服务器能够使用编码在 TCP 序号内的信息重构 SYN 队列条目</strong>。</li><li>等待队列详解博客</li><li>阻塞模式</li></ul>]]></content>
    
    
    <summary type="html">Socket网络编程重点</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>英语外刊超精读笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-04T05:36:46.000Z</published>
    <updated>2023-03-15T14:21:57.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="font-color-3b8dfe-词汇-font"><font color=#3b8dfe>词汇</font></h4><p><strong><mark class="hl-label blue">思考</mark> </strong></p><ul><li>contemplate 沉思</li><li>meditate 冥想</li><li>muse</li><li>ponder （powder-粉末）</li><li>chew over</li><li>think over</li></ul><p><strong><mark class="hl-label blue">支出、花费</mark> </strong></p><ul><li>outlay</li><li>expenditure 一般指政府\机构等支出</li><li>spending</li><li>expense</li></ul><p><strong><mark class="hl-label blue">检查、探究、调查</mark> </strong></p><ul><li>examine</li><li>explore</li><li>investigate</li><li>research</li></ul><p><strong><mark class="hl-label blue">匹敌、媲美</mark> </strong></p><ul><li>rival<br>——Nobody could rival him in this respect.</li><li>match</li></ul><p><strong><mark class="hl-label blue">闲逛</mark> </strong></p><ul><li>wander</li><li>roam</li><li>ramble</li><li>stroll</li><li>hang out</li></ul><p><strong><mark class="hl-label blue">描述、描绘</mark> </strong></p><ul><li>describe</li><li>depict</li><li>portray</li><li>present</li></ul><h4 id="font-color-gree-搭配-font"><font color='gree'>搭配</font></h4><ul><li><p>long since 很久以前，早就</p></li><li><p>banish fears 驱除恐惧</p></li><li><p>be afraid of / have fears about sth 对某事有恐惧</p></li><li><p>in one’s image 以…形象</p></li><li><p>dependence on/upon，be dependent on/upon，independence from，be independent of</p></li><li><p>constitute/pose/present a threat to sb 对…构成威胁<br>considerable/major/great/significant/grave/serious threat 巨大/严重的威胁</p></li><li><p>sb is <strong><u>in charge of</u></strong> sth，sth is <strong><u>in the charge of</u></strong> sb</p></li><li><p>pick up an ailment 得病</p></li><li><p>soap opera 肥皂剧，pulp magazine 低俗杂志，mass tastes 大众品味</p></li><li><p>for the good of sb，for sb’s good 为了某人利益</p></li><li><p>uncritical acceptance （盲目地）全盘接受</p></li><li><p><strong>denfend/guard/secure A against B</strong><br><strong>protect/keep/shield A from B</strong></p></li><li><p><strong>be conscious/aware of sth</strong><br><strong>be alert/alive/awake to sth</strong> 意识到、警觉、了解</p></li><li><table><thead><tr><th>除…外（且包含）</th><th>除了（不包含）</th><th>除了（通用，看语境）</th></tr></thead><tbody><tr><td>in addition to</td><td>except (for)</td><td>apart from</td></tr><tr><td>besides</td><td>not counting</td><td>aside from</td></tr><tr><td></td><td>excluding</td><td></td></tr><tr><td></td><td>other than</td><td></td></tr></tbody></table></li><li><p>a densely/thickly/heavily/highly populated area 人口稠密的地区<br>a sparsely/thinly populated area 人口稀少的地区</p></li><li><p>a(n) element/trace/hint/tinge of ，a wee bit 一点、一丝、少量的</p></li><li><p>at a session on sth 在关于…的会议上</p></li><li><p>annual meeting 年会</p></li><li><p>next to 仅次于</p></li><li><p>be responsible for 对…负责</p></li><li><p>associate A with B 将A和B联系</p></li><li><p>up to speed …的最新消息<br>——Jack will bring you up to speed. 杰克将告诉你最新消息。</p></li><li><p>fit the bill/checklist 满足要求，符合条件</p></li><li><p>come by 顺道拜访，得到</p></li><li><p>let alone 更不用说</p></li><li><p>scientific case 科学论据</p></li><li><p>go too far、take sth too far 把某事做得太过<br>——Have child protection measures gone too far?</p></li><li><p>an expert on sth 某方面的专家</p></li><li><p>be concerned with 关心某事</p></li><li><p>out of a hat 随意、随机；像变魔术般<br>——I will pick up a number out of a hat.</p></li><li><p>like rabbits out of a hat 轻易的，不费吹灰之力</p></li><li><p>before long 不久后；long before 很久以前；</p></li><li><p>for one’s amusement 为了让某人取乐</p></li><li><p>sth is less A than B 与其说某物是A，不如说是B</p></li><li><p><strong>bother with 为…花功夫、费神</strong><br>——It’s so facile that you need not to bother with it at all.</p></li><li><p>translate A as B 将A解释成B</p></li><li><p>at the dawn of 在…初期</p></li><li><p>shape the perception 形成观念</p></li><li><p><strong>years to come 后来（的岁月）</strong></p></li><li><p><strong>ascribe/owe/attribute/credit A to B 将A归因于B</strong></p></li><li><p>play down 贬低</p></li><li><p>national consciousness 民族觉醒</p></li><li><p>pull out 撤离</p></li><li><p>pride onesel on (doning) sth、take pride in、be proud of</p></li><li><p>brand sb as 给某人贴上…的标签<br>——The world has branded the entire Chechen nation as terrists.</p></li><li><p><strong>count on 指望</strong></p></li><li><p>mobilize resources 调动资源</p></li><li><p>bring sth to life 使…变得生动有趣</p></li><li><p>touch the nerve points of 触及…的神经</p></li><li><p>power politics 强权政治</p></li><li><p>warn the reports 报告如此警告到<br>says the girl 女孩这样说<br>concludes a study 一份研究得到这样的结论</p></li><li><p>split from = separate from 从…分离出来</p></li><li><p>put a date to 确定…的日期</p></li><li><p>part ways 分道扬镳</p></li><li><p>in response to 作为对…的反应</p></li><li><p>over time 随着时间的推移</p></li><li><p>zone in on 将精力集中到…</p></li><li><p>now that 既然</p></li><li><p>associate professor 副教授</p></li><li><p>account for 解释，是…的原因</p></li><li><p>market cap 市值</p></li><li><p>market capitalization 市值</p></li><li><p>account for / constitude / make up / represent 占比</p></li><li><p>balance sheet 资产负债表</p></li><li><p>seal of approval 正式认可</p></li><li><p>take over 接管，收购</p></li><li><p>in the long term/run 从长远来看</p></li><li><p>put sth in place 将…落实</p></li><li><p>tune out 不理睬</p></li><li><p>rank among 位列</p></li><li><p>in terms of 在…方面</p></li></ul><h4 id="font-color-yellow-句型-font"><font color='yellow'>句型</font></h4><ul><li><strong>The question is whether … 问题在于是否…</strong><br>——The question is whether you are happy to do it.</li><li><strong>But it’s not just sth that matters. 但并非只有…重要</strong></li><li><strong>sb argue that、sb make the argument that. 某人认为、提出论点</strong></li><li><strong>As might be expected 正如所料的那样</strong></li><li><strong>The finding/discovery reinforce the conclusion that 这个发现强化了…的结论</strong></li></ul><h4 id="font-color-orange-长句-font"><font color='orange'>长句</font></h4><ul><li><strong>A sparsely populated country <u>adjoining</u> a densely populated country and <u>sharing</u> with it the same speech and largely the same cutural origins must <u>expect</u> to be dominated for a time.</strong></li><li><strong>Those were the topics of discussion at a session on the ethical and policy implications of dolphin intelligence here today at the annual meeting of the American Association for Advancement of Science.</strong></li><li><strong>That would allow researchers to account for the different human fossil that fall between the divergence and the appearance of more modern-looking people in Africa around 50000 years ago.</strong></li></ul><h3 id="熟词生意">熟词生意</h3><ul><li>see  陪…一起度过<br><strong>My friends saw me through my depression.</strong></li><li>see  经历，遭受<br>Napoleon’s campaigns saw such voracious plundering.</li><li>fall   分布于（区间），属于</li><li>fare 进展，表现</li><li>level 使平整，平坦的</li><li>craft 精心制作，工艺，手艺</li><li>deliberate 仔细考虑，认真商讨</li><li>otherwise 在另一方面</li><li></li></ul>]]></content>
    
    
    <summary type="html">英语外刊超精读</summary>
    
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>关于CHATGPT的一些想法</title>
    <link href="http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2023-02-10T13:23:48.000Z</published>
    <updated>2023-03-12T11:21:19.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近一个月以来，国内乃至全世界的焦点都汇聚到了chatgpt之上。被chatgpt刷屏后，我个人也不禁产生了一些思考。</p><p><strong><mark class="hl-label blue">chatgpt对我们的生活将造成哪些影响？</mark> </strong><br>很难说。《未来世界的幸存者》中有这样一个观点：未来几十年内，人工智能将使许多传统岗位消失，如客服、信用评估员、市场分析师等；但有些职业是人工智能暂时很难取代的，如画家或律师等艺术性或人文性较强的工作，原因很容易知道，一言以蔽之，机器始终无法替代人类的灵光一闪。之前我也对此观点深信不疑，直到看见了下面这些新闻：<br><img src="/2022/img/b&bo=NwQzBjcEMwYWECA!&rf=viewer_311.jpeg" alt="AI画作：太空歌剧院" style="zoom:80%;" /><br><img src="/2022/img/b&ek=1&kp=1&pt=0&bo=OARgCTgEYAkWECA!&tl=1&vuin=1572676601&tm=1676037600&dis_t=1676037625&dis_k=f9474985ff1e09ce64e0efcb968d67df&sce=50-1-1&rf=viewer_311.jpeg" alt="AI律师" style="zoom:67%;" /></p><p>要知道，该书出版于2018年，至今仅过了短短五年…所以，你很难想象科技的发展速度，谁知道下一个五年将会是什么样呢？就chatgpt而言，虽然目前它的回答尚有较大的瑕疵，但风口已经打开，如周鸿伟所说——“搭不上ChatGPT的企业可能将被淘汰”，大量资本的注入势必会大大增强其性能，所以它的潜力仍然无法预估。不过，有一点我们必须清楚：如果想要避免未来被人工智能取代，就必须从事技术含量高、重复性低、可量化性低的工作。当然，公务员也许不错。</p><p>话说回来，也许不用对未来AI是否会造成失业潮而过度担心呢：<br><img src="/2022/img/image-20230210223238238.png" alt=""><br>本人浅薄地认为，AI过度地取代人工，将生成大量无业游民，进而引发社会动荡，这无疑是政府所不愿看到的。因此，政府可能会进行宏观上的调控。但，即使在调控下AI只会代替少部分人，你又如何保证你不是那倒霉的小部分呢？</p><p><strong><mark class="hl-label blue">由此看到的中外差距</mark> </strong><br>在<a href="https://www.huxiu.com/article/787988.html">《万字拆解：ChatGPT为什么这么强？》</a>论文中，作者向国内同胞们发出了真切的呼吁，此诚危急存亡之秋！包括但不限于人工智能领域，国内外的差距正在不断拉大，而极多数国人却在某些公知不怀好意的误导下，认为我国已经全方位赶英超美，天朝上国无所不能…如此下去，未来中国只有两个方面能够战胜国外——浓香型科技和酱香型科技。</p><p>再来看看我们的企业在干什么：<br><img src="/2022/img/image-20230210231638974.png" style="zoom:50%;" /><br><img src="/2022/img/image-20230210231800724.png" style="zoom:50%;" /><br>国外科技巨头在马不停蹄地创新，国内巨头却在你追我赶地和菜市场的小商贩抢生意。chatgpt爆火后，国内巨头们也争先恐后地计划推出类gpt产品：<br><img src="/2022/img/image-20230210232254477.png" style="zoom:67%;" /><br>个人不认为国内的这场chatgpt争夺战能够分出胜负，反而可能是全军覆没。原因很简单：2022年，OpenAI的算力支出约为4亿美元，人工支出约为9千万美元，光是这两样就达到了惊人的35亿人民币！中国有哪家企业能够下这样的血本？更不要说它的时间成本与技术成本了。在国内浮躁的学术环境和企业环境下，我们很难持续地取得技术创新。下一个5G还有多久？</p><p><strong><mark class="hl-label default">AI可能取代人类吗？</mark> </strong><br><img src="/2022/img/image-20230210222435996.png" alt=""><br>想起了流浪地球2的开头旁白——“起初，没人认为这是一场灾难，直到它和每一个人都息息相关。”</p>]]></content>
    
    
    <summary type="html">关于CHATGPT的一些想法</summary>
    
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深度思维-读书总结</title>
    <link href="http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-27T01:07:46.000Z</published>
    <updated>2023-03-12T11:21:04.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几日，我父亲醉酒后拉着我谈心，不知道是酒后起兴还是愁绪积压太久，向我倾诉了他对前半生的无尽悔恨，悔恨学生时代没有自制力（初中名列前茅，中考前被朋友带着打牌，三个月不眠，因此失利；高中仍名列前茅，又被朋友拉着打乒乓，没下课就跑去占台，耗费大量时间）；悔恨早年赚到钱时，没能听朋友劝告进入房地产；悔恨后来发家时，没能及时在深圳买房…父亲微仰着头，泪光不停地闪烁着，“在那个疯狂的、满地是钱的年代，无数个机会从我们面前闪过，然而我一个也没曾抓住。”</p><p>父亲的这些话，令我感触颇多。那个撒钱的年代，为什么机会遍地，却不曾抓住过？当然，任何一件事都有其时代的局限性，马后炮总是容易的。但话说回来，不依旧有很多人脱颖而出，改变了自己的命运吗？有人说他们靠的是胆量，或说凭的是运气。不可否认，这两者差一个都不行，但笔者认为，更重要的是——认知。与认知同义的，还有我们常说的眼界、格局等。最近有句话在网上传得很火——凭运气赚到的钱，总会凭实力亏掉，这句话的背后也许就体现了认知的重要性。如著名畅销书籍《穷爸爸富爸爸》中提到的，为什么一些运动员、演员等红极一时，短时间内赚到了普通人几辈子都赚不到的钱，而十几年甚至几年后就传出破产消息（拳王泰森、影帝尼古拉斯·凯奇都是例证）？个人认为，其背后深层次的原因都是认知（眼界）的不足。打一场拳或拍一部戏就能拿到一笔难以想象的巨款，相信绝大部分人此时都难以压抑自己的消费欲望，对于出身普通的人而言，更是会出现报复性消费，于是买豪车、置豪宅…不出多久，现金流就为负数了。而对于极少数的另一部分人，他们有更高的认知、更远的眼界，则可能用这些巨款继续创造正现金流（买房买车多数时候都属于负债，即负现金流），进而持有更多的资产。</p><p>那么，作为普通人的我们，怎样才能提升自己的眼界呢？又怎么才能把握时代的机遇呢？《深度思维》这本书也许就给出了答案。这本书给出了几种思维技术和思维格局，配以普通人的事例，让我深刻体会到了思维能力的重要性。下面简单谈谈我读完本书的感受。</p><p><strong>文章首先提到了思维链</strong> 。思维链的形式很简单，就是通过对一个问题进行连续追问，从而推测事物的未来走向（5so思考法），或探究问题的本质根源（5why思考法）。别看其思想和步骤极其简单，但结果往往令人吃惊！比如书中的例子，<strong>如何解决墙被腐蚀的问题——只需关上博物馆的窗帘！</strong> 这便是 5why思考法的威力，而普通的思考往往很难达到如此大的跨度。5so思考法同样令我震惊，书中有个精彩的真实案例：上海自贸区要成立了，so？——上海本地的贸易公司业务会繁荣，相应公司的股票一定上涨，so？——物流业务肯定也会被带动，物流公司的股票也值得购买，so？——物流繁荣，港口也一定繁荣，so？——集装箱租赁业务也肯定火爆…最后事实证明这一逻辑链完全正确，少量窥探先机的人则赚得盆满钵满。<br>既然这种简单到人人都会的思想方法能展现出如此巨大的威力，那为什么实际中，受益的人少之又少呢？个人认为，是因为没有刻意训练。方法再厉害也没有用，<strong>只有形成本能，当任何问题发生时，第一时间用这些方法思考问题，才能发挥作用</strong> 。而想要形成本能，就需要我们刻意训练，每当遇到问题，都先问自己，可以用什么样的方法或角度来解决，久而久之就可形成本能。</p><p><strong>接着提到了换位思维</strong> 。额，这还需要说？俺小学就学会了换位思考！小时候，一个小姐姐护士给我扎针，扎错了好几次，紧张得从脖子红到了耳朵，但我没怪她，因为我换位思考，如果我作为一个实习生护士，连续扎错了针，心里该多么紧张和难受啊！所以需要体谅和理解，想到这，我还安慰了这位护士，果然，一下就扎对了…呵呵，首先，这篇读后感不是小学课文；第二，换位思考不仅用于感受和体谅他人，在营销或其他领域也常有应用。还是书中的例子，一旅行社针对高压力的白领群体推出了一款旅游路线，广告语有以下两个：</p><ol><li><strong>风光无限，畅想人生</strong></li><li><strong>你是愿意待在沉闷的办公室里勉强安慰自己小点压力，还是愿意躺在大理洱海边畅快地呼吸新鲜空气？</strong></li></ol><p>高下立判。显然，第一个广告语是从你自己的角度来描述的，这并不能和白领们产生共鸣。而第二个广告语则是站在白领的角度来考虑的。想想，将自己放置于沉闷、阴暗的办公司，耳边嘈杂声不绝，满屋缭绕着对面男同事呼出的二手烟，桌面上堆满了待处理的文件…此时，你不经意抬头，看见了电脑上的第二则广告语，一幅蓝天白云，海边沙滩的画面立刻出现在你的眼前——OMG！去他妈的工作，这洱海我去定了！</p><p><strong>当我们面向的对象是人时，换位思考几乎是不能避免的</strong> 。<strong>记住，谁能引起共鸣，谁就能赢得了客户的心</strong> 。任何时候，问自己一句：如果我是他，我会想什么？我会做什么？每一份直击人心的文案策划，每一次打开局面的商业谈判，每一个引爆用户的产品设计，背后都对应着成功的换位思维。<br>另外，换位思考的一个精彩应用是爱德华·德·博诺博士提出的六顶思考帽，有专门的一本书——《六顶思考帽》详细介绍了该思想。六顶思考帽是利用换位思考，站在六种极端的角度来分析问题，最终得到一份最优的答案。后面有时间再阅读此书并另写读后感，这里就不多说了。</p><p><strong>在可视化思维一章中，文章提到了一种重要的时间管理原则——容易的事先做，重要的事先做</strong> ，经过大量实践，该原则被认为是解决拖延症的不二良方。嗯？就这么个小原则就能解决我多年的拖延症？这也太小看我了吧！再容易的事我也能拖…当然，这并不能解决你的拖延症，因为作者犀利地指出，<strong>这种时间管理原则最大的问题，在于如何评价事情的容易或重要程度</strong> ，就这点，我深有同感！很多时候，我在评价一件事情的重要性或可能性时，总会直接脱口而出：这件事有 80%~70% 的重要（可能）性！喔？70%~80% ，这些确切的数字是怎么得到的？计算得到的？还是调研得到的？又或者是随口一说？很显然，只是随口说说。通过这种模糊不定的评价标准来决策事情的先后，自己本身也会对其产生怀疑，所以当然就不会严格遵守。因此，作者就提出了一套评价标准：<br><img src="/2022/img/未命名绘图37.png" style="zoom:150%;" /><br>有了这样的确切的评价体系，我们就能够更客观地估计事件的优先级。你甚至可以对以上某一角度加权。注意，一旦决定实施这一评价体系，就必须时刻遵守它的结果。比如，算出 A 事件的优先级大于 B 事件，但你自己更喜欢 B 事件，所以你就违背了这一结果，直接先做 B 事件。长期这样违背只会降低这一方式的权威性，直到最后形同虚设。当然，你完全可以将喜爱程度也加入到这一体系中，并对喜爱度加权。</p><p><strong>令我同样印象深刻的还有秘籍型思维</strong> 。秘籍型思维是指，当我们探寻一个人是怎么成功的，或怎么才能做成一件事，最终会将原因归结到某种秘籍——职场能力、个人背景、贵人相助、思维方式…实际上，这种秘籍型思维已经深入我们的骨髓，我们将原因归结为一点，却忽视了别人在其他方面所作的努力。拿我自己举例，高中时，我一直对数学的奇技淫巧很感兴趣，花费大量时间去追求所谓的秒杀方法，基础却没能重视，最后的结果显而易见——基础不牢，地动山摇，高考数学成绩给了我一记耳光。更重要的是，直到大学，我都没有再提起过对数学的兴趣，甚至对其反感和厌恶，我想，这可能会成为我的一生之痛。<br><strong>秘籍型思维将复杂的东西过于简单化，企图用一个相对简单的秘籍去代替复杂的成功规律，而对其他方面的因素视而不见。</strong> 所有成功都是多方面因素促成的结果，单一考虑某一个方面，则有可能使得我们将鸡蛋全部放入一个篮子，增大了事件的风险性。</p><p>与秘籍型思维相反的是思维方法是全流程优化。全流程优化的最诱人的地方在于它的复利性。爱因斯坦曾说，复利是世界的第八大奇迹。全流程优化是指，将一件事情拆分为多个步骤，如果你每个步骤都做得比别人好那么一点，则成效则可能是别人的几倍！这是真正的在平凡中创造伟大！还是拿书中广告软文的例子来说明：<br>文章标题 --&gt; 正文内容 --&gt; 商品软文 --&gt; 链接跳转 --&gt; 店铺页面 --&gt; 支付界面 --&gt; 收获评价<br>富有吸引力的标题能够带来更多流量，这是第一步；正文内容不会直接谈到商品，而是做一些铺垫，这里必须保证足够吸引读者，或者和读者引发共鸣，这是第二步；接着是商品软文，这里需要承上启下，展现商品用途，需要足够打动读者；然后，读者可能成功被你的软文打动！ta尝试点入链接…<br>在以上步骤中，其他几个步骤你可以很容易地优化，比如将店铺页面装饰得漂亮些、评价反馈服务再做得到位一些…那么，链接跳转和支付页面该怎么优化呢？实际上，这两点是最容易被忽略的点，也是很容易丢失客户的点！拿我自己的感受来说，当我点击跳转链接后，经常会提示：“请复制该链接，并在浏览器中打开”，而这会极大地消耗我的耐心和冲动。本来这些软文广告就是在消费我们读者的冲动，而这些冲动都被繁琐的跳转链接给消耗了，还谈什么购买呢？对于支付页面，我也常有体会，很多时候下定决心要购买商品了，却发现没有微信支付，而只有支付宝支付，这每每令我相当恼火。<br>话转回来，如果我们将每个流程都优化 20%，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>4.29</mn></mrow><annotation encoding="application/x-tex">1.2^7=4.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4.29</span></span></span></span> ，你收获的成果将是别人的 4.29 倍！而你多做的努力只有 20% ！这就是复利的威力。因此，重视每一个细节，是我们成功的关键！</p><p>接着书中讲到了生态思维，生态思维侧重于发现事物之间的关系。《浪潮之巅》一书中介绍了计算机行业的一个著名生态链——以微软为首的软件公司吃掉硬件带来的全部好处（比如你内存越大，那我软件也刻意占用越大的内存），迫使用户更新机器让惠普和戴尔等公司收益，而这些计算机制造商再向英特尔这样的半导体厂商订货。在这条链上，相应公司的股票先后都会上涨，因此华尔街的投资者们都知道，如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔的股票。这些投资者们就深谙生态思维和逻辑链的威力。曾经在知乎上还看见一句令我印象很深刻的话：如果大家都知道某个产业赚钱，那就一定不能再挤进去，那怎么办呢——进入这个产业的上游产业。这也是一种生态思维的体现。生态思维下还有几个著名的模型：<strong>淘金模型、森林模型和平台模型</strong> 。<br>淘金模型的底层考虑是共生——如果恶龙太强，那就当恶龙的马仔！额…说错了——如果对手强大如河马，那我们可以成为牙签鸟！淘金模型来源于全球著名牛仔裤制造商李维斯。在疯狂的淘金热下，想要继续挖到大金矿已经几乎不可能，但大量的挖矿工人需要结实耐磨的裤子，聪明的李维斯便开始在金矿附近买起了牛仔裤，从而发展成了后来的著名牛仔裤品牌。相似的例子还有很多，比如为大量捡贝壳以求珍珠的人们提供坚实的橡胶手套。<br>森林模型强调的是错位竞争；平台模型则是为大量竞争者提供平台，而自己则成为平台的收益者。这些方法和事例看似简单，实践起来仍有很大难度。</p><p>文章最后提到的是大势思维。文章有一段很漂亮的话：</p><blockquote><p>古代诗人罗隐说：“时来天地皆同力，远去英雄不自由。”<br>荀子说：“君子生非异也，善假于物也。”<br>小米创始人雷军说：“站在风口上，猪都能飞起来。”</p></blockquote><p>这几句话都是对大势思维的例证。20年前，中国的富豪大多数是搞矿产的；10年前，中国富豪大多数是搞房地产的；现在，中国富豪则大多数是搞互联网的；那么可以预测，未来几十年，中国的富豪可能是发展人工智能或自动驾驶的。身为普通人的我们，又该如何发现并利用趋势呢？其实，趋势下往往隐藏着深刻的经济学规律，而文章中则给出了三条强大的规律——马太效应、科技进步和人口变化。这三条规律能够压制其他任何心理学或经济学规律，值得我们重视。</p><p>书中还有许多精彩的内容，限于笔者精力有限，就不再总结了，详细还请各位细品此书，定能有所收获。</p><p>在这个充满机遇和挑战的时代，共勉。</p>]]></content>
    
    
    <summary type="html">深度思维</summary>
    
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>更安全的用户进程?</title>
    <link href="http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-01-13T06:55:11.000Z</published>
    <updated>2023-03-12T11:21:19.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>data_limit_3gb</code></p></blockquote><p>在<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程</a>一文的文尾，笔者留下了一个思考题：既然要求用户不能直接访问内核，那为什么不将用户代码段的界限设置为 3GB 呢？正如之前所演示的那样，如果用户代码段的界限为 4GB，则用户就可以随意修改内核，包括直接访问显存：<br><img src="/2022/img/image-20230112155046604-1673594986128-1.png" alt=""><br>其实笔者也不知道准确的答案，我粗略参考了 Linux 0.11 的代码，发现 Linux 0.11 <u>似乎</u>也是直接将段界限设置为 4GB 。至于规范的防止用户修改内核的方式，咋们以后遇上了再说，现在我们来看看到底能不能通过将数据段界限改为 3GB 来防止用户直接修改内核数据。</p><p>首先将用户数据段的段界限改为 <code>0xbfffffff</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:tss.c</span></span><br><span class="line"><span class="comment">//函数说明:tss_init()</span></span><br><span class="line">*((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xbffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br></pre></td></tr></table></figure><p>还要修改 syscall：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span></span><br><span class="line">    <span class="params">(<span class="string">&quot;int 0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (retval)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a&quot;</span> (no), <span class="string">&quot;b&quot;</span> (_arg1)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.....其他syscall也需要改为内联汇编</span></span><br></pre></td></tr></table></figure><p>为什么要将之前的静态变量方式改成扩展内联汇编呢？说到这，笔者不禁流下了悔恨的泪水…当初我也是为了少学这点看起来复杂的扩展汇编，所以使用了全局静态变量这样的“巧计”来代替这种复杂的汇编。没办法，未来某些场景必须使用到它，所以，该来的早晚会来。话说回来，目前而言，由于我们还没有真正的加载用户进程（真正的用户进程是从文件中读取，进而载入内存的，而当前我们使用函数代替用户进程的），所以一切代码和数据（的标号，即地址），不论用户进程还是内核，都被链接成了 3GB 以上，这都是下面这行 makefile 指令造成的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><p>这条指令将目前的所有文件全部链接成 kernel.bin，并指定入口的虚拟地址为 <code>0xc0001500</code> ，因此，所有的函数和全局、静态变量的地址实际上都在 <code>0xc0000000</code> 以上！所以，我们将用户段的界限限制在 3GB 以下时，在用户态中就不能再使用任何全局变量和静态变量！所以这里的 _syscallX 就不能使用静态变量来中转啦！于是乎，只有改成扩展内联汇编喽。<br>最后，还得修改系统调用入口函数，因为进入中断并不会自动切换 ds、es、fs（只会切换cs），所以咋们必须手动将这几个寄存器修改为内核态的数据段选择子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;.....</span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   push eax</span><br><span class="line">   mov  ax,0x10   ;内核的数据段选择子</span><br><span class="line">   mov  ds,ax</span><br><span class="line">   mov  es,ax</span><br><span class="line">   mov  fs,ax</span><br><span class="line">   pop  eax</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;.....</span><br></pre></td></tr></table></figure><p>ok，来试试看这下能不能直接在用户态访问显存：</p><p><img src="/2022/img/image-20230114134607206.png" alt="image-20230114134607206"></p><p>显然，发生了 GP 异常，禁止访问。说明这样是能够起到一定的保护作用的。来看看正常运行的效果：<br><img src="/2022/img/image-20230114150332216.png" alt=""></p><p>上图中用户只打印了一次，我就使用 Bochs 断点指令将其打断了，因为后面任务切换时引发了程序崩溃，原因就不细说了。这说明通过限制用户数据段的界限来禁止访问内核的这种方式是不可行的。<strong><font color='orange'>实际上，现代操作系统的内存保护机制并非在段上，而是在页上</font></strong> ，关于这点，以后再说吧。</p>]]></content>
    
    
    <summary type="html">自制操作系统</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>堆管理-实现malloc</title>
    <link href="http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/"/>
    <id>http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/</id>
    <published>2023-01-12T07:11:13.000Z</published>
    <updated>2023-03-12T11:21:22.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>k_block_descs</p><ul><li>为什么 1KB 以上就不分块</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="http://jyxcpp.netlify.app/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/"/>
    <id>http://jyxcpp.netlify.app/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</id>
    <published>2023-01-11T02:47:05.000Z</published>
    <updated>2023-03-12T11:21:15.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>printk</code></p></blockquote><h3 id="font-color-red-系统调用与API-font"><font color='red'>系统调用与API</font></h3><p>之前很长一段时间，笔者都将系统调用和 API 函数混为一谈，实际上两者有较大区别。</p><p><strong>API (Application Programming Interface，应用程序接口)</strong> ，其主要功能是提供<u>通用功能集</u>，程序员通过调用 API 对应用程序进行开发，可以减轻编程任务。</p><blockquote><p>API 可以简单的理解为一个通道或者桥梁，是一个程序和其他程序进行沟通的媒介，本质上一个函数。比如我们想往屏幕上打印字符，显然，如果自己从头实现，则需要了解显卡、汇编等知识，无疑相当麻烦。而且 C 库中早就为我们准备了打印函数，即 printf，你只需要按它的要求传入参数就行，无需了解 printf 内部实现。所以 printf 也可以称为 API 。说白了，<strong>接口，就是指两个不同程序之间交互的地方</strong> ，就这么简单。</p></blockquote><p>而系统调用是一种特殊的接口，通过这个接口，用户可以访问内核空间，进而实现一些只有内核才能完成的操作，比如屏幕打印、内存申请（malloc）等。<br>那么这两者有什么区别呢？严格来说，两者没有直接关系，但一般而言，系统调用一般封装在 API 中，但不是所有 API 内部都会进行系统调用。<strong>API 的提供者是运行库，运行库则使用操作系统提供的系统调用接口</strong> ，如果再往下，内核则调用驱动程序，由驱动程序来和硬件打交道。</p><h3 id="font-color-red-系统调用实现原理-font"><font color='red'>系统调用实现原理</font></h3><p>系统调用的直接目的是进入 ring0，以便进行一些只有 ring0 才能完成的工作。我们之前说过，想要从低特权级进入高特权级，则只能通过门完成。由于调用门开销较大，Linux 选择通过中断门进入高特权级，并进行系统调用。<strong><font color='orange'>Linux 系统调用的中断号为 0x80，子功能号存入 eax，而 ebx、ecx、edx、esi 和 edi 则依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中</font></strong> 。</p><blockquote><p>如果要传入五个以上的参数，则需要使用栈传递参数，后文将演示这一过程。</p></blockquote><p>如果细分，Linux 系统调用可以分为三种方式：<br><strong><mark class="hl-label blue">通过 glibc 提供的库函数</mark> </strong><br>glibc 是 Linux 下使用的开源的标准 C 库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了系统调用。比如通过 glibc 提供的 <code>chmod</code> 函数来改变文件 <code>etc/passwd</code> 的属性为 444：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        rc = chmod(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="number">0444</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;chmod failed, errno = %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;chmod success!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用syscall</mark> &quot;</strong><br>syscall 也由库函数提供，但相比于其他调用方式， syscall 则更加灵活，比如你通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，所以你可以利用 glibc 提供的 <code>syscall</code> 函数直接调用，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">syscall</span> <span class="params">(<span class="type">long</span> <span class="type">int</span> sysno, ...)</span></span><br></pre></td></tr></table></figure><p>其中 sysno 是系统调用号（子功能号），每个系统调用都有唯一的系统调用号来标识；<code>...</code> 则是可变参数列表，根据系统调用的不同，可带0~5个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。<br><strong><mark class="hl-label blue">通过int指令调用</mark> </strong><br>直接通过内联汇编进行系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rc;</span><br><span class="line">    <span class="type">char</span> *file_name = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode = <span class="number">0444</span>;</span><br><span class="line">    <span class="keyword">asm</span></span><br><span class="line">    (</span><br><span class="line">     <span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">    :<span class="string">&quot;=a&quot;</span> (rc)</span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (SYS_chmod), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)file_name), <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)mode)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容易知道，这三种方式最终都会使用 <code>int</code> 指令进行系统调用</strong> 。</p><h3 id="font-color-red-实现系统调用-font"><font color='red'>实现系统调用</font></h3><p><strong><mark class="hl-label blue">添加_syscallX</mark> </strong><br>实际上，库函数也是通过操作系统提供的 _syscallX 宏来进行系统调用，其中 X 是参数个数，以 _syscall3 举例，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c)              \</span></span><br><span class="line"><span class="meta">type name(atype a,btype b,ctype c)&#123;                                      \</span></span><br><span class="line"><span class="meta">long __res;                                                              \</span></span><br><span class="line"><span class="meta">asm volatile                                                             \</span></span><br><span class="line"><span class="meta">    (<span class="string">&quot;int $0x80&quot;</span>                                                         \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res)                                                       \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a)),<span class="string">&quot;c&quot;</span> ((long)(b)),<span class="string">&quot;d&quot;</span> ((long)(c))) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res&gt;=0)                                                            \</span></span><br><span class="line"><span class="meta">return (type) __res;                                                 \</span></span><br><span class="line"><span class="meta">errno=-__res;                                                            \</span></span><br><span class="line"><span class="meta">return -1;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>各位无需了解以上代码的含义，咋们会契合自己的操作系统，使用更简单的方式实现。另外，此 _syscallX 已经被 Linux 废弃，但为了简单，我们仍模仿 _syscallX 进行系统调用。</p><p>由于我们的操作系统最多只会使用三个参数的系统调用，所以这里咋们只实现 0~3 个参数的系统调用，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> callno_ret;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg1;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg2;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg3;</span><br><span class="line"><span class="type">uint32_t</span> _syscall0(<span class="type">uint32_t</span> no)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall2(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall3(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2, <span class="type">uint32_t</span> _arg3)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    arg3 = _arg3;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov edx,arg3&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于为什么要使用静态变量，这已在之前的文章多次提及，不再说明。</li></ul><p>啊哈，很简单吧！这里只解释 <code>mov callno_ret,eax</code> ：因为系统调用也遵循 ABI 规范，即，将返回值存入 eax 中，所以我们还要将 eax 转移到静态变量 callno_ret 中，并将其返回（callno_ret 即说明它既用来存放调用号，也用来作为返回值）。</p><p><strong><mark class="hl-label blue">编写中断入口函数</mark> </strong><br>进入 0x80 中断例程后，代码会根据传入的调用号跳转到相应的函数，函数执行完毕后回到中断，再通过 iret 返回到用户态。0x80 中断例程代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;文件说明:interrupt.s</span><br><span class="line">;......上文忽略.......</span><br><span class="line">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;</span><br><span class="line">[bits 32]</span><br><span class="line">extern syscall_table</span><br><span class="line">section .text</span><br><span class="line">global syscall_handler</span><br><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EID</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 为系统调用子功能传入参数</span><br><span class="line">   push edx            ; 系统调用中第3个参数</span><br><span class="line">   push ecx            ; 系统调用中第2个参数</span><br><span class="line">   push ebx            ; 系统调用中第1个参数</span><br><span class="line"></span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;4 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><ul><li>以上代码的格式和之前中断处理的格式完全相同，不再赘述。</li><li><code>syscall_handler</code> 为系统调用的入口，所有系统调用都会通过该入口函数进入到指定的子功能处理函数。</li><li>第 25 行， <code>syscall_table</code> 是在 <code>syscall_init.c</code> 中定义的指针数组，该数组中存放的是各个系统调用的指针。</li><li>第 28 行，将存放返回值的 eax 存入内核栈的相应位置。为什么要这样呢？因为从用户态进入中断时，保存现场，存放调用号的 eax 被存入中断栈；所以从中断返回，恢复现场时，调用号重新被放入 eax；但 eax 必须用来存放返回值，所以必须将返回值提前放入中断栈的相应位置处，这样才能在返回用户态后从 eax 取得返回值。</li></ul><p><strong><mark class="hl-label blue">为 0x80 中断例程建立中断描述符</mark> </strong></p><p>想要通过 0x80 正确进入到相应例程，就必须建立相应的中断描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:idt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_CNT 0x81  <span class="comment">//修改为0x81</span></span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    make_idt_desc(&amp;idt[<span class="number">0x80</span>],IDT_DESC_DPL3,syscall_handler); <span class="comment">//为0x80建立中断描述符</span></span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//........</span></span><br></pre></td></tr></table></figure><p>现在完事具备，就差一个具体的系统调用啦！为了让用户进程能够说话，咋们先实现 write 系统调用，该调用可以在屏幕上打印文字。</p><h3 id="font-color-red-加入write系统调用-font"><font color='red'>加入write系统调用</font></h3><p>write系统调用相当简单，不过是对 console_put_str 的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(str,DEFUALT);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这是实际的子功能函数，是通过 <code>syscall_handler</code> 中断入口函数调用的，而不是被用户直接调用。用户调用的 write 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_WRITE,(<span class="type">uint32_t</span>)str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>SYS_WRITE</code> 为调用号，定义在 syscall.h 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SYSCALL_NR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SYS_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><u>如此一来，整个系统调用的流程就清晰的呈现在我们眼前：</u></font></strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRB(write)--&gt;L(_syscall1)--&gt;G(int 0x80)--&gt;K(syscall_handler)--&gt;A(sys_write)  </pre></div><p>最后，别忘了初始化系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    syscall_table[SYS_WRITE] = sys_write;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;init_all\n&quot;</span>,DEFUALT);</span><br><span class="line">    idt_init();    <span class="comment">// 初始化中断</span></span><br><span class="line">    timer_init();  <span class="comment">// 初始化PIT</span></span><br><span class="line">    thread_init(); <span class="comment">// 初始化线程相关结构</span></span><br><span class="line">    mem_init();   <span class="comment">// 初始化内存管理系统</span></span><br><span class="line">    console_init();<span class="comment">// 初始化终端输出</span></span><br><span class="line">    tss_init();    <span class="comment">// 初始化tss</span></span><br><span class="line">    syscall_init();<span class="comment">// 初始化系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前用户进程无法直接调用 print 系列函数进行打印（否则发生 0xd 号异常），现在实现了 write 系统调用，就可以让它说话啦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line">    process_execute(u_prog_a,<span class="string">&quot;proa&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hi,man\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/protalk.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h3 id="font-color-red-栈传递参数-font"><font color='red'>栈传递参数</font></h3><p>前文说到，如果参数超过五个，那么寄存器就不够用了，此时只能通过栈来传递。其实通过栈传递参数是调用门的原生做法，这点在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中有提到过。对于中断门而言，使用栈传递需要手动实现，但也很简单：进入中断时，处理器自动压入旧栈的 ss 和 esp，由于段基址都为 0，所以我们就能直接根据该 esp 定位到旧栈中的参数（因为旧栈压入参数后，调用中断，旧栈的 ss 和 esp 紧接着就被自动压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断剖析</a>），图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE36-1673590654821-2.png" alt=""><br>根据上图，就很容易知道如何从旧栈获取参数啦，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 获取当前栈中esp的值</span><br><span class="line">   mov ebx,[esp+4+48+4+12]</span><br><span class="line">;3 再将参数压入当前栈中</span><br><span class="line">   push dword [ebx+12]  ; 系统调用中第3个参数</span><br><span class="line">   push dword [ebx+8]   ; 系统调用中第2个参数</span><br><span class="line">   push dword [ebx+4]   ; 系统调用中第1个参数</span><br><span class="line">   mov eax,[ebx]        ; 子功能号</span><br><span class="line">;4 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;5 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><h3 id="font-color-red-思考-font"><font color='red'>思考</font></h3><p>你可能会问，为什么不直接在 API 中进行系统调用呢，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = SYS_WRITE</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式不是更直接吗？为啥还要通过 syscallX 来进行系统调用？答案是代码复用。系统调用有上百上千个，而它们的调用代码都像上面这样相似，如果每个函数都采用这种方式，无疑是相当冗余的。若参数个数相同的系统调用都使用同一种 syscall，如 syscall3，这样不就大大减少了代码量吗？</p>]]></content>
    
    
    <summary type="html">自制操作系统, 系统调用, Linux, syscall, write</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>printf加强-支持short与long long</title>
    <link href="http://jyxcpp.netlify.app/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <id>http://jyxcpp.netlify.app/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/</id>
    <published>2023-01-10T05:53:20.000Z</published>
    <updated>2023-03-16T13:19:37.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">printf 底层剖析及可变参数探究</a><br>本文参考文章：<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a> ，<a href="https://blog.csdn.net/kjlist2017/article/details/104113265">使用位运算代替取模</a><br>本节对应分支：<code>printk-enhanced</code></p></blockquote><p>上节说到 Linux 0.11 的 printk 不支持输出 short （不是不支持，而是表现得和 int 相同）和 long long，本节修改代码来支持 <code>%hd</code> 和 <code>%lld</code> 。<br>本以为很简单，只需像之前那样对 short 或 long long 数值不断除以基数并取模，依次得到数字字符，然后组成字符串即可。没想到的是，Bochs 的 <strong>32 位 x86 环境不支持 64 位除法和取模运算</strong> ，也就是说无法支持以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = a / b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = a % c;</span><br></pre></td></tr></table></figure><p>否则会报错，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `__divdi3&#x27;</span><br><span class="line">undefined reference to `__moddi3&#x27;</span><br></pre></td></tr></table></figure><p><strong><code>__divdi3</code> 和 <code>__moddi3</code> 是 gcc 为我们准备的 64 位除法和取模函数，当发生以上情况时，就用这两个函数来模拟除法和取模</strong> 。但由于咋们是自己实现操作系统，所以不能引入外部库函数（就算能，俺也不愿意，俺可不想让复杂的库函数来破坏我们操作系统的简洁性，而且链接了一个库，往往会连着其他许多库）。所以，我们要自己实现 64 位除法和取模函数。</p><p>坏消息是，笔者找了一天的相关资料，发现要么实现过于复杂，要么函数有 bug 。绞尽脑汁时，突然在知乎大佬的<a href="https://zhuanlan.zhihu.com/p/112361959">一篇文章</a>中看见了这样一个等式：</p><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x=2^{32}×H+L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></strong></p><p>其中 H 为 64 位整型 x 的高 32 位，L 为低 32 位。笔者狂喜，接着在草稿纸上写下了如下等式：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x/y=(2^{32}×H+L)/y=2^{32}×H/y+L/y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>其中 y 为 32 位整型，因为 y 就是基数 base，范围在 2~32 之间。<br>这样一来，不就将 64 位除法转换为了 32 位除法吗？哇哈哈哈哈，原来不过如此嘛！等着，别急，突然觉得哪有问题…计算机的除法是向下取整的，这也能使用分配律吗？当然不行，反例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">29</span>+<span class="number">32</span>)/<span class="number">8</span>=<span class="number">29</span>/<span class="number">8</span>+<span class="number">32</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span>  <span class="comment">//该等式成立,但换个方式拆分就不行了:</span></span><br><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">31</span>+<span class="number">31</span>)/<span class="number">8</span>=<span class="number">31</span>/<span class="number">8</span>+<span class="number">31</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span>  <span class="comment">//哦豁</span></span><br></pre></td></tr></table></figure><p>所以此方法无效喽，那怎么办？别急，考虑到我们的除法有一定特殊性，除数只为 8、10、16（printf只支持这三种格式打印），这个特性也许能用上。先想想，为什么取整除法不能像上面那样分配？因为拆分方式会影响两方的精度丢失情况，随着双方的精度丢失情况变化，就会影响最终结果。那么，使另一方被整除，从而将精度丢失只划给一方，这样不就能保证结果不受拆分方式而改变了吗？具体做法如下：</p><p>对于八进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>3</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><msup><mn>2</mn><mn>29</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">x/8=(2^{32}×H+L)/2^{3}=2^{32-3}×H+L/8=2^{29}×H+L/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span></span></span></span></font><br>对于十六进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>4</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>28</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">x/16=(2^{32}×H+L)/2^4=2^{32-4}×H+L/16=2^{28}×H+L/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span></span></span></span></font><br>可以发现，精度丢失只发生在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">L/base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span></span></span></span> 上，所以结果一定正确。</p><p>上面解决了 64 位除法的问题，那取模怎么解决呢？使用位运算的一个特性就可以完美解决这个问题：<br><u><strong><font color='orange'>取模运算 (a%b) 在当 b 为 2^n 时可简化为 a &amp; (b - 1)</font></strong></u></p><blockquote><p>简单证明：当 b 为 2^n 时,a/b的意义就是 a 右移 n 位，而右移的 n 位的值，就是 a%b 的值。</p></blockquote><p>以上除法和取模的方法只能用于 2 的幂，而 10 不是 2 的幂，所以只有另找办法了。所幸，那位知乎大佬的代码恰好能解决这个问题，详细参见<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a>。最终代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG    128     <span class="comment">//if long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_10</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = *n % <span class="number">10</span>;</span><br><span class="line">    *n = *n / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_16_8</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *n, <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = base==<span class="number">16</span>?<span class="number">28</span>:<span class="number">29</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> low = *n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hign= (*n)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mod = ((*n)&amp;(base==<span class="number">16</span>?<span class="number">15</span>:<span class="number">7</span>)); <span class="comment">//a &amp; (base - 1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(<span class="number">1</span>&lt;&lt;t) * hign + low / base;</span><br><span class="line">    *n = tmp;</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">long</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;LEFT) type &amp;= ~ZEROPAD;</span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) size--;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">16</span>) size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">16</span> || base==<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> *p = &amp;num;</span><br><span class="line">            *(++p) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div_16_8(&amp;num,base)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">                tmp[i++] = digits[do_div_10(&amp;num)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> low = num;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hign= num&gt;&gt;<span class="number">32</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i++] = ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                low = <span class="number">429496729</span> * (hign % <span class="number">10</span>) + low / <span class="number">10</span> + ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">                hign = hign / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;precision) </span><br><span class="line">        precision=i;</span><br><span class="line">    size -= precision;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line">    <span class="type">int</span> flags;<span class="comment">/* flags to number() */</span></span><br><span class="line">    <span class="type">int</span> field_width;<span class="comment">/* width of output field */</span></span><br><span class="line">    <span class="type">int</span> precision;<span class="comment">/* min. # of digits for integers; max number of chars for from string */</span></span><br><span class="line">    <span class="type">int</span> qualifier;<span class="comment">/* &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields */</span></span><br><span class="line">    <span class="keyword">for</span> (str=buf ; *fmt ; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process flags */</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">        repeat:</span><br><span class="line">        ++fmt;<span class="comment">/* this also skips first &#x27;%&#x27; */</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get field width */</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* get the precision */</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++fmt;</span><br><span class="line">                <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the conversion qualifier */</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            fmt++;</span><br><span class="line">            <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qualifier = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                flags |= LONG;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">                len = <span class="built_in">strlen</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                    precision = len;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                    len = precision;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                    *str++ = *s++;</span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    field_width = <span class="number">8</span>;</span><br><span class="line">                    flags |= ZEROPAD;</span><br><span class="line">                &#125;</span><br><span class="line">                str = number(str,(<span class="type">unsigned</span> <span class="type">long</span>) va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                flags |= SMALL;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)<span class="comment">// %llx</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                flags |= SIGN;</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">                *ip = (str - buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (*fmt)</span><br><span class="line">                    *str++ = *fmt;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --fmt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>do_div_16_8 函数就是处理 16 进制和 8 进制的例程，逻辑和前文所述相同，不再赘述。</p></li><li><p>此版本用 do_div_10 来代替了之前版本的 do_div 函数，没什么原因，只是不喜欢内联。do_div_10 只用来处理 32 位除法。</p></li><li><p>86~88 行用来处理 64 位 10 进制除法。</p></li><li><p>第 198 行，当类型为 long long 时，将 qualifier 赋值为 ‘m’，以便在 switch 中识别并处理</p></li><li><p>第 199 行，当类型为 long long 时，将 LONG 标记加入 flag 。打印 8 进制和 16 进制时，如果不为 long long，第 67~68 行则将 num 的高 4 位置零，只计算低 4 位。为什么要这样做呢？因为打印负的 16 进制和 8 进制的 32 位整型时，由于负数（补码）的首位为 1，传入 number 函数时，该数会发生符号扩展（因为 number 的参数 num 是 long long，而实参是 32 位），比如 32 整型数 -1 的二进制是 <code>0XFFFFFFFF</code> ，符号扩展后就成为 <code>0xFFFFFFFFFFFFFFFF</code> ，因此造成的结果就是：<code>printf(&quot;%x&quot;,-1)</code> 也会打印 <code>0xFFFFFFFFFFFFFFFF</code> ，而正确的结果应该是 8 个 F 。所以要对于 32 位负整型，需要将高 32 位清零。</p><blockquote><p>关于补码，详见[CSAPP][<a href="https://jyx-fyh.github.io/2022/07/08/CSAPP/">https://jyx-fyh.github.io/2022/07/08/CSAPP/</a>]。再次强调， <strong>打印八进制和十六进制的负数时，是直接打印其补码！</strong></p></blockquote></li></ul><p>最终效果如下：<br><img src="/2022/img/image-20230111102501588.png" alt=""><br>本文结束。</p>]]></content>
    
    
    <summary type="html">printf底层剖析, 可变参数, 原理, 源码</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>printf底层剖析及可变参数探究</title>
    <link href="http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-01-07T07:36:00.000Z</published>
    <updated>2023-03-16T13:19:05.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/">可变参数列表</a>，<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本文参考文章：<a href="https://book.douban.com/subject/3422332/">《你必须知道的495个C语言问题》</a><a href="https://book.douban.com/subject/1231236/">《Linux内核完全注释》</a>《操作系统真相还原》<a href="https://www.runoob.com/cprogramming/c-function-printf.html">printf-菜鸟教程</a><br>本节对应分支：<code>printk</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>相信每一位 C 选手写下的第一句代码都是下面这句经典的 Hello World 吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理所应当的，其中的 <code>printf</code> 函数也成为了咋们认识的第一个函数。对笔者个人而言， <code>printf</code> 是一个熟悉而陌生的函数，说熟悉是因为它伴随了我整个 C 语言的学习生涯；说陌生是因为学习过程中一直对它存疑，模模糊糊，始终没能一探究竟，不知道各位读者是否也是像笔者一样呢？记得 C 语言萌新阶段时，我时常吐槽 <code>printf</code> 中的那些格式符，如 <code>%d</code>、<code>%s</code>、<code>%c</code>、<code>%x</code> 等，乱七八糟的，实在是太难记啦！入门阶段时，我赞叹 <code>printf</code> 强大的格式处理能力，比如左右对齐、输出宽度、输出精度等；进阶阶段时，我又开始疑惑 <code>printf</code> 是如何做到参数可变的，但因为基础不足，就暂时搁浅。现在，天时地利人和，让我们对 <code>printf</code> 一网打尽吧！</p><p>本文将从以下几个方向逐个击破 <code>printf</code> ：</p><ul><li><strong><font color='gree'>默认参数提升</font></strong></li><li><strong><font color='gree'>可变参数的类型检查</font></strong></li><li><strong><font color='gree'>可变参函数实现原理</font></strong></li><li><strong><font color='gree'>其他注意事项</font></strong></li><li><strong><font color='gree'>printf源码详解</font></strong></li></ul><h3 id="font-color-red-默认参数提升-font"><font color='red'>默认参数提升</font></h3><p><strong><font color='orange'>注意，默认参数提升仅对可变参数列表有效</font></strong> ，其规则是：<strong><font color='orange'>char 和 short 自动提升为 int，float 自动提升为 double</font></strong> 。<br>比如我们一定知道，<code>%f</code> 用来输出 float，<code>%lf</code> 则用来输出 double；但实际上 <code>%f</code> 可以同时表示 float 和 double 类型，而无需专门指定 <code>%lf</code> 来表示 double（因为 printf 只能看到双精度），如下图：<br><img src="/2022/img/image-20230108145958396.png" alt=""></p><blockquote><p>本操作系统未支持浮点（难度较大，非常麻烦），且笔者对浮点的硬件支持不太了解，所以下面不讨论浮点。</p></blockquote><p>将 char/short 提升为 int 的原因是：<strong><u>可变参函数的原型无法提供参数个数以及参数类型，所以编译器无法针对各个参数生成相应代码，因此只好统一为 int 类型</u></strong> 。</p><blockquote><p>比如 <code>printf</code> 的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span></span><br></pre></td></tr></table></figure><p>显然，<code>...</code> （即可变参数列表）无法提供参数的个数和类型。值得一提的是，<code>printf</code> 中的 <code>f</code> 就是指的 <code>format</code> 。</p></blockquote><p>这么说原因大家可能还不太明白什么意思，下面笔者用代码进行解释，先来看普通函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">    test(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件生成的反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line">   4:   83 e4 f0                and    esp,0xfffffff0</span><br><span class="line">   7:   ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line">   a:   55                      push   ebp</span><br><span class="line">   b:   89 e5                   mov    ebp,esp</span><br><span class="line">   d:   51                      push   ecx</span><br><span class="line">   e:   83 ec 14                sub    esp,0x14</span><br><span class="line">  11:   c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">  18:   66 c7 45 f2 02 00       mov    WORD PTR [ebp-0xe],0x2</span><br><span class="line">  1e:   c6 45 f1 03             mov    BYTE PTR [ebp-0xf],0x3</span><br><span class="line">  22:   0f be 55 f1             movsx  edx,BYTE PTR [ebp-0xf]</span><br><span class="line">  26:   0f bf 45 f2             movsx  eax,WORD PTR [ebp-0xe]</span><br><span class="line">  2a:   83 ec 04                sub    esp,0x4</span><br><span class="line">  2d:   52                      push   edx</span><br><span class="line">  2e:   50                      push   eax</span><br><span class="line">  2f:   ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line">  32:   e8 fc ff ff ff          call   33 &lt;main+0x33&gt;</span><br><span class="line">  37:   83 c4 10                add    esp,0x10</span><br><span class="line">  3a:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3f:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">  42:   c9                      leave  </span><br><span class="line">  43:   8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line">  46:   c3                      ret    </span><br><span class="line"></span><br><span class="line">00000047 &lt;test&gt;:</span><br><span class="line">  47:   55                      push   ebp</span><br><span class="line">  48:   89 e5                   mov    ebp,esp</span><br><span class="line">  4a:   83 ec 08                sub    esp,0x8</span><br><span class="line">  4d:   8b 55 0c                mov    edx,DWORD PTR [ebp+0xc]</span><br><span class="line">  50:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">  53:   66 89 55 fc             mov    WORD PTR [ebp-0x4],dx</span><br><span class="line">  57:   88 45 f8                mov    BYTE PTR [ebp-0x8],al</span><br><span class="line">  5a:   c7 45 08 0a 00 00 00    mov    DWORD PTR [ebp+0x8],0xa</span><br><span class="line">  61:   66 c7 45 fc 0b 00       mov    WORD PTR [ebp-0x4],0xb</span><br><span class="line">  67:   c6 45 f8 0c             mov    BYTE PTR [ebp-0x8],0xc</span><br><span class="line">  6b:   90                      nop</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   c3                      ret  </span><br></pre></td></tr></table></figure><p>从第 34~36 行就可以看出参数类型的区别：int、short、char 对应的反汇编分别为 DWORD、WORD、BYTE ，也就是说，编译器为不同的类型生成了不同的代码。</p><blockquote><p>笔者以前想当然地认为函数参数类型影响的是压栈的字节数，比如将 char 压入栈，对应的反汇编就应该为 <code>push BYTE PTR [xxx]</code> ；实际上并非如此，<strong><font color='orange'>不论是 char、short、int 或是 long、long long，编译器都会压入 4 字节（对于 long long 8 字节，分两次压入）</font></strong> ，这点从 15~17 行就能体现。所以参数类型影响的不是压栈，而影响的是从栈中取值或赋值。</p></blockquote><p>那么对于可变参数列表，默认参数提升是如何体现的呢？待会讲解 <code>printf</code> 源码时再回过头来说这点。</p><h3 id="font-color-red-可变参数的类型检查-font"><font color='red'>可变参数的类型检查</font></h3><p>还是由于可变参数列表无法提供参数类型，所以编译器无法对参数进行类型检查，换句话说，<strong>编译器不能执行默认的类型转换，通常也不会报错</strong> 。对于普通函数而言，如果实参和形参类型不匹配，编译器会将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153040201.png" alt=""></p><p>而对于可变参数函数，编译器则无法将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153229945.png" alt=""><br>所以程序员必须自己确保参数类型的匹配或手动强制转换。</p><h3 id="font-color-red-可变参数函数实现原理-font"><font color='red'>可变参数函数实现原理</font></h3><p>想要实现可变参数，最重要的是明白其函数的调用方式，如果没有特定的<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>，可变参数将无从谈起。<strong><u>可变参数函数的调用方式必须满足以下两个条件：</u></strong></p><ol><li><p><strong><font color='orange'>从右向左压栈</font></strong></p><blockquote><p>为什么要从右往左入栈？ 因为如果从左向右，编译器就不知道用户传入了多少实参。参数的信息是由第一个参数 <code>fmt...</code> 确定的（如 <code>printf (“% s % s”,str1 ,str2)</code> 的参数信息是通过检测两个 <code>%s</code> 来获取的）。若从左向右压栈，<code>fmt...</code> 就被放入了栈底，而 esp 由于不清楚参数个数和类型，就无法跨过这些参数来指向 <code>fmt...</code> ，因此无法获取各个参数的信息。相反，若从右向左压栈，<code>fmt...</code> 就存放在栈顶，这样就可以直接通过它得知参数的个数和类型，进而准确从栈中取得各个参数。</p></blockquote></li><li><p><strong><font color='orange'>外平栈（调用者平栈）</font></strong></p><blockquote><p>必须由调用者平栈的原因是：只有调用者才知道压入了几个参数，所以也只能由调用者进行平栈。读者可能感到疑惑，为什么只有调用者才知道压入了几个参数？仍然拿 <code>printf</code> 举例，是这样的：<code>printf</code> 作为库函数，是提前被编译好了的（一般作为动态链接库），最后直接与我们自己编写生成的可重定位文件链接在一起，从而生成可执行文件；所以 <code>printf</code> 完全不知道实际压入了多少个参数（因为压参是由我们的编译器进行的）！因此也就无法由 <code>printf</code> 自己来完成平栈。相反，如果是调用方本身来调用的 <code>printf</code> ，理所应当地，调用方就知道自己向栈中压入了多少个参数，所以调用方就可以承担平栈任务，如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d  %c&quot;, 1, 2);</span><br><span class="line">&#125;</span><br><span class="line">//对应汇编：</span><br><span class="line">//......省略</span><br><span class="line">00BF17E1  push        2  </span><br><span class="line">00BF17E3  push        1  </span><br><span class="line">00BF17E5  push        offset string &quot;%d\n&quot; (0BF7BD8h)  </span><br><span class="line">00BF17EA  call        _printf  </span><br><span class="line">00BF17EF  add         esp,0Ch  </span><br><span class="line">//......省略</span><br></pre></td></tr></table></figure><p>call 之前，编译器 push 了三次，所以它当然知道平栈需要 add esp,0xC ！而 printf 是已经编好的库，它就不知道 push 了几次。</p></blockquote></li></ol><p>而 __cdel 调用约定就符合以上两个规则，所以可变参函数必须使用此方式。值得一提的是，__cdel 是 C/C++ 默认方式。<br>有了以上两种条件的支持，现在无非就是处理 <code>fmt...</code> 获取参数信息，然后从栈中取得参数即可。这就是咋们接下来要干的事。</p><h3 id="font-color-red-其他注意事项-font"><font color='red'>其他注意事项</font></h3><p><strong><mark class="hl-label blue">需要打印%咋办？</mark> </strong><br>这点相信大部分读者都清楚，打印百分号需要再加个百分号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是百分号%%&quot;</span>);</span><br></pre></td></tr></table></figure><p>很多小白会在 <code>%</code> 前加 <code>\</code> ，即 <code>printf(&quot;\%&quot;)</code> 来输出百分号。出现这种想法是因为没有理解转义字符的意义，要知道，<code>\n</code> 是一个 ASCII 码（10），由编译器负责将 <code>\n</code> 转为 10 。而 <code>\%</code> 可不是转义字符，对 <code>%</code> 的处理是由我们的代码负责，而不是由编译器负责！</p><p><strong><mark class="hl-label blue">printf实参问题</mark> </strong><br>很多读者应该都像下面这种方式调用过 printf 吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>这种方式有什么不对吗？结果正确，但这种调用方式十分危险。这是因为，<code>110</code> 没有指明类型，所以根据前面的默认参数提升，<code>110</code> 被视为 int，这符合 <code>%d</code> ，所以能够正确输出。但是碰到下面这种情况呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>结果就变得诡异，输出如下：<br><img src="/2022/img/image-20230110115919374.png" alt=""><br>这是因为 <code>110</code> 被编译器视为 int（4字节)，但 printf 内部代码根据 <code>%lld</code> 将 <code>110</code> 视为 long long（8字节)，在定位参数时，将 long long* 指针指向 <code>110</code> 所在的位置，那么用该指针解释数据的时候，将会把 <code>110</code> 后面的四字节包含进去，而这四字节中的数据是未定义的，所以造成以上错误。再来看下面的调用：<br><img src="/2022/img/image-20230110130458876.png" alt=""><br>怎么这种情况又能够正确显示呢？这是因为编译器判定 <code>0xfffffffff</code> 无法用 int 装下，所以该值的类型就变为了 long long，因此能够正确输出。正确的调用方式需要加上强制转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>看完 printf 源码后，你会对上述行为有深刻理解。</p><h3 id="font-color-red-printf源码剖析-font"><font color='red'>printf源码剖析</font></h3><blockquote><p><strong>说明：</strong></p><ul><li>以下源码来自 Linux 0.11 ，也就是 Linus Torvalds 编写的初代 Linux ，所以其功能肯定不如现在的 printf 强大，这点读者需要清楚。</li><li>printk（print kernel）和 printf 的功能完全相同，只不过前者是在内核中使用的打印函数，而后者是在用户态中使用的打印函数。</li><li>为了契合咋们的操作系统，笔者会将 printk 作轻微修改，使其能够在用户态下使用（此时也就变成了 printf ），这不会影响对 printf 的理解。</li></ul></blockquote><p>以下是原版的 <code>printk</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">va_start(args, fmt);</span><br><span class="line">i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">va_end(args);</span><br><span class="line">__asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $_buf\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;call _tty_write\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>提供原版的 printk 只是为了与下面咋们改进后的 printf 形成对比，大家无需纠结上面的代码</u>。以下是我们操作系统的 <code>printf</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> </span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="type">int</span> i = write(buf);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可见，除了第 9 行外，其他完全相同。实际上，第 9 行将最终的字符串传给我们之前实现的系统调用 write，由 write 进行打印。另外，<strong><font color='orange'>正因为 write 是系统调用，所以该 printf 既可以供内核使用，也可以供用户使用</font></strong> 。</li><li><code>printf</code> 返回字符个数。</li></ul><p>接下来重点说明处理可变参数的四个宏： <code>va_list</code> 、<code>va_start</code> 、<code>va_end</code> 和 <code>va_arg</code> 。</p><p><strong><mark class="hl-label blue">可变参数宏</mark> </strong><br>首先要破除大家的先入为主，别以为这四个宏是用来处理可变参数的，就觉得它们高大上，有什么特异功能，实际上这四个家伙的本质就普普通通：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(p, fmt) (p = (char*)&amp;fmt + sizeof(char*))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(p)        (p = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(p, type)  (p += __va_rounded_size(type), *((type*)(p - __va_rounded_size (type))))</span></span><br></pre></td></tr></table></figure><ul><li><p><em><em><code>va_list</code> <u>就是 char</em> 指针类型，该指针（args）用来在栈中依次遍历各个参数</u></em>* 。</p></li><li><p><strong><code>va_start</code> <u>的作用是将 args 指针指向参数列表（即 <code>...</code> ）中的第一个参数</u></strong> 。</p><blockquote><p><code>p = (char*)&amp;fmt + sizeof(char*)</code> 就是令 p 跳过栈中的 fmt ，指向栈中的下一个参数，即参数列表中的第一个参数。注意必须对 fmt 取地址，得到该指针的地址，也就是该指针在栈中的位置，<code>&amp;fmt</code> 为二级指针，还需要强制转换为一级指针 char* 。</p></blockquote></li><li><p><strong><code>va_end</code> <u>的作用是将 args 指针置 NULL</u></strong> 。</p></li><li><p><code>va_arg</code> 出现在下面的 <code>vsprintf</code> 函数中，<strong><u><code>va_arg</code> 的作用是返回当前 args 指向的参数的值，然后 args 向后移动，指向下一个参数</u></strong> 。</p><blockquote><p><code>__va_rounded_size(type)</code> 也是一个宏，<strong><u>用来得到取整后的 type 类型的大小，是 int 的整数倍</u></strong> ，比如 type 为 char，则返回 4；type 为 long long，则返回 8 ，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __va_rounded_size(type)  \</span></span><br><span class="line"><span class="meta">  (((sizeof (type) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span></span><br></pre></td></tr></table></figure><p>注意，va_arg 宏定义是一个逗号表达式，第一个表达式<u>根据目前所指参数 A 的大小</u>，将指针 p 移向了下一个参数 B（+=，p的值已经被改变）；接着将 A 的值返回（逗号表达式中的最后一个式子作为返回值）。顺便提一下，如果按照《操作系统真相还原》中的代码，将无法应对 long long 的情况。</p></blockquote></li></ul><p>接着来看 vsprintf 。</p><p><strong><mark class="hl-label blue">vsprintf</mark> </strong><br><strong>vsprintf 的作用是格式化字符串，也就是将参数列表中的所有参数值填入到 fmt 中的对应位置，并将最终的字符串存入 buf</strong> 。<code>fmt</code> 中的格式符，如 <code>%d</code> 、<code>%s</code> 等都在此函数中进行处理。在讲解该函数代码前，有必要先复习 printf 的用法，否则看代码时将一头雾水。</p><p>我们将 <code>%s</code> 这样的格式称之为一个 format 标签，format 标签的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure><p>比如下面这样的 printf 调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10ld&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中的 <code>-</code> 为 flags，即指明左对齐；<code>10</code> 为 width，即指明输出宽度；<code>l</code> 为长度，对于 <code>d</code> 而言，即输出长整型 long；<code>d</code> 为 specifier，指明输出整型。<br>具体规则如下：</p><table><thead><tr><th><strong>flags</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>-</strong></td><td>在给定的字段宽度内左对齐，默认是右对齐</td></tr><tr><td><strong>+</strong></td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td><strong>空格</strong></td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td><strong>#</strong></td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。由于本操作系统暂不支持小数，所以不说明 # 对 f、e、g 等说明符的影响。</td></tr><tr><td><strong>0</strong></td><td>在左边填充零，而不是空格</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>width</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>number</strong></td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充；如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定宽度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>.number</strong></td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 <br />对于 s：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 <br />对于 c：没有任何影响。 当未指定任何精度时，默认为 1。</td></tr><tr><td style="text-align:left"><strong>.</strong>*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定精度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>length</strong></th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>h</strong></td><td style="text-align:left">参数被解释为短整型或无符号短整型 short（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left"><strong>l</strong></td><td style="text-align:left">参数被解释为长整型或无符号长整型 long，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left"><strong>L</strong></td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。本操作系统不支持。</td></tr><tr><td style="text-align:left"><strong>ll</strong></td><td style="text-align:left">本操作系统中，ll 仅被解释为 <strong>无符号 long long</strong>，适用于整数说明符。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">和 d 完全相同</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">到目前为止成功写入缓冲区的字符数，此值存储在指定的整数中，其地址作为参数给出。</td></tr></tbody></table><p>下面做几个示范：<br><img src="/2022/img/image-20230109092042387.png" alt=""><br><img src="/2022/img/image-20230109092442698.png" alt=""><br><img src="/2022/img/image-20230109094520482.png" alt="由于安全原因，VS默认禁止使用%n，所以此处用 Bochs 代替"></p><p>了解以上格式后，再来看 vsprintf 就十分轻松啦，总的来说，该函数就是在依次处理 flags --&gt; width --&gt; .precision --&gt; length --&gt; specifier 。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成2的倍数,是因为我们将flag变量视为位图,将属性保存到各个二进制位上</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">int</span> flags;          <span class="comment">// flags to number() </span></span><br><span class="line"><span class="type">int</span> field_width;    <span class="comment">// width of output field </span></span><br><span class="line"><span class="type">int</span> precision;      <span class="comment">// min of digits for integers; max number of chars for from string </span></span><br><span class="line"><span class="type">int</span> qualifier;      <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (str=buf ; *fmt ; ++fmt) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//如果不是format标签,则直接复制到str</span></span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//处理flags</span></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">repeat:</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理输出宽度</span></span><br><span class="line">field_width = <span class="number">-1</span>; <span class="comment">//默认为-1,即未指示宽度,因为 flag | -1 = flag</span></span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">field_width = skip_atoi(&amp;fmt); <span class="comment">//skip_atoi将字符转为数字,后文给出</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则width由下一个参数给出 </span></span><br><span class="line"><span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)  <span class="comment">//若宽度参数小于0,则左靠齐,和&#x27;-&#x27;号效果相同</span></span><br><span class="line">&#123;</span><br><span class="line">field_width = -field_width;</span><br><span class="line">flags |= LEFT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理精度</span></span><br><span class="line">precision = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">precision = skip_atoi(&amp;fmt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">precision = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则precision由下一个参数给出 </span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理长度描述符符</span></span><br><span class="line">qualifier = <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">qualifier = *fmt;  <span class="comment">//实际上,后面就没有用到qualifier了,显得鸡肋</span></span><br><span class="line">++fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理格式字符</span></span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT)) <span class="comment">//如果不是左靠齐,则左边补field_width-1个空格</span></span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">*str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) <span class="comment">//否则后方补空格</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) <span class="comment">//如果字符串长度大于精度,则丢弃超过精度的部分</span></span><br><span class="line">len = precision;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">*str++ = *s++;</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)<span class="comment">//如果执行了上面的while,此处就不会再执行</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:  <span class="comment">//number函数用来将数字转换为字符串</span></span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="comment">//按十六进制输出指针,宽度为8,宽度不足则补前导0</span></span><br><span class="line"><span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">field_width = <span class="number">8</span>;</span><br><span class="line">flags |= ZEROPAD;</span><br><span class="line">&#125;</span><br><span class="line">str = number(str,(<span class="type">unsigned</span> <span class="type">int</span>)va_arg(args,<span class="type">void</span>*), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">flags |= SMALL;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">flags |= SIGN;  <span class="comment">//%d和%i都是有符号数</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">*ip = (str - buf); <span class="comment">//返回目前字符串的宽度</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若格式转换符不是&#x27;%,则表示格式字符串有错,直接将一个%写入输出串中;如果格式转换符的位置处还有字符,则也直接将该字符写入输</span></span><br><span class="line">        <span class="comment">//出串中,并返回到107行继续处理格式字符串;否则表示已经处理到格式字符串的结尾处,则退出循环。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt)</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">--fmt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释得比较清楚，对照之前的规则来看代码就很容易理清其中的逻辑，不再详细说明。提一点，看第 90 行，<code>va_arg(args, int)</code> ，这说明从栈中取字符时，是以 int 大小来取的（ <strong><u><font color='orange'>这里就体现了默认参数提升</font></u></strong> ），然后再被强制转换为 char 。为什么不能 <code>va_arg(args,char)</code> 呢？实际上这样完全能够准确获取栈中字符的值，但如果这样的话，下一次使用 va_arg 宏取参数时，args 指针就指向了该字符的下一字节，但下一个参数应该是在该字符的四字节后，这无疑将引发错误，图示如下：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE35.png" alt=""></p><p>代码中还用到了 skip_atoi() 和 number() 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//判断是否为数字字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \    <span class="comment">// n=n/base,并返回n%base</span></span></span><br><span class="line"><span class="type">int</span> __res; \                   <span class="comment">//宏定义采用大括号的方式,最后一条语句作为返回值</span></span><br><span class="line">__asm__(<span class="string">&quot;div %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (n),<span class="string">&quot;=d&quot;</span> (__res):<span class="string">&quot;0&quot;</span> (n),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),<span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">__res; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span><span class="comment">//pointer to fmt,即fmt的指针,所以该指针为二级指针</span></span><br><span class="line">&#123;                                      <span class="comment">//为什么要用二级指针?因为咋们要在函数中修改fmt的值(不仅是修改形参,实参也要修改)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;                           <span class="comment">//由于fmt是指针,所以要修改指针的值,就需要用二级指针</span></span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//(*fmtp)++,就是fmt++</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SMALL) </span><br><span class="line">digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;LEFT) </span><br><span class="line">type &amp;= ~ZEROPAD; <span class="comment">//如果为左对齐,则无需0填充</span></span><br><span class="line"><span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>) <span class="comment">//仅支持2~36进制,否则返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">num = -num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);<span class="comment">//要么+,要么空1格</span></span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">size--; <span class="comment">//如果有符号或空格,则占一位</span></span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">size -= <span class="number">2</span>; <span class="comment">//0x占两位</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">size--;    <span class="comment">//0占一位</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 以下开始处理数字</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">tmp[i++]=digits[ do_div(num,base) ]; <span class="comment">//依次取得num的最低位数字,并填入tmp,</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;precision)                     <span class="comment">//此时顺序是反的,第72行会调整顺序</span></span><br><span class="line">precision=i; <span class="comment">//如果数字个数大于精度,不会截断,精度成鸡肋</span></span><br><span class="line">size -= precision;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">*str++ = sign;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">&#123;</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">*str++ = digits[<span class="number">33</span>]; <span class="comment">//&#x27;X&#x27;或&#x27;x&#x27;,取决于digit的指向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>) <span class="comment">//如果是右靠齐,则补前导0或前导空格</span></span><br><span class="line">*str++ = c;</span><br><span class="line"><span class="keyword">while</span>(i&lt;precision--)<span class="comment">//精度大于数字个数,则补前导0</span></span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = tmp[i];<span class="comment">//i--,str++,调整数字顺序</span></span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果67行已经执行,此处就不会再执行</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释详尽，不再说明。<br>值得一提的是，该版 printf 有许多不足，例如不支持 <code>%hd</code> (short)，<code>%lld</code> (long long) ，下节<a href="https://jyx-fyh.github.io/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/">printf加强版</a>中我们会增加这两个功能。<br><img src="/2022/img/image-20230110134655302.png" alt=""></p><p>本文结束。</p>]]></content>
    
    
    <summary type="html">printf, 底层, 剖析, Linux, 可变参数</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>实现用户进程-代码详解</title>
    <link href="http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-01-06T09:17:36.000Z</published>
    <updated>2023-03-12T11:21:04.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程-进入用户态</a><br>本节对应分支：<code>userprog</code></p></blockquote><h3 id="font-color-red-初始化TSS、C语言接管GDT-font"><font color='red'>初始化TSS、C语言接管GDT</font></h3><p>下面是 <code>global.h</code> 中添加的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="comment">//=============用户进程的段选择子================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_CODE   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span></span><br><span class="line"><span class="comment">// ===============GDT描述符属性=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_G_4K    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_D_32    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_L     0<span class="comment">// 64位代码标记，此处标记为0便可。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_AVL     0<span class="comment">// cpu不用此位，暂置为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_P     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_1   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_2   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_3   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_CODE1       <span class="comment">// s为1时表示存储段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_DATADESC_S_CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_SYS0       <span class="comment">// s为0时表示系统段.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_CODE8<span class="comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_DATA  2<span class="comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_TSS   9<span class="comment">// B位为0,不忙</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ATTR_HIGH     ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_CODE_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_DATA_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span></span><br><span class="line"><span class="comment">//================ TSS描述符属性===================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_DESC_D  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_LOW ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_TSS ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2 ) + RPL0)</span></span><br><span class="line"><span class="comment">//================ GDT描述符 =====================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit_low_word;</span><br><span class="line">    <span class="type">uint16_t</span> base_low_word;</span><br><span class="line">    <span class="type">uint8_t</span>  base_mid_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  attr_low_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  limit_high_attr_high;</span><br><span class="line">    <span class="type">uint8_t</span>  base_high_byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第 3~5 行定义了用户进程的段选择子，其中代码段选择子索引为 5，即用户代码段的描述符位于 GDT 的第 5 号描述符的位置处；数据段和栈段共享一个描述符，选择子索引为 6 。你可能会疑惑，为什么只定义了一套用户的选择子，万一将来有多个用户进程同时运行，这几个选择子岂不是不够用？实际上只需要一套用户选择子就可以了，<strong><font color='orange'>因为所有用户进程都共享这一套选择子</font></strong> 。为什么可以共享呢？这便体现出虚拟空间下平坦模型的优越性了。<strong><font color='orange'><u>因为每个进程都有自己独立的虚拟地址空间，平坦模型下数据段和代码段描述符的基址直接设为 0，所以执行流只取决于 EIP 而依赖 CS。反观分段模型，由于没有虚拟地址空间，各个用户进程被分配到不同区域的物理内存中，所以为了隔离它们，每个用户进程的段基址都不相同，因此需要为每个用户进程都分配一套段选择子和段描述符</u></font></strong> ，不仅管理繁琐，而且效率低下。<br>另外，当初咋们在 <code>loader.s</code> 中设计 GDT 表时，并没有为用户和 TSS 预留段描述符，所以现在必须在 <code>loader.s</code> 中加上一行代码以预留空间：<br><img src="/2022/img/image-20230103153548106.png" style="zoom:100%;" /></li><li>之前是在 <code>loader.s</code> 中直接书写 GDT ，为了方便，现在我们使用 C 语言接管 GDT，以方便在 GDT 中添加和修改段描述符。所以在头文件中定义了段描述符和 TSS 描述符的各个属性以及段描述符的结构体 <code>gdt_struct</code> 。关于各个位的解释，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">GDT</a> 。</li></ul><p>下面是 <code>tss.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">gdt_operand</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> tss_slt;</span><br><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> backlink;</span><br><span class="line">    <span class="type">uint32_t</span>* esp0;</span><br><span class="line">    <span class="type">uint32_t</span> ss0;</span><br><span class="line">    <span class="type">uint32_t</span>* esp1;</span><br><span class="line">    <span class="type">uint32_t</span> ss1;</span><br><span class="line">    <span class="type">uint32_t</span>* esp2;</span><br><span class="line">    <span class="type">uint32_t</span> ss2;</span><br><span class="line">    <span class="type">uint32_t</span> cr3;</span><br><span class="line">    <span class="type">uint32_t</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> ldt;</span><br><span class="line">    <span class="type">uint32_t</span> trace;</span><br><span class="line">    <span class="type">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新tss中esp0字段的值为pthread的0级线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tss_esp</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    tss.esp0 = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建gdt描述符 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gdt_desc <span class="title function_">make_gdt_desc</span><span class="params">(<span class="type">uint32_t</span>* desc_addr, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> attr_low, <span class="type">uint8_t</span> attr_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> desc_base = (<span class="type">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="type">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="type">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在gdt中创建tss并重新加载gdt */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tss_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"><span class="comment">/* gdt基址为0x910,把tss放到第4个位置,也就是0x910+0x20的位置 */</span></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">   *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000930</span>)  = make_gdt_desc((<span class="type">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000940</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    load_xdt(&amp;gdt_operand,<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>,<span class="number">0xc0000910</span>);</span><br><span class="line">    tss_slt = SELECTOR_TSS;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lgdt gdt_operand&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ltr tss_slt&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init and ltr done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4~33 行定义了 TSS 结构，这没有太多要说的，有个小问题是，结构体定义不应该放在头文件中吗，这里为什么要放在 C 文件中呢？是不是不太规范？这也是笔者之前的误解，原以为只要是宏定义或者结构体定义一类的都应该放在头文件，而 C 文件中只放函数定义，这样才显得规范。实际上并不是如此，原则应该是：<strong><font color='orange'>如果其可见性超出一个 .c 文件，那么应当放入 .h 中，如果只是某一个 .c 里需要这么一个结构作为辅助，直接放入这个.c中更好一些</font></strong> 。放在 .c 还是 .h 取决于该结构是否要暴露给其他 .c，能放 .c 绝不放 .h 。而 TSS 结构只会在此文件中使用，所以就定义在此 .c 文件中。</li><li>第 37 行，update_tss_esp() 用来将 TSS 中 esp0 字段的值更新为 pthread 的内核线。如上节内容所说，所有任务共享一个 TSS，只是在任务切换时更新 ESP0 的值。</li><li>第 61 行，将 TSS 的 io_base 字段设置为 TSS 的大小，这表示此 TSS 中没有 IO 位图。</li><li>第 62 行，GDT 的基址为 0x910，这是如何确定的？见下面 <code>loader.s</code> 的片段即可知道。<br><img src="/2022/img/image-20230105121240944.png" style="zoom:67%;" /></li><li>第 69 行的 load_xdt 函数，咋们之前用它设置过 IDTR，定义在 global.h 中。gdt_operand 是加载 GDT 时用的操作数，设置好 gdt_operand 的基址和界限后，第 71 行便使用内联汇编 <code>lgdt</code> 指令加载 GDTR。至于为什么要将 gdt_operand 和 tss_slt 定义为全局静态变量，这在之前的文章中反复提及过，不再赘述。同理，第 72 行使用 <code>ltr</code> 指令将 TSS 的选择子 tss_slt 加载进 TR 寄存器，由于 TSS 只有一个，所以只会加载这一次，以后就不会再修改 TR 了。</li></ul><h3 id="font-color-red-用户进程的虚拟地址空间-font"><font color='red'>用户进程的虚拟地址空间</font></h3><p>在<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础篇</a>中，我们划出了三个内存池：内核物理内存池、内核虚拟内存池、用户物理内存池。为了实现用户进程的虚拟地址空间，我们还需要给每个进程设置私有的用户虚拟内存池。见以下步骤。</p><p><strong><mark class="hl-label blue">在task_struct中添加虚拟内存池</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       <span class="comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> <span class="comment">// general_tag的作用是用于线程在一般队列中的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span><span class="comment">// all_list_tag的作用是用于线程队列thread_all_list中的结点</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              <span class="comment">// 进程页表</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span>   <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 14 行即为用户进程的虚拟内存池。</p><p><strong><mark class="hl-label blue">用户虚拟内存管理</mark> </strong><br>在 <a href="">内存管理-进阶</a>中，我们留下了部分内容等到实现用户进程时补充，如下：<br><img src="/2022/img/image-20230105154723658.png" style="zoom:67%;" /><br>第 33 行的作用和其上内核部分的代码相似，都是在申请虚拟内存。以下代码补齐这部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct* cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">        <span class="comment">/*0xc0000000-PAGE_SIZE作为3级用户栈已经在start_process中被分配*/</span></span><br><span class="line">        assert((<span class="type">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>逻辑清晰，不再解释。另外还添加了几个必要的内存管理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_user_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="type">void</span>* vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将地址vaddr与pf池中的物理地址关联,仅支持一页空间分配 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_a_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="type">int32_t</span> bit_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;pgdir != <span class="literal">NULL</span> &amp;&amp; pf == PF_USER)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;pgdir == <span class="literal">NULL</span> &amp;&amp; pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span></span><br><span class="line">        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        panic(<span class="string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">    <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">    lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址映射到的物理地址 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">addr_v2p</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"><span class="comment">/* (*pte)的值是页表所在的物理页框地址,</span></span><br><span class="line"><span class="comment"> * 去掉其低12位的页表项属性+虚拟地址vaddr的低12位 */</span></span><br><span class="line">    <span class="keyword">return</span> ((*pte &amp; <span class="number">0xfffff000</span>) + (vaddr &amp; <span class="number">0x00000fff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>get_user_pages 和 get_kernel_page 的逻辑完全相同，不再赘述。提一下，笔者在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶</a>中提到过如下内容：</p><blockquote><p>扫描和设置位图必须连续，中间不能切换线程 。这里和线程切换有关，简单解释：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题 。因此扫描和设置位图必须保证原子操作。需要注意的是，此处代码并没有保证原子性，未来我们会用锁来实现 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></blockquote><p>现在咋们已经实现了锁机制，所以这里申请内存时用锁来保证原子性。锁加在 pool 结构体中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span>                      //管理物理内存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 本内存池字节容量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>            <span class="comment">// 保证内存申请时的原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第 13 行定义 get_a_page 函数，该函数与 get_kernel_page 或 get_user_page 的差别在于前者能够申请指定位置的虚拟内存，而后者则无法指定位置。该函数待会用来指定在 0xc0000000 处申请一页虚拟内存作用户栈。</p></li><li><p>addr_v2p 函数，其中 2 和 to 同音，即 addr_v_to_p，功能是将虚拟地址 vaddr 转换为对应的物理地址。下面咋们马上就会用到此函数。</p></li></ul><p><strong><mark class="hl-label blue">创建用户进程</mark> </strong><br>这部分内容很多，打起精神啦！</p><p>在中断栈中构建用户进程的上下文时，需要设置 eflags 寄存器，所以在 global 中定义好 eflags 的属性位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:global.h</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_MBS(1 &lt;&lt; 1)        <span class="comment">// 该位保留,总是为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_1(1 &lt;&lt; 9)        <span class="comment">// if为1,开中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_00               <span class="comment">// if为0,关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_3(3 &lt;&lt; 12)   <span class="comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_0(0 &lt;&lt; 12)   <span class="comment">// IOPL0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_ROUND_UP(X, STEP) ((X + STEP - 1) / (STEP)) <span class="comment">//用于除法的向上取整,如2/3=1</span></span></span><br></pre></td></tr></table></figure><p>下面则开始创建用户进程，<strong><font color='orange'>注意上节中的进程创建流程图对比</font></strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:process.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">proc_stack</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pagedir_phy_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">intr_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_process</span><span class="params">(<span class="type">void</span>* filename_)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* function = filename_;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);   <span class="comment">//跨过thread_stack,指向intr_stack</span></span><br><span class="line">    proc_stack = (<span class="keyword">struct</span> intr_stack*)cur-&gt;self_kstack; <span class="comment">//可以不用定义成结构体指针</span></span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>;          <span class="comment">// 不允许用户态直接访问显存资源,用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function; <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="type">void</span>*)((<span class="type">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,proc_stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;jmp intr_exit&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 击活页表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_dir_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">     * 执行此函数时,当前任务可能是线程。</span></span><br><span class="line"><span class="comment">     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,</span></span><br><span class="line"><span class="comment">     * 否则不恢复页表的话,线程就会使用进程的页表了。</span></span><br><span class="line"><span class="comment">     ********************************************************/</span></span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    pagedir_phy_addr = <span class="number">0x100000</span>;  <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)  <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov eax,pagedir_phy_addr&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov cr3,eax&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 激活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0特权级,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0*/</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建页目录表,将当前页表的表示内核空间的pde复制,</span></span><br><span class="line"><span class="comment"> * 成功则返回页目录的虚拟地址,否则返回-1 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">create_page_dir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页目录表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">&quot;create_page_dir: get_kernel_page failed!&quot;</span>,FT_RED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span>*<span class="number">4</span>), (<span class="type">uint32_t</span>*)(<span class="number">0xfffff000</span>+<span class="number">0x300</span>*<span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_user_vaddr_bitmap</span><span class="params">(<span class="keyword">struct</span> task_struct* user_prog)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_execute</span><span class="params">(<span class="type">void</span>* filename, <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 **/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, DEFUALT_PRIO);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);<span class="comment">//start_process(filename)</span></span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>start_process 中，proc_stack 结构体指向中断栈，并初始化进程上下文。</p></li><li><p>第 9 行，需要说明的是，用户进程一般是硬盘中的一段程序，需要加载到内存，然后再运行，所以进程的定义就是“运行中的程序”。<strong>但目前我们还没有实现硬盘驱动程序和文件系统，所以用户进程只能由一个函数代替</strong> ，实际上，这两者也没有本质区别。</p></li><li><p>第 15 行，由于 <strong><font color='orange'>用户不能直接使用显存</font></strong>，所以将 gs 直接初始化为 0，则用户使用该选择子时，会索引到 GDT 的第 0 号描述符而引发异常。</p></li><li><p>第 20 行，调用 get_a_page() 在指定位置，即用户空间 3GB 顶端处申请一页内存用来作用户栈，这在之前有所提及。</p><blockquote><p>用户栈只有一页吗？笔者暂不清楚当栈使用超过一页会发生什么，后续补充。</p></blockquote></li><li><p>第 23 行，intr_exit 是从 <code>interrupt.s</code> 引入的函数，专门处理中断返回。这没有什么好说的，只是为了复用代码，也可以直接在 23 行处使用内联汇编连续弹栈并 <code>iret</code> 。<code>iret</code> 后执行流就转移到用户进程啦！</p></li><li><p>第 27 行，page_dir_active，页表激活函数。从流程图中可以看见，该函数在 schedule() 中被调用，如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.c</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    process_activate(next);</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong><u>每当任务切换(swtich_to)前，都会重新激活页表</u></strong> ，这不禁引发我们的疑惑：不是进程才有独立的地址空间吗？怎么连线程都要激活页表了呢？其实这可以在上节<a href="">进程的实现方式</a>找到答案。在 Linux 中，<strong><u>多个地址空间相同的线程组成了一个进程</u></strong> ，所以线程也需要记录页表。需要注意的是，<strong><font color='gree'>目前我们只实现了内核线程(thread_start) 和用户进程 (process_execute)，还未实现用户线程</font></strong>  (未来看情况按需添加)，所以 task_struct 中的 pgdir 只分为两种情况：NULL 和其他值；如果为 NULL，则说明该任务为内核线程；如果为非 NULL，则说明该任务为用户进程。<br>另外，<strong>第 40 行加载 cr3 有大坑！</strong> 还记得吗，在<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>一文中，笔者将内核的起始虚拟地址设置为了 0x1500，并提醒读者未来这个 0x1500 会留下问题。这个问题就在此处浮现：首次切换页表之前，执行流一直位于内核进程中，而内核进程虚拟空间的低 1MB 和高 3GB 处都是内核（这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中早有说明，忘记的读者请回头复习）。又因为之前将内核的起始虚拟地址设置为了 0x1500，所以一直以来内核始终运行在低端 1MB 处，而非高 3GB 处。关键来了，当内核执行流运行到第 40 行切换页表时，切换前执行流位于 1MB 下，切换后当然也仍位于 1MB 下（因为代码中的地址都是提前编译好的），但是，切换到用户进程的页表后，低端 1MB 就不再是内核啦（对于用户进程而言，内核只位于高 3GB 处）之前说过，用户进程的低端 128MB 为保留，没有任何东西，所以执行流运行在用户进程虚拟空间的低端 1MB 下将必定出错！因此，为了保证切换页表前后执行流能够统一，我们必须将内核的起始虚拟地址设置为 0xc0001500，这样对于内核进程和用户进程来说，内核都运行在高 3GB 上，切换页表前后执行流就不会改变。修改如下：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><blockquote><p>这里也是卡了笔者很久，如果当初不作死修改 Ttext，也不会引发这些问题，但实际上，不就是这些找 Bug 的过程加深了我们对程序的理解吗？</p></blockquote></li><li><p>第 51 行，只有用户进程才会更新 TSS 中的 ESP0，因为从内核进入中断不涉及特权级转移，从用户进程进入中断才会切换到对应的内核栈。</p></li><li><p>第 58 行是笔者期待已久的页表创建函数 create_page_dir()，该函数为用户进程创建对应的页目录表，其任务很简单：1）<strong>申请一页内存用来存放页目录表 <strong>；2）</strong><u>将内核页目录的第 768~1022 项复制到用户页目录表的相同位置，从而实现所有用户进程共享内核</u></strong> （这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中重点提到过）；3）将用户进程页目录表的物理地址写入第 1023 号页目录项，这是为了访问页目录表和页表本身，详细原因仍请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。注意，<strong><u>用户进程的页目录表和页表不能安装在用户空间中，而是安装在内核空间里</u></strong> ，否则用户就可能自己修改页表，映射任意的内存地址，访问任何内存，进程间、内核的隔离保护就失去了意义。</p><blockquote><p>另外，不知道读者是否和我一样有这样的疑惑：为什么没有为用户程序本身开辟页表？也就是说，现在只映射了 3~4GB 的内核，而没有映射 0~3GB 的用户空间，那用户程序本身运行在哪？笔者从两个方面来解释此问题：<br>1）由于现在还没有完成硬盘驱动和文件系统，所以只能使用函数（如下面的u_prog_a、u_prog_b）来代替用户程序。而这些函数也是同样定义在 main.c 中，所以它们都会被链接进 kernel.bin，然后载入内核。换句话说，这些函数虽然是用户进程，但也位于 3~4GB 空间中（即使位于内核空间，特权级仍然为 3）。<strong>这只是目前为了演示用户进程而作的妥协</strong> 。<br><img src="/2022/img/image-20230106150001512.png" style="zoom:67%;" /></p><p>2）真正的用户进程加载是从硬盘读取程序并载入内存，进而运行，大致流程是这样的：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  &gt; graph LR&gt; A{创建独立的虚拟空间}--&gt;B{读取可执行文件头}--&gt;C{建立虚拟空间和可执行文件的映射关系}--&gt;D{将EIP设置为可执行文件的入口地址，开始运行}&gt;   </pre></div><p>啊啥？这不是还没将程序加载进内存吗？怎么就开始运行啦？是这样的，比如入口地址为 <code>0x08048000</code> ，<strong><font color='orange'>当执行流运行到该地址时，发现页面 <code>0x08048000~0x08049000</code> 是空页面，于是陷入缺页异常，异常处理程序通过第三步建立的映射关系找到可执行文件中缺失页面对应的部分代码，然后再将该部分载入内存，最后重新运行</font></strong> 。相关详细内容可参考《链接、装载与库》。<br>综上两点考虑，当前无需建立其他部分的映射。</p></blockquote></li><li><p>第 78 行，create_user_vaddr_bitmap() 函数用来为用户进程创建虚拟内存池，以便管理内存空间。其中 USER_VADDR_START 的值即为 <code>0x08048000</code> 。该函数逻辑清晰，不做说明。</p></li><li><p>第 88 行便是 process_execute() 函数。需要说明的是，该函数是在内核中被调用来创建用户进程的，而 fork 函数则是在用户程序中来创建子进程的，两者有巨大区别，将来实现 fork 时还会提到这一点。</p></li></ul><p>大功告成，了解了具体实现后，再来回顾进程创建的整个过程，思路也许会变得更清晰：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><h3 id="font-color-red-运行用户进程-font"><font color='red'>运行用户进程</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> test_var_a = <span class="number">0</span>, test_var_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;argA &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_b&quot;</span>, <span class="number">31</span>, k_thread_b, <span class="string">&quot;argB &quot;</span>);</span><br><span class="line">    process_execute(u_prog_a, <span class="string">&quot;user_prog_a&quot;</span>);</span><br><span class="line">    process_execute(u_prog_b, <span class="string">&quot;user_prog_b&quot;</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_int(test_var_a,FT_RED,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        console_put_int(test_var_b,FT_YELLOW,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而运行结果不尽人意：<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br>可见，运行一段时间后任务就停止了切换。这个 Bug 目前还没有找到，只知道这是锁引起的问题，没办法，只能将锁改为开关中断了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:console.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//console_acquire();</span></span><br><span class="line">    CLI;</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    STI;</span><br><span class="line">    <span class="comment">//console_release();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>再次运行：</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro1.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>现在好多了。关于这个锁的问题，笔者调试了两天还是不知道原因，请知道原因的读者朋友们在评论区留言，感谢！<br>需要说明的是，print 和 console 系列打印函数只能在内核，即 ring0 下使用，在用户进程中调用则会引发 0xd 号异常：<br><img src="/2022/img/image-20230112092402708.png" alt=""><br>所以这里使用两个变量 test_var_b、test_var_a 来间接反映进程的调度情况。</p><p>最后留下一个问题：既然禁止用户直接访问内核，那为什么还要将用户代码段描述符的界限设置为 4GB 呢？这样用户不就能轻松访问高地址的内核了吗？就像下面这样直接在用户态访问显存：<br><img src="/2022/img/image-20230112155046604.png" alt=""><br>既然这样，为什么不将用户代码段的界限设置为 3GB 呢？留给读者思考，笔者将在后续文章给出答案。</p><p>本文结束，下节实现系统调用。</p>]]></content>
    
    
    <summary type="html">自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实现用户进程—进入用户态</title>
    <link href="http://jyxcpp.netlify.app/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>http://jyxcpp.netlify.app/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-12-26T01:08:59.000Z</published>
    <updated>2023-03-12T11:21:04.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>本文前置内容(必看)：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> ，<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a></strong> ，<a href="https://markrepo.github.io/kernel/2018/08/22/memory/">进程的虚拟内存布局</a>、《装载、链接与库》<br>本节对应代码讲解：<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程-代码详解</a></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong><font color='gree'>操作系统有三大核心功能：内存管理、进程管理、文件管理</font></strong> 。截至目前，我们已经完成了内存管理和进程管理的部分内容，对于内存管理，咋们还差内存回收机制；对于进程管理，由于线程是进程的基础，之前咋们实现了线程，所以进程也就完成了一半；文件管理将在不久后实现文件系统后再进行。</p><h3 id="font-color-red-任务切换的原生方式-font"><font color='red'>任务切换的原生方式</font></h3><p>在 <a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 一文中，我们简单了解过 TSS 与 LDT 的作用，明白了 TSS 和 LDT 只是理想中的任务管理和切换的工具： <strong><font color='orange'>Intel 建议用 TSS 来保存并恢复任务的状态，用 LDT 来保存任务的实体资源</font></strong> 。而考虑到效率问题，现代操作系统并未（完全）使用 TSS 和 LDT 来进行任务切换。至于为什么效率低下，看看其任务切换的具体过程便能体会到：<br>CPU <strong>原生支持</strong> 的任务切换方式有两种：1）中断 + 任务门；2）call / jmp + 任务门；下面分别介绍这两种方式。</p><p><strong><mark class="hl-label blue">中断+任务门</mark> </strong><br>既然是通过中断调用，那么调用方式只能通过中断信号或 int 指令进行，此时任务门也当然是在 IDT 中注册。<br><strong>调用过程如下：</strong></p><ol><li><p>时钟中断发生，处理器自动从该任务门描述符中取出新任务的 TSS 选择子。</p><blockquote><p>之前咋们的时钟中断的向量号对应的是中断门描述符，对应时钟中断处理程序（schedule），而现在我们要使用任务门来切换任务，所以时钟中断向量号就应该指向任务门描述符：<br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>这里笔者有个问题，时钟中断号为 0x20，如果 0x20 指向任务门描述符，那岂不是每次发生时钟中断时，都会切换到同一个任务？那还如何实现任务调度呢？由于我们的操作系统不会使用任务门来进行任务切换（Linux也不会)，所以这里就不深究了，直到答案的读者还请麻烦在评论区指点一二。</p></blockquote></li><li><p>用 TSS 选择子在 GDT 中索引 TSS 描述符。</p></li><li><p>判断该 TSS 描述符的 P 位是否为 1，为 0 则表示对应的 TSS 不在内存中，这将引发异常。</p></li><li><p>从 TR 寄存器中获取旧任务（当前任务）的 TSS 位置，将当前寄存器状态保存到该 TSS 中。</p></li><li><p>将新任务 TSS 中的值加载进相应寄存器。</p></li><li><p>将新任务的 TSS 段选择子加载进 TR 寄存器，这由 CPU 自动完成。</p></li><li><p>将当前任务的 B 位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 。</p></li><li><p>将新任务标志寄存器的 NT  位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>将旧任务的 TSS 选择子写入到新任务 TSS 的 <code>上一个任务的TSS指针</code> 字段中。</p></li><li><p>开始执行新任务。</p></li></ol><p><strong>返回过程如下：</strong></p><ol><li>调用 <code>iret</code> ，检查 NT 位，如果为 1，则应该返回旧任务而非中断返回。</li><li>将当前任务的 NT 位置 0 。</li><li>将当前任务的 TSS 描述符中的 B 位置 0 。</li><li>将寄存器现场保存到当前 TSS 中。</li><li>获取当前 TSS 中 <code>上一任务的TSS指针</code> 字段，将选择子加载进 TR 。</li><li>根据 TR 指向的 TSS 恢复寄存器现场。</li></ol><p><strong><mark class="hl-label blue">call、jmp切换任务</mark> </strong><br>任务门除了可以在 IDT 中注册，还能在 GDT 和 LDT 中注册，当在后两者中注册时，就可以通过 call、jmp 指令来切换任务。call 和 jmp 有所不同，前者有去有回，<strong>所以通过 call 调用的新任务可以认为是旧任务的分支，本质上它们算是同一个任务</strong> ；而 jmp 则是有去无回，新旧任务之间没有关系。<strong><font color='orange'>此二者的区别体现在是否将旧任务的 B 位置 0</font></strong> ，先以指令 <code>call 0x0018:0x1234</code> 来看 call 的任务调用过程：</p><ol><li><code>0x0018</code> 表示在 GDT 中索引第 3 号描述符，即任务门描述符。不同于普通段描述符，任务门描述符中记录的是 TSS 选择子，所以处理器自动忽略 <code>0x1234</code> 。</li><li>检查 P 位，为 0 则表示该描述符不在内存中，抛出异常。</li><li>检测 S 和 TYPE 位，判断描述符类型，如果是任务门描述符，则检查 B 位，若为 1 则抛出异常。</li><li>特权级检查，数值上 CPL 和 TSS 选择子中的 RPL 都要小于或等于 TSS 描述符的 DPL，关于特权级检查与 RPL、CPL、DPL 的区别，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a> 。</li><li>将当前任务的现场保存到 TR 寄存器所指向的 TSS 中。</li><li>将新任务的 TSS 选择子加载到 TR 寄存器中。</li><li>将新任务 TSS 中的寄存器载入到相应寄存器中，并进行特权级检查。</li><li>将新任务的 NT 位置 1，表示为任务嵌套，以便 iret 时从新任务返回到旧任务，而非从中断返回。</li><li>将旧任务的 TSS 选择子写入到新任务 TSS 中 <code>上一任务的TSS指针</code> 字段中，以便能够返回。</li><li>将新任务的 B 位置 1 以表示当前任务忙，<strong><u>但旧任务的 B 位仍然为 1，不会置零</u></strong> ；</li><li>切换完成，新任务开始。</li></ol><p>任务返回则同上文中断调用相同。</p><p>jmp 的任务调度过程和 call 几乎相同，只是第 10 步 B 位置零有所不同：<strong><u>由于 jmp 有去无回，所以新旧任务不构成链式关系，因此会将旧任务的 B 位置 0</u></strong> 。<br>从以上过程便能看出，CPU 原生的任务调度方式很是繁杂，这降低了任务切换的效率和灵活性，因此现代操作系统都没有采用这种方式。</p><h3 id="font-color-red-任务切换的现代方式-font"><font color='red'>任务切换的现代方式</font></h3><p>虽然咋们没有用 Intel 建议的方式来进行任务调度，但这也不是说 TSS 就一无是处了（LDT 是真的完全成孤儿了），Linux 在以下两个地方还是会用到 TSS：</p><ul><li><p><strong><font color='gree'>I/O 特权级控制</font></strong><br>我们一直认为用户进程无法直接访问硬件，必须通过操作系统才行；但是，为了在某些场景下快速反应，TSS 中的 I/O 位图为用户程序直接控制硬件提供了途径。</p><blockquote><p>提示：我们的操作系统并不会使用 IO 位图。</p></blockquote></li><li><p><strong><font color='gree'>将进程的内核栈记录在 TSS 中的 SS0 和 ESP0 位置处</font></strong><br>我们通过时钟中断来进行任务调度，在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>一文中提到，<strong><u><font color='orange'>当发生中断并引用中断门描述符时，会检查是否发生特权级转移，如果特权级改变，则会自动转移到新栈，这个新栈就从 TSS 中获取</font></u></strong> 。换句话说，一个任务分为用户部分和内核部分，从用户转移到内核时，CPU 就会 <u><strong>自动</strong></u> 切换到内核自己的栈。</p></li></ul><p>同时注意，<strong><u>Linux 只使用一个 TSS ，任务切换时并不会随之切换 TSS，而是只修改 TSS 中的 ESP0</u></strong> ，这样也会大大提高任务切换的效率。后文解析代码时，读者朋友就能清楚地看到这一过程。</p><h3 id="font-color-red-进程的实现方式-font"><font color='red'>进程的实现方式</font></h3><p><strong>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。<font color='orange'>而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务（这点对于理解进程和线程的关系至关重要）</font>，这在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程基础</a>中有代码说明</strong> 。<strong><font color='red'>每个任务都类似于单线程，具有内存空间、执行实体（寄存器）、文件资源等，<u>但不同的任务可以选择共享同一虚拟内存空间，因此，共享了同一个内存空间的任务集合构成了一个进程</u></font></strong> 。</p><p>我们的操作系统是仿 Linux 系统，所以咋们实现用户进程就能够以线程为基础，具体方式如下：<br>先回顾线程创建的大概流程：</p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，调用 get_kernel_page() 向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息（task_struct），包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>要以线程为基础实现进程，<strong>就只需要将执行普通任务的线程函数替换成创建进程的新函数（即start_progress）即可</strong> 。那么，具体创建进程的流程是怎么样的呢？见下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><p>以上函数具体的实现待会再说，先来看看程序是如何进入到用户进程的。我们已经知道如下几点：</p><ol><li>用户进程运行在 3 特权级（ring3），而内核则运行在 ring0；</li><li>在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中我们了解到，除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上。<br><img src="/2022/img/image-20230103141410952.png" style="zoom:67%;" /></li><li>一直以来我们都在内核中运行，即执行流一直停留在 ring0 。</li></ol><p>那么现在，要在内核中，即 ring0 下创建用户进程，并进入到 ring3 用户态，该怎么做呢？显然，只能通过中断返回，即 <code>iret</code> 进入用户态。<u>所以我们采用的具体办法是：利用之前的方式创建线程，将线程里运行的函数设置为 start_progress() ；然后在 start_progress 中初始化该线程的中断栈（也就是将用户进程的寄存器现场提前写入中断栈）；最后 <code>iret</code> 中断返回，即可 ring0 -&gt; ring3，进入用户态</u>。</p><p>其实这种方式可以说是瞒天过海，妥妥地欺骗了 CPU。我们用 <code>iret</code> 指令使 CPU 以为咋们处于中断处理环境中，于是便假装从中断返回，顺利通过特权级检查并进入用户态。</p><h3 id="font-color-red-用户进程的虚拟内存分布-font"><font color='red'>用户进程的虚拟内存分布</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE34-1672909464756-2.png" alt="未命名绘图34"><br><strong>上图是经典的 Linux 用户进程内存布局(内核2.4版本)</strong> ，下面依次对各个部分作简单阐述：</p><ul><li><p>3GB~4GB 虚拟内存映射为内核空间，由所有进程共享。</p></li><li><p>用户内存的顶部是用户栈。一般而言，用户栈的最大空间为 8MB，详见<a href="https://www.tiehichi.site/2020/10/22/Linux%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/#%E5%86%85%E6%A0%B8%E6%A0%88">Linux进程栈空间大小 - Tiehichi’s Blog</a>。另外，用户栈的最高处会用来保存命令行参数和环境变量，这些数据是由 C 运行库压入的，后续从文件系统加载进程时会再提及此处。</p></li><li><p>用户栈下面是共享库的内存映射区域。共享库就是动态链接库，一个共享对象（即.so文件）由所有用户进程共享。举个例子，A 进程用到了 math 库，B进程也用到了 math 库，则 math 库会被加载到物理内存中，进而被映射到各个进程的虚拟内存空间中，由此实现共享，大大节省了内存，这便是动态链接库相对于静态链接库的优势。</p></li><li><p>接着是运行时堆，用于满足程序运行时的动态内存需求。</p></li><li><p>.bss 用于保存未初始化的数据，如未初始化的静态变量和全局变量。</p></li><li><p>.data 段用来保存已初始化且可读写的数据。实际上还有 .rodata 用来存放只读数据，此段并未体现在图中。</p></li><li><p>.text 则是代码区。IA-32 体系结构中，进程空间的代码段都从 <code>0x08048000</code> 开始，这与最低可用地址 <code>0x00000000</code> 有 128M 的间距。</p><blockquote><p>关于 <code>0x08048000</code> 这个值有许多解释，<a href="">Linker And Loader</a>一书给出的解释如下：<br>在 386 系统上，代码的起始虚拟地址是 <code>0x08048000</code> ，这允许在代码下方有一个相当大的堆栈；同时保持在地址0x08000000上方，允许大多数程序使用单个二级页表（回想一下，在 386 上，每个页目录项映射 0x00400000 大小的空间）。其他原因可参见<a href="https://www.cnblogs.com/l2017/p/11879310.html">0x08048000由来</a></p></blockquote></li></ul><p>关于进程的虚拟内存分布，这将在《 <strong>链接、装载与库</strong> 》系列笔记中详细阐述，敬请期待。</p>]]></content>
    
    
    <summary type="html">自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
