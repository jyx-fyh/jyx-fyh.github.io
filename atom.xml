<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极简</title>
  
  <subtitle>用时间去沉淀</subtitle>
  <link href="http://jyxcpp.netlify.app/atom.xml" rel="self"/>
  
  <link href="http://jyxcpp.netlify.app/"/>
  <updated>2023-04-16T01:37:48.516Z</updated>
  <id>http://jyxcpp.netlify.app/</id>
  
  <author>
    <name>极简</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络字节序及其注意事项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-04-16T01:37:48.000Z</published>
    <updated>2023-04-16T01:37:48.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是不可重入</title>
    <link href="http://jyxcpp.netlify.app/2023/04/15/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5/"/>
    <id>http://jyxcpp.netlify.app/2023/04/15/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5/</id>
    <published>2023-04-15T12:55:18.000Z</published>
    <updated>2023-04-15T12:55:18.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三握四挥异常分析</title>
    <link href="http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
    <id>http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/</id>
    <published>2023-04-15T11:16:23.000Z</published>
    <updated>2023-04-15T11:42:01.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">全连接与半连接队列</a> 、<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;optval, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    Listen(sock_listen, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    bzero(&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr *) &amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包裹函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(fd, backlog))</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == accept(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-第一次握手异常-font"><font color='red'>第一次握手异常</font></h2><p>第一次握手异常一般有三种情况：<br><strong>1） 目标主机不可达，响应一个 “destination unreachable” 的 ICMP 报文。</strong></p><blockquote><p>这个情况很好模拟，在客户端 connect 一个任意 IP 的地址结构即可。</p></blockquote><p><strong>2）目标主机的指定端口上没有套接字处于监听状态，connect 返回 “Connection refused” 。</strong></p><p><strong>3）接收方丢弃 SYN 报文。</strong></p><p>下面重点说说第三种情况。</p><p><strong><mark class="hl-label blue">什么情况下会丢弃SYN报文？</mark> </strong></p><p>有两种情况是可以确定的：</p><ol><li><strong>半连接队列已满，且没有开启 SYN-Cookie</strong></li><li><strong>全连接队列已满</strong></li></ol><p><strong><font color='orange'>情况一验证：</font></strong></p><blockquote><p><strong>在笔者环境下（Ubuntu 16.04），半连接队列的长度等于全连接长度，即为 <code>min(somaxconn,backlog)</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>); <span class="comment">//backlog为5,则全连接队列容量为6,半连接队列为5</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将 SYN-Cookie 设置为 0（默认为 1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//须在管理员身份下运行</span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/tcp_syncookies </span><br></pre></td></tr></table></figure><blockquote><p>0 值，表示关闭该功能；<br>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；<br>2 值，表示无条件开启功能；</p></blockquote></li><li><p>运行 server 端。</p></li><li><p>运行 hping3，发起 SYN 洪水攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机,即伪造</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><p>发送了 1000 个<u>虚假</u> SYN 报文，而半连接队列中只有 5 个连接（满），说明其他 SYN 确实是被服务端丢弃了。那么如果开启了 SYN-Cookie 会怎么样呢？继续实验：</p><ol><li><p>将 SYN-Cookie 设置为 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>运行 server 端和 hping3</p></li><li><p>查看 SYN_RECV 状态的个数，仍然为 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>查看 ESTABLISHED 状态的个数，为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | wc -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>运行客户端，并查看 ESTABLISHED 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p>这里显示为 12，实际上为 6，这是因为服务器端和客户端都在一个主机上，netstat 命令分别以服务器和客户端的角度进行了输出，所以算重复了一次。<br>已连接状态数为 6 的原因请参见前置文章，这里不再赘述。</p></blockquote></li></ol><p><strong><font color='gree'>所以，若半连接队列已满，且没有开启 SYN-Cookie ，则丢弃 SYN 报文。开启 SYN Cookies 后，就可以在不经过半连接队列的情况下成功建立连接：</font></strong><br><img src="/2022/img/39-1679303729834-1-1679373170821-1.jpg" alt=""></p><p><strong><font color='orange'>情况二验证</font></strong></p><ol><li><p>先后运行服务器端和客户端</p></li><li><p>分别查看 ESTABLISH 和 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>可见，当全连接队列满了后，半连接队列也不再接受 SYN</strong> 。</p></li></ol><p>追问：如果全连接队列仅还有一个空位，那么半连接队列也只会接收一个 SYN 吗？继续实验：</p><ol><li><p>修改 client 的第 23 行代码，将 10 改为 5，即发起 5 次连接（全队列容量为 6，这样就能余下一个空位）</p></li><li><p>先后运行 server 和 client</p></li><li><p>查看 ESTABLISHED 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>即，有 5 个连接已经完成建立，全队列余下一个空位。</p></li><li><p>运行 hping3，并查看 SYN_RECV 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>发现半连接队列也已经满员。</p></li></ol><p>综合以上两种情况，得到下面的流程图：<br><img src="/2022/img/aha.png" alt=""></p><p><strong><mark class="hl-label blue">SYN报文丢失了会怎样？</mark> </strong><br>很简单，重传即可。值得一提的是，<strong><font color='orange'>SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制</font></strong> 。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，即，<strong>每次超时的时间是上一次的 2 倍</strong> 。在笔者环境下，重传次数为 6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>为了更清晰地看到这个过程，我们先关闭 SYN-Cookie，然后发起泛洪，使半连接队列满员，进而只能丢弃新到的 SYN 报文；接着开启一个客户端，此时使用 wireshark 进行抓包，结果如下：<br><img src="/2022/img/image-20230407213529813.png" alt="image-20230407213529813"><br>一共发送 7 次 SYN 报文，其中重传 6 次。看左边的数字小数点的前两位：50 -&gt; 51 -&gt; 53 -&gt; 57 -&gt; 65 -&gt; 81 ，间隔时间分别为 1、2、4、8、16，和我们前面的结论相同。只是最后差了 34s，接近 32s，可能是误差吧，不太清楚这里是怎么回事。</p><hr><h2 id="font-color-red-第二次握手异常-font"><font color='red'>第二次握手异常</font></h2><p>有了第一次异常的分析，第二次握手异常就很容易分析出来了。首先能够确定的是，第一次握手的 SYN 报文仍然会重传，因为 client 压根没有收到 server 的 SYN+ACK 报文。那么 server 会怎么样呢？也容易猜到，由于迟迟没有收到第三次握手的 ACK 报文，server 也一定会重传，<strong><font color='orange'>且重传次数由 <code>tcp_synack_retries</code> 决定</font></strong>（ 在笔者环境下，该值为 5）。实验如下：<br>1）使用 <code>iptables</code> 屏蔽第二次握手：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT -p tcp  --tcp-flags SYN,ACK SYN,ACK -j DROP</span><br></pre></td></tr></table></figure><p>2）运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230415194126268.png" alt=""></p><p>可见，第一次和第二次握手都在重传。</p><h2 id="font-color-red-第三次握手异常-font"><font color='red'>第三次握手异常</font></h2><p>第三次握手就有意思了。看下面的三次握手的过程图：<br><img src="/2022/img/image-20230408101018084.png" alt=""></p><p>可见当第三次握手的 ACK 发出后，客户端已经处于建立连接的状态，而服务器此时还没收到客户端的 ACK 报文，仍处于 SYN_RECV 状态。那么问题来了，如果 client 给 server 发送数据报文，会出现什么情况呢？</p><p>为了模拟server 无法接收 ACK 报文的情况，我们使用 iptables 在防火墙阻截这个 ACK 报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --tcp-flag ACK,SYN  ACK -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>只需知道上述命令的作用为：屏蔽含有 ACK 标记 <strong>且</strong> 不包含 SYN 标记的报文，显然三次握手中只有第三次符合要求，因此会被屏蔽。关于 iptables，请移步本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">iptables</a><br>另外，实验完成后记得把屏蔽去掉，将 -I 改为 -D 重新执行上述命令即可。</p></blockquote><p>结果如下：<br><img src="/2022/img/image-20230408151310936.png" alt=""></p><p>可见，如果第三次握手的 ACK 报文丢失，则会引起第二次握手 ACK+SYN 重传，且重传 5 次，如 <code>tcp_synack_retries</code> 示，然后 clinet 重发 ACK，仍然丢失。再来看看 server 和 client 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep 12345</span><br><span class="line">tcp        0      0 192.168.248.128:59999   192.168.248.128:12345   ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.248.128:12345   192.168.248.128:59999   SYN_RECV   </span><br></pre></td></tr></table></figure><p>表明 client 已处于已连接状态，server 还未连接。而且重传 5 次完毕后不久，SYN_RECV 状态消失，说明 server 已经主动断开连接。如果此时 client 发送数据，这些报文当然也无法得到回复。<strong><font color='orange'>建立连接后（是指在 ESTABLISHED 状态下）发送的报文丢失，则会重传，次数由 <code>tcp_retries2</code> 决定（本机为 15 次，等待大概 15min）</font></strong> ，没有回应则直接关闭连接。</p><blockquote><p><code>tcp_retries1</code> 变量是控制在系统向下级发出信号以尝试验证网络是否可用之前的重试次数，可忽略。</p></blockquote><p>那么如果 client 不发送数据呢？它岂不是会一直保持 ESTABLISHED 状态。并不会，TCP 有保活机制，当一条连接上连续 <strong>两小时</strong> 没有任何动静时，本端就会发送探测报文，若连续几次探测报文都没有得到回应，则直接断开连接。保活时间，探测报文的次数、时间间隔分别由以下三个参数决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75 </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>即，最少需要经过 2 小时 11 分 15 秒才能断开一个死亡连接</font></strong> 。</p><blockquote><p>关于心跳包和保活机制，可参见<a href="https://jyx-fyh.github.io/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/">保活机制与心跳包设计</a> 。</p></blockquote><hr><h2 id="font-color-red-第一次挥手异常-font"><font color='red'>第一次挥手异常</font></h2><p><strong><font color='gree'>FIN 报文丢失的原因之一是因为对方接收缓冲区满导致 FIN 无法被接收。</font></strong></p><p>重传 FIN 报文，次数由 <code>tcp_orphan_retries</code> 控制，超过指定次数则直接关闭。这里有个细节： <code>tcp_orphan_retries</code> 默认为 0，但实际上重传次数为 8，源码向我们解释了原因：<br><img src="/2022/img/28-1680942414542-4.jpg" alt=""></p><p><strong><font color='orange'>为了避免 <code>FIN_WAIT1</code> 状态的连接过多，我们可以调小 <code>tcp_orphan_retries</code> 的值，也可以通过 <code>tcp_max_orphans</code> 限制其数量，</font></strong>  <strong><font color='orange'>如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，<u>而是直接发送 RST 复位报文强制关闭</u>。</font></strong></p><hr><h2 id="font-color-red-第二次挥手异常-font"><font color='red'>第二次挥手异常</font></h2><p>即 ACK 报文丢失，这种情况下会重复第一次挥手。<strong><font color='orange'>注意，pure ACK 报文都不会被重传！</font></strong></p><h2 id="font-color-red-第三次挥手异常-font"><font color='red'>第三次挥手异常</font></h2><p>则重传 FIN 报文，次数仍由 <code>tcp_orphan_retries</code> 控制，超出指定次数则直接关闭连接。不过需要注意，此时 client 已经处于 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果 client 是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果 client 是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></p><blockquote><p>关于 close 和 shutdown，参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a></p></blockquote><h2 id="font-color-red-第四次挥手异常-font"><font color='red'>第四次挥手异常</font></h2><p>则重传第三次挥手的 FIN 报文，超过指定次数则直接关闭。</p><hr><h2 id="font-color-red-区分连接断开的几种常见情况-font"><font color='red'>区分连接断开的几种常见情况</font></h2><p><strong><mark class="hl-label blue">进程崩溃</mark> </strong><br>进程崩溃可以指是使用 kill 命令杀死进程，此时进程会进行关闭套接字等一系列动作，并向对方发出 FIN 报文，和正常四次挥手无差别。</p><p><strong><mark class="hl-label blue">服务器主机崩溃</mark> </strong><br>服务器主机崩溃可以是断电，这种情况下进程来不及关闭套接字，因此服务器主机直接从网络中消失，那么客户向服务器重传数次后将返回 “destination unreachable” 错误。</p><p><strong><mark class="hl-label blue">服务器主机关机</mark> </strong><br>Unix 系统关机时，init 进程会先给所有进程发送 SIGTERM 信号，等待一小段时间（以给进程清除和终止的时间）后发送 SIGKILL 信号强制终止所有进程。进程终止时会关闭所有描述符，于是进行正常挥手。</p><p><strong><mark class="hl-label blue">服务器主机崩溃后重启</mark> </strong><br>服务器崩溃后重启，之前的 TCP 连接状态信息已经丢失，因此服务器对之前连接上发来的消息都将回复 RST。</p><blockquote><p>参考：《UNP》、<a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">小林网络</a> 、<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptable用法详解</a></p></blockquote>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>UNIX信号于网络编程</title>
    <link href="http://jyxcpp.netlify.app/2023/04/15/UNIX%E4%BF%A1%E5%8F%B7%E5%89%96%E6%9E%90/"/>
    <id>http://jyxcpp.netlify.app/2023/04/15/UNIX%E4%BF%A1%E5%8F%B7%E5%89%96%E6%9E%90/</id>
    <published>2023-04-15T06:21:08.000Z</published>
    <updated>2023-04-15T10:54:59.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux多线程服务端编程：使用muduo网络库</p><ul><li>《高性能》p285：信号与线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络学习利器—hping3</title>
    <link href="http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/"/>
    <id>http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/</id>
    <published>2023-04-09T07:44:31.000Z</published>
    <updated>2023-04-10T12:15:47.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络学习利器—hping3</p><blockquote><p>参考：<a href="https://techyrick.com/hping3-full-tutorial-for-dummies-to-pro/">hping3-tutorial</a> 、<a href="https://www.anquanke.com/post/id/239641#h2-10">端口扫描浅析</a>、<a href="https://linux.die.net/man/8/hping3">hping3-man</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">  -c  --count     packet count</span><br><span class="line">  -i  --interval  wait (uX for X microseconds, for example -i u1000)</span><br><span class="line">      --fast      alias for -i u10000 (10 packets for second)</span><br><span class="line">      --faster    alias for -i u1000 (100 packets for second)</span><br><span class="line">      --flood   sent packets as fast as possible. Don&#x27;t show replies.</span><br><span class="line">  -n  --numeric   numeric output</span><br><span class="line">  -q  --quiet     quiet</span><br><span class="line">  -I  --interface interface name (otherwise default routing interface)</span><br><span class="line">  -V  --verbose   verbose mode</span><br><span class="line">  -D  --debug     debugging info</span><br><span class="line">  -z  --bind      bind ctrl+z to ttl           (default to dst port)</span><br><span class="line">  -Z  --unbind    unbind ctrl+z</span><br><span class="line">      --beep      beep for every matching packet received</span><br><span class="line">Mode</span><br><span class="line">  default mode     TCP</span><br><span class="line">  -0  --rawip      RAW IP mode</span><br><span class="line">  -1  --icmp       ICMP mode</span><br><span class="line">  -2  --udp        UDP mode</span><br><span class="line">  -8  --scan       SCAN mode.</span><br><span class="line">                   Example: hping --scan 1-30,70-90 -S www.target.host</span><br><span class="line">  -9  --listen     listen mode</span><br><span class="line">IP</span><br><span class="line">  -a  --f      spoof source address</span><br><span class="line">  --rand-dest      random destionation address mode. see the man.</span><br><span class="line">  --rand-source    random source address mode. see the man.</span><br><span class="line">  -t  --ttl        ttl (default 64)</span><br><span class="line">  -N  --id         id (default random)</span><br><span class="line">  -W  --winid      use win* id byte ordering</span><br><span class="line">  -r  --rel        relativize id field          (to estimate host traffic)</span><br><span class="line">  -f  --frag       split packets in more frag.  (may pass weak acl)</span><br><span class="line">  -x  --morefrag   set more fragments flag</span><br><span class="line">  -y  --dontfrag   set don&#x27;t fragment flag</span><br><span class="line">  -g  --fragoff    set the fragment offset</span><br><span class="line">  -m  --mtu        set virtual mtu, implies --frag if packet size &gt; mtu</span><br><span class="line">  -o  --tos        type of service (default 0x00), try --tos help</span><br><span class="line">  -G  --rroute     includes RECORD_ROUTE option and display the route buffer</span><br><span class="line">  --lsrr           loose source routing and record route</span><br><span class="line">  --ssrr           strict source routing and record route</span><br><span class="line">  -H  --ipproto    set the IP protocol field, only in RAW IP mode</span><br><span class="line">ICMP</span><br><span class="line">  -C  --icmptype   icmp type (default echo request)</span><br><span class="line">  -K  --icmpcode   icmp code (default 0)</span><br><span class="line">      --force-icmp send all icmp types (default send only supported types)</span><br><span class="line">      --icmp-gw    set gateway address for ICMP redirect (default 0.0.0.0)</span><br><span class="line">      --icmp-ts    Alias for --icmp --icmptype 13 (ICMP timestamp)</span><br><span class="line">      --icmp-addr  Alias for --icmp --icmptype 17 (ICMP address subnet mask)</span><br><span class="line">      --icmp-help  display help for others icmp options</span><br><span class="line">UDP/TCP</span><br><span class="line">  -s  --baseport   base source port             (default random)</span><br><span class="line">  -p  --destport   [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec</span><br><span class="line">  -k  --keep       keep still source port</span><br><span class="line">  -w  --win        winsize (default 64)</span><br><span class="line">  -O  --tcpoff     set fake tcp data offset     (instead of tcphdrlen / 4)</span><br><span class="line">  -Q  --seqnum     shows only tcp sequence number</span><br><span class="line">  -b  --badcksum   (try to) send packets with a bad IP checksum</span><br><span class="line">                   many systems will fix the IP checksum sending the packet</span><br><span class="line">                   so you&#x27;ll get bad UDP/TCP checksum instead.</span><br><span class="line">  -M  --setseq     set TCP sequence number</span><br><span class="line">  -L  --setack     set TCP ack</span><br><span class="line">  -F  --fin        set FIN flag</span><br><span class="line">  -S  --syn        set SYN flag</span><br><span class="line">  -R  --rst        set RST flag</span><br><span class="line">  -P  --push       set PUSH flag</span><br><span class="line">  -A  --ack        set ACK flag</span><br><span class="line">  -U  --urg        set URG flag</span><br><span class="line">  -X  --xmas       set X unused flag (0x40)</span><br><span class="line">  -Y  --ymas       set Y unused flag (0x80)</span><br><span class="line">  --tcpexitcode    use last tcp-&gt;th_flags as exit code</span><br><span class="line">  --tcp-mss        enable the TCP MSS option with the given value</span><br><span class="line">  --tcp-timestamp  enable the TCP timestamp option to guess the HZ/uptime</span><br><span class="line">Common</span><br><span class="line">  -d  --data       data size                    (default is 0)</span><br><span class="line">  -E  --file       data from file</span><br><span class="line">  -e  --sign       add &#x27;signature&#x27;</span><br><span class="line">  -j  --dump       dump packets in hex</span><br><span class="line">  -J  --print      dump printable characters</span><br><span class="line">  -B  --safe       enable &#x27;safe&#x27; protocol</span><br><span class="line">  -u  --end        tell you when --file reached EOF and prevent rewind</span><br><span class="line">  -T  --traceroute traceroute mode              (implies --bind and --ttl 1)</span><br><span class="line">  --tr-stop        Exit when receive the first not ICMP in traceroute mode</span><br><span class="line">  --tr-keep-ttl    Keep the source TTL fixed, useful to monitor just one hop</span><br><span class="line">  --tr-no-rtt    Don&#x27;t calculate/show RTT information in traceroute mode</span><br><span class="line">ARS packet description (new, unstable)</span><br><span class="line">  --apd-send       Send the packet described with APD (see docs/APD.txt)</span><br></pre></td></tr></table></figure><hr><p>先运行服务器端，在 12345 端口上监听。</p><p><strong>1）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 SYN 报文</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S 192.168.248.128 -p 12345 -c 5</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410122835239.png" alt=""></p><p><strong>2）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 ACK 报文，且窗口大小为 100</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -A  192.168.248.128 -p 12345 -c 5 -w 100</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410123028629.png" alt="image-20230410123028629"></p><blockquote><p><strong><font color='red'>注意：</font></strong><br>我们向开放的 12345 端口发送 SYN 报文，得到的回复是 SYN+ACK 报文，即第二次握手；而发送 ACK 报文，则得到的回复是 RST 。这两种情况能够反应出端口的开放和过滤状态：<br><strong>发送 SYN 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>数次重发未响应</td><td>filtered</td></tr><tr><td>收到ICMP不可达错误</td><td>filtered</td></tr><tr><td>SYN/ACK</td><td>open</td></tr><tr><td>RST</td><td>closed</td></tr></tbody></table><p><strong>发送 ACK 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>收到RST报文</td><td>unfiltered(open/closed)</td></tr><tr><td>未响应</td><td>filtered</td></tr><tr><td>ICMP不可达</td><td>filtered</td></tr></tbody></table><p><strong>也就是说，我们可以通过向指定端口发送 SYN 或 ACK 报文来检测该端口的状态，这称为<font color='red'><u>端口扫描</u></font></strong> 。</p><p>另外，关于报文过滤，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">包过滤工具iptables</a></p></blockquote><p><strong>3）端口扫描模式</strong><br>扫描 <a href="http://baidu.com">baidu.com</a> 的 75~85 和 12345 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 --scan  75-85,12345 -S baidu.com</span></span><br><span class="line">Scanning baidu.com (39.156.66.10), port 75-85,12345</span><br><span class="line">12 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">   80 http       : .S..A... 128 27907 64240    46</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports: (75 ) (76 ) (77 rje) (78 ) (79 finger) (81 ) (82 ) (83 ) (84 ) (85 ) (12345 ) </span><br></pre></td></tr></table></figure><p><strong>4）flood 泛洪攻击</strong><br>向 <code>127.0.0.1:12345</code> 发起泛洪攻击，源 IP 随机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 -S -p 12345 --flood --rand-source </span><br></pre></td></tr></table></figure><p><strong>5）指定源端口为 12345，源 IP 为 1.1.1.1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S baidu.com -a 1.1.1.1 -s 12345</span><br><span class="line">或</span><br><span class="line">hping3 -S baidu.com --spoof 1.1.1.1 --baseport 12345</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下源 IP 为主机地址，源端口随机</p></blockquote><p><strong>6）传输文件</strong><br>Hping3 支持通过 TCP/UDP/ICMP 等包来进行文件传输。相当于借助 TCP/UDP/ICMP 包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为 <code>--listen</code> 后面输入的字符串）的内容进行相应的解析。在接收端开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 127.0.0.1  --listen signature --safe  --icmp</span> </span><br></pre></td></tr></table></figure><p>监听 ICMP 包中的签名，根据签名解析出文件内容。在发送端使用签名打包的 ICMP 包发送文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 --icmp -d 100 --sign signature --file ./data</span><br></pre></td></tr></table></figure><p>注意两点：1）必须指定数据长度 <code>-d</code> ；2）签名字符串必须和接收端相同，这里是字符串 <code>signature</code> 。<br><img src="/2022/img/image-20230410195315834.png" alt="接收端收到文件,并输出文件内容"></p><p>不过没人会使用这种方式来传送文件，因为它是明文发送的：<br><img src="/2022/img/image-20230410201345056.png" alt=""><br><code>--safe</code> 保证的是丢失重传，而不是安全性。</p>]]></content>
    
    
    <summary type="html">网络学习利器—hping3 入门教程</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>保活机制与心跳包设计</title>
    <link href="http://jyxcpp.netlify.app/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jyxcpp.netlify.app/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-04-08T10:26:48.000Z</published>
    <updated>2023-04-08T10:26:48.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“包过滤工具—iptables”</title>
    <link href="http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/"/>
    <id>http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/</id>
    <published>2023-04-08T03:21:14.000Z</published>
    <updated>2023-04-15T11:31:11.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>防火墙是保护服务器和基础设施安全的重要工具。在 Linux 生态系统中，<code>iptables</code> 是使用很广泛的防火墙工具之一，它能够用来完成封包过滤、封包重定向和网络地址转换(NAT)等功能。 <strong><code>iptables</code> 基于内核的包过滤框架 <code>netfilter</code></strong> 。如果管理员或用户不了解这些系统的架构，那可能就无法创建出可靠的防火墙策略。</p><p><strong><u>这里我们只简单地使用 iptables 的包过滤功能（后面讨论的命令也仅限于此）</u></strong> ，因为它能够很方便地模拟各种网络状况（<a href="https://jyx-fyh.github.io/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/">TCP 三握四挥的异常处理</a>、报文丢失等），非常有助于我们对网络理论知识的学习。其他功能的详细介绍可以参见<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptables用法规则小结</a> 。</p><hr><p>命令格式：<br><img src="/2022/img/FUCKAHA.png" alt=""></p><blockquote><p><code>ACCEPT</code> 允许数据包通过<br><code>DROP</code>  直接丢弃数据包，不给任何回应信息<br><code>REJECT</code> 拒绝数据包通过，必要时会给数据发送端一个响应的信息</p></blockquote><blockquote><p><strong><font color='red'>注意：</font></strong> 即使我们在输入链 INPUT 上 DROP 了指定报文，tcpdump/wireshark 仍然可以抓到该报文，因为报文的进入顺序是：<code>Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables</code> ；而出站顺序为：<code>iptables -&gt; tcpdump -&gt; NIC -&gt; Wire</code> ，此时 tcpdump/wireshark 才无法抓到指定报文。</p><p>注意，在 INPUT 中丢弃报文后，虽然可以被 tcpdump 捕获，但指定的端口或程序仍然无法收到该报文。</p></blockquote><p>示例：</p><p>1）在 lo 接口上丢弃目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j DROP</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定端口必须放在指定协议之后</strong> 。<br>另外，如果是做实验，那么添加之后记得删除，将 -I 改为 -D 再执行一次即可。</p></blockquote><p>2）拒绝目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝报文后，一般会给发送端发送 IMCP 报文以报告错误：<img src="/2022/img/image-20230409110416756.png" alt=""></p><p>3）拒绝源 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> ，且报文含有 SYN 标志的报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN SYN -j DROP</span><br></pre></td></tr></table></figure><p>这样我们就屏蔽了源 IP 为 <code>192.168.248.128</code> 发向 <code>12345</code> 端口的第一次握手。</p><blockquote><p>这条命令使用了 tcp 扩展模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tcp-flags mask comp</span><br></pre></td></tr></table></figure><p>第一个参数 mask 是我们应该检查的标志，写成由逗号分隔的列表。<br>第二个参数 comp 是必须匹配的标志的列表，列表以逗号分隔。<br>没有被匹配上的标志则要求不能被设置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><p>这条命令只会匹配到设置了 ACK 而没有设置 SYN 的报文。<br>Flags ： SYN ，ACK ，FIN ，RST ，URG ，PSH ，ALL ，NONE</p><p>另外，有时会使用 <code>-m</code> 显式指定模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 -m tcp --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br></pre></td></tr></table></figure></blockquote><p>4）列出 filter 表的所有规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN,ACK/ACK</span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN/SYN</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='orange'>注意，如果不使用 <code>-t</code> 指定表，则默认都为 filter</font></strong></p></blockquote><p>5）删除指定规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables  -D INPUT 1  删除第一条规则</span><br></pre></td></tr></table></figure><p>6）<code>!</code> 取反：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT ! -s 192.168.248.128 -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>丢弃除了源 IP 为 <code>192.168.248.128</code> 的其他所有 TCP 报文。</p><p>7）操作网段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>8）端口范围：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 1000:2000 -j DROP</span><br></pre></td></tr></table></figure><p>9）拒绝 DDOS 攻击：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p>-m limit: 启用limit扩展，限制速度。<br>–limit 25/minute: 允许最多每分钟25个连接<br>–limit-burst 100: 当达到100个连接后，才启用上述25/minute限制</p><p>这种方式似乎不能有效解决 DDOS 攻击。</p></blockquote><p>10）包含指定字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 12345 -m string --algo bm --string &#x27;admin&#x27; -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝目标端口为 12345 且数据中包含 “admin” 字符串的报文。</p>]]></content>
    
    
    <summary type="html">包过滤工具—iptables</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>RST情况汇总</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/RST%E6%83%85%E5%86%B5%E6%B1%87%E6%80%BB/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/RST%E6%83%85%E5%86%B5%E6%B1%87%E6%80%BB/</id>
    <published>2023-04-02T13:19:50.000Z</published>
    <updated>2023-04-12T10:34:55.526Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/qq_35238352/article/details/106051090">什么时候出现RST</a></p><ul><li><p>在接收到RST报文时，对于应用程序来说，通常会产生一个信号来通知应用程序连接已经中止。具体来说，Linux系统中会产生SIGPIPE信号，而Windows系统中会产生WSAECONNRESET异常。</p><p>另外，在接收到RST报文时，errno通常会被设置为ECONNRESET（Linux）或WSAECONNRESET（Windows）。这个错误代码表示连接被对方重置了，即对方发来了一个RST报文，导致当前的连接被中止。这个错误代码可以帮助应用程序识别连接中止的原因，并采取相应的处理措施。例如，应用程序可以尝试重新建立连接，或者通知用户连接已经中止。<br>——chatgpt</p></li></ul><ol><li><strong><font color='orange'>TCP 接收缓冲区<em>中存在未处理的</em>数据时关闭连接，会向对端发送RST报文。</font></strong></li></ol><p>下面进行实验验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn;</span><br><span class="line">    sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">//等待10秒,确保接收缓冲区已收到100000字节</span></span><br><span class="line">    close(sock_conn);<span class="comment">//不read,直接关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//发送100000字节</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先后运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="../../public/2022/img/image-20230402215357889.png" alt=""></p><p>直接看倒数第二项，server 回复的 ACK = 100001，说明 server 端的缓冲区已经接收了这 100000 字节，但由于没有读取（read）缓冲区就关闭（close）套接字，因此向 client 发出了 RST，即最后一项。</p><p>那么我们为 server 加上 read，读取这 100000 字节后再 close，结果如下：<br><img src="../../public/2022/img/image-20230402215925109.png" alt=""><br>这次就是标准的四次挥手啦！</p><hr><ul><li><strong><font color='orange'>为了避免 <code>FIN_WAIT1</code> 状态的连接过多，我们可以调小 <code>tcp_orphan_retries</code> 的值，也可以通过 <code>tcp_max_orphans</code> 限制其数量，</font></strong>  <strong><font color='orange'>如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。</font></strong></li><li>《UNP》P160——linger</li><li><strong>close 后过段时间端口彻底关闭，收到 FIN也只会回复RST</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用socket选项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/</id>
    <published>2023-04-02T12:38:14.000Z</published>
    <updated>2023-04-10T13:27:05.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-获取和设置socket选项-font"><font color='red'>获取和设置socket选项</font></h2><p>使用 <code>getsockopt()</code> 和 <code>setsockopt</code> 来获取和设置 socket 的各种选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(bufsize);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span> <span class="params">(<span class="type">int</span> socket,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">void</span> *option_val,</span></span><br><span class="line"><span class="params">                <span class="type">socklen_t</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</span><br></pre></td></tr></table></figure><ul><li><strong>以上两个函数，成功时均返回 0，出错则返回 -1</strong> 。</li><li>关于第二个和第三个参数，参见《UPN》第 151 页。</li></ul><p>注意，细心的朋友可能已经注意到：上面的例子中，作用的套接字是 sock_listen，即监听套接字。那么，能不能作用于已连接套接字呢？好问题！是这样的，<strong><font color='orange'>以下几个选项是由已连接套接字从监听套接字继承而来：</font></strong> <strong><font color='red'>SO_KEEPALIVE、SO_LINGER、SO_RECVBUF、SO_SNDBUF、SO_RCVLOWAT、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY</font></strong> 、SO_DEBUF、SO_DONTROUTE、SO_OBBINLINE （红色标记为重点选项）。所以，在这几个选项上设置监听套接字，将影响后面的所有已连接套接字。<u>作为对比，getpeername() 函数就必须要作用于已连接套接字</u>。</p><h2 id="font-color-red-SO-RCVBUF-和-SO-SNDBUF-font"><font color='red'>SO_RCVBUF 和 SO_SNDBUF</font></h2><p>这是两个重要的选项。要弄清楚这两个选项，就必须先搞明白 Socket 的缓冲区机制。下面总结了 Socket 缓冲区的关键特性：<br><img src="/2022/img/IMG_0579(20230406-190556).PNG" alt=""></p><ul><li><strong><font color='gree'>每个套接字都有独立的输入/输出缓冲区。</font></strong></li><li><strong><font color='gree'>创建套接字时，自动生成缓冲区。</font></strong></li><li><strong><font color='gree'>如果要写（write）的数据大于发送（输出）缓冲区的最大长度，那么将分批写入。</font></strong></li><li><strong><font color='gree'>如果发送缓冲区全满（分批写入也不能进行），则进程被阻塞（假设套接字是阻塞模式）。</font></strong></li><li><strong><font color='gree'>发送缓冲区的数据将一直保存（以便重发），直到接收到相应 ACK。</font></strong></li><li><strong><font color='gree'>接收（输入）缓冲区的数据将一直保存，直到应用层读取（read）。</font></strong></li><li><strong><font color='gree'>接收缓冲区若满，则直接抛弃新数据（不发送其他任何信息，等待对面重传）。</font></strong></li><li><strong><font color='gree'>TCP 接收窗口大小 &lt;= 接收缓冲区大小。</font></strong></li></ul><blockquote><p>以上几个特性的实验，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">网络数据读取的常见问题</a> ，建议浏览，加深理解。</p></blockquote><p><strong><font color='red'>SO_RCVBUF 直接限制本端 TCP 接收窗口的大小</font></strong> 。下面进行实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF,(<span class="type">void</span>*)&amp;recv_size,&amp;optlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server recv buffer size: %d\n&quot;</span>,recv_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不read,不close</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行运行 server 和 client 后，server 的接收缓冲区的大小为 6000：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server recv buffer size: <span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将 recv_size 设置的为 3000，而实际反馈为 6000，<strong>说明 recv_size 只是一个建议值，操作系统会根据一定条件进行修改（×2）</strong> 。在笔者操作系统上，接收缓冲区最小为 2304 。</p></blockquote><p>然后我们使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230403111812767.png" alt=""></p><p>看第二项，server 发送的 SYN 报文中，<strong>win 为 3000，和我们设置的 SO_RECVBUF 大小相同</strong> ，但这并不意味着窗口大小就一定等于 SO_RECVBUF。<strong><u><font color='gree'>接收窗口会随着网络状况而不断调整，但肯定不会超过缓冲区的大小</font></u></strong> 。</p><blockquote><p>在本机上实验多次发现，<strong>接收窗口始终不会超过接收缓冲区的一半大小</strong> 。</p></blockquote><p>还有以下几点需要注意：</p><ol><li>上面说过，这两个选项是由监听套接字继承而来，<strong><u><font color='orange'>所以对于 server，必须在 listen 前设置选项；对于 client，必须在 connect 前设置选项</font></u></strong> 。对已连接套接字（在 accept 返回之后）设置选项没有任何作用，因为 accept 只是从已连接队列中取出一个连接而已（参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a>）。</li><li>为了避免潜在的缓冲区空间浪费，接收缓冲区大小应该为 MSS 的整数倍，且至少为 MSS 的 4 倍，参见《UNP》P163。</li><li><strong><font color='orange'>为了最大化性能，缓冲区大小应该约等于带宽-延迟积</font></strong> ，参见《UNP》P164 。</li></ol><h2 id="font-color-red-SO-RCVLOWAT-和-SO-SNDLOWAT-font"><font color='red'>SO_RCVLOWAT 和 SO_SNDLOWAT</font></h2><p>这两个选项作用于 select/poll/epoll，目的在于减少网络 I/O 的次数。<code>SO_RCVLOWAT</code> 指定接收缓冲区中的数据量必须达到多少时，才会唤醒 select/poll/epoll 去读取数据；<code>SO_SNDLOWAT</code> 指定当发送缓冲区的<u>空闲空间</u>大于低水平位标记时，将唤醒 select/poll/epoll 写数据到socket 。</p><h2 id="font-color-red-SO-REUSEADDR-font"><font color='red'>SO_REUSEADDR</font></h2><p>这是服务器最常用的选项之一。该选项有以下几个作用：</p><ol><li><p><strong>可以在 TIME_WAIT 期间重新绑定该端口，这对服务器崩溃重启并快速恢复有至关重要的作用，避免了几十秒甚至几分钟的等待。</strong></p><blockquote><p>需要注意的是，如果没有开启时间戳选项（默认开启），则 TIME_WAIT 期间重新绑定<u>可能</u>失败，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT探究</a>。</p></blockquote></li><li><p><strong>允许在已连接的状态下重新绑定该端口</strong> ，常见情景如下：<br>a）启动监听进程<br>b）连接请求到达，派生一个子进程处理该连接<br>c）监听进程崩溃，子进程仍在运行<br>d）重启监听进程，并绑定之前的端口</p></li><li><p><strong>允许在同一个端口启动多个服务器，前提是每个服务器绑定的本地 IP 不同（IP 别名）</strong></p><blockquote><p>笔者在本机上实验，分别绑定环回地址 <code>127.0.0.1</code> 和本机 IP 地址，两者可以同时绑定同一个端口。如果未开启 SO_REUSEADDR，则无法同时绑定。<br><strong><u>注意，如果某个服务器程序绑定的是通配地址（INADDR_ANY），那么后续在同一端口上启动的服务器程序则无法完成绑定。</u></strong></p></blockquote></li><li><p>其他作用不常见，详见《UNP》P166</p></li></ol><p><strong><font color='orange'>另外注意，不论是否开启该选项，不同传输层协议是可以同时绑定到同一端口的，比如 TCP 和 UDP 程序就能够同时绑定到一个端口。</font></strong></p><p><strong><font color='red'>对于所有 TCP 服务器，都应该在 bind 前开启 SO_REUSEADDR ！</font></strong></p><blockquote><p>另外，还有一个 <code>SO_REUSEPORT</code> 选项，不常用，参见《UNP》P165</p></blockquote><h2 id="font-color-red-SO-LINGER-font"><font color='red'>SO_LINGER</font></h2><p><code>SO_LINGER</code> 用来控制 close 的行为：<br><img src="/2022/img/image-20230407141037746.png" alt=""><br><img src="/2022/img/image-20230407141059416.png" alt=""><img src="/2022/img/IMG_0580(20230407-134909).PNG" alt=""></p><p><strong><u>注意缓冲区的各种情况。前三种情况须熟记于心！</u></strong> 另外，书中提供了一种有效办法，使发送端能够确认接收端的<u>应用层</u>已收到数据，详见《UPN》P161。</p><p><strong>另外有个细节，上图中 SHUT_RD 后，接收到的任何数据都会被丢弃，这里的丢弃是先确认再丢弃，也就是说，这不会引发对方的重传。</strong></p><h2 id="font-color-red-TCP-NODELAY-font"><font color='red'>TCP_NODELAY</font></h2><p>此选项用来禁止 Nagle 算法。关于 Nagle 算法，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">TCP流量控制</a> 。 有时候我们必须要关闭 Nagle 算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>]]></content>
    
    
    <summary type="html">常用socket选项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>wireshark入门笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-02T03:35:43.000Z</published>
    <updated>2023-04-02T11:13:00.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>学习 wireshark 前需要先了解 tcpdump，<strong>许多情况下我们使用 tcpdump 抓包（更快速、更方便），然后使用 wireshark 进行分析</strong> 。可参见 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump实操</a><br>环境：Ubuntu 16.04 LTS</p></blockquote><hr><h2 id="font-color-red-安装-wireshark-font"><font color='red'>安装 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install wireshark-qt</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-启动-wireshark-font"><font color='red'>启动 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wireshark</span></span><br></pre></td></tr></table></figure><p>启动后显示如下界面：<br><img src="/2022/img/image-20230402115238469.png" alt=""></p><p>发现没有我们想要的网卡。如何知道哪块网卡是我们想要的？打开命令行终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4331 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3064 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2400943 (2.4 MB)  TX bytes:462038 (462.0 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1249 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1249 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:121848 (121.8 KB)  TX bytes:121848 (121.8 KB)</span><br></pre></td></tr></table></figure><p><code>ens33</code> 就是可用网卡（<code>lo</code> 是环回接口，不用管）。</p><p>没有显示 <code>ens33</code> 是因为操作权限问题。重新以管理员身份运行 wireshark：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo wireshark</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230402115430627.png" alt=""></p><p>成功显示 <code>ens33</code> ，<strong><u>双击该选项</u></strong> ，进入 wireshark 抓包页面。</p><hr><h2 id="font-color-red-捕获过滤器-font"><font color='red'>捕获过滤器</font></h2><p>捕获过滤和显示过滤器是 wireshark 的两种主要过滤方式，但二者机制完全不同。前者是指示 wireshark 只捕获满足一定要求的报文，而后者则是在已经捕获到的报文中筛选出满足进一步要求的报文。捕获过滤器在打开 wireshark 时设置：</p><p><img src="/2022/img/image-20230402151407256.png" alt=""></p><p>或者打开 wireshark 后，在设置页面操作：<br><img src="/2022/img/image-20230402151634036.png" alt="注意，需要先停止捕获才可设置"></p><p>配置捕获规则的语法和 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump</a> 相同，这里不再赘述。</p><blockquote><p>建议：某些时候无需设置太过具体的条件，以免不利于网络错误排查。比如你要求只接收 TCP 报文，但 TCP 连接出错时可能会产生 ICMP 报文来传达错误信息，而这却被你给屏蔽了…</p></blockquote><hr><h2 id="font-color-red-显示过滤器-font"><font color='red'>显示过滤器</font></h2><p>显示过滤在捕获网络报文后进行：<br><img src="/2022/img/image-20230402152619594.png" alt=""></p><p>显示过滤的语法和 tcpdump 完全不同。详细语法参见<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html">wireshark manual</a></p><hr><h2 id="font-color-red-名称解析-font"><font color='red'>名称解析</font></h2><p><img src="/2022/img/image-20230402163513811.png" alt=""><br><img src="/2022/img/image-20230402163636148.png" alt=""></p><ul><li>选项 1：将 MAC 地址解析为名称。</li><li>选项 2：将著名端口号解析为协议名，如，将端口号 80 解析为 http 。</li><li>选项 3：将 IP 解析为域名。</li><li>选项 4：如果将 IP 解析为域名，则只利用已经抓到的包来解析，不另外专门进行 DNS 查询。</li><li>选项 5：如果无法从已抓到的报文解析 IP，则另外进行 DNS 查询。这会影响速度，一般不开。</li></ul><p>已经解析的名字可以通过以下方式找到：<br><img src="/2022/img/image-20230402165754095.png" alt=""></p><p>另外，你也可以自己命名一些 IP 地址：<br><img src="/2022/img/image-20230402165953271.png" alt=""><br>自己命名的 IP 也会被加入到上面的 Resolved Address 栏目中。</p><hr>]]></content>
    
    
    <summary type="html">wireshark入门笔记</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump实操</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/tcpdump/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/tcpdump/</id>
    <published>2023-03-21T08:34:40.000Z</published>
    <updated>2023-04-07T11:06:45.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-tcpdump-font"><font color='red'>tcpdump</font></h2><blockquote><p><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man</a></p></blockquote><p>tcpdump 须在管理员权限下运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump</span></span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><ul><li>输出结果表明 tcpdump 的监听网卡为 <code>ens33</code> 。</li><li>默认截断大小为 262144 字节（随版本而改变），超过该数字报文会被截断。</li></ul><p>使用 <code>ifconfig</code> 查看其他网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12058 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4911 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:9115911 (9.1 MB)  TX bytes:577567 (577.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1110 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1110 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:1022006 (1.0 MB)  TX bytes:1022006 (1.0 MB)</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-i 指定网卡</mark> </strong></p><p>上面默认监听网卡是 <code>ens33</code> ，我们也可以指定为 <code>lo</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump -i lo</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><p><code>-i any</code> 可以监听所有网卡。</p><hr><p><strong><mark class="hl-label blue">-nn 直接显示IP和端口号</mark> </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcpdump -i lo</span></span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">01:12:54.640796 IP localhost.44438 &gt; localhost.12345: Flags [S], <span class="built_in">seq</span> 1028792545, win 65495, options [mss 65495,sackOK,TS val 1381449987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640834 IP localhost.12345 &gt; localhost.44438: Flags [S.], <span class="built_in">seq</span> 3925511357, ack 1028792546, win 65483, options [mss 65495,sackOK,TS val 1381449987 ecr 1381449987,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640870 IP localhost.44438 &gt; localhost.12345: Flags [.], ack 1, win 512, options [nop,nop,TS val 1381449987 ecr 1381449987], length 0</span><br></pre></td></tr></table></figure><p>监听环回网卡时，我们运行自己编写的简易 TCP 服务器端和客户端的回射程序，结果输出以上三次握手内容。其中主机地址为 <code>localhost</code> ，由于 server 和 client 都在一台主机，所以都为 <code>localhost</code> 。如果服务器的端口为著名端口（如 ssh 为 22 号端口），那么 22 也会显示为 ssh。若想直接显示 IP 和端口号，则使用 <code>-nn</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn</span></span><br><span class="line">01:14:54.615811 IP 127.0.0.1.44438 &gt; 127.0.0.1.12345: Flags [P.], seq 1028792546:1028792548, ack 3925511358, win 512, options [nop,nop,TS val 1381569983 ecr 1381449987], length 2</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-n 不将IP转换为域名</mark> </strong></p><p>不讲 IP 转为域名，则可以省去 DNS 查询，输出速度会快很多。</p><hr><p><strong><mark class="hl-label blue">过滤主机</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源地址是 192.168.1.1 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定源地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定目的地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>也可直接指定域名：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dest host <span class="string">&quot;baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">过滤端口</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源端口是 25 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定源端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定目的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure><ul><li><p>指定端口范围：portrange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo portrange 10000-20000</span></span><br></pre></td></tr></table></figure></li><li><p>对于著名端口，可直接用应用层协议替代，相当于宏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump port http</span> </span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">网段过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst net 192.168.0.0/16</span>  </span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">协议过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump arp</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump ip</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump tcp</span>  </span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不能直接过滤协议,如下</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump http</span>  </span><br></pre></td></tr></table></figure><p>而应该</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump port http</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">常用表达式</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非 : ! 或 not </span><br><span class="line">且 : &amp;&amp; 或 and  </span><br><span class="line">或 : || 或 or</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp &amp;&amp; dst port 12345 &amp;&amp; src host 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp and dst port 12345 and src host 127.0.0.1</span></span><br></pre></td></tr></table></figure><p>有时条件比较复杂的需要用括号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 <span class="string">&#x27;((tcp) and (! port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))&#x27;</span></span></span><br><span class="line">抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200,并且端口不是80的TCP数据</span><br></pre></td></tr></table></figure><p><strong>如果使用括号，则整个表达式需要用 <code>''</code> 或 <code>&quot;&quot;</code> 包住。</strong></p><hr><p><strong><mark class="hl-label blue">包头过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（从第0字节开始）</span><br><span class="line">proto[x:y] &amp; z = 0  : proto[x:y]和z的与操作为0</span><br><span class="line">proto[x:y] &amp; z !=0  : proto[x:y]和z的与操作不为0</span><br></pre></td></tr></table></figure><p><strong>IP报头格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    0                   1                   2                   3</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1   \bit</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0   |Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4   |         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">12  |  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16  |                       Source Address                          |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20  |                    Destination Address                        |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24  |                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">28  |                            DATA ...                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><p><strong>TCP报头格式：</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   0                   1                   2                   3</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \bit</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0  |          Source Port          |       Destination Port        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4  |                        Sequence Number                        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">8  |                    Acknowledgment Number                      |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">12 | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">   |       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16 |           Checksum            |         Urgent Pointer        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20 |                    Options                    |    Padding    |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24 |                             data                              |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;tcp[2:2]=12345&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的报文</span><br></pre></td></tr></table></figure><p><strong>TCP标记定义在TCP头的第 13 个字节：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;src port 12345 &amp;&amp; tcp[13]&amp;1 = 1&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的FIN报文</span><br></pre></td></tr></table></figure><p>TCP标记宏可以替代数值：</p><p><code>tcpflags</code> , <code>tcp-fin</code> , <code>tcp-syn</code> , <code>tcp-rst</code> , <code>tcp-push</code> , <code>tcp-push</code> , <code>tcp-ack</code> , <code>tcp-urg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;dst port 12345 &amp;&amp; tcp[tcpflags]&amp;tcp-fin=tcp-fin&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-w 输出到文件、-r 读取文件</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -w test.cap</span></span><br></pre></td></tr></table></figure><p>把信息输出到 test.cap 文件。将文件保存为 <code>cap</code> 或 <code>pcap</code> 类型就能方便地使用 wireshark 打开并分析：<br><img src="/2022/img/image-20230401192959234.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap</span></span><br></pre></td></tr></table></figure><p>读取 <code>test.cap</code> 文件并打印在终端，同时也可以使用过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap port 12345</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">输出时间</mark> </strong></p><ul><li><code>-t</code>：在每行的输出中不输出时间</li><li><code>-tt</code>：在每行的输出中会输出时间戳</li><li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li><li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -t dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1650, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">1680352032.093467 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1662, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -ttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line"> 00:00:00.000000 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1672, length 64</span><br><span class="line"> 00:00:01.002438 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1673, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">2023-04-01 05:27:30.131073 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1680, length 64</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-v 展示详细信息</mark> </strong></p><p><code>-v</code>：产生详细的输出。比如包的TTL，id标识，数据包长度，以及IP包的一些选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/butcher/Documents# tcpdump -v dst  &quot;baidu.com&quot;</span><br><span class="line">tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">05:36:46.543701 IP (tos 0x0, ttl 64, id 44013, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 12115, seq 7, length 64</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-c 指定接收报文个数</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -v -c 3</span> </span><br><span class="line">05:46:32.275269 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.248.2 tell 192.168.248.1, length 46</span><br><span class="line">05:46:32.276545 IP (tos 0x0, ttl 64, id 50690, offset 0, flags [DF], proto UDP (17), length 72)</span><br><span class="line">    192.168.248.128.34566 &gt; 192.168.248.2.domain: 39118+ PTR? 2.248.168.192.in-addr.arpa. (44)</span><br><span class="line">05:46:32.280758 IP (tos 0x0, ttl 128, id 35219, offset 0, flags [none], proto UDP (17), length 127)</span><br><span class="line">    192.168.248.2.domain &gt; 192.168.248.128.34566: 39118 NXDomain 0/1/0 (99)</span><br><span class="line">3 packets captured</span><br></pre></td></tr></table></figure><p>抓满指定数量的报文后自动停止。</p><p><strong><mark class="hl-label blue">-C -W 分文件写入</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -C 1 -W 4 -w <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>-C 和 -w 配套使用，后者将抓包情况写入文件，前者指定每个文件的最大大小，单位为 1MB（小文件利于分析）。</p><ul><li><code>-C 1</code> ：指定单个文件最大为 1MB</li><li><code>-W</code> ：指定最多写 4 个文件</li><li><code>-w</code> ：写入文件</li></ul><p>每个文件会依次添加后缀：test1、test2、test3、test4 。<strong><u>注意，如果写满这 4 个文件后，数据还在持续，那么会重新覆盖这 4 个文件并继续写入，而不会新建文件。</u></strong></p><hr><p><strong><mark class="hl-label blue">-Q 指定方向</mark> </strong></p><ul><li>-Q in ：只显示收到的数据</li><li>-Q out ：只显示发出的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -Q <span class="keyword">in</span></span></span><br><span class="line">06:04:34.157713 IP 192.168.248.1.50277  &gt; 239.255.255.250.1900: UDP, length 175</span><br><span class="line">06:04:34.163603 IP 192.168.248.2.domain &gt; 192.168.248.128.34566: 27092 NXDomain 0/1/0 (103)</span><br><span class="line">06:04:35.003369 IP 180.101.49.186.https &gt; 192.168.248.128.33644: Flags [.], ack 769671203, win 64240, length 0</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-s 指定截取大小</mark> </strong></p><p><code>-s</code> 指定每个包捕获的长度、单位是 byte，而不是默认的 262144 字节；如果超过了设定的大小限制，包就会被截断，并在打印行出现[|proto]这种标识，这个proto就是被截断的报文的协议名字。但是抓取越长，包的处理时间越长，并且会减少 tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好，<strong><u>一般只抓报头</u></strong> ，抓 80 个字节一般就能包含 TCP 层、IP 层、链路层。</p><p><code>-s 0</code> 使用默认长度 262144。</p><p><strong><mark class="hl-label blue">-e 显示链路层信息</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump  -e</span> </span><br><span class="line">06:49:36.315000 00:0c:29:48:09:a9 (oui Unknown) &gt; 00:50:56:fb:6d:e0 (oui Unknown), ethertype IPv4 (0x0800), length 54: 192.168.248.128.33644 &gt; 180.101.49.186.https: Flags [.], ack 565954419, win 65535, length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-F 指定过滤过滤表达式文件</mark> </strong></p><p>有些过滤表达式经常用，但又很冗长，每次输入都很麻烦。所以可以保存为文件，每次 tcpdump 时指定该文件为过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -F filter_file</span></span><br></pre></td></tr></table></figure><p>该命令行中的其他命令会被忽略。</p><hr><p><strong><mark class="hl-label blue">less，greater 指定大小</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump less 100</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-X 打印数据内容</mark> </strong><br><code>-X</code> 除了打印每个数据包的头之外，还可以用十六进制和ASCII打印每个数据包的数据（不包括链路级头，<code>-XX</code> 可包含）：<br><img src="/2022/img/image-20230402084531352.png" alt=""></p>]]></content>
    
    
    <summary type="html">常用网络命令和抓包工具</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>高级I/O函数&amp;网络数据读取的常见问题</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-21T08:31:41.000Z</published>
    <updated>2023-04-13T16:33:03.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《UNIX网络编程》《UNIX环境高级编程》《TCP/IP编程》、<a href="http://c.biancheng.net/view/2349.html">socket阻塞模式</a></p></blockquote><h2 id="font-color-red-read-font"><font color='red'>read</font></h2><p><img src="/2022/img/IMG_0576(20230325-120322).PNG" alt=""></p><blockquote><p><code>ssize_t</code> 是有符号整型 long；<code>size_t</code> 是无符号整型 unsigned long</p></blockquote><p>对于 read 和 write 这类 <strong>低速系统调用（即可能使进程永远阻塞下去的系统调用）</strong> ，当执行期间捕捉到信号，则该系统调用就会被中断不再执行，且返回 -1，并将 errno 设置为 -1。为什么呢？有这样一个常见的场景：网络中，由于不知道对端网络具体会发来多大的包，所以我们会让 read 尽可能多地接收数据，即把其第三个参数设置大些。那么问题来了，对端只发送了 1000 字节的数据，而你却指定本端的 read 读取 10000 字节，那怎么办？总不能一直阻塞下去吧？所以此时就需要用到信号，来中断 read 使其结束。</p><blockquote><p>至于 read 在读取数据时是被什么信号中断的，笔者也没有查到相关资料，知晓的读者还请在评论区指点一二。</p></blockquote><p><strong><font color='orange'>需要注意的是，TCP 套接字上的 IO 表现的行为不同于通常的磁盘 IO。</font></strong> <strong><u>磁盘 IO 一般不会被信号打断而终止，因为磁盘 IO 与网络 IO 的区别在于：前者的 IO 量是可以确定的，虽然可能会暂时阻塞调用者，但只要把指定量的数据处理掉就 OK，任务很明确；而网络 IO 一般不知道具体的 IO 量，就像上面的场景一样，所以必须在某个时刻终止 IO（终端 IO 也是如此，计算机不知道用户可能会输入多少数据）。除非发生硬件错误，否则磁盘 IO 总会很快返回</u></strong> 。</p><p>对于被中断的 read，<u>早期实现</u>是：如果 read 已接收部分数据到应用缓冲区，但还未接收到应用程序请求的所有数据（即 read 的第三个参数），则操作系统会认为本次 read 调用失败，返回 -1，errno 被设置为 EINTR 。<strong><font color='orange'>目前的 POSIX 标准采用的方式是：如果 read 只接收了部分数据就被信号中断，那么也算成功，且返回已接收的字节数，errno 不修改</font></strong> 。</p><blockquote><p><strong><font color='gree'>这就是为什么在 Socket 编程中，往往将 read 函数放在循环中的原因！</font></strong> 大多数书籍将其归咎于 Socket 的缓冲机制，实际上这只是原因之一。也有许多人认为 read 只将接收缓冲区读一次就返回，当请求的数据量大于接收缓冲区时，read 返回值就当然会小于请求的字节数，这种说法更不准确。做个实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> rcv_buf=<span class="number">1000</span>; <span class="comment">//系统会调整接收缓冲区大小,本例中被调整为2304</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server rcv_buf : %d\n&quot;</span>,rcv_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">int</span> snd_buf =<span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client snd_buf : %d\n&quot;</span>,snd_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后 server 的结果如下：<br><img src="/2022/img/image-20230324152945053.png" alt=""></p><p>你看，server 的接收缓冲区大小被修改为 2304 字节，但却 read 了 65482 字节，大于 2304，说明不止读取一次缓冲区；小于请求值 100000，说明 read 还没有读完对面发送的 10000 字节就被信号中断。</p></blockquote><p>所以得出一个重要结论：如果 read 返回值小于请求值，说明有两种情况：</p><ol><li><strong>提前收到了 EOF。</strong></li><li><strong>被信号中断。</strong></li></ol><p>第一种情况说明数据已经接收完，第二种情况则还需要重新调用 read 才能将数据接收完毕。我们可以使用自己的包裹函数 readn 一次性将数据读完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* tmp = buf;</span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, tmp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nread == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">//被信号打断,则继续循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        tmp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不过需要注意，readn 可能会一直阻塞</font>，因为正常情况下它只会在接收到 EOF 或者读满 n 字节才会返回；而 read 不同，read 收到 EOF 、读满 n 字节或者被信号中断（没读满）时就能返回</strong> 。所以当发送的字节数小于请求的字节数时，readn 就会被阻塞，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    writen(sock_clnt,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//while停住,以免关闭套接字发送EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上程序时，服务器不会显示客户端发来的消息，因为 readn 要求读满 1000 或者读到 EOF。当把 readn 改成 read，就能成功显示消息了。解决这个问题的办法之一是设计应用层协议，比如在包头说明本包的大小，这方面内容后续补充。</p><p><strong>recv 的第四个参数可以选 MSG_WAITALL 标志来阻止这种行为，当 flags 为 MSG_WAITALL 时，recv 会阻塞直到所指定的长度 nbytes 字节的数据全部返回，recv 才会返回。</strong></p><h2 id="font-color-red-write-font"><font color='red'>write</font></h2><p><strong>不同于 read，作用于字节流套接字时，输出字节比请求的字节少这种情况仅在非阻塞前提下才会发生</strong> 。</p><p>调用 write 时，如果套接字的发送缓冲区容不下请求量，那么 write 被阻塞，直到缓冲区中的数据被发送到对端，腾出足够的空间，才唤醒 write 函数继续写入数据。有以下几个要点需要注意：</p><ol><li><strong>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</strong></li><li><strong>发送缓冲区中的数据必须保留，直到对端回复相应的 ACK（这是由内核自动完成的）。</strong></li><li><strong>接收缓冲区的数据将一直保留，直到应用层读取（read）。</strong></li><li><strong>write 函数的返回只说明应用层的数据已经全部转移到输出缓冲区，这不代表对方已经收到所有数据。</strong></li></ol><p>让我们做几个实验来验证上面的结论。</p><p><strong><mark class="hl-label blue">实验一</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">100000</span>; <span class="comment">//设置接收缓冲区,系统会调节该值,可能为200000</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">1000</span>; <span class="comment">//系统会调节该值,可能为3000左右</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> size = write(sock_clnt,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，<strong>立刻</strong> 输出结果，client 发送 100000 字节，server 接收 100000 字节。这说明即使我们将 client 的发送缓冲区设置为 1000，数据也会分批发送。结论一得证。</p><p><strong><mark class="hl-label blue">实验二</mark> </strong></p><p>将上面代码 server 的接收缓冲区改为 1000，运行程序，<strong>等待几秒后</strong> 输出结果，两方仍是 100000 字节。这说明接收缓存区虽小，但由于应用层一直在读取数据（readn），所以接收缓冲区可以不断地丢弃旧数据、接收新数据，直到收到所有数据。</p><p>继续，修改 14~22 行代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf_size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//循环,不close套接字</span></span><br></pre></td></tr></table></figure><p>即，不从接收缓冲区读取数据，同时不 close 套接字。close 套接字可能导致缓冲区的一系列动作，不利于我们进行实验。</p><p>运行程序，<strong>两端都陷入阻塞</strong> 。这说明由于接收缓冲区没有被 read，数据一直积压，因此无法接收 client 发来的数据，也就不能回复 ACK；而 client 因为没有收到 server 回复的 ACK ，所以发送缓冲区不能接收应用层的新数据，以至于在 write 中阻塞。结论 2、3 得证。</p><p><strong><mark class="hl-label blue">实验三</mark> </strong></p><p>在实验二的基础上，把 client 的发送缓冲区改为 100000 字节，运行程序。client 立刻输出 <code>100000</code> 。表明 client 成功向发送缓冲区写入 100000 字节，并立刻从 write 返回。但 server 的接收缓冲区只有 1000 字节的大小，不可能接收完这 100000 字节。因此，结论 4 得证。</p><hr><hr><h2 id="font-color-red-sendfile-font"><font color='red'>sendfile</font></h2>]]></content>
    
    
    <summary type="html">网络数据读取的常见问题</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>半连接与全连接队列</title>
    <link href="http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
    <id>http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</id>
    <published>2023-03-20T10:39:37.000Z</published>
    <updated>2023-03-21T04:08:03.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《UNIX网络编程》、<a href="https://blog.csdn.net/qq_42877870/article/details/105027743">hping3命令使用</a>、<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">小林网络</a>、<a href="https://www.51cto.com/article/687595.html">51CTO</a></p></blockquote><p><strong>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</strong> 。前者又称半连接队列、SYN队列，后者又称全连接队列、accept 队列。</p><p>半连接队列：服务器收到客户端发来的 SYN 报文后，将该连接存入此队列中。这些连接处于 SYN_RCVD 状态。<br>全连接队列：服务端收到第三次握手的 ACK 后，该连接被内核从半连接队列转移到全连接队列，此时已经完成三次握手，处于  ESTABLISHED 状态。当调用 accept 函数时，该连接将从全连接队列中移除。</p><hr><p><strong><mark class="hl-label blue">backlog</mark> </strong></p><p><strong>“backlog的含义从未有过正式的定义”，不同的 UNIX 操作系统对其有不同的实现</strong> 。这里只以笔者的环境 Ubuntu 16.04 进行说明。</p><blockquote><p>其他版本的相关说明请参见《UNP》第 3 版 84 页。</p></blockquote><p><strong>先说结论：</strong></p><p><strong><font color='orange'>在 Linux 内核 2.2 之后，<code>backlog</code> 参数影响全连接队列的长度， <code>tcp_max_syn_backlog</code> 作为系统变量则影响半连接队列的长度</font></strong> 。</p><blockquote><p>为什么说“影响”而不是“决定”？因为两个队列长度的具体定义是采用的如下方式：</p><ul><li><strong><code>全连接队列长度 = min(somaxconn, backlog)+1</code></strong></li><li>半连接队列的长度计算较为复杂，且不同版本的操作系统实现不一样，故没有必要掌握其计算方法。<strong><font color='orange'>只需要知道，半连接队列长度可能同时取决于 <code>backlog</code> 、<code>somaxconn</code> 和 <code>tcp_max_syn_backlog</code> ，这三者越大，则半连接队列容量越大</font></strong> 。</li></ul><p><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值。</p></blockquote><p><strong>下面就全连接队列进行 <code>backlog</code> 的实验。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意,没有accept和close</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个客户进程并发送连接请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">            close(sock_clnt);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行以上代码，结果如下：<br><img src="/2022/img/image-20230319223902516.png" alt=""></p><p><strong><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可</strong> 。可以看到，10 条连接中，只有 6 条是 ESTABLISHED 状态，剩下 4 条是 SYN_SENT 。很奇怪，我们指定的 <code>backlog</code> 是 5，所以不应该只有 5 条是 ESTABLISHED 状态吗？嗯，这里挺坑的，<u><strong>这是因为大多数操作系统的实现都为 <code>backlog</code> 引入了 <font color='orange'>模糊因子</font></strong></u> ，我们这里的模糊因子就是 +1，也就是说，<code>实际全连接队列容量 = backlog + 1</code> 。其他操作系统的模糊因子参考：<br><img src="/2022/img/IMG_0575(20230319-224643).PNG" alt=""></p><blockquote><p>关于更多模糊因子的描述，参见《UNP》85~87 页。</p></blockquote><p>接着我们查看 <code>somaxconn</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /prog/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure><p>将其修改为 3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//必须在管理员权限下才能修改</span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /prog/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p>然后再运行服务器和客户端，得到以下结果：<br><img src="/2022/img/image-20230321093637098.png" alt=""><br>可见，有 4 条连接处于已建立状态，比我们指定的 <code>somaxconn</code> 还要多 1 。</p><p><strong><font color='orange'>综上，我们得出结论：全连接队列长度 = min(somaxconn, backlog) + 1</font></strong></p><p><strong><mark class="hl-label blue">当全连接队列满了怎么办</mark> </strong><br>默认行为是直接丢弃，我们也可通过指定 <code>tcp_abort_on_overflow</code> 参数来调整其行为：</p><ul><li>0 ：直接忽略客户端发过来的 ACK ；</li><li>1 ：回复 RST 给客户端，表示终止本次连接；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /prog/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>一般情况下默认为 0 即可，这是更合理的方式，因为全连接队列已满的状态只是暂时的，客户端会因迟迟未收到 ACK 重发报文，期待不久就能等到全连接队列腾出可用空间。</p><hr><p><strong>半连接队列的长度受多方面影响，且不同操作系统版本的实现方式各不相同</strong> ，所以无需掌握具体计算方式。这里笔者简单演示如何间接查看半连接队列的长度。</p><p>半连接队列中的状态为 SYN_RCV ，所以我们可以发起 SYN 泛洪，向端口发送大量虚假的 SYN 报文，然后查看该端口上最多时有多少个连接处于 SYN_RCV 状态，此时就是半连接队列的最大长度。</p><ol><li><p>下载 hping3 ，用来发起 SYN-flood 攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install hping3</span><br></pre></td></tr></table></figure></li><li><p>修改系统配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_max_syn_backlog = 128</span><br><span class="line">somaxconn = 150</span><br></pre></td></tr></table></figure><p>笔者将 backlog 设置为 9（那么全连接队列的容量就为 10），读者随意。</p></li><li><p>运行服务器端</p></li><li><p>发起攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>可见，半连接队列长度等于 backlog</strong></p></li><li><p>再将 backlog 设置为 200，重复以上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">150</span><br></pre></td></tr></table></figure><p><strong>可见，在笔者环境下（Ubuntu 16.04） ，<font color='orange'>如果 backlog 小于 <code>somaxconn</code> ，则半连接队列容量为 backlog，反之则为 <code>somaxconn</code> ，与 <code>tcp_max_syn_backlog</code> 无关。</font></strong></p></li></ol><p>综上， <strong><font color='orange'>半连接队列容量<u>可能</u>同时受 <code>tcp_max_syn_backlog</code> 、<code>somaxconn</code> 和 <code>backlog</code> 的影响，想要增大半连接队列的长度，就需要同时增大这三个参数，仅增大 <code>tcp_max_syn_backlog</code>  是无效的</font></strong> 。</p><p>对于半连接队列，更多的是需要掌握它与 SYN 泛洪的关系。关于 SYN 泛洪，详细可参见博主另一篇文章-<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪攻击</a></p><hr><p>另外，还可以从 <code>ss</code> 命令直接观察全连接队列的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*       </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59492              </span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59496              </span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>-n 不解析服务名称<br>-t 只显示 tcp sockets<br>-l 显示正在监听(LISTEN)的 sockets</p></blockquote><p><strong>对于 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：当前全连接队列的中的连接个数，即已完成三次握手等待应用程序 accept 的 TCP 连接</strong></li><li><strong>Send-Q：全连接队列的容量</strong></li></ul><p><strong>对于非 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：已收到 <u><font color='gree'>但未被应用程序读取</font></u> 的字节数</strong></li><li><strong>Send-Q：已发送 <u><font color='gree'>但未收到确认</font></u> 的字节数</strong></li></ul><p>注意上面的输出，LISTEN 状态下的 Recv-Q ，即全连接队列中的连接个数为 11；但 Send-Q，即全连接的最大长度才为 10，这是怎么回事？这可能是因为 Send-Q 没有包含模糊因子，直接等同于 backlog 。</p><p><strong><font color='orange'>另外注意，<code>ss</code> 命令和 <code>netstat</code> 命令对 LISTEN 状态输出的 Recv-Q 和 Send-Q 的含义不相同</font></strong> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -at</span><br><span class="line">Proto    Recv-Q     Send-Q   Local Address           Foreign Address         State </span><br><span class="line">tcp      0          0        *:12345                 *:*                     LISTEN</span><br><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*  </span><br></pre></td></tr></table></figure><p>这两条命令是在同一次网络请求下进行的，但两者的 Recv-Q 和 Send-Q 却不相同。个人猜测 <code>netstat</code> 下的 Recv-Q 和 Send-Q 就是单纯的收发字节数，不再表示连接个数或队列长度。</p><p>本文结束。</p>]]></content>
    
    
    <summary type="html">半连接与全连接队列, backlog</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>错误处理与包裹函数</title>
    <link href="http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-18T15:24:21.000Z</published>
    <updated>2023-04-11T15:57:56.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考书籍：《UNIX网络编程》《UNIX环境高级编程》</p></blockquote><h2 id="font-color-red-errno-font"><font color='red'>errno</font></h2><p>只要在一个 <strong><u>系统调用</u></strong> 中有错误发生，<strong>全局变量 errno</strong> 就会被自动设置为一个特定的正值，用来反馈具体错误，而函数本身则会返回 -1，以说明函数发生了错误；如果函数返回正值，即没有错误发生，则 errno 没有定义。errno 包含在 <code>errno.h</code> 中。</p><ul><li><p>如果函数没有出错，则之前的 errno 可能不会被清除（未定义）；只有发生错误时，才会覆盖之前的错误。</p></li><li><p>errno 不会为 0，这与多线程的 errno 处理有关。</p><blockquote><p><strong>这是因为：线程函数（以 pthread_ 开头的函数）遇到错误时不会设置标准 Unix 的 errno 变量，而是将 errno 的值以函数返回值的形式交给调用者。也就是说，返回值大于 0 则说明发生了错误，那没有发生错误呢？自然也就是返回 0 了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(&amp;ndoen_mutex))!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这意味着我们每次调用 pthread_ 函数时，都要事先分配一个整形来保存错误值，这很麻烦，所以我们可以把错误处理和 pthread_ 函数包裹起来以简化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(mptr))!=<span class="number">0</span>)</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong><font color='red'>虽然 errno 是一个全局变量，但是在多线程环境中，每个线程都会有自己独立的 errno 副本，这是通过线程本地存储（Thread-Local Storage，TLS）实现的，因此一般不用担心多线程会相互竞争 errno，可参见《APUE》P358</font></strong><br><img src="../../public/2022/img/image-20230410230004254.png" alt=""></p></li><li><p><strong>虽然在多线程下不用担心 errno 的竞争问题，不过单线程下 errno 仍可能出现问题，比如在信号处理函数中被修改</strong> 。当发生信号时，执行流会跳转到信号处理函数，这感觉就像是多线程，但实际上它和之前的执行流位于同一个上下文，也就是说信号处理函数并不是新开的线程。因此，如果之前的执行流在系统调用出错后修改 errno，接着被信号中断，进入了信号处理函数，而信号处理函数中也调用了某些系统函数如 write，如果此时这个系统调用出错，那么 errno 就会被修改，<strong>这就使得之前的 errno 被覆盖！</strong> 因此，<strong><font color='orange'>作为一个通用的规则：</font></strong> 在信号处理函数中，应首先保存 errno，退出时再恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alarm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> errno_cpy = errno;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">    write(....);</span><br><span class="line">    errno = errno_cpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="font-color-red-perror、strerror-font"><font color='red'>perror、strerror</font></h2><p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr，其中 str 是自定义内容。该函数先输出 str，再输出错误描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="comment">//连接错误则输出以下结果：</span></span><br><span class="line">connect: Connection refused</span><br></pre></td></tr></table></figure><p>C 库函数 <strong>char *strerror(int errnum)</strong> 从内部数组中搜索错误号 <strong>errnum</strong>，并返回一个指向错误消息字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = strerror(errno);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-包裹函数-font"><font color='red'>包裹函数</font></h2><p>网络编程很多时候都会遇到一些网络问题，并通过函数返回值或 errno 反馈错误，因此绝不能忽略对错误的处理。包裹函数一般用来处理致命性错误，此时能干的也就只有打印错误然后退出，对于非致命性错误，比如 EINTR 错误，就需要我们自己来处理失败情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sock_conn=accept(sock_listen,<span class="literal">NULL</span>,<span class="literal">NULL</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要自己重启被中断的系统调用。关于中断的系统调用，参见《APUE》第 260 页。</p><p>一些包裹函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bind(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (connect(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他包裹函数可参考<a href="https://github.com/jyx-fyh/unp-source-code/blob/master/lib/wrapsock.c">UNP-sockwarp.c</a></p></blockquote>]]></content>
    
    
    <summary type="html">错误处理与包裹函数</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT与SO_REUSEADDR</title>
    <link href="http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/"/>
    <id>http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/</id>
    <published>2023-03-16T10:08:32.000Z</published>
    <updated>2023-04-07T03:31:58.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>运行环境：Ubuntu 16.0.4</p></blockquote><ul><li><p>无论是否开启 SO_REUSEADDR ，客户端主动断开连接后，无需等待 TIME_WAIT 即可重连，因为客户端每次 bind 的端口都不一样。由此可见， <strong>TIME_WAIT 是对端口而言</strong> 。</p><blockquote><p>不管是服务器还是客户端，只要是主动断开连接的，都会有 TIME_WAIT 。</p></blockquote></li><li><p>如不开启 SO_REUSEADDR，服务器端主动断开连接，则必须等待 TIME_WAIT 后才可重新 bind 该端口，原因见下文。</p></li><li><p><strong><font color='red'>注意，必须是要在 accept 或 connect 成功返回后（即连接成功后）断连或终止程序，才会有 TIME_WAIT ；仅仅 bind 但未连接成功，终止程序后是不会 TIME_WAIT 的</font></strong> 。</p></li><li><p><strong><font color='red'>注意，如果 bind 指定端口不成功，则会自动 bind 其他任意端口；</font></strong></p></li><li><p><code>SO_REUSEADDR</code> 生效的前提条件是开启时间戳，即令 <code>/proc/sys/net/ipv4/tcp_timestamps</code> 为 1（默认也为1）。</p><blockquote><p>实操发现即使关闭时间戳，服务器也能立刻重新绑定端口，原因尚不明确。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>; <span class="comment">//SO_REUSEADDR默认也是0</span></span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR, &amp;opt, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server failed to bind\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> != (sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>)))&#123;</span><br><span class="line">        <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">        size = write(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server sent %ld bytes\n=====================&quot;</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(3);  //stop 3s so that client could send FIN first</span></span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> in_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">99</span>;i++)</span><br><span class="line">        out_buf[i]=<span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="keyword">sizeof</span>(out_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    size = read(sock_clnt, in_buf, <span class="keyword">sizeof</span>(in_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">//stop 3s so that server could send FIN first</span></span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编译上述代码，先运行 server 端，再运行 client 端（注意，最好运行可执行文件，不要直接在编译器中运行），结果如下：<br><img src="/2022/img/image-20230316190258629.png" alt="server"><br><img src="/2022/img/image-20230316190325197.png" alt="client"><br>由于客户端 close 前调用了 sleep，所以可以判断一定是 server 主动断开连接，如下图：<br><img src="/2022/img/image-20230316190534357.png" alt=""><br><code>localhost:12345</code> 是本端地址信息，<code>localhost:53188</code> 是对端地址信息，后面的状态是描述本端状态的，因此可知 server 主动发送 FIN 并断开连接后，进入了 TIME_WAIT 状态。此时我们马上重启服务器，则输出以下内容：<br><img src="/2022/img/image-20230316191622035.png" alt=""><br>在 TIME_WAIT 内重启服务器，则报错绑定失败。注意，绑定指定端口失败后，会随机绑定其他端口，如下：<br><img src="/2022/img/image-20230316191842098.png" alt=""><br>第三行的 <code>46937</code> 便是服务器端随机绑定的端口。不过这已经失去意义，因为服务器是通过知名端口来被客户端认识的，客户端根本不认识这些随机端口，所以 server 会一直处于监听状态，不会有 client 来连接。因此，对于服务端，如果 bind 失败，应该直接终止程序或等待 TIME_WAIT 后重新 bind。</p><p>下面我们让 client 主动关闭连接——加上 server 的 sleep ，去掉 client 的 sleep 即可。结果如下：<br><img src="/2022/img/image-20230316193318143.png" alt="server"><br><img src="/2022/img/image-20230316193335972.png" alt="client"><br><img src="/2022/img/image-20230316193425965.png" alt=""><br>本端为 <code>localhost:53200</code> ，可见确实是 client 发起的 FIN 。因为 client 无需 bind 特定端口，即 client 每次运行绑定的端口都不同，所以不用担心会因为 TIME_WAIT 而连接失败。</p><p>接下来我们使用 SO_REUSEADDR 选项来修改 TIME_WAIT 的限制——将 server 代码第 7 行的 opt 赋值为 1 即可，这样就可以无视 TIME_WAIT 直接复用端口。下面是连续两次运行 server 和 client 的结果：<br><img src="/2022/img/image-20230316204302114.png" alt=""><br><img src="/2022/img/image-20230316204349584.png" alt="">你看，即使服务器处于处于 TIME_WAIT 状态，还是可以直接绑定端口并进行通信。</p><p><strong><font color='red'>注意，即使将 SO_REUSEADDR 置 1，TIME_WAIT 状态也依旧存在，只是可以无视该状态直接 bind 而已。</font></strong></p><p>待补充</p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1-time-wait-%E7%8A%B6%E6%80%81">https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#为什么要设计-time-wait-状态</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#先说结论</a></p>]]></content>
    
    
    <summary type="html">TIME_WAIT与SO_REUSEADDR实操</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程重点</title>
    <link href="http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-05T10:30:46.000Z</published>
    <updated>2023-04-15T15:11:12.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li><li>本文只记录重点内容和个人理解，系统学习请移步《UNIX网络编程》</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>“门卫”</font>套接字，注意，此时仅指定了该套接字的类型（TCP/UDP）</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='red'>“门卫”套接字，即监听套接字，该套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong><font color='red'>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</font></strong> 。<strong>注意，区分监听套接字和已连接套接字非常重要！</strong> 一个服务器端口通常只创建一个监听套接字，而当服务器完成客户端的服务时，相应已连接套接字就会关闭。下图可看到监听套接字和已连接套接字的描述符是不同的，以说明这两个套接字的差异：</p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><p><strong><mark class="hl-label blue">socket</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>该函数返回主动套接字，经过 listen 函数转换后才会成为监听套接字。</li><li><strong>protocol 敲定最终协议</strong> 。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；</li></ul><p><strong><mark class="hl-label blue">bind</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png" alt=""></p><ul><li><p>该函数将 addr 地址结构所包含的信息绑定到 sockfd 套接字上，相当于为套接字办理身份证。</p></li><li><p><strong>bind 可以手动指定 IP 地址或端口，可以两者都指定，也能两者都不指定，如果不手动指定，则按以下方式处理：</strong></p>  <img src="../../public/2022/img/image-20230308162549530.png" style="zoom:80%;" />  **<font color='red'>对于 IPv4，通配地址为宏 INADDR_ANY；对于 IPv6，为 in6addr_any</font>** ：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servSock.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//INADDR_ANY一般为0,可以不用htonl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果绑定 INADDR_ANY，此时服务器自己的所有 IP 上（如果是多宿）监听，等到客户发来的 SYN 报文时，再绑定到该报文指定的对端 IP</strong> 。</p></li><li><p><strong><u>注意，对于 TCP 而言，如果不手动指定端口，<font color='orange'>则在调用 listen (server) 或 connect (client) 时</font>，内核会选择一个临时端口</u></strong> 。对于客户端，我们一般让内核来绑定套接字的端口（除非需要预留端口）；<strong><u><font color='orange'>对于服务器端，很少让内核自行决定端口，因为服务器是通过它们的总所周知端口而被外界认识的</font></u></strong> 。</p></li><li><p><strong><u>对于 TCP 客户端，由内核绑定 IP 地址；对于 TCP 服务器端，如果没有手动绑定，则内核就把客户发送的 SYN 报文中的目的IP地址作为绑定的 IP 地址。</u></strong></p></li><li><p><strong><font color='red'>不论是服务器还是客户端，如果绑定指定端口失败，则随机分配一个端口</font></strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p><strong>如果服务器的某个端口刚断开连接，处于 TIME_WAIT 状态，则默认情况下不能立即再次绑定该端口，否则返回 EADDRINUSE 错误</strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p>注意 bind 与 accept 参数类型的差异，前者是值类型，后者是值-结果类型（调用函数后，参数会被改变，即作为返回值）。</p></li></ul><p><strong><mark class="hl-label blue">listen</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li><strong>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</strong></li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同；<strong><u>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</u></strong> 。关于这两点，详见<a href="https://jyx-fyh.github.io/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/">socket等待队列</a> 。</li></ul><p><strong><mark class="hl-label blue">accept</mark> </strong></p><p><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li><p>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度。<strong><font color='orange'>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</font></strong> 。</p></li><li><p><strong><font color='red'>accept 从已完成队列中取出一个连接；仅仅只是取出一个完成了三次握手的连接，并返回绑定此连接的套接字</font></strong> 。</p></li><li><p><strong><font color='orange'>上面这句话说明了一个很重要的事实：accept 与三次握手无关！三次握手是底层网络协议栈自动完成的（当然，第一次握手是 connect 发起的）！换句话说，即使没有 accept 也能完成三次握手！</font></strong></p><blockquote><p>做个实验便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_lsn.sin_family = AF_INET;</span><br><span class="line"> Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> Listen(sock_lsn, <span class="number">20</span>);</span><br><span class="line"> <span class="comment">//注意,没有accept和close</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line"> addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"> addr_clnt.sin_family = AF_INET;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个进程并发送连接</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">         Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">         sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">         close(sock_clnt);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行，结果如下：</p><p><img src="../../public/2022/img/image-20230319221140308.png" alt=""><br><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可。显然，即使服务器端没有调用 accept，两端仍然建立了连接。<strong><font color='orange'>这再次说明，accept 只是从全连接队列中取出一个四元组，并绑定到一个新的套接字描述符而已</font></strong> 。<br>——<strong>四元组：即本端 IP、本端端口、对端 IP、对端端口，用来唯一确定一个 TCP 连接</strong> 。</p></blockquote></li></ul><p><strong><mark class="hl-label blue">connect</mark> </strong></p><ul><li><p>connect 函数仅在客户端使用，调用此函数时，内核会为客户端绑定套接字，端口随机，这个过程相当于 bind。</p></li><li><p>connect 会激发三次握手，只在连接成功或出错时返回。出错有以下三种情况：</p><ol><li><p>客户端迟迟未收到对 SYN 报文的 ACK，此时返回 ETIMEDOUT 错误。</p><blockquote><p>“迟迟”是多久？SYN 重传次数由 <code>tcp_syn_retries</code> 控制。<u><strong>通常</strong></u> ，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后。即，每次超时的时间是上一次的 2 倍。</p></blockquote></li><li><p>对 SYN 报文的回复是 RST，表明服务端在我们指定的端口上没有套接字处于监听状态，返回 ECONNREFUSED 错误。</p></li><li><p>SYN 报文在某个中间路由器上引发了“目的地不可达”的 ICMP 错误，重复发送几次 SYN 后，如果在规定时间内仍无响应，则返回错误。</p></li></ol></li><li><p><strong><font color='red'>如果 connect 失败，则该套接字不能再重新调用 connect，只能生成新的套接字再 connect 。</font></strong></p><blockquote><p>为什么不能对其重调用 connect 呢？其实如果联想到上文中的 TIME_WAIT ，那么这个问题就有思路了。考虑这样一种情况：当发送 SYN 后，由于网络拥堵，在 MSL(报文最大生存时间) 的前一刻到达了服务器，然后服务器发送 ACK 报文，然后 ACK 也在 MSL 前到达客户端；但是，将近 2MSL 已经挺久了，客户端没有等到这么久就返回 connect 错误，同时重新在该套接字上发起 connect 并发送新的 SYN；问题来了，此时上一个 ACK 刚好到达客户端！换句话说，第二次发送的 SYN 得到的回复是第一次的 ACK，这可能被时间戳机制判定为非法。关于时间戳，参见<a href="https://jyx-fyh.github.io/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">时间戳与序列号回绕</a> 。<br>以上只是本人的猜想，仅作为一种思路。</p></blockquote></li></ul><p><strong><mark class="hl-label blue">close</mark> </strong></p><ul><li>调用 close 后，<strong><font color='orange'>该套接字（文件描述符）的引用计数减 1</font></strong> ，<strong>如果引用计数仍大于 0，则不会给对端发送 FIN 报文，等于 0 才会引发挥手</strong> 。这一点在多进程网络编程中有重要作用。</li><li><strong>close 函数的默认操作是立刻关闭套接字并返回，但如果发送缓冲区中还有数据残留，则内核会将这些数据继续发送给对端。close 的行为可以由 <code>SO_LINGER</code> 控制。</strong> 关于 <code>SO_LINGER</code> ，参见<a href="https://jyx-fyh.github.io/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/">SOCKET常见选项</a></li><li>对于主动关闭端而言，发送 FIN 并收到对方回复的 ACK 报文后进入 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果主动关闭端是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></li></ul><p><strong><mark class="hl-label blue">shutdown</mark> </strong></p><ul><li>close 同时终止读与写两个方向的数据传送，而 shutdown 用来指定关闭一个方向的数据传送。</li><li><strong><font color='orange'>使用 shutdown 关闭读后，缓冲区的所有数据都被丢弃，而且后续收到的数据会<u>先被确认</u>然后悄然丢弃，不会返回 RST。</font></strong></li><li><strong><font color='orange'>shutdown 的 SHUT_WR 不管套接字的引用计数是否为 0，直接发起挥手。</font></strong></li></ul><p><img src="../../public/2022/img/IMG_0580(20230407-134909)-1681295358001-1.png" alt=""></p><p><strong><mark class="hl-label blue">各类地址转换函数</mark> </strong></p><ul><li></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">    若字符串有效,则返回二进制值,无效则返回<span class="title function_">INADDR_NONE</span><span class="params">(其值为<span class="number">-1</span>)</span></span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值。32 位说明它只能用于 IPv4 地址转换。该函数不能处理 <code>255.255.255.255</code> ，详细原因参见《UNP》P67；另外，此函数已经被废弃，最好不再使用。</p><ul><li></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="keyword">struct</span> in_addr *addr)</span></span><br><span class="line">    若字符串有效,则返回1,否则返回0</span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值并保存在 addr 结构体中。</p><ul><li></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span> <span class="params">(<span class="keyword">struct</span> in_addr addr)</span></span><br></pre></td></tr></table></figure><p>将 32 位的网络字节序二进制值转换为点分十进制字符串。<strong><font color='orange'>注意，<u>inet_ntoa() 是不可重入的</u>，该函数返回的字符串是储存在静态内存中的，第二次调用该函数时将覆盖之前的结果。因此，当我们通过该函数的返回值取得字符串后必须马上转移到其他地方储存。</font></strong><br><img src="../../public/2022/img/image-20230415204033411.png" alt=""></p><blockquote><p>关于重入问题，参见<a href="https://jyx-fyh.github.io/2023/04/15/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5/">什么是不可重入</a></p></blockquote><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> * str, <span class="type">void</span> * addr)</span></span><br><span class="line">    成功则返回1,若str不是有效表达式则返回0,失败则-1</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，因此第三个参数为 void*，因为实参既可以为 in_addr 也可以为 in6_addr 。</p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntop</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> * addr, <span class="type">char</span> * str, <span class="type">socklen_t</span> len)</span></span><br><span class="line">    成功则返回字符串指针,否则返回<span class="literal">NULL</span>,并置errno为ENOSPC</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，将网络字节序二进制值转换为点分十进制字符串。其中 str 不能为 NULL，其必须为 str 分配空间并指定大小。这个大小可使用 <code>&lt;netinet/in.h&gt;</code> 中的宏指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure><p><strong>第二个参数 addr 的结构体类型为 <code>in_addr</code> 或 <code>in6_addr</code></strong> ，后面有例子。</p><blockquote><p>另外，<code>inet_pton</code> 和 <code>inet_ntop</code> 总是可重入的，应尽量使用 <code>inet_ntop</code> 来代替 <code>inet_ntoa</code></p></blockquote></li></ul><p><strong><mark class="hl-label blue">getsockname与getpeername</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *local_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *peer_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line">    成功返回0,否则-1</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>参数 len 是值-参数类型（既做参数，也储存返回值），作为返回值时，传递实际地址结构体的大小</font></strong> 。什么是实际地址结构体？是这样的：当你 getpeername 时，你不知道对面是 IPv4 还是 IPv6，如果此时你将 <code>sockaddr_in</code> 类型（IPv4）的结构体作为第二个参数，len 为 <code>sockaddr_in</code> 的长度，那么问题来了——万一对方是 IPv6 ，那这个 <code>sockaddr_in</code> 就无法完全存储 <code>sockaddr_in6</code> ，一部分会被截断。同时，len 被修改为 <code>sockaddr_in6</code> 的大小。如何解决这个问题呢？很简单，<strong>使用通用结构 <code>sockaddr_storage</code> 来储存实际地质结构体，它能够承载任何套接字地址结构，因此不会被截断</strong> 。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">saddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>* <span class="title">pinaddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span>* <span class="title">pin6addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"><span class="type">int</span> ret = getpeername(sock, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;getpeername err\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET)</span><br><span class="line">&#123;</span><br><span class="line">    pinaddr = (<span class="keyword">struct</span> sockaddr_in*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv4:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pinaddr-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%u\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET6)</span><br><span class="line">&#123;</span><br><span class="line">    pin6addr = (<span class="keyword">struct</span> sockaddr_in6*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv6:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pin6addr-&gt;sin6_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%ud\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下理由需要这两个函数：</p><ul><li><p>客户端一般不调用 bind，端口和地址都在 connect 时由内核分配，所以需要通过 getsockname 获得本端信息。</p></li><li><p>服务器端经常绑定通配地址 <code>INADDR_ANY</code> ，所以需要使用 getsockname 来确定本端绑定的地址。<strong><font color='orange'>注意，上文说过，当绑定通配地址时，监听套接字的最终绑定结果是在收到对端发来 SYN 报文后才确定的，所以此时 getsockname 的作用对象只能是已连接套接字，而不能是监听套接字。</font></strong></p></li><li><p><strong><font color='orange'>如果一个服务器程序是由执行过 accept 的某个进程调用 exec 而得到，那么这个服务器程序只能通过 getpeername 来获取对端信息</font></strong> 。inetd 派生 Telnet 服务器就是这样的情况：<br><img src="../../public/2022/img/IMG_0585(20230415-212627).PNG" alt=""></p></li><li><p>gethostbyname<br><img src="../../public/2022/img/Screenshot_2023-04-13-19-54-59-94_40deb401b9ffe8e.jpg" alt=""></p></li></ul><p><strong><font color='orange'>常错点总结：</font></strong></p><ul><li><p>将 sockaddr_in 敲成 sockaddr</p></li><li><p>忘记 memset</p></li><li><p>accept 的第三个参数不同于 bind，须要对 size 取地址</p></li><li><p>别忘了 close</p></li><li><p>对于Linux，socket函数都是<code>&lt;sys/socket.h&gt;</code> ，某些宏，如<code>IPPROTO_XXX</code> 则是<code>&lt;apar/inet.h&gt;</code> 。</p></li><li><p>通过getsockname()获取套接字的信息。</p></li><li><p><strong>猜想：似乎每次回收套接字都需要一定时间？因为如果不调用close，一定时间内重启程序，客户端并不能再次直接连接。</strong><br>似乎和 TIME_WAIT 有关</p></li><li><p>memset 清零的目的是将 sockaddr_in 的成员 sin_zero 字段清零；该字段没有用，只是为了占位，以便和通用</p></li><li><p>一个socket能同时进行多个连接吗？</p></li><li><p>为什么要sockaddr_in --&gt; sockaddr</p></li></ul><h3 id="font-color-red-网络序-font"><font color='red'>网络序</font></h3><ul><li><strong>端口号就是在同一操作系统下为区分不同套接字而设置的，所以不能将一个端口号分配给不同套接字。但注意，tcp和udp不会共用端口号，所以允许重复，比如。。。</strong></li><li><a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_cookies">SYN cookie</a>是一种用于对抗<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_flood">SYN flood</a>攻击的技术，可以避免在incomplete connection queue被填满时无法建立新的TCP连接。对于使用SYN Cookie的服务来说， 当incomplete connection queue被填满时，<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>会表现得像SYN队列扩大了一样。对于队列填满后的新TCP连接，服务器会返回适当的SYN+ACK响应包，但会丢弃对应的SYN队列条目（因为队列已经满了）。如果服务器收到客户端随后的ACK响应，<strong>服务器能够使用编码在 TCP 序号内的信息重构 SYN 队列条目</strong>。</li><li>等待队列详解博客</li><li>阻塞模式</li></ul>]]></content>
    
    
    <summary type="html">Socket网络编程重点</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于CHATGPT的一些想法</title>
    <link href="http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2023-02-10T13:23:48.000Z</published>
    <updated>2023-03-12T11:21:19.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近一个月以来，国内乃至全世界的焦点都汇聚到了chatgpt之上。被chatgpt刷屏后，我个人也不禁产生了一些思考。</p><p><strong><mark class="hl-label blue">chatgpt对我们的生活将造成哪些影响？</mark> </strong><br>很难说。《未来世界的幸存者》中有这样一个观点：未来几十年内，人工智能将使许多传统岗位消失，如客服、信用评估员、市场分析师等；但有些职业是人工智能暂时很难取代的，如画家或律师等艺术性或人文性较强的工作，原因很容易知道，一言以蔽之，机器始终无法替代人类的灵光一闪。之前我也对此观点深信不疑，直到看见了下面这些新闻：<br><img src="/2022/img/b&bo=NwQzBjcEMwYWECA!&rf=viewer_311.jpeg" alt="AI画作：太空歌剧院" style="zoom:80%;" /><br><img src="/2022/img/b&ek=1&kp=1&pt=0&bo=OARgCTgEYAkWECA!&tl=1&vuin=1572676601&tm=1676037600&dis_t=1676037625&dis_k=f9474985ff1e09ce64e0efcb968d67df&sce=50-1-1&rf=viewer_311.jpeg" alt="AI律师" style="zoom:67%;" /></p><p>要知道，该书出版于2018年，至今仅过了短短五年…所以，你很难想象科技的发展速度，谁知道下一个五年将会是什么样呢？就chatgpt而言，虽然目前它的回答尚有较大的瑕疵，但风口已经打开，如周鸿伟所说——“搭不上ChatGPT的企业可能将被淘汰”，大量资本的注入势必会大大增强其性能，所以它的潜力仍然无法预估。不过，有一点我们必须清楚：如果想要避免未来被人工智能取代，就必须从事技术含量高、重复性低、可量化性低的工作。当然，公务员也许不错。</p><p>话说回来，也许不用对未来AI是否会造成失业潮而过度担心呢：<br><img src="/2022/img/image-20230210223238238.png" alt=""><br>本人浅薄地认为，AI过度地取代人工，将生成大量无业游民，进而引发社会动荡，这无疑是政府所不愿看到的。因此，政府可能会进行宏观上的调控。但，即使在调控下AI只会代替少部分人，你又如何保证你不是那倒霉的小部分呢？</p><p><strong><mark class="hl-label blue">由此看到的中外差距</mark> </strong><br>在<a href="https://www.huxiu.com/article/787988.html">《万字拆解：ChatGPT为什么这么强？》</a>论文中，作者向国内同胞们发出了真切的呼吁，此诚危急存亡之秋！包括但不限于人工智能领域，国内外的差距正在不断拉大，而极多数国人却在某些公知不怀好意的误导下，认为我国已经全方位赶英超美，天朝上国无所不能…如此下去，未来中国只有两个方面能够战胜国外——浓香型科技和酱香型科技。</p><p>再来看看我们的企业在干什么：<br><img src="/2022/img/image-20230210231638974.png" style="zoom:50%;" /><br><img src="/2022/img/image-20230210231800724.png" style="zoom:50%;" /><br>国外科技巨头在马不停蹄地创新，国内巨头却在你追我赶地和菜市场的小商贩抢生意。chatgpt爆火后，国内巨头们也争先恐后地计划推出类gpt产品：<br><img src="/2022/img/image-20230210232254477.png" style="zoom:67%;" /><br>个人不认为国内的这场chatgpt争夺战能够分出胜负，反而可能是全军覆没。原因很简单：2022年，OpenAI的算力支出约为4亿美元，人工支出约为9千万美元，光是这两样就达到了惊人的35亿人民币！中国有哪家企业能够下这样的血本？更不要说它的时间成本与技术成本了。在国内浮躁的学术环境和企业环境下，我们很难持续地取得技术创新。下一个5G还有多久？</p><p><strong><mark class="hl-label default">AI可能取代人类吗？</mark> </strong><br><img src="/2022/img/image-20230210222435996.png" alt=""><br>想起了流浪地球2的开头旁白——“起初，没人认为这是一场灾难，直到它和每一个人都息息相关。”</p>]]></content>
    
    
    <summary type="html">关于CHATGPT的一些想法</summary>
    
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深度思维-读书总结</title>
    <link href="http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-27T01:07:46.000Z</published>
    <updated>2023-03-12T11:21:04.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几日，我父亲醉酒后拉着我谈心，不知道是酒后起兴还是愁绪积压太久，向我倾诉了他对前半生的无尽悔恨，悔恨学生时代没有自制力（初中名列前茅，中考前被朋友带着打牌，三个月不眠，因此失利；高中仍名列前茅，又被朋友拉着打乒乓，没下课就跑去占台，耗费大量时间）；悔恨早年赚到钱时，没能听朋友劝告进入房地产；悔恨后来发家时，没能及时在深圳买房…父亲微仰着头，泪光不停地闪烁着，“在那个疯狂的、满地是钱的年代，无数个机会从我们面前闪过，然而我一个也没曾抓住。”</p><p>父亲的这些话，令我感触颇多。那个撒钱的年代，为什么机会遍地，却不曾抓住过？当然，任何一件事都有其时代的局限性，马后炮总是容易的。但话说回来，不依旧有很多人脱颖而出，改变了自己的命运吗？有人说他们靠的是胆量，或说凭的是运气。不可否认，这两者差一个都不行，但笔者认为，更重要的是——认知。与认知同义的，还有我们常说的眼界、格局等。最近有句话在网上传得很火——凭运气赚到的钱，总会凭实力亏掉，这句话的背后也许就体现了认知的重要性。如著名畅销书籍《穷爸爸富爸爸》中提到的，为什么一些运动员、演员等红极一时，短时间内赚到了普通人几辈子都赚不到的钱，而十几年甚至几年后就传出破产消息（拳王泰森、影帝尼古拉斯·凯奇都是例证）？个人认为，其背后深层次的原因都是认知（眼界）的不足。打一场拳或拍一部戏就能拿到一笔难以想象的巨款，相信绝大部分人此时都难以压抑自己的消费欲望，对于出身普通的人而言，更是会出现报复性消费，于是买豪车、置豪宅…不出多久，现金流就为负数了。而对于极少数的另一部分人，他们有更高的认知、更远的眼界，则可能用这些巨款继续创造正现金流（买房买车多数时候都属于负债，即负现金流），进而持有更多的资产。</p><p>那么，作为普通人的我们，怎样才能提升自己的眼界呢？又怎么才能把握时代的机遇呢？《深度思维》这本书也许就给出了答案。这本书给出了几种思维技术和思维格局，配以普通人的事例，让我深刻体会到了思维能力的重要性。下面简单谈谈我读完本书的感受。</p><p><strong>文章首先提到了思维链</strong> 。思维链的形式很简单，就是通过对一个问题进行连续追问，从而推测事物的未来走向（5so思考法），或探究问题的本质根源（5why思考法）。别看其思想和步骤极其简单，但结果往往令人吃惊！比如书中的例子，<strong>如何解决墙被腐蚀的问题——只需关上博物馆的窗帘！</strong> 这便是 5why思考法的威力，而普通的思考往往很难达到如此大的跨度。5so思考法同样令我震惊，书中有个精彩的真实案例：上海自贸区要成立了，so？——上海本地的贸易公司业务会繁荣，相应公司的股票一定上涨，so？——物流业务肯定也会被带动，物流公司的股票也值得购买，so？——物流繁荣，港口也一定繁荣，so？——集装箱租赁业务也肯定火爆…最后事实证明这一逻辑链完全正确，少量窥探先机的人则赚得盆满钵满。<br>既然这种简单到人人都会的思想方法能展现出如此巨大的威力，那为什么实际中，受益的人少之又少呢？个人认为，是因为没有刻意训练。方法再厉害也没有用，<strong>只有形成本能，当任何问题发生时，第一时间用这些方法思考问题，才能发挥作用</strong> 。而想要形成本能，就需要我们刻意训练，每当遇到问题，都先问自己，可以用什么样的方法或角度来解决，久而久之就可形成本能。</p><p><strong>接着提到了换位思维</strong> 。额，这还需要说？俺小学就学会了换位思考！小时候，一个小姐姐护士给我扎针，扎错了好几次，紧张得从脖子红到了耳朵，但我没怪她，因为我换位思考，如果我作为一个实习生护士，连续扎错了针，心里该多么紧张和难受啊！所以需要体谅和理解，想到这，我还安慰了这位护士，果然，一下就扎对了…呵呵，首先，这篇读后感不是小学课文；第二，换位思考不仅用于感受和体谅他人，在营销或其他领域也常有应用。还是书中的例子，一旅行社针对高压力的白领群体推出了一款旅游路线，广告语有以下两个：</p><ol><li><strong>风光无限，畅想人生</strong></li><li><strong>你是愿意待在沉闷的办公室里勉强安慰自己小点压力，还是愿意躺在大理洱海边畅快地呼吸新鲜空气？</strong></li></ol><p>高下立判。显然，第一个广告语是从你自己的角度来描述的，这并不能和白领们产生共鸣。而第二个广告语则是站在白领的角度来考虑的。想想，将自己放置于沉闷、阴暗的办公司，耳边嘈杂声不绝，满屋缭绕着对面男同事呼出的二手烟，桌面上堆满了待处理的文件…此时，你不经意抬头，看见了电脑上的第二则广告语，一幅蓝天白云，海边沙滩的画面立刻出现在你的眼前——OMG！去他妈的工作，这洱海我去定了！</p><p><strong>当我们面向的对象是人时，换位思考几乎是不能避免的</strong> 。<strong>记住，谁能引起共鸣，谁就能赢得了客户的心</strong> 。任何时候，问自己一句：如果我是他，我会想什么？我会做什么？每一份直击人心的文案策划，每一次打开局面的商业谈判，每一个引爆用户的产品设计，背后都对应着成功的换位思维。<br>另外，换位思考的一个精彩应用是爱德华·德·博诺博士提出的六顶思考帽，有专门的一本书——《六顶思考帽》详细介绍了该思想。六顶思考帽是利用换位思考，站在六种极端的角度来分析问题，最终得到一份最优的答案。后面有时间再阅读此书并另写读后感，这里就不多说了。</p><p><strong>在可视化思维一章中，文章提到了一种重要的时间管理原则——容易的事先做，重要的事先做</strong> ，经过大量实践，该原则被认为是解决拖延症的不二良方。嗯？就这么个小原则就能解决我多年的拖延症？这也太小看我了吧！再容易的事我也能拖…当然，这并不能解决你的拖延症，因为作者犀利地指出，<strong>这种时间管理原则最大的问题，在于如何评价事情的容易或重要程度</strong> ，就这点，我深有同感！很多时候，我在评价一件事情的重要性或可能性时，总会直接脱口而出：这件事有 80%~70% 的重要（可能）性！喔？70%~80% ，这些确切的数字是怎么得到的？计算得到的？还是调研得到的？又或者是随口一说？很显然，只是随口说说。通过这种模糊不定的评价标准来决策事情的先后，自己本身也会对其产生怀疑，所以当然就不会严格遵守。因此，作者就提出了一套评价标准：<br><img src="/2022/img/未命名绘图37.png" style="zoom:150%;" /><br>有了这样的确切的评价体系，我们就能够更客观地估计事件的优先级。你甚至可以对以上某一角度加权。注意，一旦决定实施这一评价体系，就必须时刻遵守它的结果。比如，算出 A 事件的优先级大于 B 事件，但你自己更喜欢 B 事件，所以你就违背了这一结果，直接先做 B 事件。长期这样违背只会降低这一方式的权威性，直到最后形同虚设。当然，你完全可以将喜爱程度也加入到这一体系中，并对喜爱度加权。</p><p><strong>令我同样印象深刻的还有秘籍型思维</strong> 。秘籍型思维是指，当我们探寻一个人是怎么成功的，或怎么才能做成一件事，最终会将原因归结到某种秘籍——职场能力、个人背景、贵人相助、思维方式…实际上，这种秘籍型思维已经深入我们的骨髓，我们将原因归结为一点，却忽视了别人在其他方面所作的努力。拿我自己举例，高中时，我一直对数学的奇技淫巧很感兴趣，花费大量时间去追求所谓的秒杀方法，基础却没能重视，最后的结果显而易见——基础不牢，地动山摇，高考数学成绩给了我一记耳光。更重要的是，直到大学，我都没有再提起过对数学的兴趣，甚至对其反感和厌恶，我想，这可能会成为我的一生之痛。<br><strong>秘籍型思维将复杂的东西过于简单化，企图用一个相对简单的秘籍去代替复杂的成功规律，而对其他方面的因素视而不见。</strong> 所有成功都是多方面因素促成的结果，单一考虑某一个方面，则有可能使得我们将鸡蛋全部放入一个篮子，增大了事件的风险性。</p><p>与秘籍型思维相反的是思维方法是全流程优化。全流程优化的最诱人的地方在于它的复利性。爱因斯坦曾说，复利是世界的第八大奇迹。全流程优化是指，将一件事情拆分为多个步骤，如果你每个步骤都做得比别人好那么一点，则成效则可能是别人的几倍！这是真正的在平凡中创造伟大！还是拿书中广告软文的例子来说明：<br>文章标题 --&gt; 正文内容 --&gt; 商品软文 --&gt; 链接跳转 --&gt; 店铺页面 --&gt; 支付界面 --&gt; 收获评价<br>富有吸引力的标题能够带来更多流量，这是第一步；正文内容不会直接谈到商品，而是做一些铺垫，这里必须保证足够吸引读者，或者和读者引发共鸣，这是第二步；接着是商品软文，这里需要承上启下，展现商品用途，需要足够打动读者；然后，读者可能成功被你的软文打动！ta尝试点入链接…<br>在以上步骤中，其他几个步骤你可以很容易地优化，比如将店铺页面装饰得漂亮些、评价反馈服务再做得到位一些…那么，链接跳转和支付页面该怎么优化呢？实际上，这两点是最容易被忽略的点，也是很容易丢失客户的点！拿我自己的感受来说，当我点击跳转链接后，经常会提示：“请复制该链接，并在浏览器中打开”，而这会极大地消耗我的耐心和冲动。本来这些软文广告就是在消费我们读者的冲动，而这些冲动都被繁琐的跳转链接给消耗了，还谈什么购买呢？对于支付页面，我也常有体会，很多时候下定决心要购买商品了，却发现没有微信支付，而只有支付宝支付，这每每令我相当恼火。<br>话转回来，如果我们将每个流程都优化 20%，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>4.29</mn></mrow><annotation encoding="application/x-tex">1.2^7=4.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4.29</span></span></span></span> ，你收获的成果将是别人的 4.29 倍！而你多做的努力只有 20% ！这就是复利的威力。因此，重视每一个细节，是我们成功的关键！</p><p>接着书中讲到了生态思维，生态思维侧重于发现事物之间的关系。《浪潮之巅》一书中介绍了计算机行业的一个著名生态链——以微软为首的软件公司吃掉硬件带来的全部好处（比如你内存越大，那我软件也刻意占用越大的内存），迫使用户更新机器让惠普和戴尔等公司收益，而这些计算机制造商再向英特尔这样的半导体厂商订货。在这条链上，相应公司的股票先后都会上涨，因此华尔街的投资者们都知道，如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔的股票。这些投资者们就深谙生态思维和逻辑链的威力。曾经在知乎上还看见一句令我印象很深刻的话：如果大家都知道某个产业赚钱，那就一定不能再挤进去，那怎么办呢——进入这个产业的上游产业。这也是一种生态思维的体现。生态思维下还有几个著名的模型：<strong>淘金模型、森林模型和平台模型</strong> 。<br>淘金模型的底层考虑是共生——如果恶龙太强，那就当恶龙的马仔！额…说错了——如果对手强大如河马，那我们可以成为牙签鸟！淘金模型来源于全球著名牛仔裤制造商李维斯。在疯狂的淘金热下，想要继续挖到大金矿已经几乎不可能，但大量的挖矿工人需要结实耐磨的裤子，聪明的李维斯便开始在金矿附近买起了牛仔裤，从而发展成了后来的著名牛仔裤品牌。相似的例子还有很多，比如为大量捡贝壳以求珍珠的人们提供坚实的橡胶手套。<br>森林模型强调的是错位竞争；平台模型则是为大量竞争者提供平台，而自己则成为平台的收益者。这些方法和事例看似简单，实践起来仍有很大难度。</p><p>文章最后提到的是大势思维。文章有一段很漂亮的话：</p><blockquote><p>古代诗人罗隐说：“时来天地皆同力，远去英雄不自由。”<br>荀子说：“君子生非异也，善假于物也。”<br>小米创始人雷军说：“站在风口上，猪都能飞起来。”</p></blockquote><p>这几句话都是对大势思维的例证。20年前，中国的富豪大多数是搞矿产的；10年前，中国富豪大多数是搞房地产的；现在，中国富豪则大多数是搞互联网的；那么可以预测，未来几十年，中国的富豪可能是发展人工智能或自动驾驶的。身为普通人的我们，又该如何发现并利用趋势呢？其实，趋势下往往隐藏着深刻的经济学规律，而文章中则给出了三条强大的规律——马太效应、科技进步和人口变化。这三条规律能够压制其他任何心理学或经济学规律，值得我们重视。</p><p>书中还有许多精彩的内容，限于笔者精力有限，就不再总结了，详细还请各位细品此书，定能有所收获。</p><p>在这个充满机遇和挑战的时代，共勉。</p>]]></content>
    
    
    <summary type="html">深度思维</summary>
    
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>更安全的用户进程?</title>
    <link href="http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-01-13T06:55:11.000Z</published>
    <updated>2023-03-12T11:21:19.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>data_limit_3gb</code></p></blockquote><p>在<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程</a>一文的文尾，笔者留下了一个思考题：既然要求用户不能直接访问内核，那为什么不将用户代码段的界限设置为 3GB 呢？正如之前所演示的那样，如果用户代码段的界限为 4GB，则用户就可以随意修改内核，包括直接访问显存：<br><img src="/2022/img/image-20230112155046604-1673594986128-1.png" alt=""><br>其实笔者也不知道准确的答案，我粗略参考了 Linux 0.11 的代码，发现 Linux 0.11 <u>似乎</u>也是直接将段界限设置为 4GB 。至于规范的防止用户修改内核的方式，咋们以后遇上了再说，现在我们来看看到底能不能通过将数据段界限改为 3GB 来防止用户直接修改内核数据。</p><p>首先将用户数据段的段界限改为 <code>0xbfffffff</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:tss.c</span></span><br><span class="line"><span class="comment">//函数说明:tss_init()</span></span><br><span class="line">*((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xbffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br></pre></td></tr></table></figure><p>还要修改 syscall：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span></span><br><span class="line">    <span class="params">(<span class="string">&quot;int 0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (retval)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a&quot;</span> (no), <span class="string">&quot;b&quot;</span> (_arg1)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.....其他syscall也需要改为内联汇编</span></span><br></pre></td></tr></table></figure><p>为什么要将之前的静态变量方式改成扩展内联汇编呢？说到这，笔者不禁流下了悔恨的泪水…当初我也是为了少学这点看起来复杂的扩展汇编，所以使用了全局静态变量这样的“巧计”来代替这种复杂的汇编。没办法，未来某些场景必须使用到它，所以，该来的早晚会来。话说回来，目前而言，由于我们还没有真正的加载用户进程（真正的用户进程是从文件中读取，进而载入内存的，而当前我们使用函数代替用户进程的），所以一切代码和数据（的标号，即地址），不论用户进程还是内核，都被链接成了 3GB 以上，这都是下面这行 makefile 指令造成的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><p>这条指令将目前的所有文件全部链接成 kernel.bin，并指定入口的虚拟地址为 <code>0xc0001500</code> ，因此，所有的函数和全局、静态变量的地址实际上都在 <code>0xc0000000</code> 以上！所以，我们将用户段的界限限制在 3GB 以下时，在用户态中就不能再使用任何全局变量和静态变量！所以这里的 _syscallX 就不能使用静态变量来中转啦！于是乎，只有改成扩展内联汇编喽。<br>最后，还得修改系统调用入口函数，因为进入中断并不会自动切换 ds、es、fs（只会切换cs），所以咋们必须手动将这几个寄存器修改为内核态的数据段选择子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;.....</span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   push eax</span><br><span class="line">   mov  ax,0x10   ;内核的数据段选择子</span><br><span class="line">   mov  ds,ax</span><br><span class="line">   mov  es,ax</span><br><span class="line">   mov  fs,ax</span><br><span class="line">   pop  eax</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;.....</span><br></pre></td></tr></table></figure><p>ok，来试试看这下能不能直接在用户态访问显存：</p><p><img src="/2022/img/image-20230114134607206.png" alt="image-20230114134607206"></p><p>显然，发生了 GP 异常，禁止访问。说明这样是能够起到一定的保护作用的。来看看正常运行的效果：<br><img src="/2022/img/image-20230114150332216.png" alt=""></p><p>上图中用户只打印了一次，我就使用 Bochs 断点指令将其打断了，因为后面任务切换时引发了程序崩溃，原因就不细说了。这说明通过限制用户数据段的界限来禁止访问内核的这种方式是不可行的。<strong><font color='orange'>实际上，现代操作系统的内存保护机制并非在段上，而是在页上</font></strong> ，关于这点，以后再说吧。</p>]]></content>
    
    
    <summary type="html">自制操作系统</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>堆管理-实现malloc</title>
    <link href="http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/"/>
    <id>http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/</id>
    <published>2023-01-12T07:11:13.000Z</published>
    <updated>2023-03-12T11:21:22.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>k_block_descs</p><ul><li>为什么 1KB 以上就不分块</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
