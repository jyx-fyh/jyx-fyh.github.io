<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极简</title>
  
  <subtitle>用时间去沉淀</subtitle>
  <link href="http://jyxcpp.netlify.app/atom.xml" rel="self"/>
  
  <link href="http://jyxcpp.netlify.app/"/>
  <updated>2023-05-02T08:01:58.126Z</updated>
  <id>http://jyxcpp.netlify.app/</id>
  
  <author>
    <name>极简</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何使用VS编译调试一个大型项目?</title>
    <link href="http://jyxcpp.netlify.app/2023/05/02/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/"/>
    <id>http://jyxcpp.netlify.app/2023/05/02/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/</id>
    <published>2023-05-02T02:43:02.000Z</published>
    <updated>2023-05-02T08:01:58.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中 <code>.cpp</code> ，文件位于 <strong>“源文件”</strong> 节点下。 <code>.h</code>文件位于“**头文件”<strong>节点下，<code>.ico</code>文件<code>.rc</code>位于</strong>“资源文件”**下。 此位置由筛选器文件控制。</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/580990312">C/C++网络训练营</a> 、<a href="https://shiyousan.com/post/636441130259624698">.vs的作用</a> 、<code>chatgpt</code> 。</p></blockquote><h2 id="font-color-red-VS-工程概览-font"><font color='red'>VS 工程概览</font></h2><p>你有没有这样一种感受：想学习 github 上的一些优秀项目时不知道怎么开始；拿到源码后不知道如何运行；项目中密密麻麻的文件是怎么被组织起来的…于是，万里长征路，你就被难在了第一步。确实，学习和使用一个大型项目可能会让人感到困难和无从下手。但是，编译和调试大型项目的过程并不是无法掌握的。下面我将为你提供一些有用的建议和技巧，帮助你更好地理解和使用大型项目。</p><p>1）了解项目的结构和依赖关系是非常重要的。在大多数情况下，大型项目都会有一些文档或者说明文件，尤其是 README 文件，它会告诉你项目的基本信息，包括项目的结构、依赖关系、编译和运行方式等等。你可以先仔细阅读这些文件，了解项目的大致框架和组织方式。</p><p>2）了解项目的编译和构建过程也是非常重要的。大多数大型项目都会使用一些构建工具来自动化编译和构建过程，例如 Make、CMake等。你需要了解这些工具的基本使用方法，以及项目中使用的具体配置和参数。同时，你也需要掌握编译与链接的基本原理。</p><p>3）调试大型项目也是需要一些技巧的。一些常见的调试技巧包括使用调试器、打印日志、使用断言等等。你需要了解这些技巧的基本原理和使用方法，以便更好地定位和解决问题。</p><p>4）充分利用 Google 和 chatgpt，尤其是后者，将报错信息发给它，往往会给你极具引导性的答案。</p><p>一个好的 IDE 也是项目分析的关键。这里我们先来了解 Visual Studio 是如何组织项目的。</p><p>Visual Studio 中，最重要的两个概念是 <strong><u><font color='orange'>解决方案</font></u></strong> 和 <strong><u><font color='orange'>项目</font></u></strong>。</p><p>解决方案 (Solution) 是一个包含一个或多个项目的 <strong>容器</strong> 。<strong>它是用来组织、构建和调试项目的一个虚拟项目</strong> 。解决方案可以包含多个项目，这些项目可以是不同类型的，例如 C++ 项目、静态或动态链接库等等。<strong>在解决方案中，可以对不同项目之间的依赖关系进行管理和设置</strong> 。</p><p>项目 (Project) 是一个实际的代码库（lib \ dll）或者可执行文件（.exe）。在 Visual Studio 中，每个项目都有一个独立的项目文件（.vcxproj），其中包含了项目的所有配置信息，包括编译与链接选项。一个项目可以包含多个源文件（source）、头文件（header）、资源文件（resource）等等，它们一起构成了一个可编译的代码库或者可执行文件。</p><p>在 Visual Studio 中，解决方案和项目是紧密结合的。一个解决方案可以包含多个项目，这些项目可以共享同一个解决方案的设置和配置。例如，你可以在解决方案中设置所有项目的编译选项、链接选项、调试选项等等。同时，你也可以在项目级别上进行一些独立的配置和设置，例如项目的特定编译选项、依赖项等等。</p><p>以 teamtalk 这个在线聊天软件为例（），让我们看看它的结构：<br><img src="/2022/img/image-20230502133617307.png" alt=""></p><p>teamtalk 的解决方案下有 11 个项目。直接运行后报错：<br><img src="/2022/img/image-20230502133719222.png" alt=""></p><p>错误提示 <code>DuiLib.dll</code> 不是一个有效的可执行程序。这是因为 DuiLib 项目为默认启动项，但它生成的是动态链接库，而动态链接库是无法直接运行的，因此报错。<strong><font color='orange'>如何知道哪个项目是默认启动项？</font></strong> 看右边窗口，加粗字体的项目即为默认启动项目。<strong>一般将生成 exe 的项目设置为默认启动项</strong> 。右击任何一个项目，然后点击 <code>Set as Startup Project</code> 选项即可把该项目设置为启动项：<br><img src="/2022/img/image-20230502135834519.png" alt=""></p><p><strong><font color='orange'>怎么知道一个项目的目标生成文件是库还是可执行程序？</font></strong> 右击项目，点击最下方的 Property，显示如下窗口：<br><img src="/2022/img/image-20230502140120538.png" alt="image-20230502140120538"></p><p>可见，teamtalk 项目的目标生成文件为 .exe 。<strong><font color='orange'>一般而言，每个项目都有一个目标生成文件，文件名的前缀即为项目名称（图中高亮的上一行，Target Name）。</font></strong> 目标文件的生成路径也可以在图中的 Output Directory 进行修改。既然它的目标文件是 .exe，那就说明可以运行，我们将其设置为启动项，然后运行：<br><img src="/2022/img/image-20230502141050271.png" alt=""></p><p>成功运行！</p><hr><h2 id="font-color-red-区别几种项目文件-font"><font color='red'>区别几种项目文件</font></h2><p>下面看看 teamtalk 项目的项目文件：<br><img src="/2022/img/image-20230502140749981.png" alt=""></p><p>在 Visual Studio 中创建一个新的 C++ 项目时，通常会生成三个文件：.vcxproj、.vcxproj.filters 和 .vcxproj.user。这些文件分别用于存储项目的配置信息、过滤器信息和用户特定的配置信息。</p><p><strong><font color='gree'>1）</font></strong> .vcxproj 文件是 Visual C++ 项目的主要配置文件，它包含了项目的所有配置信息，例如编译选项、链接选项、输出文件、依赖项等等。这个文件是必需的，没有它，你无法编译和构建项目。<strong><font color='orange'>注意，项目中设置的任何相对路径都是以 .vcxproj 所在路径为基准的。</font></strong></p><blockquote><p>有些朋友可能还见过 <code>.vcproj</code> 文件。vcxproj 和 vcproj 都是 Visual Studio 项目文件的扩展名，但它们之间有一些区别：<br>vcproj 是用于 Visual Studio 2002 和 2003 版本的 C++ 项目文件格式，而 vcxproj 是用于 Visual Studio 2005 及更高版本的 C++ 项目文件格式。因此，vcxproj 是 vcproj 的升级版，它使用了更先进的 XML 格式来表示项目文件。</p></blockquote><p><strong><font color='gree'>2）</font></strong> .vcxproj.filters 文件是 Visual C++ 项目的过滤器配置文件，它用于组织和管理项目中的源文件、头文件、资源文件等。这个文件不是必需的，但是它可以帮助你更好地组织和管理项目中的文件，使代码更易于维护和重用。具体而言，它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中， 某些文件位于 “Main” 文件夹下，某些文件位于 “ProjectFils” 文件夹下。 此位置由筛选器文件控制：<br><img src="/2022/img/image-20230502142944601.png" alt=""></p><p>将 .vcxproj.filters 文件删除后，显示如下：<br><img src="/2022/img/image-20230502143614625.png" alt=""></p><p>结果散乱一团。所以 .vcxproj.filters 最好保留（一并添加到版本控制中）。</p><p><strong><font color='gree'>3）</font></strong> .vcxproj.user 文件是用户特定的配置文件，它包含了用户特定的配置信息，比如窗体和鼠标位置等。这个文件是可选的，它可以让不同的用户在同一个项目中使用不同的配置，以适应不同的开发需求。此文件无需保存到版本控制中。</p><p><strong><font color='gree'>4）</font></strong> .vs 文件夹（一般是隐藏状态），通常存放在解决方案的目录下，<strong>用来存储当前用户在解决方案中的工作配置，具体包括 VS 关闭前最后的窗口布局、最后打开的选项卡/操作记录/文件文档、某些自定义配置/开发环境、调试断点等这类设置信息和状态。</strong> 这样每当用户关闭解决方案后再重新打开，就能继续之前的工作状态。因此也无需保存到版本控制中。<br><img src="/2022/img/image-20230502151248516.png" alt=""></p><hr><h2 id="font-color-red-小技巧-font"><font color='red'>小技巧</font></h2><p><strong><font color='gree'>1）编译整个解决方案</font></strong><br>有时候右击 solution 然后点击 build 后，不会编译 solution 下的所有项目，这就很坑，调了半天原来压根没编译。调整方法如下：<br><img src="/2022/img/image-20230502151950947.png" alt=""></p><p><strong><font color='gree'>2）查看构建顺序</font></strong><br>某些库项目可能依赖另外一些库，通过查看构建顺序，我们能够更有针对性地解决库的编译问题，查看方法如下：<br><img src="/2022/img/image-20230502153808196.png" alt=""></p><p>这样，当我们单独编译 network 时出了问题，就可以去检查 network 是否依赖了 GifSmiley 和 httpclient，并针对性地去排查错误。</p><p><strong><font color='gree'>3）头文件搜索目录</font></strong><br>在Visual Studio中，头文件的搜索顺序如下：</p><ol><li>当前项目目录：Visual Studio 首先会在当前项目目录中搜索头文件，如果头文件存在于该目录中，则会直接使用该头文件。</li><li>系统目录：如果头文件不在当前项目目录中，则会在系统目录中搜索。这些系统目录包括 Visual Studio 安装目录、Windows SDK 安装目录、以及其他系统级目录。</li><li>环境变量：如果头文件不在系统目录中，则会在环境变量中指定的目录中搜索。例如，如果你在环境变量中设置了 <code>INCLUDE</code> 变量，则 Visual Studio 会在该目录中搜索头文件。</li><li>项目属性：如果头文件仍然无法找到，则会在项目属性中指定的搜索路径里搜寻。</li></ol><p>在项目属性中指定头文件的搜寻路径是高频使用的方法，必须掌握：<br><img src="/2022/img/image-20230502154638921.png" alt=""></p><p><strong><font color='gree'>5）库搜索目录</font></strong><br>库文件的搜索顺序如下：</p><ol><li>当前项目目录。</li><li>系统目录。</li><li>环境变量。例如，如果你在环境变量中设置了“LIB”变量，则 VS 会在该目录中搜索库文件。</li><li>项目属性。</li><li>引用的项目。<u>如果你的项目引用了其他项目，则 VS 会在这些项目的输出目录中搜索库文件。</u></li></ol><p>在项目属性中设置库的搜索目录，方法如下：<br><img src="/2022/img/image-20230502155314071.png" alt=""></p><p>也可以设置依赖项目，方法如下：<br><img src="/2022/img/image-20230502155518589.png" alt=""></p><p><strong><font color='gree'>6）定义宏</font></strong><br>有时候给你的整个项目定义宏会方便许多，如下：<br><img src="/2022/img/image-20230502155709943.png" alt=""></p><hr><p>OK，暂时先到这里，后面我们将会进行几个编译练习，分别是 teamtalk、Nginx、Libevent、电驴和 uwebsocket。</p>]]></content>
    
    
    <summary type="html">何编译调试一个大型项目?</summary>
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>练习1-编译调试teamtalk</title>
    <link href="http://jyxcpp.netlify.app/2023/05/01/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/"/>
    <id>http://jyxcpp.netlify.app/2023/05/01/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/</id>
    <published>2023-05-01T07:16:41.000Z</published>
    <updated>2023-05-02T04:33:28.012Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>TeamTalk 是一款蘑菇街开源的企业内部即时通讯软件，代码质量优秀，具有较高的学习价值。<a href="https://github.com/balloonwj/TeamTalk">源码</a>由张小方老师提供，在此表示感谢。<br>此次的任务仍然是在 Visual Studio 中将源码跑起来，这个过程碰到了许多编译和链接的问题，通过不断调整试错终于跑通了代码，实属不易！学习源码，往往就难在这第一步，只要将源码运行起来，我们就成功了一半。后续的代码细节直接边调试边理解，再爽不过！这个过程大大加深了我对编译与链接的理解，也熟悉了 Visual Studio 的开发环境。</p></blockquote><blockquote><p>勘误：文中图片的路径有时候为 TeamTalk，有时为 TeamTalk_test，前者是笔者为写此博客而重新开的项目，后者是之前的项目，由于本人疏忽不小心混淆了，大家直接将 TeamTalk_test 视作 TeamTalk 即可。</p></blockquote><p>1）从 <a href="https://github.com/balloonwj/TeamTalk">github</a> 上拉取源码，然后打开客户端的 <code>.sln</code> 解决方案文件：<br><img src="pictureimage-20230501211233465.png" alt=""></p><p>2）VS可能提示我们更新项目的编译工具集，默认即可：<br><img src="pictureimage-20230502103951134.png" alt=""></p><p>3）配置 configuration manager，指定 Build Solution 时是将该方案下的所有项目进行编译。</p><p><img src="pictureimage-20230501212233009.png" alt=""></p><p>4）点击 Build Solution，编译完成后报错如下：<br><img src="pictureimage-20230501212537341.png" alt="">我们一个一个来解决错误。</p><hr><p>先看 &lt;hash_map&gt; 的报错。该错误出现在 <code>network</code> 项目中，提示 &lt;hashmap&gt; 已经被废弃，如果要使用它，请先定义指定的宏。 右击 侧边栏的 <code>network</code> 项目，点击最下方的 property 选项；然后在 C/C++ 栏目中找到 Preprocessor 预处理栏，然后打开 Preprocessor Definitions ，向其中添加提示的宏 <code>_SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS</code> 即可。Modules 和 teamtalk 项目也有此错误，相同操作。<br><img src="pictureimage-20230501213353573.png" alt=""></p><hr><p>之前的报错中还提示 ‘function’: is not a member of ‘std’ ，这个简单，直接在对应文件中添加头文件 &lt;functional&gt; 即可。</p><hr><p>再次编译，报错如下：<br><img src="pictureimage-20230501214331967.png" alt=""><br><code>mbstate_t</code> 是结构体，无法直接赋值，应该使用初始化列表，将 <code>0</code> 改为 <code>&#123;0&#125;</code> 即可。</p><hr><p>再次编译，报错如下：<br><img src="pictureimage-20230501214805977.png" alt=""><br>先看后三个错误。在 utility 项目中无法打开 <code>mfcs120ud.lib</code> 文件，而在 Modules 和 teamtalk 项目中无法打开 <code>utility.lib</code> 。<strong>显然，是因为 <code>mfcs120ud.lib</code> 无法被打开导致 utility 项目无法生成 <code>utility.lib</code> ，继而使得 Modules 和 teamtalk 项目无法使用 <code>utility.lib</code> 。</strong> 所以我们必须先解决 <code>mfcs120ud.lib</code> 的问题。从这个静态链接库的名字我们可以知道，它不由任何项目生成，所以它应该是一个第三方库。打开文件夹，在整个 teamtalk 中搜索该文件，没有找到相关内容：<br><img src="pictureimage-20230501220032627.png" alt=""></p><p>所以我们可以大胆猜测这个库应该是系统库或编译器自带库。让 chatgpt 来告诉我们：<br><img src="pictureimage-20230501220445545.png" alt="image-20230501220445545"></p><p>ok，我们现在知道它是 MFC 的库，而且对应的版本是 Visual Studio 2013 。而当前我们的 VS 版本为 2022，所以极有可能是版本不匹配的原因。还是不确定，那让我们在 VS 的 VC 目录下搜索 mfcs 的相关内容：<br><img src="pictureimage-20230501220913135.png" alt=""></p><p>因此可以推断，2022 版本的对应库为 <code>mfcs140u.lib</code> 而不是 <code>mfcs120ud.lib</code> 。所以我们修改 utility 项目的依赖库，如下：<br><img src="pictureimage-20230501221137089.png" alt=""></p><p>然后再次编译：<br><img src="pictureimage-20230501221225358.png" alt=""></p><p>果然，utility 的 <code>mfcs120ud.lib</code> 错误解决。Modules 也有相同问题，步骤如法炮制。</p><hr><p>再次编译：<br><img src="pictureimage-20230501221431394.png" alt=""></p><p>尼玛！问题又多了，头大！现在提示在 Modules 项目中的 <code>libprotobuf-lite.lib</code> 文件中有<code>_MSC_VER</code> 相关的错误。 <code>_MSC_VER</code> 是什么？chatgpt 告诉你：<br><img src="pictureimage-20230501221808184.png" alt=""></p><p>真清晰！OK，现在我们大概知道报错是因为 <code>libprotobuf-lite.lib</code> 的编译版本较低造成的。同样，<code>libprotobuf-lite.lib</code> 依然不是我们的项目生成的库文件，让我们看看它在哪：<br><img src="pictureimage-20230501222531477.png" alt=""></p><p>嗯，从路径中的 3rdParty（第三方）也可以看出这是第三方库，而不是我们自己编译的库。那么问题来了，我们应该如何将 <code>libprotobuf-lite.lib</code> 转换为高编译器版本呢？大多数第三方库都是知名库，可以直接从官方下载最新版本，比如这个库就可以在<a href="https://github.com/protocolbuffers/protobuf/tree/main">github</a>下载。不过仔细搜寻后发现第三方库下有相关的压缩包（最下方的 protobuf）：<br><img src="pictureimage-20230501233642275.png" alt=""></p><p>解压后进入 vsprojects 目录，使用 VS 打开其中的 <code>libprotobuf-lite.vcxproj</code> ，这是工程文件：<br><img src="pictureimage-20230501233840160.png" alt=""></p><p>打开后 Build 这个解决方案，编译成功，最新编译版本的 <code>libprotobuf-lite.lib</code> 的输出位置见图：</p><p><img src="pictureimage-20230501233437643.png" alt=""></p><p>由于 Modules 项目的 linker 输入目录（Additional Library Directories）为 <code>D:\VSProjects\TeamTalk\win-client\3rdParty\lib\debug</code> ：<img src="pictureimage-20230501235111560.png" alt=""></p><p>所以我们用新的 lib 将久版本的 lib 替换掉：<br><img src="pictureimage-20230501235420326.png" alt=""></p><p>然后再次编译，该错误已经消失。teamwork 也有相同错误，同样加上前缀即可：<br><img src="pictureimage-20230502002924115.png" alt=""></p><p>啊哦，出现了关于 <code>security.lib</code> 的新错误…还是关于编译版本的问题。不过这次和之前的 <code>libprotobuf-lite.lib</code> 不同，第三方库目录下没有相关的压缩包。不过我们在 <code>3rdParty\src</code> 下发现了 <code>security.cpp</code> 源文件，所以为什么不直接编译呢？将这个源文件作为一个项目引入到 solution 下：<br><img src="pictureimage-20230502093523653.png" alt=""></p><p>发现有多个源文件找不到路径，搜索后发现它们位于 <code>\TeamTalk\server\src\libsecurity\src</code> 下，所以将此目录包含进项目的头文件搜寻范围：<br><img src="pictureimage-20230502093758527.png" alt=""></p><p>现在头文件已经能够检测到，不过还有些类型报错：<br><img src="pictureimage-20230502093855723.png" alt=""></p><p>小问题，<code>typedef unsigned char uchar_t</code> 即可。然后单独编译 security 项目，报错如下：<br><img src="pictureimage-20230502094149718.png" alt=""></p><p>预编译头文件？这是什么？还是问问 chatgpt 吧：<br><img src="pictureimage-20230502094505883.png" alt=""></p><p>我们无需使用预编译头文件，这里报错是因为项目默认开启了预编译头文件的功能，关闭即可：<br><img src="pictureimage-20230502094705556.png" alt=""></p><p>再次编译 security 项目，报错如下：<br><img src="pictureimage-20230502094754249.png" alt=""></p><p>好，我们在项目中添加 <code>SECURITY_WIN32</code> 宏：<br><img src="pictureimage-20230502094917057.png" alt=""></p><p>于是 security 项目编译成功：<br><img src="pictureimage-20230502095015199.png" alt=""></p><p>好，同样，我们用新生成的 <code>security.lib</code> 把之前的替换掉：<br><img src="pictureimage-20230502095155732.png" alt=""></p><p>然后编译整个 solution，报错：<br><img src="pictureimage-20230502095844929.png" alt=""></p><p>提示在 <code>security.lib</code> 中调用了一些没有定义的函数。回想一下，刚才我们是不是只为 security 项目引入了头文件目录以确保头文件能够找到，却没有把这些头文件对应的源文件包含进来，这样的话，<strong><u>如果 <code>security.cpp</code> 中调用了这些头文件声明的函数，只有声明而没有定义，就一定会导致上图所示的链接错误</u></strong> 。因此我们需要把头文件对应的源文件包含进 security 项目，它们仍位于 <code>\TeamTalk\server\src\libsecurity\src</code> 中：<br><img src="pictureimage-20230502100837276.png" alt=""></p><p>ok，编译 security 项目，报错如下：<br><img src="pictureimage-20230502101048441.png" alt=""></p><p>问题不大，定义该宏就行。然后再次编译，成功！然后把新的 <code>security.lib</code> 替换掉之前的即可。然后编译整个 solution，报错如下：<br><img src="pictureimage-20230502102713327.png" alt=""></p><p><code>Please verify that you have sufficient right to run this command</code> ，权限不够？那我们关闭 VS，以管理员身份重新运行：<br><img src="pictureimage-20230502102907161.png" alt=""></p><p>哟呼！跑起来啦！！！！大功告成。</p><p>接下来我们就可以随意打断点，单步调试 teamtalk 了，这样来学习源码真是不要太爽！</p>]]></content>
    
    
    <summary type="html">编译调试teamtalk</summary>
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>gdb入门</title>
    <link href="http://jyxcpp.netlify.app/2023/05/01/gdb%E5%85%A5%E9%97%A8/"/>
    <id>http://jyxcpp.netlify.app/2023/05/01/gdb%E5%85%A5%E9%97%A8/</id>
    <published>2023-05-01T02:28:16.000Z</published>
    <updated>2023-05-01T12:43:17.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>-args xuan<br>GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</p><hr><h3 id="font-color-red-调试前提-font"><font color='red'>调试前提</font></h3><p>只有具备调试信息的可执行文件才可被调试，即，编译时需要添加 <code>-g</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gcc main.c main -g</span></span><br></pre></td></tr></table></figure><p>调试时最好不要优化代码，使用 <code>-O0</code> 默认级别即可。对 GDB 调试器更友好的是 <code>-Og</code> 选项，-Og 对代码所做的优化程序介于 O0 ~ O1 之间，真正可做到“在保持快速编译和良好调试体验的同时，提供较为合理的优化级别”。</p><hr><h3 id="font-color-red-常用命令-font"><font color='red'>常用命令</font></h3><table><thead><tr><th>调试指令</th><th>作 用</th></tr></thead><tbody><tr><td>(gdb) file program</td><td>调试 program 程序</td></tr><tr><td>(gdb) break xxx <br />(gdb) b xxx</td><td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置。</td></tr><tr><td>(gdb) run <br />(gdb) r</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。其后可以传入参数。</td></tr><tr><td>(gdb) start</td><td>执行到 main 函数中的第一条指令停止。其后可以传入参数。</td></tr><tr><td>(gdb) continue <br />(gdb) c</td><td>当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束。</td></tr><tr><td>(gdb) next <br />(gdb) n</td><td>令程序一行代码一行代码的执行。</td></tr><tr><td>(gdb) print xxx <br />(gdb) p xxx</td><td>打印指定变量的值，其中 xxx 指的就是某一变量名。</td></tr><tr><td>(gdb) list <br />(gdb) l</td><td>显示源程序代码的内容，包括各行代码所在的行号。</td></tr><tr><td>(gdb) quit <br />(gdb) q</td><td>终止调试。</td></tr><tr><td>-q <br />-quiet <br />-silent</td><td>取消启动 GDB 调试器时打印的介绍信息和版权信息</td></tr><tr><td>–args prog arg1<br />(gdb) set args arg1 …</td><td>调试可执行程序 prog 并传入参数 arg1</td></tr><tr><td>(gdb) cd</td><td>修改 GDB 调试器的工作目录</td></tr></tbody></table><blockquote><p><code>(gdb)</code> 表示已经运行 gdb，目前是 gdb 中的命令行</p></blockquote><hr><h3 id="font-color-red-调试方式-font"><font color='red'>调试方式</font></h3><ol><li><p>调试尚未运行的程序：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb program</span></span><br><span class="line">或者 </span><br><span class="line">(gdb) file program</span><br></pre></td></tr></table></figure></li><li><p>调试正在运行的程序</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach program</span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb -p 进程号</span></span><br></pre></td></tr></table></figure><p>这种方式可能需要 root 权限。调式完毕后可执行 <code>detach</code> 指令，使 GDB 调试器和程序分离：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(gdb) detach</span></span><br></pre></td></tr></table></figure></li></ol><p>###<font color='red'>core dump</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言宏的几处陷阱</title>
    <link href="http://jyxcpp.netlify.app/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/"/>
    <id>http://jyxcpp.netlify.app/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/</id>
    <published>2023-04-28T12:04:23.000Z</published>
    <updated>2023-04-28T12:52:44.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《C与指针》</p></blockquote><ol><li><p><strong>为宏定义中的变量以及宏定义体加上括号：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) ((x)*(y))</span></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) (x*y)</span></span><br></pre></td></tr></table></figure><p>否则按错误方式书写则可能出现如下错误：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL(a+b, c+d);</span><br><span class="line"><span class="comment">//被编译为 a + b * c + d , 显然是错误的</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义多语句宏代码时，请使用 do{…}while() 语句：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) &#123;error_code=x;return false;&#125;</span></span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) do&#123;error_code=x;return false;&#125;while(0);</span></span><br></pre></td></tr></table></figure><p>是否感觉到很莫名其妙，为什么不能使用 <code>&#123;&#125;</code> ？看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)</span><br><span class="line">    ERROR_RET(x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这段代码被编译成：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)&#123;</span><br><span class="line">    error_code=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>显然，第 4 行花括号后面的 <code>;</code> 是一个语法错误。关于 <code>do&#123;&#125;while()</code> 的详细说明，参见<a href="https://jyx-fyh.github.io/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/">do{}while()有什么用？</a> 。</p></li><li><p><strong>如果你不了解所使用的宏，则尽量不要在宏调用中发生动作：</strong><br>什么是 <code>发生动作</code> ？简单解释，就是操作变量或者调用函数，看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">7</span>;</span><br><span class="line">z = MAX(x++, y++);</span><br><span class="line"><span class="comment">//较小的x自增了一次,结果较大的y却自增了两次</span></span><br></pre></td></tr></table></figure><p>这种错误就比较隐蔽。<strong><u>对于宏定义中同一个变量出现多次的情况，更要预防这种错误</u></strong> 。函数调用也可能产生问题：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_lower(ch)  (((ch) &gt; <span class="string">&#x27;a&#x27;</span> &amp;&amp; (ch) &lt; <span class="string">&#x27;z&#x27;</span>) ? 1 : 0)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">is_lower(getchar());</span><br></pre></td></tr></table></figure><p>宏展开后，getchar() 将会被调用两次，也就是说，缓冲区将消耗两个字符，这对后续的文本分析工作可能造成毁灭性影响。</p></li></ol><p>其他注意事项待补充。</p>]]></content>
    
    
    <summary type="html">C语言宏的几处陷阱</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>&lt;转载&gt;do{}while()有什么用?</title>
    <link href="http://jyxcpp.netlify.app/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
    <id>http://jyxcpp.netlify.app/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</id>
    <published>2023-04-26T14:37:58.000Z</published>
    <updated>2023-04-26T15:36:10.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一直以来我都认为 do{}while() 语句十分鸡肋，直到最近才发现它的一些妙用，下面这篇文章总结了 do{}while() 的一些使用场景，希望对各位有所帮助。<br>原文：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3535674.html">do{}while()有什么用?</a></p></blockquote><p>在一些Linux内核和其它的开源代码中，我们经常看到像下面这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;while(0)</span><br></pre></td></tr></table></figure><p>该代码片段并非循环，这样想想似乎使用do…while没有任何意义，那么为什么还要使用它呢？</p><p>实际上，do{…}while(0)的用途并不仅仅是优化你的代码。经过一系列的调研和探索，我们总结出它的一些用途如下。</p><h2 id="font-color-red-帮助定义多语句宏以避免错误-font"><font color='red'>帮助定义多语句宏以避免错误</font></h2><p>如果你是一名 C 程序员，你肯定很熟悉宏，它们非常强大，如果正确使用可以让你的工作事半功倍。然而，如果你在定义宏时很随意没有认真检查，那么它们可能使你发狂，浪费N多时间。在很多的C程序中，你可能会看到许多看起来不是那么直接的较特殊的宏定义。下面就是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __set_task_state(tsk, state_value)      \</span><br><span class="line">    do &#123; (tsk)-&gt;state = (state_value); &#125; while (0)</span><br></pre></td></tr></table></figure><blockquote><p>在Linux内核和其它一些著名的C库中有许多使用do{…}while(0)的宏定义。这种宏的用途是什么？有什么好处？Google 的 Robert Love（先前从事Linux内核开发）给我们解答如下：<br><strong><font color='orange'>do{…}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</font></strong></p></blockquote><p><strong>这句话听起来可能有些拗口，其实用一句话概括就是：<font color='orange'>使用 do{…}while(0) 构造后的宏定义不会受到大括号、分号等的影响，并总是会按你期望的方式调用运行。</font></strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure><p>然后你可能这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(wolf);</span><br></pre></td></tr></table></figure><p>这将被宏扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar(wolf); baz(wolf);</span><br></pre></td></tr></table></figure><p>这的确是我们期望的正确输出。下面看看如果我们这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br></pre></td></tr></table></figure><p>那么扩展后可能就不是你所期望的结果。上面语句将扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    bar(wolf);</span><br><span class="line">baz(wolf);</span><br></pre></td></tr></table></figure><p>显而易见，这是错误的。这里你可能感到迷惑不解了，<strong>为什么不用大括号直接把宏包围起来呢？</strong> 而非得使用 <strong>do/while(0)</strong> 逻辑呢？例如，我们用大括号来定义宏如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure><p>这对于上面举的if语句的确能被正确扩展，但是如果我们有下面的语句调用呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>宏扩展后将变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral) &#123;</span><br><span class="line">    bar(wolf);</span><br><span class="line">    baz(wolf);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>大家可以看出，这就有语法错误了。</p><p><strong><font color='orange'>几乎在所有的情况下，期望写<u>多语句宏</u>来保证正确的结果是不可能的，你不能让宏像函数一样行为——除非使用 do/while(0) 语句。</font></strong></p><h2 id="font-color-red-避免使用goto控制程序流-font"><font color='red'>避免使用goto控制程序流</font></h2><p>在一些函数中，我们在return语句之前可能需要做一些工作，比如释放在函数一开始由malloc函数申请的内存空间，使用goto总是一种简单的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">END:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于 goto 关键字可能会使代码不易读，因此许多人都不推荐使用它，那么我们可以使用 do{…}while(0) 来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用 do{…}while(0) 来包含函数的主要部分，同时使用 break 替换 goto，代码的可读性增强了。</p><blockquote><p>禁止使用 goto 已经成为程序员的教条，但它并非魔鬼，少量使用是有益而无害的——尤其在跳出多重循环时很方便。</p></blockquote><h2 id="font-color-red-避免由宏引起的警告-font"><font color='red'>避免由宏引起的警告</font></h2><p>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用do{…}while(0) 来定义空宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define EMPTYMICRO do&#123;&#125;while(0) </span><br></pre></td></tr></table></figure><p>这样在编译的时候就不会产生警告。</p>]]></content>
    
    
    <summary type="html">do{}while()有什么用?</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>select/poll/epoll用法及注意事项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/25/select-poll-epoll%E7%94%A8%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/25/select-poll-epoll%E7%94%A8%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-04-25T15:18:37.000Z</published>
    <updated>2023-04-26T12:14:35.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pan.baidu.com/s/1JUArLBgxO9nqyzvI0Db2nQ">https://pan.baidu.com/s/1JUArLBgxO9nqyzvI0Db2nQ</a></p><ul><li>select 的 except 集合能够检测到套接字上的读写异常吗？不能</li><li>如何用select模拟sleep，pselect呢？</li><li>EPOLL水平触发下EPOLLOUT注册后会一直可读；边缘触发下，如果想要立刻再次可写，则必须epoll_ctl(mod)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EPOLLHUP/EPOLLRDHUP与read返回0的区别</title>
    <link href="http://jyxcpp.netlify.app/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://jyxcpp.netlify.app/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-04-24T15:13:59.000Z</published>
    <updated>2023-04-25T06:25:12.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：<a href="https://blog.csdn.net/halfclear/article/details/78061771">epoll触发事件的分析</a> 、<a href="https://stackoverflow.com/questions/51833215/why-do-we-need-epollrdhup-when-epollhup-seems-enough">EPOLLHUP&amp;EPOLLRDHUP</a> 、<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">man_page</a></p></blockquote><p>相信很多时候，大家都是通过检测 read/recv 返回 0 来判断对端是否关闭了连接，如果返回 0，我们通常也会 close 该连接。这没有问题，但在很多场景下有个缺陷：FIN 报文和普通数据报文一样，也是需要在缓冲区中排队的，只有当 read 读取到 FIN 以后才会返回 0，而且 FIN 报文无法和数据同时被读取，也就是说，必须将数据 read 完毕后，再调用一次 read 才能读取到 FIN 并返回 0 。这也是为什么在网络读取时需要将 read 放在循环中的原因之一，不仅是为了将数据读取完整，也是为了能够读到 FIN 报文。</p><blockquote><p><strong>注意，FIN 报文虽然会排队，但当本端收到 FIN 后，内核网络栈会立刻回复 ACK，而不会管你是否 read 到这个 FIN 报文。</strong></p></blockquote><p>那么这个缺陷会引发什么问题呢？由于笔者现在也是网络编程初学者，没有太多实战经验，所以这里只提供本人猜想的两个情景：</p><ul><li>在一个高并发网络场景下，服务器收到了对端发来的 FIN 报文（对端 close），但没有立即读取（正忙于处理已接收的数据），所以现在此连接处于半关状态，因为服务器的 read 还没有返回 0。直到服务器处理完其他事情后 read 并返回 0 才会 close 此连接。问题在于，这段时间内该连接被白白占用了，浪费了服务器的端口，这对高并发处理是不利的。服务器完全可以先关闭该连接，再去处理数据。</li><li>客户端向服务器发送文件，而文件的末端是 EOF，所以当服务器 read 到文件末端的 EOF 后返回 0，进而关闭连接。问题来了，万一客户还想继续发送文件呢？也就是说，<strong><font color='orange'>此时 read 返回 0 并不代表客户端想关闭连接</font></strong> 。</li></ul><p>因此，我们应该尽量避免使用 read/recv 返回 0 来判断对端的关闭状态。那还有什么方法？答案是 epoll 的 EPOLLRDHUP 和 EPOLLHUP 事件。这两者很容易混淆，下面略作区分。</p><p>EPOLLRDHUP 最为常用，<strong>当对方关闭（close）连接或者关闭写（shutdown(SHUT_WR)）时，本事件就会被触发</strong> 。所以 EPOLLRDHUP 被用来监听对方的连接状态。与前面 read 不同，<strong><font color='orange'>只要 FIN 报文进入了缓冲区，不管是否读取，都会引发 EPOLLRDHUP 事件</font></strong> 。</p><blockquote><p>那么当 EPOLLRDHUP 发生时，我们该做什么呢？<strong>因为我不知道对方是 close 还是 shutdown(SHUT_WR)，如果是后者，我就还能够将处理好的数据发给对方，如果是前者，则发送数据后则会收到对方发来的 RST 报文，从而直接结束连接。</strong> 该做什么应该取决于应用场景，如果是 http 服务，那就不应该直接关闭连接，因为对端可能是 shutdown，且还需要接收数据（比如请求图片）；如果是上传文件到服务器，那么就可以直接关闭连接，因为服务器不需要再向对端回复数据。</p></blockquote><p>EPOLLHUP 则令人困惑，官方文档的解释是：当套接字挂起时，本事件被激发。然而什么是“挂起”却没有解释，网络讨论也说法不一。笔者给出两种已经被实验证实的情况：</p><ul><li><p><strong>收到对端发来的 RST 报文</strong></p><blockquote><p>RST 报文用来重置连接，当一方发送RST报文后，对端会立即关闭连接，并释放相关资源。所以收到 RST 后，套接字相当于残废，被“挂起”。</p></blockquote></li><li><p><strong>将一个不可能触发该事件发生的套接字加入 EPOLL</strong></p><blockquote><p>比如，使用 socket() 返回了一个套接字，既不 listen 也不 connect，这个套接字将没有任何事情发生（这也许就是“挂起”的含义），此时如果将其加入到 EPOLL 中，则会产生 EPOLLHUP 事件。</p><p><strong><font color='orange'>值得一提的是，对端 close 连接时，不会触发本端的 EPOLLHUP；但对端同时 shutdown 读和写时（即 shutdown(SHUT_RDWR) ），则会触发本端的 EPOLLHUP</font></strong> 。<strong>因为调用 shutdown(SHUT_RDWR) 只会关闭连接的读端和写端，不会释放文件描述符和其他相关资源，但此时该套接字已经处于“聋哑”状态，没有作用了，所以相当与被“挂起”；</strong><font color='orange'><strong>而当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</strong></font> ，如果应用程序需要释放文件描述符和相关资源，还需要调用 close 函数。</p></blockquote></li></ul><p><strong>注意，EPOLLHUP 不能用来监听对方的关闭状态！</strong></p><p>补充说明：</p><ul><li><strong><font color='orange'>对于 EPOLLERR 和 EPOLLHUP，不需要在 epoll_event 时针对 fd 作设置，一样也会触发</font></strong></li><li><strong>对端发来 RST 信号，触发本端的 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件</strong></li><li>如前文，对端不管是 close 套接字，还是 shutdown 写，本端触发的都是 EPOLLIN + EPOLLRDHUP 事件，<strong>因此，本端无从区分对端是 close 了套接字，还是 shutdown 了写</strong> 。但有一点可以区分，如果对端是 close 了套接字，则本端在套接字上发送数据时，本端会收到对端发来的 RST 报文从而本端会触发 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件；而如果对端只是 shutdown 了写，则本端可以正常发送数据不会触发任何信号。</li><li><strong><font color='orange'>当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</font></strong></li></ul>]]></content>
    
    
    <summary type="html">EPOLLHUP/EPOLLRDHUP与read返回0的区别</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁、条件变量与信号量的区别及其用法</title>
    <link href="http://jyxcpp.netlify.app/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jyxcpp.netlify.app/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2023-04-23T07:02:07.000Z</published>
    <updated>2023-04-30T04:26:23.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《操作系统导论》《操作系统之哲学原理》《Linux高性能服务器编程》</p></blockquote><p>由于没有具体的应用场景，笔者之前一直对锁、条件变量和信号量感觉迷迷糊糊，总觉得它们很相似但又有所区别。这两天在写线程池时需要用到任务队列，主线程生产任务，工作线程则竞争地从队列中取出任务——也就是我们常说的“生产者/消费者问题”，接触到这个具体的场景后，笔者突然就明白了它们的区别。</p><p><strong><font color='orange'>互斥锁用来保证多线程/进程之间对共享资源的互斥访问，也就是保证同一时刻只有一个执行流在临界区中。</font></strong></p><p>POSIX 的互斥锁操作主要有如下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化锁,将锁的各个字段都初始化为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> pthread_mutexattr* attr)</span>;</span><br><span class="line"><span class="comment">//销毁锁,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//非阻塞上锁,如果锁已经被持有,则返回错误EBUSY</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>除了使用 <code>pthread_mutex_init</code> 初始化锁，也可以采用 <code>PTHREAD_MUTEX_INITIALIZER</code> 如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>注意，这种方式必须在初始化锁使用，不能在声明后赋值。</p></li><li><p><code>attr</code> 是锁的属性，常用的有两种——pshared 和 type，前者指定锁是否跨进程共享，后者指定锁的类型。互斥锁的类型有普通所、检错锁、递归锁，这里笔者没有深入研究，读者可自行了解。正常情况下，attr 设置为 NULL 即可。</p></li><li><p>需要注意，同一个执行流重复持有一个锁会导致死锁，此时需要使用递归锁。两个线程按照不同的顺序来申请两个互斥锁也可能导致死锁，具体情境参见《Linux高性能服务器编程》P278 。</p></li></ul><p><strong><font color='orange'>条件变量则提供了一种线程之间的通知机制，当某个条件满足时再唤醒沉睡在这个条件上的线程。</font></strong> 就笔者遇到的场景来说，只有当任务队列中存在任务时，线程才能获取任务并继续它的工作，否则只能睡眠。相关函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* attr)</span>; <span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>; <span class="comment">// 销毁条件变量,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex)</span>; <span class="comment">//在条件变量上睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒一个线程,具体唤醒哪个则取决于优先级和调度策略</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒所有线程</span></span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>同样可以使用如下方式初始化条件变量：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>我们看到 <code>pthread_cond_wait()</code> 函数的第二个参数是互斥锁，那么为什么在条件变量上等待时还需要上锁呢？</font></strong> 假设等待条件变量时不需要加锁，考虑这样的情形：线程 A 中某个时刻，条件变量 cond 还未成立，于是调用 <code>pthread_cond_wait()</code> 准备睡眠，而在**<u>睡眠前一刻</u>** ，执行流切换到线程 B，B 使条件变量 cond 成立，然后调用 <code>pthread_cond_signal()</code> 唤醒在 cond 上睡眠的线程，但线程 A 还没有完全睡眠，所以等待队列中没有可以唤醒的线程（这也就是所谓的 <strong><u>虚假唤醒</u></strong> ）。问题来了，现在执行流切换到 A，接着 A 完全睡眠。于是，线程 A 错过了 B 发送的唤醒信号，继而引发死锁。<strong>上面的问题在于，从 <code>pthread_cond_signal()</code> 函数被执行到调用线程被放入等待队列的这段时间内条件变量发生了改变。</strong> 所以我们必须保证这段空窗期内条件变量不会被修改，这也就是 <code>pthread_cond_wait()</code> 中锁参数的作用。因此 <strong><font color='red'>调用 <code>pthread_cond_wait()</code> 前必须保证 mutex 已经上锁</font></strong> 。</p><blockquote><p>调用 <code>pthread_cond_wait()</code> 时加锁是强制要求（该函数的第二个参数），但 <code>pthread_cond_signal()</code> 则不一定需要在加锁时调用。<strong><font color='red'>但是作为一般化的规则，在 wait 和 signal 时都持有锁总是正确的</font></strong> 。</p></blockquote></li><li><p><strong><code>pthread_cond_wait()</code> 在睡眠前一刻会释放锁，以使其他线程能够进入临界区；被唤醒后执行流从该函数返回，锁又会被该线程持有，以保证互斥访问临界区。</strong></p></li><li><p><code>pthread_cond_broadcast()</code> 函数有什么应用场景？参见《操作系统导论》 P261</p></li></ul><p>下面我们来看条件变量的局限性。先引入具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    add_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在只有两个线程时能够准确无误的运行，但当线程数多于两个时，就会发生问题：消费者 A 发现没有 food，于是沉睡在条件变量 food 上，然后执行流转移到生产者，生产者 add_food 后唤醒消费者 A，于是消费者 A 进入就绪队列（只是就绪，但没有运行）。问题来了，<u>此时消费者 B 抢先执行</u> ，发现 food 不为空，于是 eat_food 。紧接着切换到消费者 A ，从 17 行返回，由于 food 已经被消费者 B 吃掉，所以执行第 18 行 eat_food() 时将引发错误（只有 food 不为空时才能 eat）。</p><p>我们很容易知道解决上面问题的办法：<strong>不让消费者 B 抢先执行。也就是说，唤醒消费者 A 后立刻调度。</strong> 实际上，这种方式被称为 <code>Hoare</code> 语义，而前面的只唤醒，不保证立刻调度的方式称为 <code>Mesa</code> 语义。然而，由于 <code>Hoare</code> 语义的实现难度较大，几乎所有的操作系统都采用 <code>Mesa</code> 语义。</p><p>那么该如何解决这个问题呢？也很简单，将第 7、16 行的 <code>if</code> 改成 <code>while</code> 即可。消费者被唤醒后，总是再次检查共享变量 food，如果不满足，则再次睡眠。因此，<strong><font color='red'>谨记使用条件变量的通用规则：总是使用 while() 判断条件是否成立</font></strong> 。</p><p>上面的方案依旧存在问题：当消费者 A 发出 signal 时，会唤醒哪个线程呢？按道理来说应该是唤醒生产者，但线程调度不保证这一点。设想，当消费者 A 发出 signal 后唤醒的是消费者 B，而 B 发现 food 仍然为空，于是陷入睡眠；而生产者根本没有被唤醒，于是一直相互等待。<strong>这个问题的原因在于信号没有指向性</strong> ，显然消费者不应该唤醒消费者，而应该唤醒生产者。<strong><font color='orange'>解决办法也很简单——使用两个条件变量：</font></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> empty;</span><br><span class="line"><span class="type">pthread_cond_t</span> filled;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">//如果还有food,就等待被消耗完再添加</span></span><br><span class="line">    add_food(&amp;food); </span><br><span class="line">    pthread_cond_signal(&amp;full);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;filled, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;empty);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们提出下一个问题：为什么还要引入信号量？<strong><u>实际上，信号量不是必须的，它是对互斥锁和条件变量的封装</u></strong> ，看看源码便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE &amp;&amp; sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">while</span> (sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;sem-&gt;cond, &amp;sem-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        sem-&gt;value--;</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        sem-&gt;value++;</span><br><span class="line">        pthread_cond_signal(&amp;sem-&gt;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> pshared;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上源码由 chatgpt 生成。</p></blockquote><p>可以很清楚地看到，信号量内部使用了互斥锁和条件变量。信号量和条件变量的区别在于：</p><ol><li><p>信号量内部使用了 value ，而条件变量是在外部使用 value （也就是上面的 food）来计数。</p><blockquote><p>之前代码中的 food 是二元变量（true\false），实际上你完全可以直接将它改为多值变量。</p></blockquote></li><li><p>由于条件变量是在外部维护的 value，所以操作 value 时必须由程序员负责先持有锁。而信号量也会持有锁，只不过对程序员屏蔽了细节。</p></li><li><p>信号量只能一次唤醒一个特定的线程/进程，而条件变量可以广播。</p></li></ol><p><strong><font color='orange'>二元信号量可以充当互斥锁，也能够充当条件变量。当信号量的 value 初始化为 1 时即为互斥锁。</font></strong></p><p>信号量的 POSIX 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面函数成功时返回 0，失败时返回 -1，并设置 errno。</p></blockquote><ul><li>pshared 表示信号量的类型，可以是 PTHREAD_PROCESS_PRIVATE 或 PTHREAD_PROCESS_SHARED，分别表示进程内私有和进程间共享。value 表示信号量的初始值。</li><li><code>sem_wait()</code> 将信号量的值减 1 。如果信号量的值为 0，则 sem_wait 陷入阻塞，直到信号量大于 0 。参见上面的源码。<br><code>sem_post()</code> 将信号量的值加 1，并唤醒一个线程。</li></ul><p>为了更好地理解信号量，下面使用信号量改写之前的生产者/消费者代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> food; <span class="comment">//food为一个队列,没有食物时队列为空</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> sem; <span class="comment">//信号量的值即为队列中的食物量</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pushback(); <span class="comment">//向队列中添加food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    sem_post(&amp;sem);  <span class="comment">//信号量+1,即食物量+1,并唤醒一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem); <span class="comment">//将信号量-1,如果为0就等待</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pop(); <span class="comment">//从队列中取出food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为当条件可累积时，信号量比条件变量更方便。从上面的代码也能够看出，<strong><u><font color='orange'>即使使用了信号量，在操作共享资源时仍然必须锁来保证互斥访问</font></u></strong> 。</p><blockquote><p><strong><font color='red'>注意，为了避免死锁，请将互斥锁的获取和释放紧贴着临界区，务必不要将 sem_wait 和 sem_post 放入锁范围内</font></strong> ！详细参见《操作系统导论》P271</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络字节序及其注意事项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-04-16T01:37:48.000Z</published>
    <updated>2023-04-16T11:23:45.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网页上有许多关于字节序的讨论，这里就不多说了，只强调笔者认为最重要的两点：</p><ul><li><strong><font color='orange'>字节序与 CPU 相关，或者说与计算机体系架构相关，而与操作系统无关。</font></strong></li><li><strong><font color='orange'>字节序只针对多字节数据（如 int ）才有意义，单字节数据（如 char）不用考虑字节序的问题。</font></strong></li></ul><p>笔者是这样理解上面两点的：<br><strong><font color='red'>字节序就是指 CPU 中的寄存器对数据的解释方式</font></strong> 。32 位 CPU ，其寄存器大小为 4 字节，如果被设计为小端序，那么低地址的字节会被解释为低位数据，高地址的字节会被解释为高位数据：<br><img src="/2022/img/endian-1681633780948-2.png" alt=""></p><p>从上图也能看出，当单字节数据不会被解释方式（大小端）影响，比如 0x11 仍然被解释为 0x11：<br><img src="/2022/img/endian1.png" alt=""><br>那么，如何知道自己主机的大小端呢？很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span>* p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输出 0x44，那么就是小端。有种常见的错误做法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> j;</span><br><span class="line">    i = <span class="number">0x1234</span>;</span><br><span class="line">    j = (<span class="type">char</span>)i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序不论大小端，都会输出 0x34，<strong><font color='orange'>因为数据截断时，总会保留最低有效字节，而不是保留地址处于最低位的字节</font></strong> 。最低有效字节中的“最低”是指的数据的低位，而不是内存地址的低位，比如 4 字节整型 0x11223344 截断为 1 字节的 char 时，就只会保留最低有效字节 0x44。<strong>截断的行为不会被大小端影响</strong> 。</p><hr><p>下面来讨论网络字节序。</p><p>为了保证在不同字节序机器之间传输网络数据时数据能够被正确解释，<strong><font color='orange'>规定网络数据传输的格式一律为大端序</font></strong> 。使用以下函数转换字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line">    net to host,将网络字节序转为主机字节序</span><br><span class="line">    </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line">    host to net,将主机字节序转为网络字节序</span><br></pre></td></tr></table></figure><p>SOCKET 网络编程初学者可能会疑惑，除了为端口和 IP 地址赋值时会用到上面的函数，其他时候我们发送网络数据都没有用到这些函数呀！<strong><font color='orange'>这是因为大多数情况下我们都是发送的字符串数据，而字符都是 char，即单字节数据，因此根本不会被字节序影响</font></strong> 。那么我们来传输一个 int 整型试试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机是小端序，使用 wireshark 抓取网络报文，可见数据仍是以小端序传输的。如果对端机器是大端序，那么字节序列 <code>78 56 34 12</code> 则会被解释为 <code>0x78563412</code> ，从而造成数据错乱。<br><img src="/2022/img/image-20230416181222470.png" alt=""></p><p>所以我们必须先将整型转为大端序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line">    <span class="type">int</span> a = htonl(<span class="number">0x12345678</span>);</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230416181831813.png" alt=""></p><hr><p>从上面我们能得到：跨网络传输字符串或其他单字节数据时，不会受大小端影响；而传输多字节的二进制数据时，如果不提前转为大端序，那么就会发生错误。即使手动将二进制数据（如结构体）转为大端序，也存在以下几个问题：</p><ul><li>两端机器对 C 数据类型的实现不同，比如本端机器的 int 为 4 字节，而对端的机器可能为 2 字节。</li><li>不同实现的结构体对齐方式存在差异。</li></ul><p>可以使用以下两种方法解决以上问题：</p><ul><li>将所有数值类型作为字符串来传递，显然效率很低。</li><li>自己定义一个二进制数据结构（协议）。</li></ul><p>最后补充一点，大小端问题不仅出现在主机之间，在同一主机的不同进程之间也可能出现，比如在Java虚拟机中采用的是网络字节序（即大端字节序），因此在与其他进程进行数据交换时，需要进行字节序转换。</p>]]></content>
    
    
    <summary type="html">网络字节序及其注意事项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三握四挥异常分析</title>
    <link href="http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
    <id>http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/</id>
    <published>2023-04-15T11:16:23.000Z</published>
    <updated>2023-04-16T13:51:14.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">全连接与半连接队列</a> 、<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;optval, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    Listen(sock_listen, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    bzero(&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr *) &amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包裹函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(fd, backlog))</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == accept(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-第一次握手异常-font"><font color='red'>第一次握手异常</font></h2><p>第一次握手异常一般有三种情况：<br><strong>1） 目标主机不可达，响应一个 “destination unreachable” 的 ICMP 报文。</strong></p><blockquote><p>这个情况很好模拟，在客户端 connect 一个任意 IP 的地址结构即可。</p></blockquote><p><strong>2）目标主机的指定端口上没有套接字处于监听状态，connect 返回 “Connection refused” 。</strong></p><p><strong>3）接收方丢弃 SYN 报文。</strong></p><p>下面重点说说第三种情况。</p><p><strong><mark class="hl-label blue">什么情况下会丢弃SYN报文？</mark> </strong></p><p>有两种情况是可以确定的：</p><ol><li><strong>半连接队列已满，且没有开启 SYN-Cookie</strong></li><li><strong>全连接队列已满</strong></li></ol><p><strong><font color='orange'>情况一验证：</font></strong></p><blockquote><p><strong>在笔者环境下（Ubuntu 16.04），半连接队列的长度等于全连接长度，即为 <code>min(somaxconn,backlog)</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>); <span class="comment">//backlog为5,则全连接队列容量为6,半连接队列为5</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将 SYN-Cookie 设置为 0（默认为 1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//须在管理员身份下运行</span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/tcp_syncookies </span><br></pre></td></tr></table></figure><blockquote><p>0 值，表示关闭该功能；<br>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；<br>2 值，表示无条件开启功能；</p></blockquote></li><li><p>运行 server 端。</p></li><li><p>运行 hping3，发起 SYN 洪水攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机,即伪造</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><p>发送了 1000 个<u>虚假</u> SYN 报文，而半连接队列中只有 5 个连接（满），说明其他 SYN 确实是被服务端丢弃了。那么如果开启了 SYN-Cookie 会怎么样呢？继续实验：</p><ol><li><p>将 SYN-Cookie 设置为 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>运行 server 端和 hping3</p></li><li><p>查看 SYN_RECV 状态的个数，仍然为 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>查看 ESTABLISHED 状态的个数，为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | wc -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>运行客户端，并查看 ESTABLISHED 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p>这里显示为 12，实际上为 6，这是因为服务器端和客户端都在一个主机上，netstat 命令分别以服务器和客户端的角度进行了输出，所以算重复了一次。<br>已连接状态数为 6 的原因请参见前置文章，这里不再赘述。</p></blockquote></li></ol><p><strong><font color='gree'>所以，若半连接队列已满，且没有开启 SYN-Cookie ，则丢弃 SYN 报文。开启 SYN Cookies 后，就可以在不经过半连接队列的情况下成功建立连接：</font></strong><br><img src="/2022/img/39-1679303729834-1-1679373170821-1.jpg" alt=""></p><p><strong><font color='orange'>情况二验证</font></strong></p><ol><li><p>先后运行服务器端和客户端</p></li><li><p>分别查看 ESTABLISH 和 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>可见，当全连接队列满了后，半连接队列也不再接受 SYN</strong> 。</p></li></ol><p>追问：如果全连接队列仅还有一个空位，那么半连接队列也只会接收一个 SYN 吗？继续实验：</p><ol><li><p>修改 client 的第 23 行代码，将 10 改为 5，即发起 5 次连接（全队列容量为 6，这样就能余下一个空位）</p></li><li><p>先后运行 server 和 client</p></li><li><p>查看 ESTABLISHED 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>即，有 5 个连接已经完成建立，全队列余下一个空位。</p></li><li><p>运行 hping3，并查看 SYN_RECV 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>发现半连接队列也已经满员。</p></li></ol><p>综合以上两种情况，得到下面的流程图：<br><img src="/2022/img/aha.png" alt=""></p><p><strong><mark class="hl-label blue">SYN报文丢失了会怎样？</mark> </strong><br>很简单，重传即可。值得一提的是，<strong><font color='orange'>SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制</font></strong> 。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，即，<strong>每次超时的时间是上一次的 2 倍</strong> 。在笔者环境下，重传次数为 6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>为了更清晰地看到这个过程，我们先关闭 SYN-Cookie，然后发起泛洪，使半连接队列满员，进而只能丢弃新到的 SYN 报文；接着开启一个客户端，此时使用 wireshark 进行抓包，结果如下：<br><img src="/2022/img/image-20230407213529813.png" alt="image-20230407213529813"><br>一共发送 7 次 SYN 报文，其中重传 6 次。看左边的数字小数点的前两位：50 -&gt; 51 -&gt; 53 -&gt; 57 -&gt; 65 -&gt; 81 ，间隔时间分别为 1、2、4、8、16，和我们前面的结论相同。只是最后差了 34s，接近 32s，可能是误差吧，不太清楚这里是怎么回事。</p><hr><h2 id="font-color-red-第二次握手异常-font"><font color='red'>第二次握手异常</font></h2><p>有了第一次异常的分析，第二次握手异常就很容易分析出来了。首先能够确定的是，第一次握手的 SYN 报文仍然会重传，因为 client 压根没有收到 server 的 SYN+ACK 报文。那么 server 会怎么样呢？也容易猜到，由于迟迟没有收到第三次握手的 ACK 报文，server 也一定会重传，<strong><font color='orange'>且重传次数由 <code>tcp_synack_retries</code> 决定</font></strong>（ 在笔者环境下，该值为 5）。实验如下：<br>1）使用 <code>iptables</code> 屏蔽第二次握手：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT -p tcp  --tcp-flags SYN,ACK SYN,ACK -j DROP</span><br></pre></td></tr></table></figure><p>2）运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230415194126268.png" alt=""></p><p>可见，第一次和第二次握手都在重传。</p><h2 id="font-color-red-第三次握手异常-font"><font color='red'>第三次握手异常</font></h2><p>第三次握手就有意思了。看下面的三次握手的过程图：<br><img src="/2022/img/image-20230408101018084.png" alt=""></p><p>可见当第三次握手的 ACK 发出后，客户端已经处于建立连接的状态，而服务器此时还没收到客户端的 ACK 报文，仍处于 SYN_RECV 状态。那么问题来了，如果 client 给 server 发送数据报文，会出现什么情况呢？</p><p>为了模拟server 无法接收 ACK 报文的情况，我们使用 iptables 在防火墙阻截这个 ACK 报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --tcp-flag ACK,SYN  ACK -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>只需知道上述命令的作用为：屏蔽含有 ACK 标记 <strong>且</strong> 不包含 SYN 标记的报文，显然三次握手中只有第三次符合要求，因此会被屏蔽。关于 iptables，请移步本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">iptables</a><br>另外，实验完成后记得把屏蔽去掉，将 -I 改为 -D 重新执行上述命令即可。</p></blockquote><p>结果如下：<br><img src="/2022/img/image-20230408151310936.png" alt=""></p><p>可见，如果第三次握手的 ACK 报文丢失，则会引起第二次握手 ACK+SYN 重传，且重传 5 次，如 <code>tcp_synack_retries</code> 示，然后 clinet 重发 ACK，仍然丢失。再来看看 server 和 client 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep 12345</span><br><span class="line">tcp        0      0 192.168.248.128:59999   192.168.248.128:12345   ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.248.128:12345   192.168.248.128:59999   SYN_RECV   </span><br></pre></td></tr></table></figure><p>表明 client 已处于已连接状态，server 还未连接。而且重传 5 次完毕后不久，SYN_RECV 状态消失，说明 server 已经主动断开连接。如果此时 client 发送数据，这些报文当然也无法得到回复。<strong><font color='orange'>建立连接后（是指在 ESTABLISHED 状态下）发送的报文丢失，则会重传，次数由 <code>tcp_retries2</code> 决定（本机为 15 次，等待大概 15min）</font></strong> ，没有回应则直接关闭连接。</p><blockquote><p><code>tcp_retries1</code> 变量是控制在系统向下级发出信号以尝试验证网络是否可用之前的重试次数，可忽略。</p></blockquote><p>那么如果 client 不发送数据呢？它岂不是会一直保持 ESTABLISHED 状态。并不会，TCP 有保活机制，当一条连接上连续 <strong>两小时</strong> 没有任何动静时，本端就会发送探测报文，若连续几次探测报文都没有得到回应，则直接断开连接。保活时间，探测报文的次数、时间间隔分别由以下三个参数决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75 </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>即，最少需要经过 2 小时 11 分 15 秒才能断开一个死亡连接</font></strong> 。</p><blockquote><p>关于心跳包和保活机制，可参见<a href="https://jyx-fyh.github.io/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/">保活机制与心跳包设计</a> 。</p></blockquote><hr><h2 id="font-color-red-第一次挥手异常-font"><font color='red'>第一次挥手异常</font></h2><p><strong><font color='gree'>FIN 报文丢失的原因之一是因为对方接收缓冲区满导致 FIN 无法被接收。</font></strong></p><p>重传 FIN 报文，次数由 <code>tcp_orphan_retries</code> 控制，超过指定次数则直接关闭。这里有个细节： <code>tcp_orphan_retries</code> 默认为 0，但实际上重传次数为 8，源码向我们解释了原因：<br><img src="/2022/img/28-1680942414542-4.jpg" alt=""></p><p><strong><font color='orange'>为了避免 <code>FIN_WAIT1</code> 状态的连接过多，我们可以调小 <code>tcp_orphan_retries</code> 的值，也可以通过 <code>tcp_max_orphans</code> 限制其数量，</font></strong>  <strong><font color='orange'>如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，<u>而是直接发送 RST 复位报文强制关闭</u>。</font></strong></p><hr><h2 id="font-color-red-第二次挥手异常-font"><font color='red'>第二次挥手异常</font></h2><p>即 ACK 报文丢失，这种情况下会重复第一次挥手。<strong><font color='orange'>注意，pure ACK 报文都不会主动重传！只能被第一次挥手驱动而重传</font></strong></p><h2 id="font-color-red-第三次挥手异常-font"><font color='red'>第三次挥手异常</font></h2><p>则重传 FIN 报文，次数仍由 <code>tcp_orphan_retries</code> 控制，超出指定次数则直接关闭连接。注意，此时 client（主动关闭方） 已经处于 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果 client 是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果 client 是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></p><blockquote><p>关于 close 和 shutdown，参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a></p></blockquote><h2 id="font-color-red-第四次挥手异常-font"><font color='red'>第四次挥手异常</font></h2><p>则重传第三次挥手的 FIN 报文，超过指定次数则直接关闭。第三次挥手成功后，主动关闭方进入了 TIME_WAIT 状态，这在期间如果收到重传的第三次挥手报文则回复 ACK：<br><img src="/2022/img/image-20230416215104213.png" alt=""></p><hr><h2 id="font-color-red-区分连接断开的几种常见情况-font"><font color='red'>区分连接断开的几种常见情况</font></h2><p><strong><mark class="hl-label blue">进程崩溃</mark> </strong><br>进程崩溃可以指是使用 kill 命令杀死进程，此时进程会进行关闭套接字等一系列动作，并向对方发出 FIN 报文，和正常四次挥手无差别。</p><p><strong><mark class="hl-label blue">服务器主机崩溃</mark> </strong><br>服务器主机崩溃可以是断电，这种情况下进程来不及关闭套接字，因此服务器主机直接从网络中消失，那么客户向服务器重传数次后将返回 “destination unreachable” 错误。</p><p><strong><mark class="hl-label blue">服务器主机关机</mark> </strong><br>Unix 系统关机时，init 进程会先给所有进程发送 SIGTERM 信号，等待一小段时间（以给进程清除和终止的时间）后发送 SIGKILL 信号强制终止所有进程。进程终止时会关闭所有描述符，于是进行正常挥手。</p><p><strong><mark class="hl-label blue">服务器主机崩溃后重启</mark> </strong><br>服务器崩溃后重启，之前的 TCP 连接状态信息已经丢失，因此服务器对之前连接上发来的消息都将回复 RST。</p><blockquote><p>参考：《UNP》、<a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">小林网络</a> 、<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptable用法详解</a></p></blockquote>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络学习利器—hping3</title>
    <link href="http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/"/>
    <id>http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/</id>
    <published>2023-04-09T07:44:31.000Z</published>
    <updated>2023-04-10T12:15:47.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络学习利器—hping3</p><blockquote><p>参考：<a href="https://techyrick.com/hping3-full-tutorial-for-dummies-to-pro/">hping3-tutorial</a> 、<a href="https://www.anquanke.com/post/id/239641#h2-10">端口扫描浅析</a>、<a href="https://linux.die.net/man/8/hping3">hping3-man</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">  -c  --count     packet count</span><br><span class="line">  -i  --interval  wait (uX for X microseconds, for example -i u1000)</span><br><span class="line">      --fast      alias for -i u10000 (10 packets for second)</span><br><span class="line">      --faster    alias for -i u1000 (100 packets for second)</span><br><span class="line">      --flood   sent packets as fast as possible. Don&#x27;t show replies.</span><br><span class="line">  -n  --numeric   numeric output</span><br><span class="line">  -q  --quiet     quiet</span><br><span class="line">  -I  --interface interface name (otherwise default routing interface)</span><br><span class="line">  -V  --verbose   verbose mode</span><br><span class="line">  -D  --debug     debugging info</span><br><span class="line">  -z  --bind      bind ctrl+z to ttl           (default to dst port)</span><br><span class="line">  -Z  --unbind    unbind ctrl+z</span><br><span class="line">      --beep      beep for every matching packet received</span><br><span class="line">Mode</span><br><span class="line">  default mode     TCP</span><br><span class="line">  -0  --rawip      RAW IP mode</span><br><span class="line">  -1  --icmp       ICMP mode</span><br><span class="line">  -2  --udp        UDP mode</span><br><span class="line">  -8  --scan       SCAN mode.</span><br><span class="line">                   Example: hping --scan 1-30,70-90 -S www.target.host</span><br><span class="line">  -9  --listen     listen mode</span><br><span class="line">IP</span><br><span class="line">  -a  --f      spoof source address</span><br><span class="line">  --rand-dest      random destionation address mode. see the man.</span><br><span class="line">  --rand-source    random source address mode. see the man.</span><br><span class="line">  -t  --ttl        ttl (default 64)</span><br><span class="line">  -N  --id         id (default random)</span><br><span class="line">  -W  --winid      use win* id byte ordering</span><br><span class="line">  -r  --rel        relativize id field          (to estimate host traffic)</span><br><span class="line">  -f  --frag       split packets in more frag.  (may pass weak acl)</span><br><span class="line">  -x  --morefrag   set more fragments flag</span><br><span class="line">  -y  --dontfrag   set don&#x27;t fragment flag</span><br><span class="line">  -g  --fragoff    set the fragment offset</span><br><span class="line">  -m  --mtu        set virtual mtu, implies --frag if packet size &gt; mtu</span><br><span class="line">  -o  --tos        type of service (default 0x00), try --tos help</span><br><span class="line">  -G  --rroute     includes RECORD_ROUTE option and display the route buffer</span><br><span class="line">  --lsrr           loose source routing and record route</span><br><span class="line">  --ssrr           strict source routing and record route</span><br><span class="line">  -H  --ipproto    set the IP protocol field, only in RAW IP mode</span><br><span class="line">ICMP</span><br><span class="line">  -C  --icmptype   icmp type (default echo request)</span><br><span class="line">  -K  --icmpcode   icmp code (default 0)</span><br><span class="line">      --force-icmp send all icmp types (default send only supported types)</span><br><span class="line">      --icmp-gw    set gateway address for ICMP redirect (default 0.0.0.0)</span><br><span class="line">      --icmp-ts    Alias for --icmp --icmptype 13 (ICMP timestamp)</span><br><span class="line">      --icmp-addr  Alias for --icmp --icmptype 17 (ICMP address subnet mask)</span><br><span class="line">      --icmp-help  display help for others icmp options</span><br><span class="line">UDP/TCP</span><br><span class="line">  -s  --baseport   base source port             (default random)</span><br><span class="line">  -p  --destport   [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec</span><br><span class="line">  -k  --keep       keep still source port</span><br><span class="line">  -w  --win        winsize (default 64)</span><br><span class="line">  -O  --tcpoff     set fake tcp data offset     (instead of tcphdrlen / 4)</span><br><span class="line">  -Q  --seqnum     shows only tcp sequence number</span><br><span class="line">  -b  --badcksum   (try to) send packets with a bad IP checksum</span><br><span class="line">                   many systems will fix the IP checksum sending the packet</span><br><span class="line">                   so you&#x27;ll get bad UDP/TCP checksum instead.</span><br><span class="line">  -M  --setseq     set TCP sequence number</span><br><span class="line">  -L  --setack     set TCP ack</span><br><span class="line">  -F  --fin        set FIN flag</span><br><span class="line">  -S  --syn        set SYN flag</span><br><span class="line">  -R  --rst        set RST flag</span><br><span class="line">  -P  --push       set PUSH flag</span><br><span class="line">  -A  --ack        set ACK flag</span><br><span class="line">  -U  --urg        set URG flag</span><br><span class="line">  -X  --xmas       set X unused flag (0x40)</span><br><span class="line">  -Y  --ymas       set Y unused flag (0x80)</span><br><span class="line">  --tcpexitcode    use last tcp-&gt;th_flags as exit code</span><br><span class="line">  --tcp-mss        enable the TCP MSS option with the given value</span><br><span class="line">  --tcp-timestamp  enable the TCP timestamp option to guess the HZ/uptime</span><br><span class="line">Common</span><br><span class="line">  -d  --data       data size                    (default is 0)</span><br><span class="line">  -E  --file       data from file</span><br><span class="line">  -e  --sign       add &#x27;signature&#x27;</span><br><span class="line">  -j  --dump       dump packets in hex</span><br><span class="line">  -J  --print      dump printable characters</span><br><span class="line">  -B  --safe       enable &#x27;safe&#x27; protocol</span><br><span class="line">  -u  --end        tell you when --file reached EOF and prevent rewind</span><br><span class="line">  -T  --traceroute traceroute mode              (implies --bind and --ttl 1)</span><br><span class="line">  --tr-stop        Exit when receive the first not ICMP in traceroute mode</span><br><span class="line">  --tr-keep-ttl    Keep the source TTL fixed, useful to monitor just one hop</span><br><span class="line">  --tr-no-rtt    Don&#x27;t calculate/show RTT information in traceroute mode</span><br><span class="line">ARS packet description (new, unstable)</span><br><span class="line">  --apd-send       Send the packet described with APD (see docs/APD.txt)</span><br></pre></td></tr></table></figure><hr><p>先运行服务器端，在 12345 端口上监听。</p><p><strong>1）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 SYN 报文</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S 192.168.248.128 -p 12345 -c 5</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410122835239.png" alt=""></p><p><strong>2）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 ACK 报文，且窗口大小为 100</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -A  192.168.248.128 -p 12345 -c 5 -w 100</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410123028629.png" alt="image-20230410123028629"></p><blockquote><p><strong><font color='red'>注意：</font></strong><br>我们向开放的 12345 端口发送 SYN 报文，得到的回复是 SYN+ACK 报文，即第二次握手；而发送 ACK 报文，则得到的回复是 RST 。这两种情况能够反应出端口的开放和过滤状态：<br><strong>发送 SYN 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>数次重发未响应</td><td>filtered</td></tr><tr><td>收到ICMP不可达错误</td><td>filtered</td></tr><tr><td>SYN/ACK</td><td>open</td></tr><tr><td>RST</td><td>closed</td></tr></tbody></table><p><strong>发送 ACK 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>收到RST报文</td><td>unfiltered(open/closed)</td></tr><tr><td>未响应</td><td>filtered</td></tr><tr><td>ICMP不可达</td><td>filtered</td></tr></tbody></table><p><strong>也就是说，我们可以通过向指定端口发送 SYN 或 ACK 报文来检测该端口的状态，这称为<font color='red'><u>端口扫描</u></font></strong> 。</p><p>另外，关于报文过滤，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">包过滤工具iptables</a></p></blockquote><p><strong>3）端口扫描模式</strong><br>扫描 <a href="http://baidu.com">baidu.com</a> 的 75~85 和 12345 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 --scan  75-85,12345 -S baidu.com</span></span><br><span class="line">Scanning baidu.com (39.156.66.10), port 75-85,12345</span><br><span class="line">12 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">   80 http       : .S..A... 128 27907 64240    46</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports: (75 ) (76 ) (77 rje) (78 ) (79 finger) (81 ) (82 ) (83 ) (84 ) (85 ) (12345 ) </span><br></pre></td></tr></table></figure><p><strong>4）flood 泛洪攻击</strong><br>向 <code>127.0.0.1:12345</code> 发起泛洪攻击，源 IP 随机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 -S -p 12345 --flood --rand-source </span><br></pre></td></tr></table></figure><p><strong>5）指定源端口为 12345，源 IP 为 1.1.1.1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S baidu.com -a 1.1.1.1 -s 12345</span><br><span class="line">或</span><br><span class="line">hping3 -S baidu.com --spoof 1.1.1.1 --baseport 12345</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下源 IP 为主机地址，源端口随机</p></blockquote><p><strong>6）传输文件</strong><br>Hping3 支持通过 TCP/UDP/ICMP 等包来进行文件传输。相当于借助 TCP/UDP/ICMP 包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为 <code>--listen</code> 后面输入的字符串）的内容进行相应的解析。在接收端开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 127.0.0.1  --listen signature --safe  --icmp</span> </span><br></pre></td></tr></table></figure><p>监听 ICMP 包中的签名，根据签名解析出文件内容。在发送端使用签名打包的 ICMP 包发送文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 --icmp -d 100 --sign signature --file ./data</span><br></pre></td></tr></table></figure><p>注意两点：1）必须指定数据长度 <code>-d</code> ；2）签名字符串必须和接收端相同，这里是字符串 <code>signature</code> 。<br><img src="/2022/img/image-20230410195315834.png" alt="接收端收到文件,并输出文件内容"></p><p>不过没人会使用这种方式来传送文件，因为它是明文发送的：<br><img src="/2022/img/image-20230410201345056.png" alt=""><br><code>--safe</code> 保证的是丢失重传，而不是安全性。</p>]]></content>
    
    
    <summary type="html">网络学习利器—hping3 入门教程</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>“包过滤工具—iptables”</title>
    <link href="http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/"/>
    <id>http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/</id>
    <published>2023-04-08T03:21:14.000Z</published>
    <updated>2023-04-15T11:31:11.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>防火墙是保护服务器和基础设施安全的重要工具。在 Linux 生态系统中，<code>iptables</code> 是使用很广泛的防火墙工具之一，它能够用来完成封包过滤、封包重定向和网络地址转换(NAT)等功能。 <strong><code>iptables</code> 基于内核的包过滤框架 <code>netfilter</code></strong> 。如果管理员或用户不了解这些系统的架构，那可能就无法创建出可靠的防火墙策略。</p><p><strong><u>这里我们只简单地使用 iptables 的包过滤功能（后面讨论的命令也仅限于此）</u></strong> ，因为它能够很方便地模拟各种网络状况（<a href="https://jyx-fyh.github.io/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/">TCP 三握四挥的异常处理</a>、报文丢失等），非常有助于我们对网络理论知识的学习。其他功能的详细介绍可以参见<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptables用法规则小结</a> 。</p><hr><p>命令格式：<br><img src="/2022/img/FUCKAHA.png" alt=""></p><blockquote><p><code>ACCEPT</code> 允许数据包通过<br><code>DROP</code>  直接丢弃数据包，不给任何回应信息<br><code>REJECT</code> 拒绝数据包通过，必要时会给数据发送端一个响应的信息</p></blockquote><blockquote><p><strong><font color='red'>注意：</font></strong> 即使我们在输入链 INPUT 上 DROP 了指定报文，tcpdump/wireshark 仍然可以抓到该报文，因为报文的进入顺序是：<code>Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables</code> ；而出站顺序为：<code>iptables -&gt; tcpdump -&gt; NIC -&gt; Wire</code> ，此时 tcpdump/wireshark 才无法抓到指定报文。</p><p>注意，在 INPUT 中丢弃报文后，虽然可以被 tcpdump 捕获，但指定的端口或程序仍然无法收到该报文。</p></blockquote><p>示例：</p><p>1）在 lo 接口上丢弃目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j DROP</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定端口必须放在指定协议之后</strong> 。<br>另外，如果是做实验，那么添加之后记得删除，将 -I 改为 -D 再执行一次即可。</p></blockquote><p>2）拒绝目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝报文后，一般会给发送端发送 IMCP 报文以报告错误：<img src="/2022/img/image-20230409110416756.png" alt=""></p><p>3）拒绝源 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> ，且报文含有 SYN 标志的报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN SYN -j DROP</span><br></pre></td></tr></table></figure><p>这样我们就屏蔽了源 IP 为 <code>192.168.248.128</code> 发向 <code>12345</code> 端口的第一次握手。</p><blockquote><p>这条命令使用了 tcp 扩展模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tcp-flags mask comp</span><br></pre></td></tr></table></figure><p>第一个参数 mask 是我们应该检查的标志，写成由逗号分隔的列表。<br>第二个参数 comp 是必须匹配的标志的列表，列表以逗号分隔。<br>没有被匹配上的标志则要求不能被设置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><p>这条命令只会匹配到设置了 ACK 而没有设置 SYN 的报文。<br>Flags ： SYN ，ACK ，FIN ，RST ，URG ，PSH ，ALL ，NONE</p><p>另外，有时会使用 <code>-m</code> 显式指定模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 -m tcp --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br></pre></td></tr></table></figure></blockquote><p>4）列出 filter 表的所有规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN,ACK/ACK</span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN/SYN</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='orange'>注意，如果不使用 <code>-t</code> 指定表，则默认都为 filter</font></strong></p></blockquote><p>5）删除指定规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables  -D INPUT 1  删除第一条规则</span><br></pre></td></tr></table></figure><p>6）<code>!</code> 取反：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT ! -s 192.168.248.128 -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>丢弃除了源 IP 为 <code>192.168.248.128</code> 的其他所有 TCP 报文。</p><p>7）操作网段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>8）端口范围：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 1000:2000 -j DROP</span><br></pre></td></tr></table></figure><p>9）拒绝 DDOS 攻击：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p>-m limit: 启用limit扩展，限制速度。<br>–limit 25/minute: 允许最多每分钟25个连接<br>–limit-burst 100: 当达到100个连接后，才启用上述25/minute限制</p><p>这种方式似乎不能有效解决 DDOS 攻击。</p></blockquote><p>10）包含指定字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 12345 -m string --algo bm --string &#x27;admin&#x27; -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝目标端口为 12345 且数据中包含 “admin” 字符串的报文。</p>]]></content>
    
    
    <summary type="html">包过滤工具—iptables</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>常用socket选项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/</id>
    <published>2023-04-02T12:38:14.000Z</published>
    <updated>2023-04-27T00:07:20.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-获取和设置socket选项-font"><font color='red'>获取和设置socket选项</font></h2><p>使用 <code>getsockopt()</code> 和 <code>setsockopt</code> 来获取和设置 socket 的各种选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(bufsize);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span> <span class="params">(<span class="type">int</span> socket,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">void</span> *option_val,</span></span><br><span class="line"><span class="params">                <span class="type">socklen_t</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</span><br></pre></td></tr></table></figure><ul><li><strong>以上两个函数，成功时均返回 0，出错则返回 -1</strong> 。</li><li>关于第二个和第三个参数，参见《UPN》第 151 页。</li></ul><p>注意，细心的朋友可能已经注意到：上面的例子中，作用的套接字是 sock_listen，即监听套接字。那么，能不能作用于已连接套接字呢？好问题！是这样的，<strong><font color='orange'>以下几个选项是由已连接套接字从监听套接字继承而来：</font></strong> <strong><font color='red'>SO_KEEPALIVE、SO_LINGER、SO_RECVBUF、SO_SNDBUF、SO_RCVLOWAT、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY</font></strong> 、SO_DEBUF、SO_DONTROUTE、SO_OBBINLINE （红色标记为重点选项）。所以，在这几个选项上设置监听套接字，将影响后面的所有已连接套接字。<u>作为对比，getpeername() 函数就必须要作用于已连接套接字</u>。</p><h2 id="font-color-red-SO-RCVBUF-和-SO-SNDBUF-font"><font color='red'>SO_RCVBUF 和 SO_SNDBUF</font></h2><p>这是两个重要的选项。要弄清楚这两个选项，就必须先搞明白 Socket 的缓冲区机制。下面总结了 Socket 缓冲区的关键特性：<br><img src="/2022/img/IMG_0579(20230406-190556).PNG" alt=""></p><ul><li><strong><font color='gree'>每个套接字都有独立的输入/输出缓冲区。</font></strong></li><li><strong><font color='gree'>创建套接字时，自动生成缓冲区。</font></strong></li><li><strong><font color='gree'>如果要写（write）的数据大于发送（输出）缓冲区的最大长度，那么将分批写入。</font></strong></li><li><strong><font color='gree'>如果发送缓冲区全满（分批写入也不能进行），则进程被阻塞（假设套接字是阻塞模式）。</font></strong></li><li><strong><font color='gree'>发送缓冲区的数据将一直保存（以便重发），直到接收到相应 ACK。</font></strong></li><li><strong><font color='gree'>接收（输入）缓冲区的数据将一直保存，直到应用层读取（read）。</font></strong></li><li><strong><font color='gree'>接收缓冲区若满，则直接抛弃新数据（不发送其他任何信息，等待对面重传）。</font></strong></li><li><strong><font color='gree'>TCP 接收窗口大小 &lt;= 接收缓冲区大小。</font></strong></li></ul><blockquote><p>以上几个特性的实验，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">网络数据读取的常见问题</a> ，建议浏览，加深理解。</p></blockquote><p><strong><font color='red'>SO_RCVBUF 直接限制本端 TCP 接收窗口的大小</font></strong> 。下面进行实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF,(<span class="type">void</span>*)&amp;recv_size,&amp;optlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server recv buffer size: %d\n&quot;</span>,recv_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不read,不close</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行运行 server 和 client 后，server 的接收缓冲区的大小为 6000：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server recv buffer size: <span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将 recv_size 设置的为 3000，而实际反馈为 6000，<strong>说明 recv_size 只是一个建议值，操作系统会根据一定条件进行修改（×2）</strong> 。在笔者操作系统上，接收缓冲区最小为 2304 。</p></blockquote><p>然后我们使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230403111812767.png" alt=""></p><p>看第二项，server 发送的 SYN 报文中，<strong>win 为 3000，和我们设置的 SO_RECVBUF 大小相同</strong> ，但这并不意味着窗口大小就一定等于 SO_RECVBUF。<strong><u><font color='gree'>接收窗口会随着网络状况而不断调整，但肯定不会超过缓冲区的大小</font></u></strong> 。</p><blockquote><p>在本机上实验多次发现，<strong>接收窗口始终不会超过接收缓冲区的一半大小</strong> 。</p></blockquote><p>还有以下几点需要注意：</p><ol><li>上面说过，这两个选项是由监听套接字继承而来，<strong><u><font color='orange'>所以对于 server，必须在 listen 前设置选项；对于 client，必须在 connect 前设置选项</font></u></strong> 。对已连接套接字（在 accept 返回之后）设置选项没有任何作用，因为 accept 只是从已连接队列中取出一个连接而已（参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a>）。</li><li>为了避免潜在的缓冲区空间浪费，接收缓冲区大小应该为 MSS 的整数倍，且至少为 MSS 的 4 倍，参见《UNP》P163。</li><li><strong><font color='orange'>为了最大化性能，缓冲区大小应该约等于带宽-延迟积</font></strong> ，参见《UNP》P164 。</li></ol><h2 id="font-color-red-SO-RCVLOWAT-和-SO-SNDLOWAT-font"><font color='red'>SO_RCVLOWAT 和 SO_SNDLOWAT</font></h2><p>这两个选项作用于 select/poll/epoll，目的在于减少网络 I/O 的次数。<code>SO_RCVLOWAT</code> 指定接收缓冲区中的数据量必须达到多少时，才会唤醒 select/poll/epoll 去读取数据；<code>SO_SNDLOWAT</code> 指定当发送缓冲区的<u>空闲空间</u>大于低水平位标记时，将唤醒 select/poll/epoll 写数据到socket 。</p><h2 id="font-color-red-SO-REUSEADDR-font"><font color='red'>SO_REUSEADDR</font></h2><p>这是服务器最常用的选项之一。该选项有以下几个作用：</p><ol><li><p><strong>可以在 TIME_WAIT 期间重新绑定该端口，这对服务器崩溃重启并快速恢复有至关重要的作用，避免了几十秒甚至几分钟的等待。</strong></p><blockquote><p>需要注意的是，如果没有开启时间戳选项（默认开启），则 TIME_WAIT 期间重新绑定<u>可能</u>失败，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT探究</a>。</p></blockquote></li><li><p><strong>允许在已连接的状态下重新绑定该端口</strong> ，常见情景如下：<br>a）启动监听进程<br>b）连接请求到达，派生一个子进程处理该连接<br>c）监听进程崩溃，子进程仍在运行<br>d）重启监听进程，并绑定之前的端口</p></li><li><p><strong>允许在同一个端口启动多个服务器，前提是每个服务器绑定的本地 IP 不同（IP 别名）</strong></p><blockquote><p>笔者在本机上实验，分别绑定环回地址 <code>127.0.0.1</code> 和本机 IP 地址，两者可以同时绑定同一个端口。如果未开启 SO_REUSEADDR，则无法同时绑定。<br><strong><u>注意，如果某个服务器程序绑定的是通配地址（INADDR_ANY），那么后续在同一端口上启动的服务器程序则无法完成绑定。</u></strong></p></blockquote></li><li><p>其他作用不常见，详见《UNP》P166</p></li></ol><p><strong><font color='orange'>另外注意，不论是否开启该选项，不同传输层协议是可以同时绑定到同一端口的，比如 TCP 和 UDP 程序就能够同时绑定到一个端口。</font></strong></p><p><strong><font color='red'>对于所有 TCP 服务器，都应该在 bind 前开启 SO_REUSEADDR ！</font></strong></p><blockquote><p>另外，还有一个 <code>SO_REUSEPORT</code> 选项，不常用，参见《UNP》P165</p></blockquote><h2 id="font-color-red-SO-LINGER-font"><font color='red'>SO_LINGER</font></h2><p><code>SO_LINGER</code> 用来控制 close 的行为：<br><img src="/2022/img/image-20230407141037746.png" alt=""><br><img src="/2022/img/image-20230407141059416.png" alt=""><img src="/2022/img/IMG_0580(20230407-134909).PNG" alt=""></p><p><strong><u>注意缓冲区的各种情况！</u></strong> 其中第四种关闭方式就是我们常说的“优雅关闭”。</p><p>书中提供了一种有效办法，使发送端能够确认接收端的<u>应用层</u>已收到数据，详见《UPN》P161。</p><p><strong>另外有个细节，上图中 SHUT_RD 后，接收到的任何数据都会被丢弃，这里的丢弃是先确认再丢弃，也就是说，这不会引发对方的重传。</strong></p><h2 id="font-color-red-TCP-NODELAY-font"><font color='red'>TCP_NODELAY</font></h2><p>此选项用来禁止 Nagle 算法。关于 Nagle 算法，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">TCP流量控制</a> 。 有时候我们必须要关闭 Nagle 算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>]]></content>
    
    
    <summary type="html">常用socket选项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>wireshark入门笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-02T03:35:43.000Z</published>
    <updated>2023-04-02T11:13:00.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>学习 wireshark 前需要先了解 tcpdump，<strong>许多情况下我们使用 tcpdump 抓包（更快速、更方便），然后使用 wireshark 进行分析</strong> 。可参见 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump实操</a><br>环境：Ubuntu 16.04 LTS</p></blockquote><hr><h2 id="font-color-red-安装-wireshark-font"><font color='red'>安装 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install wireshark-qt</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-启动-wireshark-font"><font color='red'>启动 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wireshark</span></span><br></pre></td></tr></table></figure><p>启动后显示如下界面：<br><img src="/2022/img/image-20230402115238469.png" alt=""></p><p>发现没有我们想要的网卡。如何知道哪块网卡是我们想要的？打开命令行终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4331 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3064 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2400943 (2.4 MB)  TX bytes:462038 (462.0 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1249 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1249 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:121848 (121.8 KB)  TX bytes:121848 (121.8 KB)</span><br></pre></td></tr></table></figure><p><code>ens33</code> 就是可用网卡（<code>lo</code> 是环回接口，不用管）。</p><p>没有显示 <code>ens33</code> 是因为操作权限问题。重新以管理员身份运行 wireshark：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo wireshark</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230402115430627.png" alt=""></p><p>成功显示 <code>ens33</code> ，<strong><u>双击该选项</u></strong> ，进入 wireshark 抓包页面。</p><hr><h2 id="font-color-red-捕获过滤器-font"><font color='red'>捕获过滤器</font></h2><p>捕获过滤和显示过滤器是 wireshark 的两种主要过滤方式，但二者机制完全不同。前者是指示 wireshark 只捕获满足一定要求的报文，而后者则是在已经捕获到的报文中筛选出满足进一步要求的报文。捕获过滤器在打开 wireshark 时设置：</p><p><img src="/2022/img/image-20230402151407256.png" alt=""></p><p>或者打开 wireshark 后，在设置页面操作：<br><img src="/2022/img/image-20230402151634036.png" alt="注意，需要先停止捕获才可设置"></p><p>配置捕获规则的语法和 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump</a> 相同，这里不再赘述。</p><blockquote><p>建议：某些时候无需设置太过具体的条件，以免不利于网络错误排查。比如你要求只接收 TCP 报文，但 TCP 连接出错时可能会产生 ICMP 报文来传达错误信息，而这却被你给屏蔽了…</p></blockquote><hr><h2 id="font-color-red-显示过滤器-font"><font color='red'>显示过滤器</font></h2><p>显示过滤在捕获网络报文后进行：<br><img src="/2022/img/image-20230402152619594.png" alt=""></p><p>显示过滤的语法和 tcpdump 完全不同。详细语法参见<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html">wireshark manual</a></p><hr><h2 id="font-color-red-名称解析-font"><font color='red'>名称解析</font></h2><p><img src="/2022/img/image-20230402163513811.png" alt=""><br><img src="/2022/img/image-20230402163636148.png" alt=""></p><ul><li>选项 1：将 MAC 地址解析为名称。</li><li>选项 2：将著名端口号解析为协议名，如，将端口号 80 解析为 http 。</li><li>选项 3：将 IP 解析为域名。</li><li>选项 4：如果将 IP 解析为域名，则只利用已经抓到的包来解析，不另外专门进行 DNS 查询。</li><li>选项 5：如果无法从已抓到的报文解析 IP，则另外进行 DNS 查询。这会影响速度，一般不开。</li></ul><p>已经解析的名字可以通过以下方式找到：<br><img src="/2022/img/image-20230402165754095.png" alt=""></p><p>另外，你也可以自己命名一些 IP 地址：<br><img src="/2022/img/image-20230402165953271.png" alt=""><br>自己命名的 IP 也会被加入到上面的 Resolved Address 栏目中。</p><hr>]]></content>
    
    
    <summary type="html">wireshark入门笔记</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump实操</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/tcpdump/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/tcpdump/</id>
    <published>2023-03-21T08:34:40.000Z</published>
    <updated>2023-04-07T11:06:45.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-tcpdump-font"><font color='red'>tcpdump</font></h2><blockquote><p><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man</a></p></blockquote><p>tcpdump 须在管理员权限下运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump</span></span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><ul><li>输出结果表明 tcpdump 的监听网卡为 <code>ens33</code> 。</li><li>默认截断大小为 262144 字节（随版本而改变），超过该数字报文会被截断。</li></ul><p>使用 <code>ifconfig</code> 查看其他网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12058 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4911 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:9115911 (9.1 MB)  TX bytes:577567 (577.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1110 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1110 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:1022006 (1.0 MB)  TX bytes:1022006 (1.0 MB)</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-i 指定网卡</mark> </strong></p><p>上面默认监听网卡是 <code>ens33</code> ，我们也可以指定为 <code>lo</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump -i lo</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><p><code>-i any</code> 可以监听所有网卡。</p><hr><p><strong><mark class="hl-label blue">-nn 直接显示IP和端口号</mark> </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcpdump -i lo</span></span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">01:12:54.640796 IP localhost.44438 &gt; localhost.12345: Flags [S], <span class="built_in">seq</span> 1028792545, win 65495, options [mss 65495,sackOK,TS val 1381449987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640834 IP localhost.12345 &gt; localhost.44438: Flags [S.], <span class="built_in">seq</span> 3925511357, ack 1028792546, win 65483, options [mss 65495,sackOK,TS val 1381449987 ecr 1381449987,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640870 IP localhost.44438 &gt; localhost.12345: Flags [.], ack 1, win 512, options [nop,nop,TS val 1381449987 ecr 1381449987], length 0</span><br></pre></td></tr></table></figure><p>监听环回网卡时，我们运行自己编写的简易 TCP 服务器端和客户端的回射程序，结果输出以上三次握手内容。其中主机地址为 <code>localhost</code> ，由于 server 和 client 都在一台主机，所以都为 <code>localhost</code> 。如果服务器的端口为著名端口（如 ssh 为 22 号端口），那么 22 也会显示为 ssh。若想直接显示 IP 和端口号，则使用 <code>-nn</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn</span></span><br><span class="line">01:14:54.615811 IP 127.0.0.1.44438 &gt; 127.0.0.1.12345: Flags [P.], seq 1028792546:1028792548, ack 3925511358, win 512, options [nop,nop,TS val 1381569983 ecr 1381449987], length 2</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-n 不将IP转换为域名</mark> </strong></p><p>不讲 IP 转为域名，则可以省去 DNS 查询，输出速度会快很多。</p><hr><p><strong><mark class="hl-label blue">过滤主机</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源地址是 192.168.1.1 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定源地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定目的地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>也可直接指定域名：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dest host <span class="string">&quot;baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">过滤端口</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源端口是 25 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定源端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定目的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure><ul><li><p>指定端口范围：portrange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo portrange 10000-20000</span></span><br></pre></td></tr></table></figure></li><li><p>对于著名端口，可直接用应用层协议替代，相当于宏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump port http</span> </span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">网段过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst net 192.168.0.0/16</span>  </span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">协议过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump arp</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump ip</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump tcp</span>  </span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不能直接过滤协议,如下</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump http</span>  </span><br></pre></td></tr></table></figure><p>而应该</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump port http</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">常用表达式</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非 : ! 或 not </span><br><span class="line">且 : &amp;&amp; 或 and  </span><br><span class="line">或 : || 或 or</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp &amp;&amp; dst port 12345 &amp;&amp; src host 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp and dst port 12345 and src host 127.0.0.1</span></span><br></pre></td></tr></table></figure><p>有时条件比较复杂的需要用括号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 <span class="string">&#x27;((tcp) and (! port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))&#x27;</span></span></span><br><span class="line">抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200,并且端口不是80的TCP数据</span><br></pre></td></tr></table></figure><p><strong>如果使用括号，则整个表达式需要用 <code>''</code> 或 <code>&quot;&quot;</code> 包住。</strong></p><hr><p><strong><mark class="hl-label blue">包头过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（从第0字节开始）</span><br><span class="line">proto[x:y] &amp; z = 0  : proto[x:y]和z的与操作为0</span><br><span class="line">proto[x:y] &amp; z !=0  : proto[x:y]和z的与操作不为0</span><br></pre></td></tr></table></figure><p><strong>IP报头格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    0                   1                   2                   3</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1   \bit</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0   |Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4   |         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">12  |  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16  |                       Source Address                          |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20  |                    Destination Address                        |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24  |                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">28  |                            DATA ...                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><p><strong>TCP报头格式：</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   0                   1                   2                   3</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \bit</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0  |          Source Port          |       Destination Port        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4  |                        Sequence Number                        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">8  |                    Acknowledgment Number                      |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">12 | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">   |       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16 |           Checksum            |         Urgent Pointer        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20 |                    Options                    |    Padding    |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24 |                             data                              |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;tcp[2:2]=12345&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的报文</span><br></pre></td></tr></table></figure><p><strong>TCP标记定义在TCP头的第 13 个字节：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;src port 12345 &amp;&amp; tcp[13]&amp;1 = 1&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的FIN报文</span><br></pre></td></tr></table></figure><p>TCP标记宏可以替代数值：</p><p><code>tcpflags</code> , <code>tcp-fin</code> , <code>tcp-syn</code> , <code>tcp-rst</code> , <code>tcp-push</code> , <code>tcp-push</code> , <code>tcp-ack</code> , <code>tcp-urg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;dst port 12345 &amp;&amp; tcp[tcpflags]&amp;tcp-fin=tcp-fin&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-w 输出到文件、-r 读取文件</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -w test.cap</span></span><br></pre></td></tr></table></figure><p>把信息输出到 test.cap 文件。将文件保存为 <code>cap</code> 或 <code>pcap</code> 类型就能方便地使用 wireshark 打开并分析：<br><img src="/2022/img/image-20230401192959234.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap</span></span><br></pre></td></tr></table></figure><p>读取 <code>test.cap</code> 文件并打印在终端，同时也可以使用过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap port 12345</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">输出时间</mark> </strong></p><ul><li><code>-t</code>：在每行的输出中不输出时间</li><li><code>-tt</code>：在每行的输出中会输出时间戳</li><li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li><li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -t dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1650, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">1680352032.093467 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1662, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -ttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line"> 00:00:00.000000 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1672, length 64</span><br><span class="line"> 00:00:01.002438 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1673, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">2023-04-01 05:27:30.131073 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1680, length 64</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-v 展示详细信息</mark> </strong></p><p><code>-v</code>：产生详细的输出。比如包的TTL，id标识，数据包长度，以及IP包的一些选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/butcher/Documents# tcpdump -v dst  &quot;baidu.com&quot;</span><br><span class="line">tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">05:36:46.543701 IP (tos 0x0, ttl 64, id 44013, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 12115, seq 7, length 64</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-c 指定接收报文个数</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -v -c 3</span> </span><br><span class="line">05:46:32.275269 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.248.2 tell 192.168.248.1, length 46</span><br><span class="line">05:46:32.276545 IP (tos 0x0, ttl 64, id 50690, offset 0, flags [DF], proto UDP (17), length 72)</span><br><span class="line">    192.168.248.128.34566 &gt; 192.168.248.2.domain: 39118+ PTR? 2.248.168.192.in-addr.arpa. (44)</span><br><span class="line">05:46:32.280758 IP (tos 0x0, ttl 128, id 35219, offset 0, flags [none], proto UDP (17), length 127)</span><br><span class="line">    192.168.248.2.domain &gt; 192.168.248.128.34566: 39118 NXDomain 0/1/0 (99)</span><br><span class="line">3 packets captured</span><br></pre></td></tr></table></figure><p>抓满指定数量的报文后自动停止。</p><p><strong><mark class="hl-label blue">-C -W 分文件写入</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -C 1 -W 4 -w <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>-C 和 -w 配套使用，后者将抓包情况写入文件，前者指定每个文件的最大大小，单位为 1MB（小文件利于分析）。</p><ul><li><code>-C 1</code> ：指定单个文件最大为 1MB</li><li><code>-W</code> ：指定最多写 4 个文件</li><li><code>-w</code> ：写入文件</li></ul><p>每个文件会依次添加后缀：test1、test2、test3、test4 。<strong><u>注意，如果写满这 4 个文件后，数据还在持续，那么会重新覆盖这 4 个文件并继续写入，而不会新建文件。</u></strong></p><hr><p><strong><mark class="hl-label blue">-Q 指定方向</mark> </strong></p><ul><li>-Q in ：只显示收到的数据</li><li>-Q out ：只显示发出的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -Q <span class="keyword">in</span></span></span><br><span class="line">06:04:34.157713 IP 192.168.248.1.50277  &gt; 239.255.255.250.1900: UDP, length 175</span><br><span class="line">06:04:34.163603 IP 192.168.248.2.domain &gt; 192.168.248.128.34566: 27092 NXDomain 0/1/0 (103)</span><br><span class="line">06:04:35.003369 IP 180.101.49.186.https &gt; 192.168.248.128.33644: Flags [.], ack 769671203, win 64240, length 0</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-s 指定截取大小</mark> </strong></p><p><code>-s</code> 指定每个包捕获的长度、单位是 byte，而不是默认的 262144 字节；如果超过了设定的大小限制，包就会被截断，并在打印行出现[|proto]这种标识，这个proto就是被截断的报文的协议名字。但是抓取越长，包的处理时间越长，并且会减少 tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好，<strong><u>一般只抓报头</u></strong> ，抓 80 个字节一般就能包含 TCP 层、IP 层、链路层。</p><p><code>-s 0</code> 使用默认长度 262144。</p><p><strong><mark class="hl-label blue">-e 显示链路层信息</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump  -e</span> </span><br><span class="line">06:49:36.315000 00:0c:29:48:09:a9 (oui Unknown) &gt; 00:50:56:fb:6d:e0 (oui Unknown), ethertype IPv4 (0x0800), length 54: 192.168.248.128.33644 &gt; 180.101.49.186.https: Flags [.], ack 565954419, win 65535, length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-F 指定过滤过滤表达式文件</mark> </strong></p><p>有些过滤表达式经常用，但又很冗长，每次输入都很麻烦。所以可以保存为文件，每次 tcpdump 时指定该文件为过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -F filter_file</span></span><br></pre></td></tr></table></figure><p>该命令行中的其他命令会被忽略。</p><hr><p><strong><mark class="hl-label blue">less，greater 指定大小</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump less 100</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-X 打印数据内容</mark> </strong><br><code>-X</code> 除了打印每个数据包的头之外，还可以用十六进制和ASCII打印每个数据包的数据（不包括链路级头，<code>-XX</code> 可包含）：<br><img src="/2022/img/image-20230402084531352.png" alt=""></p>]]></content>
    
    
    <summary type="html">常用网络命令和抓包工具</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>高级I/O函数&amp;网络数据读取的常见问题</title>
    <link href="http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://jyxcpp.netlify.app/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-21T08:31:41.000Z</published>
    <updated>2023-04-13T16:33:03.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《UNIX网络编程》《UNIX环境高级编程》《TCP/IP编程》、<a href="http://c.biancheng.net/view/2349.html">socket阻塞模式</a></p></blockquote><h2 id="font-color-red-read-font"><font color='red'>read</font></h2><p><img src="/2022/img/IMG_0576(20230325-120322).PNG" alt=""></p><blockquote><p><code>ssize_t</code> 是有符号整型 long；<code>size_t</code> 是无符号整型 unsigned long</p></blockquote><p>对于 read 和 write 这类 <strong>低速系统调用（即可能使进程永远阻塞下去的系统调用）</strong> ，当执行期间捕捉到信号，则该系统调用就会被中断不再执行，且返回 -1，并将 errno 设置为 -1。为什么呢？有这样一个常见的场景：网络中，由于不知道对端网络具体会发来多大的包，所以我们会让 read 尽可能多地接收数据，即把其第三个参数设置大些。那么问题来了，对端只发送了 1000 字节的数据，而你却指定本端的 read 读取 10000 字节，那怎么办？总不能一直阻塞下去吧？所以此时就需要用到信号，来中断 read 使其结束。</p><blockquote><p>至于 read 在读取数据时是被什么信号中断的，笔者也没有查到相关资料，知晓的读者还请在评论区指点一二。</p></blockquote><p><strong><font color='orange'>需要注意的是，TCP 套接字上的 IO 表现的行为不同于通常的磁盘 IO。</font></strong> <strong><u>磁盘 IO 一般不会被信号打断而终止，因为磁盘 IO 与网络 IO 的区别在于：前者的 IO 量是可以确定的，虽然可能会暂时阻塞调用者，但只要把指定量的数据处理掉就 OK，任务很明确；而网络 IO 一般不知道具体的 IO 量，就像上面的场景一样，所以必须在某个时刻终止 IO（终端 IO 也是如此，计算机不知道用户可能会输入多少数据）。除非发生硬件错误，否则磁盘 IO 总会很快返回</u></strong> 。</p><p>对于被中断的 read，<u>早期实现</u>是：如果 read 已接收部分数据到应用缓冲区，但还未接收到应用程序请求的所有数据（即 read 的第三个参数），则操作系统会认为本次 read 调用失败，返回 -1，errno 被设置为 EINTR 。<strong><font color='orange'>目前的 POSIX 标准采用的方式是：如果 read 只接收了部分数据就被信号中断，那么也算成功，且返回已接收的字节数，errno 不修改</font></strong> 。</p><blockquote><p><strong><font color='gree'>这就是为什么在 Socket 编程中，往往将 read 函数放在循环中的原因！</font></strong> 大多数书籍将其归咎于 Socket 的缓冲机制，实际上这只是原因之一。也有许多人认为 read 只将接收缓冲区读一次就返回，当请求的数据量大于接收缓冲区时，read 返回值就当然会小于请求的字节数，这种说法更不准确。做个实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> rcv_buf=<span class="number">1000</span>; <span class="comment">//系统会调整接收缓冲区大小,本例中被调整为2304</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server rcv_buf : %d\n&quot;</span>,rcv_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">int</span> snd_buf =<span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client snd_buf : %d\n&quot;</span>,snd_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后 server 的结果如下：<br><img src="/2022/img/image-20230324152945053.png" alt=""></p><p>你看，server 的接收缓冲区大小被修改为 2304 字节，但却 read 了 65482 字节，大于 2304，说明不止读取一次缓冲区；小于请求值 100000，说明 read 还没有读完对面发送的 10000 字节就被信号中断。</p></blockquote><p>所以得出一个重要结论：如果 read 返回值小于请求值，说明有两种情况：</p><ol><li><strong>提前收到了 EOF。</strong></li><li><strong>被信号中断。</strong></li></ol><p>第一种情况说明数据已经接收完，第二种情况则还需要重新调用 read 才能将数据接收完毕。我们可以使用自己的包裹函数 readn 一次性将数据读完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* tmp = buf;</span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, tmp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nread == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">//被信号打断,则继续循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        tmp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不过需要注意，readn 可能会一直阻塞</font>，因为正常情况下它只会在接收到 EOF 或者读满 n 字节才会返回；而 read 不同，read 收到 EOF 、读满 n 字节或者被信号中断（没读满）时就能返回</strong> 。所以当发送的字节数小于请求的字节数时，readn 就会被阻塞，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    writen(sock_clnt,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//while停住,以免关闭套接字发送EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上程序时，服务器不会显示客户端发来的消息，因为 readn 要求读满 1000 或者读到 EOF。当把 readn 改成 read，就能成功显示消息了。解决这个问题的办法之一是设计应用层协议，比如在包头说明本包的大小，这方面内容后续补充。</p><p><strong>recv 的第四个参数可以选 MSG_WAITALL 标志来阻止这种行为，当 flags 为 MSG_WAITALL 时，recv 会阻塞直到所指定的长度 nbytes 字节的数据全部返回，recv 才会返回。</strong></p><h2 id="font-color-red-write-font"><font color='red'>write</font></h2><p><strong>不同于 read，作用于字节流套接字时，输出字节比请求的字节少这种情况仅在非阻塞前提下才会发生</strong> 。</p><p>调用 write 时，如果套接字的发送缓冲区容不下请求量，那么 write 被阻塞，直到缓冲区中的数据被发送到对端，腾出足够的空间，才唤醒 write 函数继续写入数据。有以下几个要点需要注意：</p><ol><li><strong>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</strong></li><li><strong>发送缓冲区中的数据必须保留，直到对端回复相应的 ACK（这是由内核自动完成的）。</strong></li><li><strong>接收缓冲区的数据将一直保留，直到应用层读取（read）。</strong></li><li><strong>write 函数的返回只说明应用层的数据已经全部转移到输出缓冲区，这不代表对方已经收到所有数据。</strong></li></ol><p>让我们做几个实验来验证上面的结论。</p><p><strong><mark class="hl-label blue">实验一</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">100000</span>; <span class="comment">//设置接收缓冲区,系统会调节该值,可能为200000</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">1000</span>; <span class="comment">//系统会调节该值,可能为3000左右</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> size = write(sock_clnt,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，<strong>立刻</strong> 输出结果，client 发送 100000 字节，server 接收 100000 字节。这说明即使我们将 client 的发送缓冲区设置为 1000，数据也会分批发送。结论一得证。</p><p><strong><mark class="hl-label blue">实验二</mark> </strong></p><p>将上面代码 server 的接收缓冲区改为 1000，运行程序，<strong>等待几秒后</strong> 输出结果，两方仍是 100000 字节。这说明接收缓存区虽小，但由于应用层一直在读取数据（readn），所以接收缓冲区可以不断地丢弃旧数据、接收新数据，直到收到所有数据。</p><p>继续，修改 14~22 行代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf_size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//循环,不close套接字</span></span><br></pre></td></tr></table></figure><p>即，不从接收缓冲区读取数据，同时不 close 套接字。close 套接字可能导致缓冲区的一系列动作，不利于我们进行实验。</p><p>运行程序，<strong>两端都陷入阻塞</strong> 。这说明由于接收缓冲区没有被 read，数据一直积压，因此无法接收 client 发来的数据，也就不能回复 ACK；而 client 因为没有收到 server 回复的 ACK ，所以发送缓冲区不能接收应用层的新数据，以至于在 write 中阻塞。结论 2、3 得证。</p><p><strong><mark class="hl-label blue">实验三</mark> </strong></p><p>在实验二的基础上，把 client 的发送缓冲区改为 100000 字节，运行程序。client 立刻输出 <code>100000</code> 。表明 client 成功向发送缓冲区写入 100000 字节，并立刻从 write 返回。但 server 的接收缓冲区只有 1000 字节的大小，不可能接收完这 100000 字节。因此，结论 4 得证。</p><hr><hr><h2 id="font-color-red-sendfile-font"><font color='red'>sendfile</font></h2>]]></content>
    
    
    <summary type="html">网络数据读取的常见问题</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>半连接与全连接队列</title>
    <link href="http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
    <id>http://jyxcpp.netlify.app/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</id>
    <published>2023-03-20T10:39:37.000Z</published>
    <updated>2023-03-21T04:08:03.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《UNIX网络编程》、<a href="https://blog.csdn.net/qq_42877870/article/details/105027743">hping3命令使用</a>、<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">小林网络</a>、<a href="https://www.51cto.com/article/687595.html">51CTO</a></p></blockquote><p><strong>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</strong> 。前者又称半连接队列、SYN队列，后者又称全连接队列、accept 队列。</p><p>半连接队列：服务器收到客户端发来的 SYN 报文后，将该连接存入此队列中。这些连接处于 SYN_RCVD 状态。<br>全连接队列：服务端收到第三次握手的 ACK 后，该连接被内核从半连接队列转移到全连接队列，此时已经完成三次握手，处于  ESTABLISHED 状态。当调用 accept 函数时，该连接将从全连接队列中移除。</p><hr><p><strong><mark class="hl-label blue">backlog</mark> </strong></p><p><strong>“backlog的含义从未有过正式的定义”，不同的 UNIX 操作系统对其有不同的实现</strong> 。这里只以笔者的环境 Ubuntu 16.04 进行说明。</p><blockquote><p>其他版本的相关说明请参见《UNP》第 3 版 84 页。</p></blockquote><p><strong>先说结论：</strong></p><p><strong><font color='orange'>在 Linux 内核 2.2 之后，<code>backlog</code> 参数影响全连接队列的长度， <code>tcp_max_syn_backlog</code> 作为系统变量则影响半连接队列的长度</font></strong> 。</p><blockquote><p>为什么说“影响”而不是“决定”？因为两个队列长度的具体定义是采用的如下方式：</p><ul><li><strong><code>全连接队列长度 = min(somaxconn, backlog)+1</code></strong></li><li>半连接队列的长度计算较为复杂，且不同版本的操作系统实现不一样，故没有必要掌握其计算方法。<strong><font color='orange'>只需要知道，半连接队列长度可能同时取决于 <code>backlog</code> 、<code>somaxconn</code> 和 <code>tcp_max_syn_backlog</code> ，这三者越大，则半连接队列容量越大</font></strong> 。</li></ul><p><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值。</p></blockquote><p><strong>下面就全连接队列进行 <code>backlog</code> 的实验。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意,没有accept和close</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个客户进程并发送连接请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">            close(sock_clnt);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行以上代码，结果如下：<br><img src="/2022/img/image-20230319223902516.png" alt=""></p><p><strong><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可</strong> 。可以看到，10 条连接中，只有 6 条是 ESTABLISHED 状态，剩下 4 条是 SYN_SENT 。很奇怪，我们指定的 <code>backlog</code> 是 5，所以不应该只有 5 条是 ESTABLISHED 状态吗？嗯，这里挺坑的，<u><strong>这是因为大多数操作系统的实现都为 <code>backlog</code> 引入了 <font color='orange'>模糊因子</font></strong></u> ，我们这里的模糊因子就是 +1，也就是说，<code>实际全连接队列容量 = backlog + 1</code> 。其他操作系统的模糊因子参考：<br><img src="/2022/img/IMG_0575(20230319-224643).PNG" alt=""></p><blockquote><p>关于更多模糊因子的描述，参见《UNP》85~87 页。</p></blockquote><p>接着我们查看 <code>somaxconn</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /prog/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure><p>将其修改为 3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//必须在管理员权限下才能修改</span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /prog/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p>然后再运行服务器和客户端，得到以下结果：<br><img src="/2022/img/image-20230321093637098.png" alt=""><br>可见，有 4 条连接处于已建立状态，比我们指定的 <code>somaxconn</code> 还要多 1 。</p><p><strong><font color='orange'>综上，我们得出结论：全连接队列长度 = min(somaxconn, backlog) + 1</font></strong></p><p><strong><mark class="hl-label blue">当全连接队列满了怎么办</mark> </strong><br>默认行为是直接丢弃，我们也可通过指定 <code>tcp_abort_on_overflow</code> 参数来调整其行为：</p><ul><li>0 ：直接忽略客户端发过来的 ACK ；</li><li>1 ：回复 RST 给客户端，表示终止本次连接；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /prog/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>一般情况下默认为 0 即可，这是更合理的方式，因为全连接队列已满的状态只是暂时的，客户端会因迟迟未收到 ACK 重发报文，期待不久就能等到全连接队列腾出可用空间。</p><hr><p><strong>半连接队列的长度受多方面影响，且不同操作系统版本的实现方式各不相同</strong> ，所以无需掌握具体计算方式。这里笔者简单演示如何间接查看半连接队列的长度。</p><p>半连接队列中的状态为 SYN_RCV ，所以我们可以发起 SYN 泛洪，向端口发送大量虚假的 SYN 报文，然后查看该端口上最多时有多少个连接处于 SYN_RCV 状态，此时就是半连接队列的最大长度。</p><ol><li><p>下载 hping3 ，用来发起 SYN-flood 攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install hping3</span><br></pre></td></tr></table></figure></li><li><p>修改系统配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_max_syn_backlog = 128</span><br><span class="line">somaxconn = 150</span><br></pre></td></tr></table></figure><p>笔者将 backlog 设置为 9（那么全连接队列的容量就为 10），读者随意。</p></li><li><p>运行服务器端</p></li><li><p>发起攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>可见，半连接队列长度等于 backlog</strong></p></li><li><p>再将 backlog 设置为 200，重复以上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">150</span><br></pre></td></tr></table></figure><p><strong>可见，在笔者环境下（Ubuntu 16.04） ，<font color='orange'>如果 backlog 小于 <code>somaxconn</code> ，则半连接队列容量为 backlog，反之则为 <code>somaxconn</code> ，与 <code>tcp_max_syn_backlog</code> 无关。</font></strong></p></li></ol><p>综上， <strong><font color='orange'>半连接队列容量<u>可能</u>同时受 <code>tcp_max_syn_backlog</code> 、<code>somaxconn</code> 和 <code>backlog</code> 的影响，想要增大半连接队列的长度，就需要同时增大这三个参数，仅增大 <code>tcp_max_syn_backlog</code>  是无效的</font></strong> 。</p><p>对于半连接队列，更多的是需要掌握它与 SYN 泛洪的关系。关于 SYN 泛洪，详细可参见博主另一篇文章-<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪攻击</a></p><hr><p>另外，还可以从 <code>ss</code> 命令直接观察全连接队列的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*       </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59492              </span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59496              </span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>-n 不解析服务名称<br>-t 只显示 tcp sockets<br>-l 显示正在监听(LISTEN)的 sockets</p></blockquote><p><strong>对于 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：当前全连接队列的中的连接个数，即已完成三次握手等待应用程序 accept 的 TCP 连接</strong></li><li><strong>Send-Q：全连接队列的容量</strong></li></ul><p><strong>对于非 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：已收到 <u><font color='gree'>但未被应用程序读取</font></u> 的字节数</strong></li><li><strong>Send-Q：已发送 <u><font color='gree'>但未收到确认</font></u> 的字节数</strong></li></ul><p>注意上面的输出，LISTEN 状态下的 Recv-Q ，即全连接队列中的连接个数为 11；但 Send-Q，即全连接的最大长度才为 10，这是怎么回事？这可能是因为 Send-Q 没有包含模糊因子，直接等同于 backlog 。</p><p><strong><font color='orange'>另外注意，<code>ss</code> 命令和 <code>netstat</code> 命令对 LISTEN 状态输出的 Recv-Q 和 Send-Q 的含义不相同</font></strong> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -at</span><br><span class="line">Proto    Recv-Q     Send-Q   Local Address           Foreign Address         State </span><br><span class="line">tcp      0          0        *:12345                 *:*                     LISTEN</span><br><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*  </span><br></pre></td></tr></table></figure><p>这两条命令是在同一次网络请求下进行的，但两者的 Recv-Q 和 Send-Q 却不相同。个人猜测 <code>netstat</code> 下的 Recv-Q 和 Send-Q 就是单纯的收发字节数，不再表示连接个数或队列长度。</p><p>本文结束。</p>]]></content>
    
    
    <summary type="html">半连接与全连接队列, backlog</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>错误处理与包裹函数</title>
    <link href="http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-18T15:24:21.000Z</published>
    <updated>2023-04-11T15:57:56.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考书籍：《UNIX网络编程》《UNIX环境高级编程》</p></blockquote><h2 id="font-color-red-errno-font"><font color='red'>errno</font></h2><p>只要在一个 <strong><u>系统调用</u></strong> 中有错误发生，<strong>全局变量 errno</strong> 就会被自动设置为一个特定的正值，用来反馈具体错误，而函数本身则会返回 -1，以说明函数发生了错误；如果函数返回正值，即没有错误发生，则 errno 没有定义。errno 包含在 <code>errno.h</code> 中。</p><ul><li><p>如果函数没有出错，则之前的 errno 可能不会被清除（未定义）；只有发生错误时，才会覆盖之前的错误。</p></li><li><p>errno 不会为 0，这与多线程的 errno 处理有关。</p><blockquote><p><strong>这是因为：线程函数（以 pthread_ 开头的函数）遇到错误时不会设置标准 Unix 的 errno 变量，而是将 errno 的值以函数返回值的形式交给调用者。也就是说，返回值大于 0 则说明发生了错误，那没有发生错误呢？自然也就是返回 0 了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(&amp;ndoen_mutex))!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这意味着我们每次调用 pthread_ 函数时，都要事先分配一个整形来保存错误值，这很麻烦，所以我们可以把错误处理和 pthread_ 函数包裹起来以简化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(mptr))!=<span class="number">0</span>)</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong><font color='red'>虽然 errno 是一个全局变量，但是在多线程环境中，每个线程都会有自己独立的 errno 副本，这是通过线程本地存储（Thread-Local Storage，TLS）实现的，因此一般不用担心多线程会相互竞争 errno，可参见《APUE》P358</font></strong><br><img src="../../public/2022/img/image-20230410230004254.png" alt=""></p></li><li><p><strong>虽然在多线程下不用担心 errno 的竞争问题，不过单线程下 errno 仍可能出现问题，比如在信号处理函数中被修改</strong> 。当发生信号时，执行流会跳转到信号处理函数，这感觉就像是多线程，但实际上它和之前的执行流位于同一个上下文，也就是说信号处理函数并不是新开的线程。因此，如果之前的执行流在系统调用出错后修改 errno，接着被信号中断，进入了信号处理函数，而信号处理函数中也调用了某些系统函数如 write，如果此时这个系统调用出错，那么 errno 就会被修改，<strong>这就使得之前的 errno 被覆盖！</strong> 因此，<strong><font color='orange'>作为一个通用的规则：</font></strong> 在信号处理函数中，应首先保存 errno，退出时再恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alarm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> errno_cpy = errno;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">    write(....);</span><br><span class="line">    errno = errno_cpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="font-color-red-perror、strerror-font"><font color='red'>perror、strerror</font></h2><p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr，其中 str 是自定义内容。该函数先输出 str，再输出错误描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="comment">//连接错误则输出以下结果：</span></span><br><span class="line">connect: Connection refused</span><br></pre></td></tr></table></figure><p>C 库函数 <strong>char *strerror(int errnum)</strong> 从内部数组中搜索错误号 <strong>errnum</strong>，并返回一个指向错误消息字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = strerror(errno);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-包裹函数-font"><font color='red'>包裹函数</font></h2><p>网络编程很多时候都会遇到一些网络问题，并通过函数返回值或 errno 反馈错误，因此绝不能忽略对错误的处理。包裹函数一般用来处理致命性错误，此时能干的也就只有打印错误然后退出，对于非致命性错误，比如 EINTR 错误，就需要我们自己来处理失败情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sock_conn=accept(sock_listen,<span class="literal">NULL</span>,<span class="literal">NULL</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要自己重启被中断的系统调用。关于中断的系统调用，参见《APUE》第 260 页。</p><p>一些包裹函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bind(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (connect(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他包裹函数可参考<a href="https://github.com/jyx-fyh/unp-source-code/blob/master/lib/wrapsock.c">UNP-sockwarp.c</a></p></blockquote>]]></content>
    
    
    <summary type="html">错误处理与包裹函数</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT与SO_REUSEADDR</title>
    <link href="http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/"/>
    <id>http://jyxcpp.netlify.app/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/</id>
    <published>2023-03-16T10:08:32.000Z</published>
    <updated>2023-04-07T03:31:58.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>运行环境：Ubuntu 16.0.4</p></blockquote><ul><li><p>无论是否开启 SO_REUSEADDR ，客户端主动断开连接后，无需等待 TIME_WAIT 即可重连，因为客户端每次 bind 的端口都不一样。由此可见， <strong>TIME_WAIT 是对端口而言</strong> 。</p><blockquote><p>不管是服务器还是客户端，只要是主动断开连接的，都会有 TIME_WAIT 。</p></blockquote></li><li><p>如不开启 SO_REUSEADDR，服务器端主动断开连接，则必须等待 TIME_WAIT 后才可重新 bind 该端口，原因见下文。</p></li><li><p><strong><font color='red'>注意，必须是要在 accept 或 connect 成功返回后（即连接成功后）断连或终止程序，才会有 TIME_WAIT ；仅仅 bind 但未连接成功，终止程序后是不会 TIME_WAIT 的</font></strong> 。</p></li><li><p><strong><font color='red'>注意，如果 bind 指定端口不成功，则会自动 bind 其他任意端口；</font></strong></p></li><li><p><code>SO_REUSEADDR</code> 生效的前提条件是开启时间戳，即令 <code>/proc/sys/net/ipv4/tcp_timestamps</code> 为 1（默认也为1）。</p><blockquote><p>实操发现即使关闭时间戳，服务器也能立刻重新绑定端口，原因尚不明确。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>; <span class="comment">//SO_REUSEADDR默认也是0</span></span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR, &amp;opt, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server failed to bind\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> != (sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>)))&#123;</span><br><span class="line">        <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">        size = write(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server sent %ld bytes\n=====================&quot;</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(3);  //stop 3s so that client could send FIN first</span></span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> in_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">99</span>;i++)</span><br><span class="line">        out_buf[i]=<span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="keyword">sizeof</span>(out_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    size = read(sock_clnt, in_buf, <span class="keyword">sizeof</span>(in_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">//stop 3s so that server could send FIN first</span></span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编译上述代码，先运行 server 端，再运行 client 端（注意，最好运行可执行文件，不要直接在编译器中运行），结果如下：<br><img src="/2022/img/image-20230316190258629.png" alt="server"><br><img src="/2022/img/image-20230316190325197.png" alt="client"><br>由于客户端 close 前调用了 sleep，所以可以判断一定是 server 主动断开连接，如下图：<br><img src="/2022/img/image-20230316190534357.png" alt=""><br><code>localhost:12345</code> 是本端地址信息，<code>localhost:53188</code> 是对端地址信息，后面的状态是描述本端状态的，因此可知 server 主动发送 FIN 并断开连接后，进入了 TIME_WAIT 状态。此时我们马上重启服务器，则输出以下内容：<br><img src="/2022/img/image-20230316191622035.png" alt=""><br>在 TIME_WAIT 内重启服务器，则报错绑定失败。注意，绑定指定端口失败后，会随机绑定其他端口，如下：<br><img src="/2022/img/image-20230316191842098.png" alt=""><br>第三行的 <code>46937</code> 便是服务器端随机绑定的端口。不过这已经失去意义，因为服务器是通过知名端口来被客户端认识的，客户端根本不认识这些随机端口，所以 server 会一直处于监听状态，不会有 client 来连接。因此，对于服务端，如果 bind 失败，应该直接终止程序或等待 TIME_WAIT 后重新 bind。</p><p>下面我们让 client 主动关闭连接——加上 server 的 sleep ，去掉 client 的 sleep 即可。结果如下：<br><img src="/2022/img/image-20230316193318143.png" alt="server"><br><img src="/2022/img/image-20230316193335972.png" alt="client"><br><img src="/2022/img/image-20230316193425965.png" alt=""><br>本端为 <code>localhost:53200</code> ，可见确实是 client 发起的 FIN 。因为 client 无需 bind 特定端口，即 client 每次运行绑定的端口都不同，所以不用担心会因为 TIME_WAIT 而连接失败。</p><p>接下来我们使用 SO_REUSEADDR 选项来修改 TIME_WAIT 的限制——将 server 代码第 7 行的 opt 赋值为 1 即可，这样就可以无视 TIME_WAIT 直接复用端口。下面是连续两次运行 server 和 client 的结果：<br><img src="/2022/img/image-20230316204302114.png" alt=""><br><img src="/2022/img/image-20230316204349584.png" alt="">你看，即使服务器处于处于 TIME_WAIT 状态，还是可以直接绑定端口并进行通信。</p><p><strong><font color='red'>注意，即使将 SO_REUSEADDR 置 1，TIME_WAIT 状态也依旧存在，只是可以无视该状态直接 bind 而已。</font></strong></p><p>待补充</p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1-time-wait-%E7%8A%B6%E6%80%81">https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#为什么要设计-time-wait-状态</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#先说结论</a></p>]]></content>
    
    
    <summary type="html">TIME_WAIT与SO_REUSEADDR实操</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程重点</title>
    <link href="http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-05T10:30:46.000Z</published>
    <updated>2023-05-01T01:49:49.414Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li><li>本文只记录重点内容和个人理解，系统学习请移步《UNIX网络编程》</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>监听</font>套接字</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='red'>监听套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong><font color='red'>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</font></strong> 。<strong>监听套接字和已连接套接字有本质区别。</strong></p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><h3 id="font-color-red-socket-font"><font color='red'>socket</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>该函数返回主动套接字，经过 listen 函数转换后才会成为监听套接字。</li><li><strong>protocol 敲定最终协议</strong> 。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；</li></ul><h3 id="font-color-red-bind-font"><font color='red'>bind</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png" alt=""></p><ul><li><p>该函数将 addr 地址结构所包含的信息绑定到 sockfd 套接字上，相当于为套接字办理身份证。</p></li><li><p><strong>bind 可以手动指定 IP 地址或端口，可以两者都指定，也能两者都不指定，如果不手动指定，则按以下方式处理：</strong></p>  <img src="/2022/img/image-20230308162549530.png" style="zoom:80%;" /><p><strong><font color='red'>对于 IPv4，通配地址为宏 INADDR_ANY；对于 IPv6，为 in6addr_any</font></strong> ：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servSock.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//INADDR_ANY一般为0,可以不用htonl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果绑定 INADDR_ANY，此时服务器在自己的所有 IP 上（如果是多宿）监听，等到客户发来的 SYN 报文时，再绑定到该报文指定的对端 IP</strong> 。</p></li><li><p><strong><u>注意，对于 TCP 而言，如果不手动指定端口，<font color='orange'>则在调用 listen (server) 或 connect (client) 时</font>，内核会选择一个临时端口</u></strong> 。对于客户端，我们一般让内核来绑定套接字的端口（除非需要预留端口）；<strong><u><font color='orange'>对于服务器端，很少让内核自行决定端口，因为服务器是通过它们的总所周知端口而被外界认识的</font></u></strong> 。</p></li><li><p><strong><u>对于 TCP 客户端，由内核绑定 IP 地址；对于 TCP 服务器端，如果没有手动绑定，则内核就把客户发送的 SYN 报文中的目的IP地址作为绑定的 IP 地址。</u></strong></p></li><li><p><strong><font color='red'>不论是服务器还是客户端，如果绑定指定端口失败，则随机分配一个端口</font></strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p><strong>如果服务器的某个端口刚断开连接，处于 TIME_WAIT 状态，则默认情况下不能立即再次绑定该端口，否则返回 EADDRINUSE 错误</strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p>注意 bind 与 accept 中后两个参数类型的差异，前者是值类型，后者是值-结果类型（调用函数后，参数会被改变，即作为返回值）。</p></li></ul><h3 id="font-color-red-listen-font"><font color='red'>listen</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li><strong>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</strong></li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同；<strong><u>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</u></strong> 。关于这两点，详见<a href="https://jyx-fyh.github.io/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/">socket等待队列</a> 。</li></ul><h3 id="font-color-red-accept-font"><font color='red'>accept</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li><p>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度 addrLen；注意，addrLen 是输入-输出参数，传参前需要将 clntAddr 的大小赋给 addrLen。<strong><font color='orange'>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</font></strong> 。</p><blockquote><p>严格来说，对端套接字可能是 IPv4，也可能是 IPv6，为了能够容纳这两者，clntAddr 最好为通用套接字结构体 <code>sockaddr_storage</code>  。</p></blockquote></li><li><p><strong><font color='red'>accept 从已完成队列中取出一个连接；仅仅只是取出一个完成了三次握手的连接，并返回绑定此连接的套接字</font></strong> 。</p></li><li><p><strong><font color='orange'>上面这句话说明了一个很重要的事实：accept 与三次握手无关！三次握手是底层网络协议栈自动完成的（当然，第一次握手是 connect 发起的）！换句话说，即使没有 accept 也能完成三次握手！</font></strong></p><blockquote><p>做个实验便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_lsn.sin_family = AF_INET;</span><br><span class="line"> Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> Listen(sock_lsn, <span class="number">20</span>);</span><br><span class="line"> <span class="comment">//注意,没有accept和close</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line"> addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"> addr_clnt.sin_family = AF_INET;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个进程并发送连接</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">         Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">         sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">         close(sock_clnt);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行，结果如下：</p><p><img src="/2022/img/image-20230319221140308.png" alt=""><br>因为是在同一主机上运行 server 和 client，<code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可。显然，即使服务器端没有调用 accept，两端仍然建立了连接。<strong><font color='orange'>这再次说明，accept 只是从全连接队列中取出一个四元组，并绑定到一个新的套接字描述符而已</font></strong> 。<br>——<strong>四元组：即本端 IP、本端端口、对端 IP、对端端口，用来唯一确定一个 TCP 连接</strong> 。</p></blockquote></li></ul><h3 id="font-color-red-connect-font"><font color='red'>connect</font></h3><ul><li><p>connect 函数仅在客户端使用，调用此函数时，内核会为客户端绑定套接字，端口随机，这个过程相当于 bind。</p></li><li><p>connect 会激发三次握手，只在连接成功或出错时返回。出错有以下三种情况：</p><ol><li><p>客户端迟迟未收到对 SYN 报文的 ACK，此时返回 ETIMEDOUT 错误。</p><blockquote><p>“迟迟”是多久？SYN 重传次数由 <code>tcp_syn_retries</code> 控制。<u><strong>通常</strong></u> ，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后。即，每次超时的时间是上一次的 2 倍。</p></blockquote></li><li><p>对 SYN 报文的回复是 RST，表明服务端在我们指定的端口上没有套接字处于监听状态，返回 ECONNREFUSED 错误。</p></li><li><p>SYN 报文在某个中间路由器上引发了“目的地不可达”的 ICMP 错误，重复发送几次 SYN 后，如果在规定时间内仍无响应，则返回错误。</p></li></ol></li><li><p><strong><font color='red'>如果 connect 失败，则该套接字不能再重新调用 connect，只能生成新的套接字再 connect 。</font></strong></p><blockquote><p>为什么不能对其重调用 connect 呢？其实如果联想到上文中的 TIME_WAIT ，那么这个问题就有思路了。考虑这样一种情况：当发送 SYN 后，由于网络拥堵，在 MSL(报文最大生存时间) 的前一刻到达了服务器，然后服务器发送 ACK 报文，然后 ACK 也在 MSL 前到达客户端；但是，将近 2MSL 已经挺久了，客户端没有等到这么久就返回 connect 错误，同时重新在该套接字上发起 connect 并发送新的 SYN；问题来了，此时上一个 ACK 刚好到达客户端！换句话说，第二次发送的 SYN 得到的回复是第一次的 ACK，这可能导致某些错误。<br>以上只是本人的猜想，仅作为一种思路。</p></blockquote></li></ul><h3 id="font-color-red-close-font"><font color='red'>close</font></h3><ul><li>调用 close 后，<strong><font color='orange'>该套接字（文件描述符）的引用计数减 1</font></strong> ，<strong>如果引用计数仍大于 0，则不会给对端发送 FIN 报文，等于 0 才会引发挥手</strong> 。这一点在多进程网络编程中有重要作用。</li><li><strong>close 函数的默认操作是立刻关闭套接字并返回，但如果发送缓冲区中还有数据残留，则内核会将这些数据继续发送给对端。close 的行为可以由 <code>SO_LINGER</code> 控制。</strong> 关于 <code>SO_LINGER</code> ，参见<a href="https://jyx-fyh.github.io/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/">SOCKET常见选项</a></li><li>对于主动关闭端而言，发送 FIN 并收到对方回复的 ACK 报文后进入 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果主动关闭端是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></li></ul><h3 id="font-color-red-shutdown-font"><font color='red'>shutdown</font></h3><ul><li>close 同时终止读与写两个方向的数据传送，而 shutdown 用来指定关闭一个方向的数据传送。</li><li><strong><font color='orange'>使用 shutdown 关闭读后，缓冲区的所有数据都被丢弃，而且后续收到的数据会<u>先被确认</u>然后悄然丢弃，不会返回 RST。</font></strong></li><li><strong><font color='orange'>shutdown 的 SHUT_WR 不管套接字的引用计数是否为 0，直接发起挥手。</font></strong></li></ul><p><img src="/2022/img/IMG_0580(20230407-134909)-1681295358001-1.png" alt=""></p><h3 id="font-color-red-地址转换函数-font"><font color='red'>地址转换函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">    若字符串有效,则返回二进制值,无效则返回<span class="title function_">INADDR_NONE</span><span class="params">(其值为<span class="number">-1</span>)</span></span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值。32 位说明它只能用于 IPv4 地址转换。该函数不能处理 <code>255.255.255.255</code> ，详细原因参见《UNP》P67；另外，此函数已经被废弃，最好不再使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="keyword">struct</span> in_addr *addr)</span></span><br><span class="line">    若字符串有效,则返回1,否则返回0</span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值并保存在 addr 结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span> <span class="params">(<span class="keyword">struct</span> in_addr addr)</span></span><br></pre></td></tr></table></figure><p>将 32 位的网络字节序二进制值转换为点分十进制字符串。<strong><font color='orange'>注意，<u>inet_ntoa() 是不可重入的</u>，该函数返回的字符串是储存在静态内存中的，第二次调用该函数时将覆盖之前的结果。因此，当我们通过该函数的返回值取得字符串后必须马上转移到其他地方储存。</font></strong><br><img src="/2022/img/image-20230415204033411.png" alt=""></p><blockquote><p>关于重入问题，参见<a href="https://jyx-fyh.github.io/2023/04/15/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5/">什么是不可重入</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> * str, <span class="type">void</span> * addr)</span></span><br><span class="line">    成功则返回1,若str不是有效表达式则返回0,失败则-1</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，因此第三个参数为 void*，因为实参既可以为 in_addr 也可以为 in6_addr 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntop</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> * addr, <span class="type">char</span> * str, <span class="type">socklen_t</span> len)</span></span><br><span class="line">    成功则返回字符串指针,否则返回<span class="literal">NULL</span>,并置errno为ENOSPC</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，将网络字节序二进制值转换为点分十进制字符串。其中 str 不能为 NULL，其必须为 str 分配空间并指定大小。这个大小可使用 <code>&lt;netinet/in.h&gt;</code> 中的宏指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure><p><strong>第二个参数 addr 的结构体类型为 <code>in_addr</code> 或 <code>in6_addr</code></strong> ，后面有例子。</p><blockquote><p>另外，<code>inet_pton</code> 和 <code>inet_ntop</code> 总是可重入的，应尽量使用 <code>inet_ntop</code> 来代替 <code>inet_ntoa</code></p></blockquote><h3 id="font-color-red-getsockname与getpeername-font"><font color='red'>getsockname与getpeername</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *local_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *peer_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line">    成功返回0,否则-1</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>参数 len 是值-参数类型（既做参数，也储存返回值），作为返回值时，传递实际地址结构体的大小</font></strong> 。什么是实际地址结构体？是这样的：当你 getpeername 时，你不知道对面是 IPv4 还是 IPv6，如果此时你将 <code>sockaddr_in</code> 类型（IPv4）的结构体作为第二个参数，len 为 <code>sockaddr_in</code> 的长度，那么问题来了——万一对方是 IPv6 ，那这个 <code>sockaddr_in</code> 就无法完全存储 <code>sockaddr_in6</code> ，一部分会被截断。同时，len 被修改为 <code>sockaddr_in6</code> 的大小。如何解决这个问题呢？很简单，<strong><font color='orange'>使用通用结构 <code>sockaddr_storage</code> 来储存实际地址结构体，它能够承载任何套接字地址结构，因此不会被截断</font></strong> 。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">saddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>* <span class="title">pinaddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span>* <span class="title">pin6addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"><span class="type">int</span> ret = getpeername(sock, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;getpeername err\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET)</span><br><span class="line">&#123;</span><br><span class="line">    pinaddr = (<span class="keyword">struct</span> sockaddr_in*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv4:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pinaddr-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%u\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET6)</span><br><span class="line">&#123;</span><br><span class="line">    pin6addr = (<span class="keyword">struct</span> sockaddr_in6*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv6:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pin6addr-&gt;sin6_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%ud\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下理由需要这两个函数：</p><ul><li>客户端一般不调用 bind，端口和地址都在 connect 时由内核分配，所以需要通过 getsockname 获得本端信息。</li><li>服务器端经常绑定通配地址 <code>INADDR_ANY</code> ，所以需要使用 getsockname 来确定本端绑定的地址。<strong><font color='orange'>注意，上文说过，当绑定通配地址时，监听套接字的最终绑定结果是在收到对端发来 SYN 报文后才确定的，所以此时 getsockname 的作用对象只能是已连接套接字，而不能是监听套接字。</font></strong></li><li><strong><font color='orange'>如果一个服务器程序是由执行过 accept 的某个进程调用 exec 而得到，那么这个服务器程序只能通过 getpeername 来获取对端信息</font></strong> 。inetd 派生 Telnet 服务器就是这样的情况：<br><img src="/2022/img/IMG_0585(20230415-212627).PNG" alt=""></li></ul><h3 id="font-color-red-字节序转换函数-font"><font color='red'>字节序转换函数</font></h3><p>为了避免在不同字节序主机之间传送数据时发生数据解释错乱，网络传输统一使用大端字节序，即高位数据在低字节，低位数据在高字节。因此，传送数据前我们必须使用以下函数对数据转换字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line">    net to host,将网络字节序转为主机字节序</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line">    host to net,将主机字节序转为网络字节序</span><br></pre></td></tr></table></figure><p>应该有初学者会疑惑，似乎这几个函数只在绑定端口和 IP 时才使用，其他时候几乎没有用，这是为什么？难道传输数据时，网络栈会自动将我们的数据转换为网络序？这个问题也困惑了我好些时候，详细请移步<a href="">网络字节序及其注意事项</a>。</p><h3 id="font-color-red-其他问题-font"><font color='red'>其他问题</font></h3><p><strong><mark class="hl-label blue">bind为什么将 sockaddr_in* 转换为 sockaddr*</mark> </strong></p><p><strong><font color='orange'>为了实现“多态”，即，使用 bind 函数处理多种协议类型。</font></strong></p><p><code>sockaddr_in</code> 是 IPv4 套接字地址结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族，一般为AF_INET</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">// 端口号，网络字节序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4地址，网络字节序</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];        <span class="comment">// 未使用，填充0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大小为16字节</span></span><br></pre></td></tr></table></figure><p><code>sockaddr</code> 是通用套接字地址结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;    <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];         <span class="comment">// 具体地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大小为16字节</span></span><br></pre></td></tr></table></figure><p>实现多态的关键在于 <code>sa_family</code> 成员。所有类型的套接字结构体都保证 <code>sa_family</code> 成员在最前面，这样即使转换后也能正确地获取地址族类型。同时，bind 的第三个参数 len 也很重要，<strong><u>系统调用将第二个参数 sockaddr* 指针指向的 len 大小的数据传入内核空间</u></strong> 。这样，内核有了正确的地址族类型和完整的地址信息，就可以针对各种不同协议类型进行套接字绑定。</p><p>你可能和我一样，认为 len 参数有些鸡肋，因为内核完全可以根据 sa_family 确定地址族，而地址族一确定，相应的套接字地址结构体大小就能确定，比如 sa_family 若为 AF_INET，那么就能判断传入的结构体一定是 sockaddr_in 。那为什么还有专门传入 len 呢？实际上，我们设想的前提就有错，<strong><font color='orange'>地址族确定并不代表套接字地址结构体就能确定，比如 UNIX 域结构和数据链路结构就是可变长度的（如下图）</font></strong> 。因此，为了向内核传入正确、完整的结构体信息，就必须手动传入 len 。<br><img src="/2022/img/AF42B09F2B4C386B42D377D97AB95965.png" alt=""></p><p>另外，我们在前文中也提到了图中的 <code>sockaddr_storage</code> 结构体，<strong>它能够承载任意大小的地址结构体，并满足某些地址结构体的对齐需要</strong> ，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> ss_family;      <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __ss_align;   <span class="comment">// 对齐要求</span></span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span> - <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)];  <span class="comment">// 填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 ss_family 成员，其他两个成员对用户透明。</p><p>最后笔者仍有一个问题：为什么 <code>sockaddr_in</code> 有一个 8 字节的填充？历史原因？效率问题？目前没有找到一套“自圆其说”的说法。</p>]]></content>
    
    
    <summary type="html">Socket网络编程重点</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
