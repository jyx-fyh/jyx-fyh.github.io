<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极简</title>
  
  <subtitle>用时间去沉淀</subtitle>
  <link href="http://jyxcpp.netlify.app/atom.xml" rel="self"/>
  
  <link href="http://jyxcpp.netlify.app/"/>
  <updated>2023-09-10T11:39:52.353Z</updated>
  <id>http://jyxcpp.netlify.app/</id>
  
  <author>
    <name>极简</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://jyxcpp.netlify.app/2023/09/09/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://jyxcpp.netlify.app/2023/09/09/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-09T10:49:01.000Z</published>
    <updated>2023-09-10T11:39:52.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：<a href="https://www.zhihu.com/question/24637339/answer/84079774">知乎-冒泡</a> 、<a href="https://zh.wikipedia.org/zh-cn/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">wiki</a> 、chatGPT、<a href="https://www.zhihu.com/question/24637339/answer/3159556193">知乎-helloCode</a></p></blockquote><p>希尔排序是一种不稳定排序算法，最坏复杂度为 O(N^2^) ，但它是插入排序的改进版本，是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，<strong><font color='orange'>因为插入排序每次只能将数据移动一位，即每次只能消除一个逆序对</font></strong></li></ul><blockquote><p><strong><u>假设我们要从小到大排序，一个数组中取两个元素如果前面比后面大，则为一个逆序，容易看出排序的本质就是消除逆序数，可以证明对于随机数组，逆序数是O(N^2^) 的，而如果采用交换相邻元素的办法来消除逆序，每次正好只消除一个，因此必须执行O(N^2^)的交换次数，这就是为啥冒泡、选择、插入等算法只能到平方级别的原因，反过来，基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，使得一次交换能消除一个以上的逆序，希尔、快排、堆排等等算法都是交换比较远的元素，只不过规则各不同罢了。</u></strong><br>——引自<a href="https://www.zhihu.com/question/24637339/answer/84079774">知乎-冒泡</a></p><p>这段总结真是醍醐灌顶！！！不过有个问题，插入排序并非交换相邻元素，为什么其复杂度仍为 O(N^2^) 呢？</p></blockquote><p>那么希尔排序是如何进行的呢？概括其思路： <strong>先将数组分为多个（不连续）小数组，对每个小数组排序（以尽可能多地消除逆序对），从而使大数组相对有序，最终对整个数组进行插入排序，而此时数组已经大概有序了，插入排序就能高效地进行</strong> 。看以下图解：<br><img src="/2022/img/v2-e7da344ba84144f716e7e0cb87148f13_1440w.webp" alt="本图引自知乎-土豆"></p><p>第一次步长为 7，那么一次交换就可能消除最多 7 个逆序对！这或许就是比插入排序更高级的原因吧。下面直接给出 C++ 描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> cmptor&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T* vec, <span class="type">int</span> len, cmptor cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> g = <span class="number">0</span>; g &lt; gap; g++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//insert sort</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = g+gap; i &lt; len; i += gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k -= gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k-gap &gt;= <span class="number">0</span> &amp;&amp; !<span class="built_in">cmp</span>(vec[k-gap], vec[k]))</span><br><span class="line"><span class="built_in">swap</span>(vec[k-gap], vec[k]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color='orange'>步长=组数！见上示意图</font></strong></li><li><strong><font color='orange'>i 相当于每组的起始下标</font></strong></li><li><strong><font color='orange'>8 行后参见<a href="https://jyx-fyh.github.io/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">插入排序</a></font></strong></li><li><strong><font color='red'>第 13 行务必检查下标是否越界！！！</font></strong></li></ul><p>另外，这里我们的步长 gap 每次递减 1/2 ，实际上这并不高效。<strong><font color='orange'>步长的选择是希尔排序的重要部分，将直接影响最终的排序效率！</font></strong> 常用步长序列有以下几种：常用的步长序列有以下几种：</p><ol><li>希尔原始序列：希尔最初提出的间隔序列是使用 n/2 作为初始间隔，然后每次缩小一半，直到间隔为 1 。</li><li>Hibbard 序列：Hibbard 序列使用 2^k - 1 作为间隔，其中 k 从初始间隔递减到 1 。例如，对于数组长度为 n 的序列，Hibbard 序列为1, 3, 7, 15, …, 2^k - 1。</li><li>Sedgewick 序列：Sedgewick 序列是由 Robert Sedgewick 提出的一种间隔序列。它结合了希尔原始序列和 Hibbard 序列的优点，并且在实践中表现良好。Sedgewick 序列的具体定义较为复杂，可以参考相关文献进行了解。</li></ol><p><strong>优点</strong></p><ol><li>相对于传统的插入排序，希尔排序通过将元素分组进行排序，减少了逆序对的数量，从而加快了排序过程。</li><li>希尔排序是原地排序算法，只需在原始数组上进行元素的交换和移动，不需要额外的辅助空间。</li></ol><p><strong>缺点</strong></p><ol><li>希尔排序的最坏情况时间复杂度并不稳定，通常在 O(N^2^) 到 O(NlogN) 之间。虽然平均情况下性能较好，但在某些特定情况下，性能可能不如其他高级排序算法。</li><li>步长序列的选择对性能产生影响，选择不当可能导致排序效率下降。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://jyxcpp.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://jyxcpp.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="数据结构与算法" scheme="http://jyxcpp.netlify.app/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>入坑vim</title>
    <link href="http://jyxcpp.netlify.app/2023/09/07/%E5%85%A5%E5%9D%91vim/"/>
    <id>http://jyxcpp.netlify.app/2023/09/07/%E5%85%A5%E5%9D%91vim/</id>
    <published>2023-09-07T08:10:10.000Z</published>
    <updated>2023-09-12T10:56:03.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th><font color='red'>插入文本</font></th><th></th></tr></thead><tbody><tr><td>vim -R filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>i</td><td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td></tr><tr><td>I</td><td>在光标所在行的行首插入随后输入的文本</td></tr><tr><td>o</td><td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td></tr><tr><td>O</td><td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td></tr><tr><td>a</td><td>在当前光标所在位置之后插入随后输入的文本</td></tr><tr><td>A</td><td>在光标所在行的行尾插入随后输入的文本</td></tr></tbody></table><table><thead><tr><th><font color='red'>查找文本</font></th><th></th></tr></thead><tbody><tr><td>/abc</td><td>从光标所在位置向前查找字符串 abc</td></tr><tr><td>/^abc</td><td>查找以 abc 为行首的行 <strong>（^表示行首）</strong></td></tr><tr><td>/abc$</td><td>查找以 abc 为行尾的行 <strong>（$表示行尾）</strong></td></tr><tr><td>?abc</td><td>从光标所在为主向后查找字符串 abc</td></tr><tr><td>n</td><td>向同一方向重复上次的查找指令</td></tr><tr><td>N</td><td>向相反方向重复上次的查找指定</td></tr><tr><td>:set ic</td><td>忽略大小写</td></tr><tr><td>:set noic</td><td>不忽略大小写</td></tr></tbody></table><table><thead><tr><th><font color='red'>替换文本</font></th><th></th></tr></thead><tbody><tr><td>r</td><td>替换光标所在位置的字符</td></tr><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td>:s/a1/a2/g</td><td>将当前光标所在行中的所有 a1 用 a2 替换</td></tr><tr><td>:n1,n2s/a1/a2/g</td><td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td></tr><tr><td>:%s/a1/a2/</td><td>将文件中所有的 a1 都用 a2 替换</td></tr></tbody></table><table><thead><tr><th><font color='red'>删除文本</font></th><th></th></tr></thead><tbody><tr><td>x</td><td>删除光标所在位置的字符</td></tr><tr><td>X</td><td>删除光标前一个位置字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除当前行（包括此行）后 n 行文本</td></tr><tr><td>dG</td><td>删除光标所在行一直到文件末尾的所有内容</td></tr><tr><td>D</td><td>删除光标位置到行尾的内容</td></tr><tr><td>:a1,a2d</td><td>函数从 a1 行到 a2 行的文本内容</td></tr></tbody></table><blockquote><p>被删除的内容都放在了剪贴板中，按下 “p” 键粘贴。</p></blockquote><table><thead><tr><th><font color='red'>复制文本</font></th><th></th></tr></thead><tbody><tr><td>p</td><td>将剪贴板中的内容粘贴到光标后</td></tr><tr><td>P</td><td>将剪贴板中的内容粘贴到光标前</td></tr><tr><td>y</td><td>复制已选中的文本到剪贴板</td></tr><tr><td>nyy</td><td>将从光标所在行及其以下共 n 行复制到剪切板</td></tr><tr><td>yy</td><td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td></tr><tr><td>yw</td><td>将光标位置的单词复制到剪贴板</td></tr><tr><td>: n,m y</td><td>将 n 到 m 行复制到剪切板</td></tr></tbody></table><table><thead><tr><th><font color='red'>撤销操作</font></th><th></th></tr></thead><tbody><tr><td>u</td><td>撤销上一次操作</td></tr><tr><td>ctrl + r</td><td>反撤销</td></tr><tr><td>U</td><td>第一次会撤销对光标所在行文本做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。</td></tr></tbody></table><table><thead><tr><th><font color='red'>移动光标</font></th><th></th></tr></thead><tbody><tr><td>h</td><td>左移</td></tr><tr><td>j</td><td>下移（j 像下箭头）</td></tr><tr><td>k</td><td>上移</td></tr><tr><td>l</td><td>右移</td></tr><tr><td>w 或 W</td><td>光标移动至下一个单词的单词首</td></tr><tr><td>b 或 B</td><td>光标移动至上一个单词的单词首</td></tr><tr><td>e 或 E</td><td>光标移动至下一个单词的单词尾</td></tr><tr><td>fx</td><td>光标移动至当前行中下一个 x 字符处</td></tr><tr><td>Fx</td><td>光标移动至当前行中上一个 x 字符处</td></tr><tr><td>gg</td><td>光标移动到文件开头</td></tr><tr><td>G</td><td>光标移动至文件末尾</td></tr><tr><td>:n</td><td>可以将光标快速定义到指定行的行首</td></tr><tr><td>0</td><td>光标移到行首非空白字符处</td></tr><tr><td>$</td><td>光标移到行尾非空白字符处</td></tr></tbody></table><table><thead><tr><th><font color='red'>可视化模式</font></th><th></th><th></th></tr></thead><tbody><tr><td>v</td><td>字符可视化模式，此模式下目标文本的选择以字符为单位</td><td></td></tr><tr><td>V</td><td>行可视化模式，此模式化目标文本的选择以行为单位</td><td></td></tr><tr><td>Ctrl+shift+v</td><td>块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本</td><td></td></tr></tbody></table><table><thead><tr><th><font color='red'>多窗口模式</font></th><th></th></tr></thead><tbody><tr><td>:sp filename</td><td>横向窗口</td></tr><tr><td>:vs filename</td><td>竖向窗口</td></tr><tr><td>ctrl+ww</td><td>切换窗口</td></tr><tr><td>:q</td><td>关闭该窗口</td></tr></tbody></table><table><thead><tr><th><font color='red'>注释</font></th><th></th></tr></thead><tbody><tr><td>:line1,line2 s/^/#/g</td><td>在line1到line2的行首添加&quot;#&quot;注释符</td></tr><tr><td>:line1,line2 s/^#//g</td><td>在line1到line2的行首去掉&quot;#&quot;注释符</td></tr><tr><td>:line1,line2 s/^////g</td><td>在line1到line2的行首添加&quot;//&quot;注释符（特殊字符须转义）</td></tr></tbody></table><blockquote><p>可见添加 <code>//</code> 注释符是异常麻烦的事，为此我们有以下两种快捷方式：<br><strong>1、单行注释快捷键映射</strong><br>在 home 目录下的 .vimrc 配置文件中定义快捷键：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-m&gt;</span> I//<span class="symbol">&lt;Esc&gt;</span> </span><br><span class="line">将 ctrl+<span class="keyword">m</span> 映射为 I//<span class="symbol">&lt;Esc&gt;</span> ,其中I进入INSERT模式并在行首插入文本,插入//后退出编辑模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-k&gt;</span> :s/^\/\///g<span class="symbol">&lt;Esc&gt;</span></span><br><span class="line">去除行首的//注释符</span><br></pre></td></tr></table></figure><p><strong>2、多行注释函数</strong><br>在 home 目录下的 .vimrc 配置文件中定义以下函数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">COM</span><span class="params">(b1, b2)</span></span><br><span class="line"> <span class="keyword">execute</span> <span class="variable">a:b1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">a:b2</span>.<span class="string">&#x27;s/^/\/\//g&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">DCOM</span><span class="params">(b1, b2)</span></span><br><span class="line"> <span class="keyword">execute</span> <span class="variable">a:b1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">a:b2</span>.<span class="string">&#x27;s/^\/\///g&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>其中 <code>COM(b1,b2)</code> 功能是为 b1 到 b2 行的行首添加 // 注释符，<code>DCOM(b1,b2)</code> 反之。以下几点供大家了解：</p><ul><li>调用函数的方式为：<code>:CALL COM(X1,X2)</code></li><li>函数名可以自定义，但首字母必须大写</li><li>函数内部使用参数时，参数名前必须有 <code>a:</code> ，这是在表明作用域</li><li>execute 函数用来执行命令（命令行模式）</li><li><code>.</code> 是连接符</li></ul><p><strong><font color='orange'>多插一句，编写此类脚本语言，多使用 chatGPT，甚是方便！</font></strong></p></blockquote><table><thead><tr><th><font color='red'>文件配置</font></th><th></th></tr></thead><tbody><tr><td>:set nu<br />:set nonu</td><td>设置与取消行号</td></tr><tr><td>:syn on<br />:syn off</td><td>是否依据语法显示相关的颜色</td></tr><tr><td>set hlsearch<br />set nohlsearch</td><td>设置是否将査找的字符串高亮显示</td></tr><tr><td>set autoindent</td><td>设置自动缩进，即每行的缩进同上一节相同</td></tr><tr><td>set tabstop=4</td><td>设置 Tab 键宽度为 4 个空格， <strong>强烈建议</strong></td></tr><tr><td>set mouse=a<br />set selection=exclusive<br />set selectmode=mouse,key</td><td>Vim 编辑器里默认是不启用鼠标的，通过此设置即可启动鼠标。</td></tr></tbody></table><blockquote><p>用户配置文件位于主目录 ~/.vimrc</p></blockquote><table><thead><tr><th><font color='red'>文件备份</font></th><th></th></tr></thead><tbody><tr><td>: set backup</td><td>备份该文件到指定目录</td></tr><tr><td>set backupdir=指定目录</td><td>在 .vimrc 中设置备份文件的保存目录</td></tr><tr><td>: w filename</td><td>将当前文件保存到 filename 文件</td></tr></tbody></table><table><thead><tr><th><font color='red'>执行外部命令</font></th><th></th></tr></thead><tbody><tr><td>!!命令（normal模式下）</td><td>执行命令并将输出结果写入到光标位置</td></tr></tbody></table><table><thead><tr><th><font color='red'>其他</font></th><th></th></tr></thead><tbody><tr><td>J</td><td>合并本行和下一行文本</td></tr><tr><td>ctrl+z 和 fg</td><td>使用 ctrl+z 挂起当前窗口，fg 命令快速返回此窗口</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">vim快捷键</summary>
    
    
    
    <category term="工具" scheme="http://jyxcpp.netlify.app/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vim" scheme="http://jyxcpp.netlify.app/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>C++模板问题小记</title>
    <link href="http://jyxcpp.netlify.app/2023/09/05/%E5%90%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BC%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <id>http://jyxcpp.netlify.app/2023/09/05/%E5%90%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BC%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-09-05T08:22:19.000Z</published>
    <updated>2023-09-09T06:55:47.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写排序函数时遇到一个关于模板的问题，有一定记录价值。需求如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* vec, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> function&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortTester</span><span class="params">(function fun)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 mySort 是我自己编写的排序函数，vec 是数组，len 是数组长度；sortTester 是对数器，用来生成随机样例来检测传入的排序函数，参数 fun 为我们要传入并检测的函数。</p><p>当我想当然地进行如下调用时，编译器报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sortTester</span>(mySort);</span><br></pre></td></tr></table></figure><p>这是很容易犯的一种错误，其实稍加思索后就能发现问题所在： <strong>sortTester 的参数类型 function 是一个模板类型，而传入的参数 mySort 是一个函数模板，所以 sortTester 当然就无法进行函数类型推断，因而报错。所以我们必须传入一个确定的函数类型，而非函数模板，即，将函数模板实例化。</strong></p><p>有下面两种方式将函数模板实例化（这里实例化为 int ）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">auto</span> funcPtr = mySort&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="built_in">sortTester</span>(funcPtr);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="built_in">sortTester</span>([](<span class="type">int</span>* arr, <span class="type">int</span> len)&#123;<span class="built_in">mySort</span>(arr, len);&#125;);</span><br></pre></td></tr></table></figure><p>尤其是第二种 lambda 方式值得学习！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://jyxcpp.netlify.app/categories/C/"/>
    
    
    <category term="C++" scheme="http://jyxcpp.netlify.app/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>23天英语背诵</title>
    <link href="http://jyxcpp.netlify.app/2023/07/22/23%E5%A4%A9%E8%8B%B1%E8%AF%AD%E8%83%8C%E8%AF%B5/"/>
    <id>http://jyxcpp.netlify.app/2023/07/22/23%E5%A4%A9%E8%8B%B1%E8%AF%AD%E8%83%8C%E8%AF%B5/</id>
    <published>2023-07-22T10:39:08.000Z</published>
    <updated>2023-07-22T12:10:31.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-引言-font"><strong><font color='red'>引言</font></strong></h2><p>大学已经过了两年，这期间好几次下定决心学好英语，然而每次都半途而废。</p><h2 id="font-color-red-DAY-1-font"><font color='red'>DAY 1 </font></h2><p><strong>Reach the goals  必须达成目标</strong></p><ol><li><p>My life has been a trade-off.</p><p>我的人生是一场交易。</p></li><li><p>If I wanted to reach the goals I set for myself, I had to get at it and stay at it everyday.</p><p>如果我想达到我给自己设定的目标，就必须每天为之奋斗，坚持不懈。</p></li><li><p>I had to think about it all the time.</p><p>必须时刻把它放在心上。</p></li><li><p>I had to get up everyday with my mind set on improving something.</p><p>我每天一起床，脑子里就想着要去改进些什么。</p></li><li><p>I was driven by a desire to always be on the top of the heap.</p><p>我一直被一种想要追求卓越的渴望驱策着。</p></li></ol><hr><h2 id="font-color-red-DAY-2-font"><strong><font color='red'>DAY 2</font></strong></h2><p><strong>Mean something  成为举足轻重的人，而不是废物</strong></p><ol><li><p>I want to do good.</p><p>我想做好的事情。</p></li><li><p>I want the world to be better because I was here.</p><p>我要这个世界因为我而变得更好。</p></li><li><p>I want my life, my work, and my family to mean something.</p><p>我想让我的生活、工作和家庭都因为我而变得更有意义。</p></li><li><p>If you’re not making someone else’s life better then you’re wasting your time.</p><p>如果你没有给他人的生活带来改变，那你就是在浪费自己的时间！</p></li><li><p>Your life will become better by making other lives better.</p><p>改善他人的生活，你的生活也会变得更好！</p></li><li><p>I want to represent an idea.</p><p>我想要再现一种理念。</p></li><li><p>I want to represent possibilities.</p><p>我想再现人生的各种可能性。</p></li><li><p>I want to represent the idea that you really can make what you want.</p><p>我想再现的理念是，你真的可以做成你想要的东西！</p></li></ol><hr><h2 id="font-color-red-DAY-3-font"><strong><font color='red'>DAY 3</font></strong></h2><p><strong>Protect your dream  捍卫你的梦想</strong></p><ol><li><p>Don’t ever let someone tell you that you can’t do something.<br>不要让任何人告诉你，你做不成事。</p></li><li><p>Not even me.<br>即便是我也不行。</p></li><li><p>You got a dream, you gotta protect it.<br>如果你有梦想，你要保护它。</p></li><li><p>When people can’t do something themselves, they’re gonna tell you that you can’t do it.<br>当人们自己做不到的时候，他们会说你也成不了大器。</p></li><li><p>You want something, go get it.<br>如果你要什么，去得到它。</p></li><li><p>Period.<br>绝不迟疑。</p></li></ol><hr><h2 id="font-color-red-DAY-4-font"><strong><font color='red'>DAY 4</font></strong></h2><p><strong>Good artists copy, great artists steal.  优秀者模仿，伟大者剽窃。</strong></p><ol><li><p>How do you know what’s the right direction?<br>你怎么知道哪个方向是正确的？</p></li><li><p>Ultimately it comes down to taste.<br>其实归根到底是品位的问题。</p></li><li><p>It comes down to taste.<br>那终究是品味问题。</p></li><li><p>It’s a matter of trying to expose yourself to the best things that humans have done.<br>你要尽量让自己接触到这个世界上最优秀的事物。</p></li><li><p>And then try to bring those things into what you are doing.<br>并把它运用到自己的工作中去。</p></li><li><p>Picasso had a saying, “Good artists copy, great artists steal.”<br>毕加索说过，“优秀者模仿, 伟大者剽窃。”</p></li><li><p>We have always been shameless about stealing great ideas.<br>当我们剽窃别人的卓越的创意的时候，从不觉得羞愧。</p></li></ol><hr><h2 id="font-color-red-DAY-5-font"><strong><font color='red'>DAY 5</font></strong></h2><p><strong>Failed over and over and over again 一次一次又一次的失败</strong></p><p>【1】I’ve missed more than 9000 shots in my career.</p><p>我的职业生涯投篮失误超过9000次。</p><p>【2】I’ve lost almost 300 games.</p><p>我输了大约300场比赛。</p><p>【3】26 times I’ve been trusted to take the game winning shot and missed.</p><p>有26次我被委以重任投制胜一球，但失手了。</p><p>【4】I’ve failed over and over and over again in my life.</p><p>我这一生，一次一次又一次失败。</p><p>【5】And that is why I succeed.</p><p>那就是我为什么能够成功的原因。</p><hr><h2 id="font-color-red-DAY-6-font"><strong><font color='red'>DAY 6</font></strong></h2><p><strong>Pushing through the pain 穿越痛苦</strong></p><ol><li><p>As a magician, I try to create images that make people stop and think.<br>作为一个魔术师，我总是尝试去创造一个现象，可以让人们驻足思考。</p></li><li><p>I also try to challenge myself to do things that doctors say are not possible.<br>我也试着挑战自己，做一些医生看来不可能的事情。</p></li><li><p>As a magician, I try to show things to people that seem impossible.<br>作为一个魔术师，我试着展示一些东西，那些看似不可能的事。</p></li><li><p>And I think magic, whether I’m holding my breath or shuffling a deck of cards, is pretty simple.<br>我认为魔术，不管是水下屏气，还是捣鼓一副纸牌，道理都很简单。</p></li><li><p>It’s practice, it’s training.<br>就是练习，训练。</p></li><li><p>And It’s practice, it’s training and experimenting, while pushing through the pain to be the best that I can be.<br>就是练习，训练，以及不断尝试。去强忍过那些极痛苦的时刻，做自己能做的一切。</p></li><li><p>And that’s what magic is to me, so, thank you. (Applause)<br>这就是魔术对于我的意义。谢谢你们。（掌声）</p></li></ol><hr><h2 id="font-color-red-DAY-7-font"><strong><font color='red'>DAY 7</font></strong></h2><p><strong>nasty place 残酷世界</strong></p><p>以下是按照第二篇格式修改后的文章：</p><ol><li><p>Then the time come for you to be your own man and take on the world and you did.<br>然后就是你自己奋斗的人生了，自己去承担自己的事情，你也确实做得很好。</p></li><li><p>But somewhere along the line, you changed.<br>但是有些时候，你变了。</p></li><li><p>You stopped being you.<br>你不再是你。</p></li><li><p>You let people stick a finger in your face and tell you you’re no good.<br>你让别人指着你的脸说你不好。</p></li><li><p>And when things got hard, you started looking for something to blame like a big shadow.<br>而且遇到不顺心的事时，你开始怪罪于其他事情，就像巨大的阴影。</p></li><li><p>Let me tell you something you already know.<br>让我告诉你一些你已经知道的事。</p></li><li><p>The world ain’t all sunshine and rainbows.<br>这世界不完全是阳光和彩虹。</p></li><li><p>It’s a very mean and nasty place, and I don’t care how tough you are…<br>这是一个非常刻薄艰险的世界，我不在乎你是多么坚强……</p></li><li><p>It will beat you to your knees and keep you there permanently if you let it.<br>如果你屈服的话，它会永远把你打趴下的。</p></li></ol><hr><h2 id="font-color-red-DAY-8-font"><strong><font color='red'>DAY 8</font></strong></h2><p><strong>hit 打击</strong></p><ol><li><p>You, me or nobody is gonna hit as hard as life.<br>你，我，没人能够击打得比生活还重。</p></li><li><p>But it ain’t about how hard you hit.<br>但是这并不在于你击打得多重。</p></li><li><p>It’s about how hard you can get hit and keep moving forward.<br>而在于无论你被击打的有多重，但却能继续向前。</p></li><li><p>How much you can take and keep moving forward.<br>你能承受多少，并且继续前进。</p></li><li><p>That’s how winning is done!<br>这才是真正的胜利。</p></li><li><p>If you know what you’re worth, go and get what you’re worth.<br>如果你知道你的价值，那么就前进，去实现你的价值。</p></li><li><p>But you gotta be willing to take the hits, and not pointing fingers saying you ain’t where you wanna be, because of him or her or anybody!<br>但是你必须乐意承受打击，而不是没能实现目标时却指着别人说，是因为他或她的原因。</p></li><li><p>Cowards do that, and that ain’t you!<br>懦夫才会那么做，你不是！</p></li><li><p>You’re better than that!<br>你远比那个出色！</p></li></ol><hr><h2 id="font-color-red-DAY-9-font"><strong><font color='red'>DAY 9</font></strong></h2><p><strong>Will you fight?</strong></p><ol><li><p>I am William Wallace.<br>我是威廉华莱士。</p></li><li><p>And I see a whole army of my countrymen here in defiance of tyranny.<br>我看到我族组成的军队向暴政宣战。</p></li><li><p>You’ve come to fight as free men.<br>你们来到这里作为自由人参战。</p></li><li><p>And free men you are.<br>你们确实是自由人。</p></li><li><p>What will you do with that freedom?<br>你们如何对待自由？</p></li><li><p>Will you fight?<br>你们愿意作战吗？</p></li><li><p>Fight, and you may die.<br>作战，你们可能会死。</p></li><li><p>Run, and you’ll live … at least awhile.<br>逃走，你会活着……至少一阵子。</p></li><li><p>And dying in your beds many years from now.<br>几年后在床上老死。</p></li><li><p>Would you be willing to trade all the days from this day to that.<br>你们是否愿意用所有的这些日子来换取。</p></li><li><p>For one chance, just for one chance.<br>为了一个机会，仅仅为了一个机会。</p></li><li><p>To come back here and tell our enemies that they may take our lives,<br>回到这里，告诉我们的敌人他们或许会夺走我们的生命，</p></li><li><p>But they’ll never take our freedom!<br>但他们永远夺不走我们的自由！</p></li></ol><hr><h2 id="font-color-red-DAY-10-font"><strong><font color='red'>DAY 10</font></strong></h2><p><strong>Never surrender</strong></p><ol><li><p>We shall not flag or fail.<br>我们绝不投降，也不会失败。</p></li><li><p>We shall go on to the end.<br>我们将战斗到底。</p></li><li><p>We shall fight in France.<br>我们将在法国作战。</p></li><li><p>We shall fight on the seas and oceans.<br>我们将在海洋中作战。</p></li><li><p>We shall fight with growing confidence and growing strength in the air.<br>我们将以越来越大的信心和越来越强的力量在空中作战。</p></li><li><p>We shall defend our island, whatever the cost may be.<br>我们将不惜一切代价保卫本土。</p></li><li><p>We shall fight on the beaches.<br>我们将在海滩作战。</p></li><li><p>We shall fight on the landing grounds.<br>我们将在敌人的登陆点作战。</p></li><li><p>We shall fight in the fields and in the streets.<br>我们将在田野和街头作战。</p></li><li><p>We shall fight in the hills.<br>我们将在山区作战。</p></li><li><p>We shall never surrender.<br>我们绝不投降。</p></li></ol><hr><h2 id="font-color-red-DAY-11-font"><strong><font color='red'>DAY 11</font></strong></h2><p><strong>Without victory, there is no survival 没有胜利，无法生存</strong></p><ol><li><p>I would say to the House, as I said to those who have joined this government: “I have nothing to offer but blood, toil, tears and sweat.”<br>正如我曾对参加本届政府的成员所说的那样，我要向下院说：“我没什么可以奉献，有的只是热血、辛劳、眼泪和汗水。”</p></li><li><p>We have before us an ordeal of the most grievous kind.<br>摆在我们面前的，是一场严峻的极为痛苦的考验。</p></li><li><p>We have before us many, many long months of struggle and of suffering.<br>在我们面前，有许多许多漫长的斗争和苦难的岁月。</p></li><li><p>You ask, what is our policy?<br>你们问：我们的政策是什么？</p></li><li><p>I will say: It is to wage war, by sea, land and air, with all our might, with all the strength that God has given us; to wage war against a monstrous tyranny, never surpassed in the dark, and lamentable catalogue of human crime.<br>我要说，我们的政策就是用我们全部能力，用上帝所给予我们的全部力量，在海上、陆地和空中进行斗争，同一个在人类黑暗悲惨的罪恶史上从未有过的穷凶极恶的暴政进行斗争。</p></li><li><p>That is our policy.<br>这就是我们的政策。</p></li><li><p>You ask, what is our aim?<br>你们问：我们的目标是什么？</p></li><li><p>I can answer in one word: victory.<br>我可以用一个词来回答：胜利。</p></li><li><p>Victory at all costs, victory in spite of all terror, victory, however long and hard the road may be.<br>不惜一切代价，去赢得胜利；无论多么可怕，也要赢得胜利，无论道路多么遥远和艰难，也要赢得胜利。</p></li><li><p>For without victory, there is no survival.<br>因为没有胜利，就没有生存。</p></li></ol><hr><h2 id="font-color-red-DAY-12-font"><strong><font color='red'>DAY 12</font></strong></h2><p><strong>It takes a strong man to save himself, and a great man to save another.</strong></p><p><strong>强者自救，圣者渡人</strong></p><ol><li><p>These walls are funny.<br>（监狱里的高墙）实在是很有趣。</p></li><li><p>First you hate them, then you get used to them.<br>刚入狱的时候你痛恨周围的高墙，慢慢地，你习惯了生活在其中；</p></li><li><p>Enough time passes, you depend on them. That’s institutionalized.<br>最终你会发现自己不得不依靠它而生存。这就是体制化。</p></li><li><p>I guess it comes down to a simple choice: get busy living or get busy dying.<br>生命可以归结为一种简单的选择：要么忙于生存，要么赶着去死。</p></li><li><p>In 1966, Andy Dufresne escaped from Shawshank Prison.<br>1966年，安迪.杜弗兰从肖申克监狱脱逃。</p></li><li><p>All they found (of him) was a muddy set of prison clothes, a bar of soap, and an old rock-hammer damn near worn down to the nub.<br>他们只发现了他的一套沾满泥浆的狱服，一条肥皂和一把磨得几乎只剩下把儿的石锤。</p></li><li><p>I remember thinking it would take a man six hundred years to tunnel through the wall with it. Old Andy did it in less than twenty.<br>我曾经想过一个人用这把锤头在墙上挖通隧道，需要花六百年，安迪用了不到二十年。</p></li></ol><hr><h2 id="font-color-red-DAY-13-font"><strong><font color='red'>DAY 13</font></strong></h2><p><strong>Lay this brick perfectly 砌好这块砖</strong></p><ol><li><p>One summer his dad tore down a brick wall in the front of his business and told 12-year-old Will and his 9-year-old brother to rebuild it.<br>一年夏天威尔的父亲推到了自家商店门前的一面墙，让12岁的威尔和他9岁的弟弟重建它。</p></li><li><p>A job they said was impossible.<br>他们认为这是一个不可完成的工作。</p></li><li><p>It took them a year and a half, but they did it.<br>那花了他们一年半的时间，但是，他们做到了。</p></li><li><p>And he said, “now don’t you ever tell me there’s something that you can’t do.”<br>威尔的父亲说，“那么，永远不要跟我说有什么事你做不到”。</p></li><li><p>You don’t set out to build a wall.<br>你不要想着去造一堵墙。</p></li><li><p>You don’t say, “I’m going to build the biggest, baddest, greatest wall that’s ever been built.”<br>不要想着说，我要造世界上最大，最厉害，最宏伟壮观的墙。</p></li><li><p>You don’t start there.<br>不要抱着这种态度开始。</p></li><li><p>You say, “I’m going to lay this brick as perfectly as a brick can be laid.”<br>你要说，我要砌好这块砖，砌的尽可能完美无缺。</p></li><li><p>You do that every single day.<br>你每天都要这样去做。</p></li><li><p>And soon you have a wall.<br>很快，你就有了一堵墙。</p></li></ol><hr><h2 id="font-color-red-DAY-14-font"><strong><font color='red'>DAY 14</font></strong></h2><p><strong>14.</strong> <strong>Do what you need to do 做你需要做的事情</strong></p><ol><li><p>I have a great time with my life, and I want to share it.<br>我的生命中有美好的时光，我想要分享。</p></li><li><p>I love living.<br>我爱生活。</p></li><li><p>I think that’s infectious, it’s something you can’t fake.<br>我认为那是有感染力的，那是无法伪装的。</p></li><li><p>Greatness is not this wonderful, esoteric elusive god-like feature that only special people possess.<br>伟大不是那么崇高辉煌、深奥难测、难以捉摸、上天钟爱的特质，不只是少数特别的人才具备。</p></li><li><p>It’s something that truly exists within all of us.<br>这种东西其实潜藏在我们每一个人身上。</p></li><li><p>It’s very simple.<br>它非常简单。</p></li><li><p>This is what I believe, and I’m willing to die for it.<br>这就是我的信念，我愿意用生命来证明这一点。</p></li><li><p>Period.<br>毫不迟疑。</p></li><li><p>It’s that simple.<br>就是这么简单。</p></li><li><p>I know who I am, I know what I believe, and that’s all I need to know.<br>我知道我是谁，我知道我的信念，那就是我需要知道的全部。</p></li><li><p>From there, you do what you need to do.<br>因此，你只要做你需要做的事情。</p></li><li><p>You know.<br>你知道。</p></li><li><p>I think what happens is we make the situation more complex.<br>我认为实际发生的事，我们自己把事情弄复杂了。</p></li></ol><hr><h2 id="font-color-red-DAY-15-font"><strong><font color='red'>DAY 15</font></strong></h2><p><strong>Sickening work ethic 病态的职业精神</strong></p><ol><li><p>The separation of talent and skill is one of the greatest misunderstood concepts for people who are trying to excel, who have dreams, who want to do things.<br>天赋和技能之间的差别是那些追求成功、追求梦想、想做事的人最容易误解的观念之一。</p></li><li><p>Talent you have naturally.<br>天赋是与生俱来的。</p></li><li><p>Skill is only developed by hours and hours and hours of beating on your craft.<br>技能只能通过成千上万小时锤炼而来。</p></li><li><p>I’ve never really viewed myself as particularly talented.<br>我从来不认为自己有特殊的天赋。</p></li><li><p>And where I excel is ridiculous, sickening, work ethic.<br>我擅长的是，荒唐的，病态的，职业精神。</p></li><li><p>You know, while the other guy’s sleeping? I’m working.<br>你知道，当别人睡觉得时候，我在工作。</p></li><li><p>While the other guy’s eatin’? I’m working.<br>当别人吃饭的时候，我在工作。</p></li><li><p>There’s no easy way around it.<br>成功从来没有容易的路可走。</p></li><li><p>No matter how talented you are, your talent is going to fail you if you’re not skilled.<br>不管你的天赋有多么出色，再好的天赋也会让你失败，如果你没有练出技能来。</p></li><li><p>If you don’t study, work really hard and dedicate yourself to getting better every single day.<br>如果你没有非常用心的学习，工作，没有致力于让自己每天进步一点点。</p></li><li><p>You’ll never be able to communicate your artistry to people the way that you want.<br>那你怎能让别人确信你能过自己想要的生活呢。</p></li><li><p>The only thing that I see that is distinctly different about me is that I’m not afraid to die on a treadmill.<br>我觉得我唯一不同的一点就是，我永远不怕在跑步机上坚持到底。</p></li><li><p>You might have more talent than me, you might be smarter than me, but if we get on a treadmill together, there’re two things.<br>你可能天赋比我强，你也可能比我聪明，但是如果我们同时踏上跑步机，那只有两个结果。</p></li><li><p>You’re getting off first, or I’m gonna die.<br>你会先下去，而我会跑到最后一刻。</p></li><li><p>It’s really that simple.<br>就是这么简单。</p></li></ol><hr><h2 id="font-color-red-DAY-16-font"><strong><font color='red'>DAY 16</font></strong></h2><p><strong>Bend your universe 驱动你的宇宙</strong></p><ol><li><p>Our thoughts, feelings, dreams, and ideas are physical in the Universe.<br>我们的想法、情感、梦想、理念在宇宙中都是物质的。</p></li><li><p>If we dream something, if we picture something, and if we commit ourselves to it – that is a physical thrust towards realization that we send out into the universe.<br>如果我们有了梦想，如果我们有了图像，如果我们让自己与它一致，那么，它们就是物质层面的延伸，使得我们可以在宇宙中实现它们。</p></li><li><p>The universe is not a thing that’s going to push us around.<br>宇宙并不是把我们推来推去的东西。</p></li><li><p>The world, people, and situations are not going to push us around.<br>人们，世界和环境并不会改变我们的追求。</p></li><li><p>We are going to bend the universe.<br>我们将驱动宇宙。</p></li><li><p>We are going to command and DEMAND that the universe become what we want it to be.<br>我们能够命令和要求宇宙成为我们希望成为的样子。</p></li><li><p>I studied the patterns of the universe.<br>我研究过宇宙的模式。</p></li><li><p>There’s a redemptive power that making a choice has.<br>人做选择的时候会产生一种救赎的力量。</p></li><li><p>Rather than feeling like you’re just affected by all the things happening, make a choice.<br>不要感到你的命运仅仅是被发生的事情所影响，做出你的选择！</p></li><li><p>Just DECIDE what you’re gonna be, who you’re gonna be, and how you’re gonna do it.<br>你必须决定，只要决定，你要成为什么，你要成为谁，你将做什么。</p></li><li><p>Just decide.<br>做出你的决定！</p></li><li><p>From that point on, the Universe is gonna get out of your way.<br>到那时，整个宇宙都会自动为你让路。</p></li></ol><hr><h2 id="font-color-red-DAY-17-font"><strong><font color='red'>DAY 17</font></strong></h2><p><strong>super hard</strong></p><ol><li><p>The first is you need to work, if you, depending on how well you want to do.<br>首先，你需要行动，这依赖于你究竟想要做的多好。</p></li><li><p>Particularly if you’re starting a company, you need to work super hard.<br>特别是对于创立公司的人，你需要超级努力地工作。</p></li><li><p>So what does super hard mean? 超级努力是什么意思呢？</p></li><li><p>Well, when my brother and I were starting up our first company, instead of getting an apartment, we just rented a small office.<br>我弟弟和我一起开创第一家公司的时候，我们租不起公寓，只租了一间小办公室。</p></li><li><p>And we slept on the couch.<br>我们都睡在沙发上。</p></li><li><p>And we showered at the YMCA.<br>我们在基督教青年会洗澡。</p></li><li><p>We were so hard up.<br>我们很拮据。</p></li><li><p>We had just one computer.<br>只买得起一台电脑。</p></li><li><p>The website was up during the day, and I was coding at night, seven days a week, all the time.<br>网站在白天运行，而我在晚上写代码，一周七天没有间歇。</p></li><li><p>And I briefly had a girlfriend at that period.<br>这期间我短暂交过一位女友。</p></li><li><p>And in order to be with me, she had to sleep in the office.<br>为了和我一起，她不得不也睡办公室。</p></li><li><p>So I worked hard at every waking hour.<br>我工作努力到醒着的时间都用于工作。</p></li><li><p>That’s the thing I would say particularly if you are starting a company.<br>特别是对于要开公司的人，这就是我的建议。</p></li><li><p>And if you do simple math, say like, if somebody else is working 50 hours, and you’re working 100, you’ll get twice as much done in the course of a year as the other company.<br>你可以简单算算，如果别人工作50小时，而你工作100小时，你公司在一年之内的成果肯定会比别人公司多一倍。</p></li></ol><hr><h2 id="font-color-red-DAY-18-font"><strong><font color='red'>DAY 18</font></strong></h2><p><strong>Think different 非同凡响</strong></p><ol><li><p>Here’s to the crazy ones.<br>向那些疯狂的家伙致敬。</p></li><li><p>The misfits.<br>他们我行我素。</p></li><li><p>The rebels.<br>桀骜不驯。</p></li><li><p>The troublemakers.<br>惹是生非。</p></li><li><p>The round pegs in the square holes.<br>就像方孔中的圆桩。</p></li><li><p>The ones who see things differently.<br>他们用不同的角度来看待事物。</p></li><li><p>They’re not fond of rules.<br>他们既不墨守成规。</p></li><li><p>And they have no respect for the status quo.<br>也不安于现状。</p></li><li><p>You can quote them, disagree with them, glorify or vilify them.<br>你尽可以引用他们，否定他们，颂扬抑或是诋毁他们。</p></li><li><p>About the only thing you can’t do is ignore them.<br>但唯独不能漠视他们。</p></li><li><p>Because they change things.<br>因为他们改变了事物。</p></li><li><p>They push the human race forward.<br>他们让人类向前跨越了一大步。</p></li><li><p>And while some may see them as the crazy ones, we see genius.<br>他们是别人眼里的疯子，却是我们眼中的天才。</p></li><li><p>Because the people who are crazy enough to think they can change the world, are the ones who do.<br>因为，只有疯狂到认为自己能够改变世界的人，才能真正地改变世界。</p></li></ol><hr><h2 id="font-color-red-DAY-19-font"><strong><font color='red'>DAY 19</font></strong></h2><p><strong>I always knew I was going to be rich 我一直知道我会富有</strong></p><ol><li><p>I always knew I was going to be rich.<br>我一直知道我会富有。</p></li><li><p>I don’t think I ever doubted it for a minute.<br>我一分钟都没怀疑过。</p></li><li><p>Einstein is reputed to have said that “compound interest is the eighth wonder of the world”. Or something like that.<br>据说爱因斯坦曾说过，“复利是世界的第八大奇迹”，或者类似的话。</p></li><li><p>And it goes back to that story, you probably learned when you were in grade school.<br>这总会追溯到那个故事，你可能在学校里听说过的故事。</p></li><li><p>Where somebody did something for the king.<br>有人为国王做了一些事情。</p></li><li><p>And the king said, “What can I do for you?”<br>国王说，“我能为你做什么。”</p></li><li><p>And he said, “Well, let’s take a chessboard, and put one kernel of wheat on the first square, and then double it on the second, and double it on the third.”<br>他说，“拿个棋盘，第一个格子里放一颗谷粒，第二个格子放两颗，第三个格子里再翻倍。”</p></li><li><p>And the king readily agreed to it, and by the time he figured out what two to the 64th amounted to, he was giving away the entire kingdom.<br>那国王立即同意了，而当他算出从第2个格子到第64个格子里总共是多少时，他就已经把整个王国的粮食给出去了。</p></li><li><p>So it’s a pretty simple concept, but over time, it accomplishes extraordinary things.<br>这是一个很简单的概念，但是随着时间的推移，就会有非凡的结果。</p></li></ol><hr><h2 id="font-color-red-DAY-20-font"><strong><font color='red'>DAY 20</font></strong></h2><p><strong>Compound interest 复利法则</strong></p><p>以下是按照第二篇格式修改后的文章：</p><ol><li><p>And very early, probably when I was seven or so, I took this book out of the Bensen Library, called “A thousand ways to make a $1,000.”<br>很早的时候，大概7岁时，我从本森图书馆借出一本书，《赚一千美元的一千种方法》。</p></li><li><p>And one of the ways in this book was having penny weighing machines.<br>书中的方法之一，就是拥有一台投币体重计。</p></li><li><p>I sat and calculated how much it would cost to buy the first weighing machine, and then how long it would take for the profit from that one to buy another one.<br>我坐下算了算我要花多少钱去购买第一台体重计，第一台体重计赚得的利润能购买另外一台需要花多长时间。</p></li><li><p>And I would sit there and create these compound interest tables to figure out how long it would take me to have a weighing machine for every person in the world.<br>我会坐在那里做复利表，去计算让世界上每个人都拥有一台体重秤需要多长时间。</p></li><li><p>I had everybody in the country weighing themselves ten times a day, and me just sitting there like John D. Rockefeller of weighing machines.<br>我要让所有美国人每天称十次体重，我只要坐在那里，像体重计行业的洛克菲勒。</p></li><li><p>That allowance when I was a little boy was a nickel a week,<br>但我想让我一个星期的零花钱不止五美分，</p></li><li><p>But I liked the idea of having a little more than a nickel a week to work with.<br>但我喜欢做我自己的老板。</p></li><li><p>And I went into business very early.<br>我很早就进入商业领域了。</p></li><li><p>I started selling Coca-Cola door to door.<br>我挨家挨户卖可口可乐。</p></li><li><p>I sold gum door to door.<br>我挨家挨户卖口香糖。</p></li><li><p>I sold “Saturday Evening Post,” “Liberty” Magazine, “Ladies Home Journal,” you name it.<br>我卖《星期六晚报》，卖《自由杂志》，《妇女家庭杂志》，凡是你想到的。</p></li><li><p>I think I enjoyed the game almost right from the start.<br>我觉得我从一开始就很喜欢这项游戏。</p></li><li><p>But I like being my own boss.<br>但我喜欢做我自己的老板。</p></li><li><p>That’s one thing I liked about delivering papers.<br>这是我喜欢投递报纸的原因之一。</p></li><li><p>I could arrange the route I wanted.<br>我可以安排我喜欢的路线。</p></li><li><p>Nobody was bothering me at 5.00 or 6.00 in the morning.<br>在早上五六点钟没人打扰我。</p></li><li><p>I was delivering 500 papers a day.<br>我一天投递500份报纸。</p></li><li><p>And I made a penny a paper, but in terms of compounding, that penny has turned into something else.<br>一份报纸赚一便士，但是通过复利法则，那一便士便换成了其他东西。</p></li></ol><hr><h2 id="font-color-red-DAY-21-font"><strong><font color='red'>DAY 21</font></strong></h2><p><strong>Method of learning 只有学习了学习方法才能进步</strong></p><ol><li>Alfred North Whitehead said it one time that “the rapid advance of civilization came only when man invented the method of invention.”<br>阿尔弗雷德·诺斯·怀特海曾经说过一句很正确的话，他说只有当人类“发明了发明的方法”之后，人类社会才能快速地发展。</li><li>And of course he was referring to the huge growth of GDP per capita and all the other good things that we now take for granted which started a few hundred years ago and before that all was stasis.<br>他指的是人均GDP的巨大增长和其他许多我们今天已经习以为常的好东西。人类社会在几百年前才出现了大发展，在那之前，每个世纪的发展几乎等于零。</li><li>So if civilization can progress only when it invents the method of invention, you can progress only when you learn the method of learning.<br>人类社会只有发明了发明的方法之后才能发展，同样的道理，你们只有学习了学习的方法之后才能进步。</li><li>I was very lucky.<br>我非常幸运。</li><li>I came to law school having learned the method of learning and nothing has served me better in my long life than continuous learning.<br>我读法学院之前就已经学会了学习的方法。在我这漫长的一生中，没有什么比持续学习对我的帮助更大。</li><li>And if you take Warren Buffett and watched him with a time clock, I would say half of all the time he spends is sitting on his ass and reading.<br>再拿沃伦·巴菲特来说，如果你们拿着计时器观察他，会发现他醒着的时候有一半时间是在看书。</li><li>And a big chunk of the rest of the time is spent talking one on one, either on the telephone or personally, with highly gifted people whom he trusts and who trust him.<br>他把剩下的时间大部分用来跟一些非常有才干的人进行一对一的交谈，有时候是打电话，有时候是当面，那些都是他信任且信任他的人。</li><li>In other words, it looks quite academic, all this worldly success.<br>换句话说，沃伦在世俗生活中的巨大成功，是通过很学术的方法获得的。</li></ol><hr><h2 id="font-color-red-DAY-22-font"><strong><font color='red'>DAY 22</font></strong></h2><p><strong>Change mindset change brain 改变思维模式，改变大脑</strong></p><ol><li>Just the words ‘yet’ or ‘not yet,’ we’re finding, give kids greater confidence, give them a path into the future that creates greater persistence.<br>我们发现，注重过程的思维模式，会赋予孩子们更多自信，指引他们不断向前，越发坚持不懈。</li><li>And we can actually change students’ mindsets.<br>事实上，我们能够改变学生的思维模式。</li><li>In one study, we taught them that every time they push out of their comfort zone to learn something new and difficult, the neurons in their brain can form new, stronger connections, and over time they can get smarter.<br>在一项研究中，我们告诉学生们，每当他们迫使自己走出舒适区，学习新知识，迎接新挑战，大脑中的神经元会形成新的更强的连接，他们会逐渐变得越来越聪明。</li><li>Look what happened.<br>看看后面发生了什么吧。</li><li>In this study, students who were not taught this growth mindset continued to show declining grades over this difficult school transition, but those who were taught this lesson showed a sharp rebound in their grades.<br>在这项研究中，没有接受成长型思维模式训练的学生，在这一困难的过渡阶段，成绩持续下滑，但那些受过该训练的学生，成绩强势反弹，卓有起色。<br>We have shown this now, this kind of improvement, with thousands and thousands of kids, especially struggling students.如今，我们已证实这一结论，通过成千上万个孩子的实例，尤其是那些在学业上挣扎的孩子。</li></ol><hr><h2 id="font-color-red-DAY-23-font"><strong><font color='red'>DAY 23</font></strong></h2><p><strong>Grit is the key to success 毅力是成功的关键</strong></p><ol><li>So I left the classroom, and I went to graduate school to become a psychologist.<br>所以我离开了讲台，回到研究院成为一名心理学家。</li><li>I started studying kids and adults in all kinds of super challenging settings, and in every study my question was, who is successful here and why?<br>我开始研究在各种非常具有挑战性的情况下的孩子和大人，在各项研究中，我的问题是：谁才是成功者，为什么他们会成功？</li><li>My research team and I went to West Point Military Academy.<br>我和我的研究团队前往西点军校展开调研。</li><li>We tried to predict which cadets would stay in military training and which would drop out.<br>我们试图预测哪些学员能够耐得住军队的训练，哪些会被淘汰出局。</li><li>We went to the National Spelling Bee and tried to predict which children would advance farthest in competition.<br>我们前去观摩全国拼字比赛，同时也试着预测哪些孩子会晋级到最后的比赛。</li><li>We studied rookie teachers working in really tough neighborhoods, asking which teachers are still going to be here in teaching by the end of the school year, and of those, who will be the most effective at improving learning outcomes for their students?<br>我们研究在恶劣的工作环境下工作的，刚入行的老师，询问他们哪些老师决定会在学年结束后继续留下来任教，以及他们之中谁能最快地提高学生的学习成绩。</li><li>We partnered with private companies, asking, which of these salespeople is going to keep their jobs?<br>我们与私企合作，向他们询问哪些销售人员可以保住工作。</li><li>And who’s going to earn the most money?<br>哪些人可以赚钱最多？</li><li>In all those very different contexts, one characteristic emerged as a significant predictor of success.<br>在所有那些不同的情境下，一种性格特征凸显了出来，这种特征在很大程度上预示了成功。</li><li>And it wasn’t social intelligence.<br>而且它并不是社交智力。</li><li>It wasn’t good looks, physical health, and it wasn’t I.Q.<br>不是漂亮的外表，强健的体魄，也不是很高的IQ。</li><li>It was grit.<br>它是毅力。</li><li>Grit is passion and perseverance for very long-term goals.<br>毅力是对长远目标的激情和坚持。</li><li>Grit is having stamina.<br>毅力是拥有持久的恒劲。</li><li>Grit is sticking with your future, day in, day out, not just for the week, not just for the month, but for years, and working really hard to make that future a reality.<br>毅力是你对未来的坚持，日复一日，而不仅仅是持续一个星期或者一个月，而是几年甚至几十年努力奋斗着让自己的梦想变为现实。</li><li>Grit is living life like it’s a marathon, not a sprint.<br>毅力是把生活当成一场马拉松而不是一次短跑。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试-基础</title>
    <link href="http://jyxcpp.netlify.app/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/"/>
    <id>http://jyxcpp.netlify.app/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-20T06:49:17.000Z</published>
    <updated>2023-09-10T08:51:21.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是对以下文章的摘录：<br><a href="http://c.biancheng.net/gdb/">C语言中文网-gdb调试</a></p></blockquote><h3 id="font-color-red-调试前提-font"><font color='red'>调试前提</font></h3><p>只有具备调试信息的可执行文件才可被调试，即，编译时需要添加 <code>-g</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gcc main.c main -g</span></span><br></pre></td></tr></table></figure><p>调试时最好不要优化代码，使用 <code>-O0</code> 默认级别即可。对 GDB 调试器更友好的是 <code>-Og</code> 选项，-Og 对代码所做的优化程序介于 O0 ~ O1 之间，真正可做到“在保持快速编译和良好调试体验的同时，提供较为合理的优化级别”。</p><hr><h3 id="font-color-red-常用命令-font"><font color='red'>常用命令</font></h3><table><thead><tr><th>调试指令</th><th>作 用</th></tr></thead><tbody><tr><td>(gdb) help</td><td><code>help commands</code> 能够显示 commands 命令的具体用法</td></tr><tr><td>(gdb) file program</td><td>调试 program 程序</td></tr><tr><td>(gdb) break xxx <br />(gdb) b xxx</td><td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置，可以是函数名、行号（当前源文件）、指定文件中的行号（b main.c:3）等</td></tr><tr><td>(gdb) run <br />(gdb) r</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。其后可以传入参数</td></tr><tr><td>(gdb) start</td><td>执行到 main 函数中的第一条指令停止。其后可以传入参数</td></tr><tr><td>(gdb) continue <br />(gdb) c</td><td>当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束</td></tr><tr><td>(gdb) next <br />(gdb) n</td><td>令程序一行代码一行代码的执行，也可指定一次执行的行数，不步入函数</td></tr><tr><td>(gdb) step<br />(gdb) s</td><td>令程序一行代码一行代码的执行，也可指定一次执行的行数，遇到函数则步入</td></tr><tr><td>(gdb) until<br />(gdb) u</td><td>使 GDB 调试器快速运行完当前的循环体，并运行至循环体外停止，可指定在某行停下</td></tr><tr><td>(gdb) finish</td><td>直接执行完当前函数</td></tr><tr><td>(gdb) return</td><td>立即跳出当前函数（即使有剩余代码也不会继续执行），并返回指定值</td></tr><tr><td>(gdb) print var <br />(gdb) p var</td><td>打印指定变量的值，也可以修改变量值：print var=1，高级用法参见<a href="http://c.biancheng.net/view/vip_8513.html">print</a></td></tr><tr><td>(gdb) display</td><td>每次程序暂停后都打印指定变量，使用 undisplay 或 disable 来取消显示</td></tr><tr><td>(gdb) list <br />(gdb) l</td><td>显示源程序代码的内容，包括各行代码所在的行号</td></tr><tr><td>(gdb) delete</td><td>删除指定编号的断点，不指定则删除全部</td></tr><tr><td>(gdb) clear</td><td>删除指定行的断点，不指定则删除当前行的断点</td></tr><tr><td>(gdb) disable</td><td>禁用指定编号的断点，不指定则禁用所有断点</td></tr><tr><td>(gdb) enable</td><td>开启指定编号的断点，不指定则开启所有断点</td></tr><tr><td>(gdb) quit <br />(gdb) q</td><td>终止调试</td></tr><tr><td>-q <br />-quiet <br />-silent</td><td>取消启动 GDB 调试器时打印的介绍信息和版权信息</td></tr><tr><td>–args prog arg1<br />(gdb) set args arg1 …</td><td>调试可执行程序 prog 并传入参数 arg1</td></tr><tr><td>(gdb) cd</td><td>修改 GDB 调试器的工作目录</td></tr><tr><td>(gdb) path xx/xx</td><td>临时修改环境变量</td></tr><tr><td>(gdb) info xxx</td><td>提供有关程序状态和调试环境的信息</td></tr><tr><td>(gdb) bt<br />(gdb) backtrace<br />(gdb) info stack</td><td>显示函数的调用堆栈</td></tr><tr><td>(gdb) info frame</td><td>显示当前函数栈帧的详细信息</td></tr><tr><td>(gdb) up</td><td>返回上一函数栈帧</td></tr><tr><td>(gdb) down</td><td>返回下一函数栈帧</td></tr><tr><td>(gdb) x</td><td>显示指定地址处的值，有多种格式，详细可在 gdb 中输入 help x 查看</td></tr><tr><td>(gdb) disassemble</td><td>反汇编指定地址处的代码，不指定则反汇编当前函数</td></tr><tr><td>(gdb) layout asm</td><td>以汇编格式调试整个程序，可以使用 layout src 切换到源代码模式</td></tr></tbody></table><blockquote><p><code>(gdb)</code> 表示已经运行 gdb，目前是 gdb 中的命令行。</p></blockquote><h3 id="font-color-orange-break-font"><font color='orange'>break</font></h3><p><strong>gdb 中有三种断点——普通断点、观察断点、捕捉断点。</strong></p><p>break 属于普通断点，其常用的语法格式有以下 2 种。</p><ul><li>(gdb) break location</li><li>(gdb) break … if cond</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号，行号通过 list 命令可以看到。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 表示具体行数。</td></tr><tr><td>+ offset - offset</td><td>offset 为整数（假设值为 2），+offset 表示以当前程序暂停位置（例如第 4 行）为准，向后数 offset 行处（第 6 行）打断点。</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 7 if num&gt;10</span><br><span class="line">(gdb) b 8 if p==null</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>break 还有两种变体：tbreak 和 rbreak</font></strong></p><p>tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，<strong>使用 tbreak 命令打的断点仅会作用 1 次</strong> 。</p><p><strong>rbreak 命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点</strong> 。rbreak 命令的使用语法格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rbreak regex</span><br></pre></td></tr></table></figure><p>其中 regex 为一个正则表达式，程序中函数的函数名只要满足 regex 条件，rbreak 命令就会其内部的开头位置打断点。该方法的一个妙用可参见<a href="https://jyx-fyh.github.io/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/">gdb调试-进阶</a> 。</p><p>使用 delete 命令清除所有断点，info breakpoints 查看所有断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete</span><br><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-watch-font"><font color='orange'>watch</font></h3><p>watch 断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch var</span><br><span class="line">(gdb) watch var if cond</span><br></pre></td></tr></table></figure><p>watch 的变体还有 rwatch 和 awatch：</p><ul><li>rwatch 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；</li><li>awatch 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。</li></ul><p>watch 命令有 <strong>硬件断点</strong> 和 <strong>软件断点</strong> 两种实现方式。软件断点监控目标变量后，GDB 调试器会以单步执行的方式运行程序，并且每行代码执行完毕后，都会检测该目标变量的值是否发生改变，因此软件断点会影响调试效率。硬件断点通过使用少量的寄存器（例如 32 位的 Intel x86 处理器提供有 4 个调试寄存器）来监控变量的值，而无需每次都主动检测变量是否改变，因此硬件断点不影响调试效率。</p><p>大多数 PowerPC 或者基于 x86 的操作系统，都支持采用硬件观点。<strong>并且 GDB 调试器在建立观察断点时，会优先尝试建立硬件观察点，只有当前环境不支持硬件观察点时，才会建立软件观察点。</strong></p><h3 id="font-color-orange-catch-font"><font color='orange'>catch</font></h3><p><strong>catch 捕捉断点的作用是监控程序中某一事件的发生</strong> ，例如程序发生某种异常时、某一动态库被加载时等等，一旦目标时间发生，则程序停止执行。 tcatch 命令只监控一次事件的发生。</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">catch exec</td><td style="text-align:center">捕获对exec的调用。</td></tr><tr><td style="text-align:center">catch fork</td><td style="text-align:center">捕获对fork的调用。</td></tr><tr><td style="text-align:center">catch load</td><td style="text-align:center">捕获共享库的加载。</td></tr><tr><td style="text-align:center">catch unload</td><td style="text-align:center">捕获共享库的卸载。</td></tr><tr><td style="text-align:center">catch signal</td><td style="text-align:center">按名称和/或编号捕获信号。</td></tr><tr><td style="text-align:center">catch syscall</td><td style="text-align:center">按名称、组和/或编号捕获系统调用。</td></tr><tr><td style="text-align:center">catch throw</td><td style="text-align:center">捕获被抛出的异常。</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>break、watch 有 if 形式，而 catch 则没有，如果想要使其成为条件断点，则需要用到 <strong>condition 命令</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type            Disp Enb Address                        What</span><br><span class="line">1       breakpoint      keep y     0x00005555555552d0  in main() at main.cpp:9    breakpoint already hit 1 time</span><br><span class="line">2       read watchpoint keep y                                       num</span><br><span class="line">3       catchpoint      keep y                                           exception throw      matching: int</span><br><span class="line">(gdb) condition 1 num==3             &lt;-- 为普通断点添加条件表达式</span><br><span class="line">(gdb) condition 2 num==5             &lt;-- 为观察断点添加条件表达式</span><br><span class="line">(gdb) condition 3 num==7             &lt;-- 为捕捉断点添加条件表达式</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-frame-font"><font color='orange'>frame</font></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb)info frame                              &lt;-- 打印当前栈帧的详细信息</span><br><span class="line">Stack level 0, frame at 0x7fffffffe240:      &lt;-- 栈帧编号0,地址 0x7fffffffe240</span><br><span class="line">rip = 0x4004cf in func (main.c:3); saved rip 0x4004e9   </span><br><span class="line">                                             &lt;-- 函数的存储地址0x4004cf,返回后的地址为0x4004e9</span><br><span class="line">called by frame at 0x7fffffffe260            &lt;-- 当前栈帧的上一级栈帧（编号 1 的栈帧）的地址为 0x7fffffffe260</span><br><span class="line">source language c.                           &lt;-- 当前栈帧使用的编程语言</span><br><span class="line">Arglist at 0x7fffffffe230, args: num=4       &lt;-- 函数参数的地址和值</span><br><span class="line">Locals at 0x7fffffffe230, Previous frame&#x27;s sp is 0x7fffffffe240  </span><br><span class="line">                                             &lt;--函数内部局部变量的存储地址</span><br><span class="line">Saved registers:                             &lt;-- 栈帧内部存储的寄存器</span><br><span class="line">  rbp at 0x7fffffffe230, rip at 0x7fffffffe238</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-info-font"><font color='orange'>info</font></h3><p>常见的 info 命令如下：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">info breakpoints</td><td style="text-align:center">列出当前设置的所有普通断点</td></tr><tr><td style="text-align:center">info watchpoints</td><td style="text-align:center">列出当前设置的所有观察断点</td></tr><tr><td style="text-align:center">info registers</td><td style="text-align:center">显示所有寄存器的当前值</td></tr><tr><td style="text-align:center">info address</td><td style="text-align:center">显示符号对应的地址</td></tr><tr><td style="text-align:center">info threads</td><td style="text-align:center">列出当前正在运行的所有线程</td></tr><tr><td style="text-align:center">info functions</td><td style="text-align:center">列出程序中定义的所有函数</td></tr><tr><td style="text-align:center">info variables</td><td style="text-align:center">列出 <strong>当前所有可见</strong> 的变量</td></tr><tr><td style="text-align:center">info locals</td><td style="text-align:center">打印当前函数中所有局部变量的值</td></tr><tr><td style="text-align:center">info args</td><td style="text-align:center">打印参数值</td></tr><tr><td style="text-align:center">info source</td><td style="text-align:center">显示当前源文件的名称和行号</td></tr><tr><td style="text-align:center">info sources</td><td style="text-align:center">显示此程序包含的所有源文件</td></tr><tr><td style="text-align:center">info frame</td><td style="text-align:center">显示当前帧的信息，包括函数名称和参数</td></tr><tr><td style="text-align:center">info stack</td><td style="text-align:center">显示调用堆栈</td></tr><tr><td style="text-align:center">info program</td><td style="text-align:center">显示正在调试的程序的名称和进程ID</td></tr><tr><td style="text-align:center">info sharedlibrary</td><td style="text-align:center">列出当前加载的共享库</td></tr><tr><td style="text-align:center">info target</td><td style="text-align:center">显示当前目标的信息，例如目标文件或核心转储文件</td></tr><tr><td style="text-align:center">info display</td><td style="text-align:center">display 命令查看的目标变量或表达式</td></tr></tbody></table><p><strong>更多 info 参数可输入 help info 进行查看。</strong></p><hr><h3 id="font-color-red-调试方式-font"><font color='red'>调试方式</font></h3><ol><li><p>调试尚未运行的程序：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb program</span></span><br><span class="line">或者 </span><br><span class="line">(gdb) file program</span><br></pre></td></tr></table></figure></li><li><p>调试正在运行的程序</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach program</span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb -p 进程号</span></span><br></pre></td></tr></table></figure><p>这种方式可能需要 root 权限。调式完毕后可执行 <code>detach</code> 指令，使 GDB 调试器和程序分离：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(gdb) detach</span></span><br><span class="line">或者直接退出</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(gdb) q</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-核心转储-font"><font color='red'>核心转储</font></h3><p>在 Linux 操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为 core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。当程序发生异常崩溃时，通过 GDB 调试 core 文件，往往可以更快速的解决问题。</p><p>默认情况下，Linux 系统不开启 core dump 这一功能，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>如果 core file size（core 文件大小）对应的值为 0，表示当前系统未开启 core dump 功能。这种情况下，可以通过执行如下指令改变 core 文件的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# ulimit -c unlimited</span><br><span class="line">[root@bogon demo]# ulimit -a</span><br><span class="line">core file size     (blocks, -c) unlimited</span><br></pre></td></tr></table></figure><p>假设执行 main.exe 发生数组越界错误生成 core 文件，则调试方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# gdb main.exe core</span><br></pre></td></tr></table></figure><p>如果没有生成 core，请参考<a href="https://www.jianshu.com/p/70e5b762386c">此处</a> 。</p><p>注意，Core文件中包含了程序运行时的内存映像（代码、数据和堆栈信息）、进程状态、系统信息、调试符号等，如果程序在崩溃时使用了大量的内存，那么 Core 文件可能会很大，可以使用 ulimit 命令来限制 Core 文件的最大大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试-进阶</title>
    <link href="http://jyxcpp.netlify.app/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/"/>
    <id>http://jyxcpp.netlify.app/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/</id>
    <published>2023-05-20T04:53:28.000Z</published>
    <updated>2023-05-24T03:35:43.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C:/Users/JiangYuxuan/Desktop/Typora/img/</p><h2 id="font-color-red-查看系统调用与库调用-font"><font color='red'>查看系统调用与库调用</font></h2><h2 id="font-color-red-跟踪每一次函数调用-font"><font color='red'>跟踪每一次函数调用</font></h2><p>这是一个非常常见的需求</p><h2 id=""></h2><ul><li><pre><code>  readelf -s 程序路径 | gawk '  &#123;     if($4 == &quot;FUNC&quot; &amp;&amp; $2 != 0) &#123;       print &quot;# code for &quot; $NF;       print &quot;b &quot; $NF;       print &quot;commands&quot;;       print &quot;silent&quot;;       print &quot;bt 1&quot;;       print &quot;c&quot;;       print &quot;end&quot;;       print &quot;&quot;;&#125;     &#125;' &gt; 输出文件  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>  gdb --command=输出文件 调试文件 -q</code></pre></li></ul><h2 id="font-color-red-跟踪一类函数调用-font"><font color='red'>跟踪一类函数调用</font></h2><p>rbreak</p><h2 id="font-color-red-信号处理-font"><font color='red'>信号处理</font></h2><p>参见<a href="http://c.biancheng.net/view/8291.html">handle</a> 。</p><h2 id="font-color-red-多线程调试-font"><font color='red'>多线程调试</font></h2><h2 id="font-color-red-多进程调试-font"><font color='red'>多进程调试</font></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>练习2-编译调试Nginx</title>
    <link href="http://jyxcpp.netlify.app/2023/05/16/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/"/>
    <id>http://jyxcpp.netlify.app/2023/05/16/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/</id>
    <published>2023-05-16T01:32:01.000Z</published>
    <updated>2023-05-20T06:50:19.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/">练习1-编译调试teamTalk</a>，<a href="https://jyx-fyh.github.io/2023/05/05/cmake%E5%85%A5%E9%97%A8/">cmake入门笔记</a>，对 makefile 有一定了解。<br>参考：<a href="https://www.jianshu.com/p/14c81fbcb401">nginx依赖库</a>，<a href="https://cloud.tencent.com/developer/article/2205549?from=article.detail.1476984&amp;areaSource=106000.16&amp;traceId=il-m4ntHJ8HD5tlLzMjN_">Windows下编译Nginx</a>，<a href="https://www.jianshu.com/p/3c2fdb06de9e">gdb远程调试</a>，《深入剖析Nginx》，chatgpt 。</p></blockquote><h2 id="font-color-red-前言-font"><font color='red'>前言</font></h2><p>Nginx 是一款高性能的开源Web服务器和反向代理服务器，其特点是占用内存少、并发能力强、处理静态文件快、可扩展性好、稳定性高、配置简单等。毫无疑问，花时间学习它将是一笔划算的投资，那么第一步便是编译、运行并调试它。本文给出以下几种途径来编译调试 Nginx：</p><ul><li><strong>原生 gdb 调试</strong></li><li><strong>CLion 编译数据库组织项目 + 远程 gdb 调试</strong></li><li><strong>CLion 原生支持 CMake 管理项目并调试</strong></li><li><strong>（转载）VS 编译调试 Nginx</strong></li></ul><p>在上节<a href="https://jyx-fyh.github.io/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/">练习1-编译调试teamTalk</a>中，我们熟悉了 Windows 的 Visual Studio 开发环境，本节我们则重点讲述 Linux 下的 CLion 开发环境，本机 Linux 环境为 Ubuntu 20.4.6 。</p><h2 id="font-color-red-原生-gdb-调试-font"><font color='red'>原生 gdb 调试</font></h2><p>此方式直接对包含调试信息的可执行程序 nginx 进行 gdb 调试，这种方式当然是最简单的，也当然是最痛苦的，没人希望在黑洞洞的狭窄界面中调试跟踪几万行的大型项目。<strong><font color='red'>下面先说明如何编译并配置 Nginx，此内容也是后续方法的前提步骤</font></strong> 。</p><h3 id="font-color-orange-1-安装依赖库-font"><font color='orange'>1.安装依赖库</font></h3><ul><li><p>pcre 库，以支持正则表达式。如果我们在配置文件 nginx.conf 中使用了正则表达式，那么必须链接此库。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev  </span><br></pre></td></tr></table></figure></li><li><p>zlib 库，用于对 HTTP 包的内容做 gzip 格式的压缩。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 库，用于支持 SSL 协议。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssl libssl-dev </span><br></pre></td></tr></table></figure></li></ul><h3 id="font-color-orange-2-安装-Nginx-font"><font color='orange'>2.安装 Nginx</font></h3><ol><li><p>在<a href="https://nginx.org/download/">官方</a>下载源码，考虑到《深入剖析Nginx》这本书采用的是 1.2.0 版本进行讲解，为了方便后续对照学习，笔者也下载的此版本。</p></li><li><p>在你喜欢的地方解压并进入该目录，使用以下配置生成 makefile：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-debug --prefix=<span class="string">&quot;/home/jyx/CLionProjects/nginx&quot;</span> --with-cc-opt=<span class="string">&quot;-Wno-error&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>--with-debug</code> ：添加调试信息，这是我们后续调试的前提！</strong></li><li><strong><code>--prefix=&quot;/home/jyx/CLionProjects/nginx&quot;</code> ：1）指定安装目录，如果不指定，则默认安装在 <code>usr/local/nginx</code> 下。2）<font color='orange'>每次启动 nginx 时，程序会首先从该位置的 conf 目录下读取 nginx.conf 配置文件。</font></strong><br>为了方便后续统一在 CLion 下编辑整个项目，我们不打算 make install，所以将路径设置为该目录本身，这样读取配置时就直接从该目录下的 conf 目录读取配置文件。<strong><font color='red'>注意，不能有中文路径！</font></strong></li><li><code>--with-cc-opt=&quot;-Wno-error&quot;</code> ：指定编译选项以忽略下面的错误：<br><img src="/2022/img/image-20230519150021172.png" alt=""></li></ul><blockquote><p><strong>输入 <code>./configure --help</code> 以查看其他选项。</strong></p></blockquote></li><li><p>执行 make ，你可能会遇到报错：<br><img src="/2022/img/webp.webp" alt=""><br>这是版本问题，不用慌，<strong>注释掉这行代码即可</strong> 。</p></li><li><p>使用 sudo 权限运行 objs/nginx，报错：<br><img src="/2022/img/image-20230519151235867.png" alt=""><br>小问题，我们在 nginx 目录下创建 logs 目录即可，重新运行，成功：<br><img src="/2022/img/image-20230519151351688.png" alt="成功访问本地服务器"></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps -aux | grep nginx</span><br><span class="line">jyx         1916  0.0  0.1 175184  8988 ?        Sl   May18   0:00 /usr/libexec/ibus-engine-simple</span><br><span class="line">root       15773  0.0  0.0   7324  1184 ?        Ss   00:38   0:00 nginx: master process /home/jyx/Downloads/nginx-1.2.0/objs/nginx</span><br><span class="line">nobody     15774  0.0  0.0   7960  3104 ?        S    00:38   0:00 nginx: worker process</span><br><span class="line">jyx        18578  0.0  0.0  17672   720 pts/1    S+   02:01   0:00 grep --color=auto ngi</span><br></pre></td></tr></table></figure><p>可见 Nginx 开启了多个进程。<strong><font color='gree'>注意，nginx 以后台方式运行，后续重启调试 nginx 时需要先关闭所有相关进程，否则会提示 bind 函数调用失败。关闭方法如下：</font></strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-orange-3-调试-nginx-font"><font color='orange'>3.调试 nginx</font></h3><p>在默认情况下， Nginx 会有多个进程，即一个主进程和多个工作进程（由 nginx.conf 决定）。如果要调试 Nginx 对客户端发过来请求的处理过程， 那么要注意请求是否被交付给另外一个工作进程处理而导致绑定到 gdb 的这个工作进程实际没有动作，为了方便，<strong><font color='gree'>我们直接指定工作进程的数量为 1 ：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure><p>同时，Nginx 默认以 daemon 形式运行， 即它会调用 fork 创建子进程并且把父进程直接 exit(0)丢弃， 而 gdb 默认将跟踪 fork() 之后的父进程， 这将导致跟踪丢失：<br><img src="/2022/img/image-20230519155524035.png" alt=""></p><p><strong>所以我们<font color='gree'>关闭 daemon 模式：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">daemon off;</span><br></pre></td></tr></table></figure><p>这样设置后，我们调试的是监控进程（master）的流程。工作进程（worker）由 master 进程 fork 而来，如果要调试 worker 进程，则需要在进入 gdb 后执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fbrk-mode child</span><br></pre></td></tr></table></figure><p>也就是让 gdb 跟踪 fork 之后的子进程。如果我们想要同时跟踪 master 和 worker，<strong>则直接将它们<font color='gree'>合并到一个进程中</font></strong> ，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">master_process off;</span><br></pre></td></tr></table></figure><p>这样，我们就将监控进程逻辑和工作进程逻辑全部合在了一个进程里。通过这三处配置，调试难度就大大降低了。</p><p>接下来我们使用 gdb 调试 objs 目录下的 nginx 程序即可，<strong><font color='orange'>注意使用 sudo 运行</font></strong> ：</p><p><img src="/2022/img/image-20230519151646848.png" alt="run起来后,程序被阻塞在某处，我们中断它(ctrl+c)，可以看到上图,程序执行流阻塞在epoll中"></p><p>接下来就开始你的调试之路吧。</p><hr><h2 id="font-color-red-CLion-编译数据库-gdb远程调试-font"><font color='red'>CLion 编译数据库+gdb远程调试</font></h2><p>Nginx 使用 makefile 来构建项目，而 CLion 本身使用 cmake 来组织管理项目，对 makefile 的支持还不够到位，因此无法直接接管 Nginx 项目。所幸的是，CLion 支持编译数据库（compile_commands.json），我们能够通过它来组织管理项目。读者朋友们可能不太熟悉编译数据库，下面是 chatgpt 对它的简单介绍：</p><blockquote><p>compile_commands.json 是一个 JSON 格式的文件，它包含了编译器生成的编译命令以及相关的源文件和编译选项。这个文件通常用于辅助代码分析工具，如代码编辑器、代码静态分析工具等，以便这些工具能够理解代码的编译过程，从而提供更好的代码提示、错误检查和重构等功能。<br><strong><font color='orange'>注意，它只能用来组织项目以便提供代码分析功能（比如代码跳转、代码提示等），其本身不是类似于 cmake 和 makefile 一类的构建文件，无法用来构建或生成项目</font></strong> 。</p></blockquote><ol><li>这里我们使用 compiledb 工具来生成 compile_commands.json，首先下载它：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过pip安装compiledb </span></span><br><span class="line">pip install compiledb </span><br></pre></td></tr></table></figure><ol start="2"><li>如之前所述，仍然先生成 makefile：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-debug --prefix=<span class="string">&quot;/home/jyx/CLionProjects/nginx&quot;</span> --with-cc-opt=<span class="string">&quot;-Wno-error&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>生成编译数据库 compile_commands.json ：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ compiledb -nf make</span><br><span class="line"><span class="comment">#-n选项表示执行make命令时不实际执行编译过程,只输出编译命令;-f选项指定Makefile文件的路径,如果不指定则默认使用当前目录下的Makefile文件.该命令利用make输出的编译信息来生成数据库.</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过 CLion 打开该编译数据库，open as projecct ：</li></ol><p><img src="/2022/img/image-20230519164056329.png" alt=""></p><p>这样我们就能利用 CLion 分析整个 Nginx 项目了。你可以试试点击头文件跳转的功能（CTRL+点击），如果不使用编译数据库，是无法跳转的（除非该头文件和目前文件在同一目录）。</p><p>此时我们仅获得了代码分析功能，还无法调试该项目，还需要借助 gdb 的远程调试功能。我们先使用 make 编译该项目生成 objs/nginx 可执行文件，然后开启 gdbserver：<br><img src="/2022/img/image-20230519170654151.png" alt=""></p><p>然后回到 CLion 添加配置选项：<br><img src="/2022/img/image-20230519170830143.png" alt=""></p><p><img src="/2022/img/image-20230519170923113.png" alt=""></p><p>点击 OK，接下来见证奇迹，点击右上方的 debug 虫子图标，开始调试：<br><img src="/2022/img/image-20230519172054271.png" alt=""><br>程序在断点处停了下来，调试成功。<strong>另外，如果我们想让程序中断下来，则需要在 gdbserver 处执行 CTRL+C，在 CLion 中的 gdb 窗口执行 CTRL+C 将没有任何反应。</strong></p><blockquote><p><strong>这里调试时依然别忘了我们之前的三处配置。</strong></p></blockquote><hr><h2 id="font-color-red-CLion-CMake-管理项目并调试-font"><font color='red'>CLion + CMake 管理项目并调试</font></h2><p>使用 gdb 远程调试总感觉有些别扭，而且中断程序时也不方便，所以下面我们尝试用 CLion 原生支持的 cmake 来管理项目。首先我们需要将 makefile 转换为 CMakeLists.txt ，这里有几点说明：</p><ul><li>cmake 比 makefile 更抽象，具备一些 makefile 没有的东西，所以不存在一种统一（或者说官方）的工具来将 makefile 转为 CMakeLists.txt 。</li><li>一般来说，采用 makefile 管理的项目中，其 makefile 都比较简单（不像 cmake 生成的 makefile，那可不是人看的），完全可以手动将其转换为 CMakeLists.txt 。</li></ul><p>就 objs 目录下的 makefile 来说（执行 configure 后），其表达的功能就三个：</p><ol><li><p>将指定源文件生成目标文件，如：</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CORE_INCS)</span> </span><br><span class="line">-o objs/src/core/nginx.o \</span><br><span class="line">src/core/nginx.c</span><br><span class="line"><span class="comment">#nginx.c --&gt; nginx.o</span></span><br></pre></td></tr></table></figure></li><li><p>将所有目标文件和库文件链接成可执行文件（第 208 行）：</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(LINK)</span> -o objs/nginx 所有目标文件 \</span><br><span class="line">-lpthread -lcrypt -lpcre -lcrypto -lcrypto -lz <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure></li><li><p>至于第 1068 行之后的就不用管了，它们是用来处理文档和安装任务的。</p></li></ol><p>所以转 CMakeLists.txt 是很轻松的，当然，前提是你需要有一定的 makefile 和 cmake 基础（头秃），下面给出笔者转换的 CMakeLists.txt ：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(nginx_cmake)</span><br><span class="line"><span class="keyword">set</span>(    SRC</span><br><span class="line">        src/core/nginx.c</span><br><span class="line">        src/core/ngx_log.c</span><br><span class="line">        src/core/ngx_palloc.c</span><br><span class="line">        src/core/ngx_array.c</span><br><span class="line">        src/core/ngx_list.c</span><br><span class="line">        src/core/ngx_hash.c</span><br><span class="line">        src/core/ngx_buf.c</span><br><span class="line">        src/core/ngx_queue.c</span><br><span class="line">        src/core/ngx_output_chain.c</span><br><span class="line">        src/core/ngx_string.c</span><br><span class="line">        src/core/ngx_parse.c</span><br><span class="line">        src/core/ngx_inet.c</span><br><span class="line">        src/core/ngx_file.c</span><br><span class="line">        src/core/ngx_crc32.c</span><br><span class="line">        src/core/ngx_murmurhash.c</span><br><span class="line">        src/core/ngx_md5.c</span><br><span class="line">        src/core/ngx_rbtree.c</span><br><span class="line">        src/core/ngx_radix_tree.c</span><br><span class="line">        src/core/ngx_slab.c</span><br><span class="line">        src/core/ngx_times.c</span><br><span class="line">        src/core/ngx_shmtx.c</span><br><span class="line">        src/core/ngx_connection.c</span><br><span class="line">        src/core/ngx_cycle.c</span><br><span class="line">        src/core/ngx_spinlock.c</span><br><span class="line">        src/core/ngx_cpuinfo.c</span><br><span class="line">        src/core/ngx_conf_file.c</span><br><span class="line">        src/core/ngx_resolver.c</span><br><span class="line">        src/core/ngx_open_file_cache.c</span><br><span class="line">        src/core/ngx_crypt.c</span><br><span class="line">        src/event/ngx_event.c</span><br><span class="line">        src/event/ngx_event_timer.c</span><br><span class="line">        src/event/ngx_event_posted.c</span><br><span class="line">        src/event/ngx_event_busy_lock.c</span><br><span class="line">        src/event/ngx_event_accept.c</span><br><span class="line">        src/event/ngx_event_connect.c</span><br><span class="line">        src/event/ngx_event_pipe.c</span><br><span class="line">        src/os/unix/ngx_time.c</span><br><span class="line">        src/os/unix/ngx_errno.c</span><br><span class="line">        src/os/unix/ngx_alloc.c</span><br><span class="line">        src/os/unix/ngx_files.c</span><br><span class="line">        src/os/unix/ngx_socket.c</span><br><span class="line">        src/os/unix/ngx_recv.c</span><br><span class="line">        src/os/unix/ngx_readv_chain.c</span><br><span class="line">        src/os/unix/ngx_udp_recv.c</span><br><span class="line">        src/os/unix/ngx_send.c</span><br><span class="line">        src/os/unix/ngx_writev_chain.c</span><br><span class="line">        src/os/unix/ngx_channel.c</span><br><span class="line">        src/os/unix/ngx_shmem.c</span><br><span class="line">        src/os/unix/ngx_process.c</span><br><span class="line">        src/os/unix/ngx_daemon.c</span><br><span class="line">        src/os/unix/ngx_setaffinity.c</span><br><span class="line">        src/os/unix/ngx_setproctitle.c</span><br><span class="line">        src/os/unix/ngx_posix_init.c</span><br><span class="line">        src/os/unix/ngx_user.c</span><br><span class="line">        src/os/unix/ngx_process_cycle.c</span><br><span class="line">        src/os/unix/ngx_linux_init.c</span><br><span class="line">        src/event/modules/ngx_epoll_module.c</span><br><span class="line">        src/os/unix/ngx_linux_sendfile_chain.c</span><br><span class="line">        src/core/ngx_regex.c</span><br><span class="line">        src/http/ngx_http.c</span><br><span class="line">        src/http/ngx_http_core_module.c</span><br><span class="line">        src/http/ngx_http_special_response.c</span><br><span class="line">        src/http/ngx_http_request.c</span><br><span class="line">        src/http/ngx_http_parse.c</span><br><span class="line">        src/http/ngx_http_header_filter_module.c</span><br><span class="line">        src/http/ngx_http_write_filter_module.c</span><br><span class="line">        src/http/ngx_http_copy_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_log_module.c</span><br><span class="line">        src/http/ngx_http_request_body.c</span><br><span class="line">        src/http/ngx_http_variables.c</span><br><span class="line">        src/http/ngx_http_script.c</span><br><span class="line">        src/http/ngx_http_upstream.c</span><br><span class="line">        src/http/ngx_http_upstream_round_robin.c</span><br><span class="line">        src/http/ngx_http_parse_time.c</span><br><span class="line">        src/http/modules/ngx_http_static_module.c</span><br><span class="line">        src/http/modules/ngx_http_index_module.c</span><br><span class="line">        src/http/modules/ngx_http_chunked_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_range_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_headers_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_not_modified_filter_module.c</span><br><span class="line">        src/http/ngx_http_busy_lock.c</span><br><span class="line">        src/http/ngx_http_file_cache.c</span><br><span class="line">        src/http/modules/ngx_http_gzip_filter_module.c</span><br><span class="line">        src/http/ngx_http_postpone_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_ssi_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_charset_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_userid_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_autoindex_module.c</span><br><span class="line">        src/http/modules/ngx_http_auth_basic_module.c</span><br><span class="line">        src/http/modules/ngx_http_access_module.c</span><br><span class="line">        src/http/modules/ngx_http_limit_conn_module.c</span><br><span class="line">        src/http/modules/ngx_http_limit_req_module.c</span><br><span class="line">        src/http/modules/ngx_http_geo_module.c</span><br><span class="line">        src/http/modules/ngx_http_map_module.c</span><br><span class="line">        src/http/modules/ngx_http_split_clients_module.c</span><br><span class="line">        src/http/modules/ngx_http_referer_module.c</span><br><span class="line">        src/http/modules/ngx_http_rewrite_module.c</span><br><span class="line">        src/http/modules/ngx_http_proxy_module.c</span><br><span class="line">        src/http/modules/ngx_http_fastcgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_uwsgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_scgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_memcached_module.c</span><br><span class="line">        src/http/modules/ngx_http_empty_gif_module.c</span><br><span class="line">        src/http/modules/ngx_http_browser_module.c</span><br><span class="line">        src/http/modules/ngx_http_upstream_ip_hash_module.c</span><br><span class="line">        src/http/modules/ngx_http_upstream_keepalive_module.c</span><br><span class="line">        objs/ngx_modules.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        src/core</span><br><span class="line">        src/event</span><br><span class="line">        src/event/modules</span><br><span class="line">        src/os/unix</span><br><span class="line">        objs</span><br><span class="line">        src/http</span><br><span class="line">        src/http/modules</span><br><span class="line">        src/mail</span><br><span class="line">        src/core</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(nginx <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(nginx pthread crypt pcre crypto z)</span><br></pre></td></tr></table></figure><p>是不是感觉太简洁了？没错，就是这么简单。将这个 txt 放在项目的根目录下。</p><p>接下来执行 configure，还是之前的选项（注意修改路径），然后进入 objs 目录，执行 <code>cmake ..</code> 生成 makefile，最后 <code>make</code> 生成可执行文件，一切顺利！<br>此时我们用 CLion 打开该项目（如果之前已经打开过，记得删除项目根目录下的 .idea 文件，避免项目缓存而检测不到 CMakeLists.txt），可以发现此时 CLion 就是使用 cmake 来管理项目的：<br><img src="/2022/img/image-20230519195102239.png" alt=""></p><p>然后点击右上角的运行图标，报错如下：<br><img src="/2022/img/image-20230519195155896.png" alt="image-20230519195155896"></p><p>这是提示权限不够，我们使用管理员权限来运行，修改步骤如下：<br><img src="/2022/img/image-20230519195504657.png" alt="image-20230519195504657"></p><p>然后运行，成功！<br><img src="/2022/img/image-20230519195605854.png" alt=""></p><p>再试试调试，效果不错！<br><img src="/2022/img/image-20230519195719650.png" alt="image-20230519195719650"></p><p>而且我们可以直接在 <code>Console</code> 中断程序来看目前执行流阻塞在哪，下图指出程序阻塞在 epoll_wait 中：<br><img src="/2022/img/image-20230519195904875.png" alt=""></p><p>笔者认为这种方式是最优雅的方式，读者朋友喜欢哪一种呢？</p><hr><h2 id="font-color-red-VS调试Nginx-font"><font color='red'>VS调试Nginx</font></h2><p>参考<a href="https://www.taurusxin.com/nginx-windows-build/#%E9%85%8D%E7%BD%AE-64-%E4%BD%8D-openssl">Windows编译Nginx</a>、<a href="https://cloud.tencent.com/developer/article/2205549?from=article.detail.1476984&amp;areaSource=106000.16&amp;traceId=il-m4ntHJ8HD5tlLzMjN_">VS调试Nginx</a> 。</p><hr><h2 id="font-color-red-注意事项-font"><font color='red'>注意事项</font></h2><p>有人发现 CLion 能够直接为外部导入的项目生成 CMakeLists.txt，如下：<br><img src="/2022/img/image-20230520124805926.png" alt=""></p><p><strong>自动创建 CMakeLists.txt 会将项目中的所有 .h 和 .c 文件都包含进来，这是不应该的！</strong> 我们应该根据执行 ./configure 后产生的 makefile 来按需引入 .c 和 .h 文件，即根据配置来引入，这是因为可能你明明指定了不需要某个功能，但却引入了相关的文件，这会在编译时产生大量报错，令人头疼不已！</p><hr><h2 id="font-color-red-总结-font"><font color='red'>总结</font></h2><ul><li>查看 README，了解项目功能、选项、依赖。</li><li>运行 <code>./configure --help</code> 来查看编译选项。</li><li>项目编译出错时，看看配置是否对的上，比如你没有配置某个功能，却引入了相关的源文件。</li><li>一些莫名奇妙的问题多问问 google 。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>非阻塞套接字及其注意事项</title>
    <link href="http://jyxcpp.netlify.app/2023/05/07/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/05/07/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-05-07T13:09:43.000Z</published>
    <updated>2023-05-07T13:10:08.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同时，如果对这种套接字进行读操作，那么 read/recv 将返回 -1 。</p><p>《高》P163，清除错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cmake学习-从实例入手</title>
    <link href="http://jyxcpp.netlify.app/2023/05/05/cmake%E5%85%A5%E9%97%A8/"/>
    <id>http://jyxcpp.netlify.app/2023/05/05/cmake%E5%85%A5%E9%97%A8/</id>
    <published>2023-05-05T03:36:32.000Z</published>
    <updated>2023-05-15T02:51:31.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-概要-font"><font color='red'>概要</font></h2><p>本篇笔记从实例出发，逐步分析 cmake 的使用方法。为了更好地拟合真实项目，本实例有如下功能：</p><ul><li><p>添加项目版本号</p></li><li><p>添加编译选项，可选择使用 myMath 库或第三方 3rdMath 库</p></li><li><p>使用了静态链接库和动态链接库，既有项目生成的库，也有第三方库</p></li><li><p>提供了安装功能</p></li><li><p>能够在 Windows 和 Linux 下成功编译运行</p><blockquote><p>读者可能认为 cmake 本来就是跨平台的，所以支持 Windows 和 Linux 应该是理所当然的。实际上，支持跨平台还需要注意一些问题，后文会提到它们。</p></blockquote></li></ul><blockquote><p>项目地址：<a href="https://github.com/jyx-fyh/cmakeLearn/tree/master">cmake实例</a></p></blockquote><p>另外，初学 cmake 的朋友们可以在 Linux 下试试 CLion ，其本身就是用 cmake 管理项目，很容易上手。</p><p>分析本项目之前，先来简单了解一下 cmake 。</p><h2 id="font-color-red-cmake、nmake、make、makefile-font"><font color='red'>cmake、nmake、make、makefile</font></h2><p><img src="/2022/img/v2-497f031761c929e5c036138f938508c6_1440w.webp" alt=""></p><p>make 是 Unix/Linux 下的一个构建工具，用于自动化构建和编译过程。它可以读取一个名为 Makefile 的文件，根据其中的指令来编译和链接源代码文件，生成可执行文件或库文件。实际上，make 最后也是调用的 gcc 和 ld 来完成编译和链接任务。Makefile 最早由程序员直接编写，但很快凸显出瓶颈：1）对于大型项目，手写 Makefile 文件相当费时费力；2）Makefile 和 make 都是 Unix/Linux 下管理工程的工具，无法跨平台使用。于是 cmake 应运而生，利用 cmake，<strong>可以根据 CMakelist.txt 在不同的平台下上产生不同的<u><font color='orange'>构建文件</font></u></strong>，<strong>比如 Linux 下产生 Makefile，Windows 下则产生 .sln 解决方案文件和 .vcxproj 项目文件等</strong> 。那么 nmake 呢？在 Linux 下，make 根据 Makefile 来构建项目，而 Windows 下则是 nmake 根据 Makefile 来构建项目。</p><h2 id="font-color-red-目录结构-font"><font color='red'>目录结构</font></h2><p>为了使后续的讲解更加具体，先给出本项目的目录结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="number">3</span>rdParty</span><br><span class="line">│   ├── lib3rdMath</span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   │   └── lib3rdMath.a</span><br><span class="line">│   │   └── include</span><br><span class="line">│   │       └── <span class="number">3</span>rdMath.h</span><br><span class="line">│   └── libplay</span><br><span class="line">│       ├── bin</span><br><span class="line">│       │   └── libplay.a</span><br><span class="line">│       └── include</span><br><span class="line">│           └── play.h</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── config.h.in</span><br><span class="line">├── include</span><br><span class="line">│   └── student.h</span><br><span class="line">├── libs</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── myMath</span><br><span class="line">│   │   ├── include</span><br><span class="line">│   │   │   └── myMath.h</span><br><span class="line">│   │   └── src</span><br><span class="line">│   │       └── myMath.c</span><br><span class="line">│   └── work</span><br><span class="line">│       ├── include</span><br><span class="line">│       │   └── work.h</span><br><span class="line">│       └── src</span><br><span class="line">│           └── work.c</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── student.c</span><br></pre></td></tr></table></figure><ul><li><code>src</code> 目录用来存放项目的主要逻辑代码，<code>include</code> 则存放对应头文件。</li><li><code>lib</code> 目录用来存放项目自己的库的源代码，<strong>myMath是静态库，work是动态库</strong> 。</li><li><code>3rdParty</code> 目录存放第三方库文件，包含静态链接库和对应头文件。</li><li><code>config.h.in</code> 用来配置项目，后文细说。</li><li><code>README</code> 用来简单说明项目的使用方法，必不可少。</li><li><code>CMakeLists.txt</code> 当然是用来指挥整个项目的编译啦，注意，文件名严格区分大小写。</li></ul><h2 id="font-color-red-外部构建-font"><font color='red'>外部构建</font></h2><p>通常我们不会在 <strong>根目录（最外层的 CMakeLists.txt 所在的目录）</strong> 中直接编译项目，这样的话生成文件会和源文件会混杂在一起凌乱不堪。常见的做法是在根目录下创建一个 build 目录，然后在 build 中进行编译，这就叫做 <strong>外部构建</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样所有的生成文件都会存放在 build 中，不会影响原来的目录结构。</p><p>提到构建目录，就不得不说 cmake 的内置变量 <code>PROJECT_BINARY_DIR</code> 。<strong><code>PROJECT_BINARY_DIR</code> 指向的是我们执行 <code>cmake</code> 命令时所处的目录，对于本项目，就指向 build 目录。<code>PROJECT_SOURCE_DIR</code> 指向的是根目录。</strong> 其他变量见后文。</p><h2 id="font-color-red-构建顺序与传播规律-font"><font color='red'>构建顺序与传播规律</font></h2><p>cmake 根据 CMakeLists.txt 来生成 Makefile 。<strong>项目的不同目录中可以存在多个 CMakeLists.txt ，它们之间存在一定的联系和依赖关系</strong> 。就本项目而言，内层的 CMakeLists.txt 指导生成 myMath 静态库和 work 动态库，外层的 CMakeList.txt 则需要使用这两个库。<br>CMakeLists.txt 文件还可以定义一些全局变量或宏，<strong>这些变量或宏可以在不同的CMakeLists.txt文件之间共享和使用</strong> ，以便在整个项目中保持一致性，本项目中外层就向内层传递了 USE_MYMATH 宏，内层判断此宏是否被定义，若定义则会生成 myMath 库，细节后文详述。</p><p>内外层的 CMakeLists.txt 是怎么联系起来的呢？很简单，使用 cmake 的内置命令 <code>add_subdirectory</code> 。外层 CMakeLists.txt 中使用此命令来添加内层 CMakeLists.txt 所在的目录，然后 cmake 就会自动搜索该目录下的 CMakeLists.txt 并建立联系。</p><p><strong><font color='orange'>绝大多数教程会忽略但又必须提到的一点：cmake 构建项目时采用的是深度优先遍历</font></strong> ，也就是说，扫描 CMakeLists.txt 时只要碰到 <code>add_subdirectory</code> 就会立刻进入内层 CMakeLists.txt 并继续扫描。证明这个结论很简单，利用 cmake 的打印命令 <code>message</code> 即可，如下构建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir0</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── dir3</span><br><span class="line">│       └── CMakeLists.txt</span><br><span class="line">├── dir2</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure><p>各自目录的 CMakeLists.txt 如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dir0</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(untitled C)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir0-before&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir2)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir0-after&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir1</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir1-before&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir3)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir1-after&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir2</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir3</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir3&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建并进入 build 目录，构建项目，提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/CLionProjects/dir0$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/dir0$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/dir0/build$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">.....省略......</span><br><span class="line">dir0-before</span><br><span class="line">dir1-before</span><br><span class="line">dir3</span><br><span class="line">dir1-after</span><br><span class="line">dir2</span><br><span class="line">dir0-after</span><br></pre></td></tr></table></figure><p>可见，确实是按深度优先顺序来构建的：<br><img src="/2022/img/ahshita.png" alt=""></p><p>笔者强调这个不起眼的顺序问题是因为它很多时候会影响构建结果，而且错误很难排查。具体而言，<strong><font color='orange'>局部变量（自定义变量）在各层 CMakeLists.txt 中的共享情况就会受构建顺序的影响</font></strong> 。那么，局部变量是如何在各个 CMakeLists.txt 中传递并共享的呢？笔者总结了一个前提条件和两个约束条件：</p><p><strong>前提条件：</strong></p><ul><li>如果想要变量向下层传递，则必须在调用 <code>add_subdirectory</code> 前定义变量。</li></ul><p><strong>约束条件：</strong></p><ul><li>作用域：变量只能从外层向内层传递。</li><li>继承链：变量只能沿着父（外）子（内）继承链传播，兄弟之间不能共享。</li></ul><blockquote><p><strong><font color='orange'>注意，以上规则只适用于自定义变量，不适用于全局变量，即 cmake 的内置变量。</font></strong></p></blockquote><p>用下面的图来表示也许更加直观，其中红色箭头代表不能传播，绿色箭头代表可以传播：<br><img src="/2022/img/mdfuck.png" alt="dir0定义了A变量,dir1定义了B变量"></p><p>另外，<strong><font color='orange'>不仅变量有这样的规则，某些函数也符合此规律</font></strong> ，比如 add_definition，使用此函数定义 C/C++ 宏后，该宏也会按照以上规则传播，同样的还有 option 和 configure_file 函数，下文还会提到这个问题。</p><blockquote><p><strong><font color='red'>声明：这三个条件是由笔者实践得出，如有错误，敬请指正！</font></strong></p></blockquote><h2 id="font-color-red-项目分析-font"><font color='red'>项目分析</font></h2><p>本项目的目录结构已经在上面给出，下面是内外层的 CMakeLists.txt 和 configure.in.h ：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#外层CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>) <span class="comment">#要求cmake最低版本</span></span><br><span class="line"><span class="keyword">project</span>(cmake VERSION <span class="number">3.0</span>) <span class="comment">#指定项目名称和版本</span></span><br><span class="line"><span class="comment"># 是否使用自己的Math库</span></span><br><span class="line"><span class="keyword">option</span> (USE_MYMATH <span class="comment">#添加编译选项,这是变量而不是宏</span></span><br><span class="line">        <span class="string">&quot;Use provided math implementation&quot;</span> <span class="comment">#打印信息</span></span><br><span class="line">        <span class="keyword">ON</span>) <span class="comment">#变量默认值为 ON</span></span><br><span class="line"><span class="keyword">configure_file</span> (<span class="string">&quot;config.h.in&quot;</span> <span class="string">&quot;config.h&quot;</span>) <span class="comment">#添加配置文件,上面的编译选项就记录在配置文件中</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(libs) <span class="comment">#关联子目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src/ SRC) <span class="comment">#自动搜索src下的所有文件并赋值给SRC变量</span></span><br><span class="line"><span class="keyword">set</span>(LIB play work) <span class="comment">#将play和work库赋值给LIB变量</span></span><br><span class="line"><span class="comment"># 是否加入 myMath 库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span> (<span class="string">&quot;libs/myMath/include&quot;</span>) <span class="comment">#添加头文件搜索目录</span></span><br><span class="line">    <span class="keyword">set</span> (LIB <span class="variable">$&#123;LIB&#125;</span> myMath) <span class="comment">#向LIB变量中添加myMath</span></span><br><span class="line">    <span class="comment">#推荐使用list(APPEND LIB myMath)代替上行</span></span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">include_directories</span> (<span class="string">&quot;3rdParty/lib3rdMath/include&quot;</span>)</span><br><span class="line">    <span class="keyword">link_directories</span>(<span class="string">&quot;3rdParty/lib3rdMath/bin&quot;</span>) <span class="comment">#添加库文件搜索目录</span></span><br><span class="line">    <span class="keyword">set</span> (LIB <span class="variable">$&#123;LIB&#125;</span> <span class="number">3</span>rdMath)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        <span class="string">&quot;include&quot;</span></span><br><span class="line">        <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span> <span class="comment">#config.h</span></span><br><span class="line">        <span class="string">&quot;libs/work/include&quot;</span></span><br><span class="line">        <span class="string">&quot;3rdParty/libplay/include&quot;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">&quot;3rdParty/libplay/bin&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin) <span class="comment">#指定可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_executable</span>(ctest <span class="variable">$&#123;SRC&#125;</span>) <span class="comment">#利用SRC变量中的源文件生成可执行文件ctest</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ctest <span class="variable">$&#123;LIB&#125;</span>) <span class="comment">#将库文件链接到ctest可执行文件</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS ctest DESTINATION bin) <span class="comment">#安装ctest到目录bin</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内层CMakeLists.txt</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(myMath/src/ myMathSrc)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(work/src workSrc)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin) <span class="comment">#设置库文件的输出目录</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH) <span class="comment">#该变量是在上层txt中定义</span></span><br><span class="line">    <span class="keyword">add_library</span>(myMath STATIC <span class="variable">$&#123;myMathSrc&#125;</span>) <span class="comment">#生成myMath静态链接库</span></span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"><span class="keyword">if</span>(WIN32) <span class="comment">#如果是在Windows下构建</span></span><br><span class="line">    <span class="keyword">add_definitions</span>(-D_WIN32_) <span class="comment">#则编译源文件时定义宏_WIN32_</span></span><br><span class="line">    <span class="keyword">set</span>(LIB_POS bin)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(LIB_POS lib)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_library</span>(work SHARED <span class="variable">$&#123;workSrc&#125;</span>) <span class="comment">#生成work共享库</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS work DESTINATION &#123;LIB_POS&#125;) <span class="comment">#将work库安装到&#123;LIB_POS&#125;中</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//configure.h.in</span><br><span class="line">#cmakedefine USE_MYMATH //如果USE_MYMATH变量为ON,则定义该宏,否则不定义</span><br><span class="line">#define PROJECT_VERSION_MAJOR @PROJECT_VERSION_MAJOR@ //用cmake中的版本变量来定义宏</span><br><span class="line">#define PROJECT_VERSION_MINOR @PROJECT_VERSION_MINOR@ //用cmake中的版本变量来定义宏</span><br><span class="line">#define PROJECT_NAME @PROJECT_NAME@ //用cmake中的名称变量来定义宏</span><br></pre></td></tr></table></figure><p>注释较为详细，下面选择性讲解一些需要补充说明的内容。先来分析外层 txt ：</p><ul><li><p><strong>外层 txt 的任务是生成可执行文件并链接库，库的生成则交给内层 txt</strong> 。</p></li><li><p>第 3 行， <code>project</code> 函数指定了项目名称和版本，有什么用呢？首先，指定项目名称后，内置变量 <code>PROJECT_NAME</code> 会被自动赋值为该名称，后续就可以直接使用该变量。<strong><font color='orange'>使用变量的语法为 <code>$&#123;变量名&#125;</code></font></strong> 。其次，指定版本后，内置变量 <code>PROJECT_VERSION_MAJOR</code> （主版本号）和 <code>PROJECT_VERSION_MINOR</code> （副版本号）也会被自动赋值。我们在 <a href="http://configure.h.in">configure.h.in</a> 中使用了它们，该文件作用见下文。</p></li><li><p>第 5 行，定义了 USE_MYMATH 选项，默认为 ON ，即使用 myMath 库。其实 option 函数完全可以使用 set 函数来替代：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(USE_MYMATH <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>只不过采用 set 则无法被 ccmake 检测为选项。<strong><font color='orange'>ccmake 是 cmake 的扩展，能够在构建时提供简单的可视化界面来配置编译选项</font></strong> ：<br><img src="/2022/img/image-20230514102921312.png" alt=""><br>可见，使用 option 命令则会在 ccmake 中看到 USE_MYMATH 选项。</p><blockquote><p><strong><font color='orange'>图中的 <code>CMAKE_BUILD_TYPE</code> 也是 cmake 内置的选项，你可以将其定义为 Debug 以开启调试模式（默认是 Release 模式）</font></strong> 。除了这种方式，还可以通过其他cmake变量开启调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定CMAKE_CFLAGS参数</span><br><span class="line">cmake -DCMAKE_C_FLAGS=&quot;-g -O0&quot; ..</span><br></pre></td></tr></table></figure></blockquote></li><li><p>第 8 行，生成配置文件。<strong><code>configure.h</code> 是 <code>configure.h.in</code> 的输出文件，后者由我们手动编写</strong> 。configure.h 会被输出到构建目录（build）中。<strong><font color='orange'><a href="http://configure.h.in">configure.h.in</a> 能够使用 CMakeLists.txt 中的变量</font></strong> ，使用方法见上文 <a href="http://configure.h.in">configure.h.in</a> 。</p></li><li><p><strong><font color='orange'>生成 configure.h 时，需要注意顺序——<a href="http://configure.h.in">configure.h.in</a> 中使用的变量应该在调用 configure_file 函数前定义</font></strong> 。如果你不信，可以将第 5 行的 option 放到 configure_file 函数之后，编译并运行程序后你会发现奇怪的现象。</p><blockquote><p>所以为了保险起见，可以总是将 configure_file 放在最后。</p></blockquote></li><li><p>第 15 行，<code>set (LIB $&#123;LIB&#125; myMath)</code> 的含义是：如果 LIB 不存在，则为其赋值 myMath；如果存在，则添加值，而不会覆盖原有值。<strong>可以使用可读性更强的 <code>list(APPEND LIB myMath)</code> 来代替</strong> 。</p></li><li><p>第 19 行，添加库文件的搜索目录，这里添加的是第三方库的目录。<strong>注意，对于我们自己生成的库（内层 txt 的第 14 行）则无需手动添加搜索目录，cmake 会自动将库的输出目录（内层第 4 行）添加进去</strong> 。</p></li><li><p><strong>第 32 行，bin 目录是相对路径，其前缀随平台而变化：对于 Linux，前缀为 <code>/usr/local</code> ；对 Windows 而言，前缀为 <code>C:\Program Files (x86)\项目名</code></strong> 。你可以在执行 cmake 时通过 -D 选项来指定安装目录的位置：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=\xxx\yyy</span><br></pre></td></tr></table></figure><p><code>CMAKE_INSTALL_PREFIX</code> 是 cmake 内置变量，指定安装目录的前缀。<strong>注意，cmake 的 -D 选项只能定义 CMakeLists.txt 中的变量，不能定义 C/C++ 中的宏</strong> 。</p></li></ul><p>下面来看内层 txt，很简单：</p><ul><li><p>第 8 行，<code>WIN32</code> 也是 cmake 的内置变量，当在 Windows 下构建项目时，该变量就会被定义。</p></li><li><p>第 9 行，<code>add_definition</code> 函数用来添加 C/C++ 的宏定义。</p></li><li><p>第 8~12 行的含义是：如果为 Windows，则将所有库安装到 bin 目录下，即与可执行文件放在一起；如果为 Linux，则将库放在 lib 中，可执行文件放在 bin 中。</p><blockquote><p>为什么要这样安排呢？因为 Linux 通常将可执行文件放在 usr\bin 下，库文件则放在 usr\lib 中，程序运行时会自动在 usr\lib 中搜寻所需的库文件。而 Windows 的习惯则是将所有库文件（尤其是 dll）和 exe 文件存放在同一个目录，当 exe 运行时，优先从当前目录搜寻库文件，例如 QQ ：<br><img src="/2022/img/image-20230514131005841.png" alt="exe与dll一起存放"></p></blockquote></li></ul><h2 id="font-color-red-Linux下构建-font"><font color='red'>Linux下构建</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>默认使用 myMath 库，输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">./bin/ctest</span> </span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use myMath.h //myMath库</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!  //play库</span><br><span class="line">Let&#x27;s dance! //play库</span><br><span class="line">Let&#x27;s work!  //work库</span><br></pre></td></tr></table></figure><p>也可以不使用 myMath 库，方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/CLionProjects/cmakeLearn/build$ </span><span class="language-bash">cmake -DUSE_MYMATH=OFF ..</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/cmakeLearn/build$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">./bin/ctest</span> </span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use 3rdMath.h</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!</span><br><span class="line">Let&#x27;s dance!</span><br><span class="line">Let&#x27;s work!</span><br></pre></td></tr></table></figure><p>接着进行安装，输入 <strong><code>sudo make install</code></strong> （一定要 sudo），安装成功：<br><img src="/2022/img/image-20230514133434317.png" alt=""></p><p><strong><font color='orange'>注意，现在直接在命令行中运行 ctest 可能会提示找不到库文件，这是因为库的默认搜索路径没有包含 /usr/local/lib，所以我们需要将这 lib 目录添加到系统变量</font></strong> ，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/lib</span><br></pre></td></tr></table></figure><blockquote><p>这种做法仅临时有效，如果要长期有效，则需要修改 .bashrc 文件。</p></blockquote><p>然后就可以运行成功啦：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/$ </span><span class="language-bash">ctest</span></span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use 3rdMath.h</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!</span><br><span class="line">Let&#x27;s dance!</span><br><span class="line">Let&#x27;s work!</span><br></pre></td></tr></table></figure><h2 id="font-color-red-Windows下构建-font"><font color='red'>Windows下构建</font></h2><p>首先需要安装 cmake，直接去官网下载安装即可。</p><p>同样步骤：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;mkdir build</span><br><span class="line">&gt;<span class="built_in">cd</span> build</span><br><span class="line">&gt;cmake ..</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230514135550812.png" alt=""></p><blockquote><p>目录中的 <code>.sln</code> 、<code>.vcxproj</code> 等文件 VS 的解决方案文件和项目管理文件。不了解 Visual Studio 的工程管理方式的朋友请先移步 <strong><a href="https://jyx-fyh.github.io/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/">如何使用 VS 编译调试一个大型项目？</a></strong></p></blockquote><p>打开 cmake.sln 文件：<br><img src="/2022/img/image-20230514140109505.png" alt=""></p><p>可见，cmake 很智能地将我们的工程分为了 6 个项目，主要是 ctest，myMath 和 work 项目，剩余的 ALL_BUILD、INSTALL、ZERO_CHECK 则是 cmake 自动构建的，作用如下：</p><ul><li>ALL_BUILD ：相当于 makefile 的默认目标 make all，用于构建整个解决方案，但不包括 INSTALL 。</li><li>INSTALL ：执行安装任务，相当于 make install 。</li><li>ZERO_CHECK ：检查 CMakeLists.txt 文件是否发生了变化，如果有变化则重新生成构建系统，以确保构建系统始终与 CMakeLists.txt 文件保持同步。通常情况下，不需要手动运行 ZERO_CHECK 项目，因为它会在构建过程中自动运行。</li></ul><p>编译整个解决方案，然后构建 INSTALL，报错如下：<br><img src="/2022/img/image-20230514162003916.png" alt=""></p><p>提示权限不够，这是因为 <code>C:\Program Files (x86)</code> 目录需要管理员权限才能进行更改。我们使用管理员权限启动 VS 并打开此 sln，重新编译并 INSTALL，成功：<br><img src="/2022/img/image-20230514162319358.png" alt=""></p><p>运行 ctest.exe 后只会闪现，你可以在源代码中添加 sleep 函数来仔细看看输出结果。</p><hr><h2 id="font-color-red-常见变量与函数-font"><font color='red'>常见变量与函数</font></h2><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CMAKE_BINARY_DIR<br />PROJECT_BINARY_DIR</td><td style="text-align:left">执行编译时所位于的目录，对于外部构建，则一般为 build 目录。</td></tr><tr><td style="text-align:left">CMAKE_SOURCE_DIR<br />PROJECT_SOURCE_DIR</td><td style="text-align:left">工程顶层目录，即最外层 CMakeLists.txt 所在目录。</td></tr><tr><td style="text-align:left">CMAKE_CURRENT_SOURCE_DIR</td><td style="text-align:left">当前 CMakeLists.txt 所在的路径。</td></tr><tr><td style="text-align:left">EXECUTABLE_OUTPUT_PATH<br />LIBRARY_OUTPUT_PATH</td><td style="text-align:left">最终目标文件存放的路径。</td></tr><tr><td style="text-align:left">PROJECT_NAME</td><td style="text-align:left">通过 PROJECT 指令定义的项目名称。</td></tr><tr><td style="text-align:left">CMAKE_INSTALL_PREFIX</td><td style="text-align:left">安装目录的前缀</td></tr><tr><td style="text-align:left">CMAKE_BUILD_TYPE</td><td style="text-align:left">构建类型，如 Debug 或 Release</td></tr><tr><td style="text-align:left">CMAKE_C_COMPILER</td><td style="text-align:left">C 编译器的路径</td></tr><tr><td style="text-align:left">CMAKE_CXX_COMPILER</td><td style="text-align:left">C++ 编译器的路径</td></tr><tr><td style="text-align:left">CMAKE_C_FLAGS</td><td style="text-align:left">C编译器的编译选项</td></tr><tr><td style="text-align:left">WIN32</td><td style="text-align:left">如果是在 Windows 下编译，则会定义该宏。</td></tr></tbody></table><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">set</td><td style="text-align:center">设置变量（覆盖原有值）</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">为变量添加值</td></tr><tr><td style="text-align:center">add_subdirectory</td><td style="text-align:center">添加子目录</td></tr><tr><td style="text-align:center">add_definitions</td><td style="text-align:center">添加编译器定义</td></tr><tr><td style="text-align:center">configure_file</td><td style="text-align:center">用于生成配置文件</td></tr><tr><td style="text-align:center">message</td><td style="text-align:center">输出消息到控制台</td></tr><tr><td style="text-align:center">add_executable</td><td style="text-align:center">添加可执行文件</td></tr><tr><td style="text-align:center">add_library</td><td style="text-align:center">添加库文件</td></tr><tr><td style="text-align:center">aux_source_directory</td><td style="text-align:center">自动包含指定目录下的所有文件</td></tr><tr><td style="text-align:center">link_directories</td><td style="text-align:center">为整个cmake项目设置库文件搜索目录</td></tr><tr><td style="text-align:center">include_directories</td><td style="text-align:center">为整个cmake项目设置头文件搜索目录</td></tr><tr><td style="text-align:center">target_include_directories</td><td style="text-align:center">为目标（可执行文件或库）设置头文件搜索路径</td></tr><tr><td style="text-align:center">target_link_directories</td><td style="text-align:center">为目标设置库文件搜索路径</td></tr><tr><td style="text-align:center">target_link_libraries</td><td style="text-align:center">将指定库链接进目标</td></tr><tr><td style="text-align:center">install</td><td style="text-align:center">安装目标文件</td></tr></tbody></table><hr><h2 id="font-color-red-其他-font"><font color='red'>其他</font></h2><ul><li><p>相比 Linux 下的 ccmake，Windows 下的 cmake 具有更人性化的图形界面，你可以很方便地设置构建目录、安装目录以及编译选项：<br><img src="/2022/img/image-20230514170003470.png" alt=""></p></li><li><p>Windows 下执行 cmake 后会生成 sln 文件，此时你可以用 VS 打开该解决方案然后进行编译（正如我们上面所做）；另外，你也可以直接在命令行中编译：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;mkdir build</span><br><span class="line">&gt;<span class="built_in">cd</span> build</span><br><span class="line">&gt;cmake  .. </span><br><span class="line">&gt;cmake <span class="literal">--build</span> . <span class="literal">--config</span> Release //以Release模式编译工程</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><code>cmake ..</code> 会生成系统默认的构建文件，你能够指定构建文件，可以是 Unix Makefiles、Ninja、Visual Studio 等等</font></strong> ：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;cmake <span class="literal">-G</span> <span class="string">&quot;Visual Studio 17&quot;</span> ..</span><br><span class="line">&gt;cmake <span class="literal">--build</span> . <span class="literal">--config</span> Release</span><br></pre></td></tr></table></figure><p>这里指定的是 Visual Studio 17 。<strong>执行 <code>cmake --build . --config Release</code> 命令时会使用在 CMake 配置时指定的编译器来构建项目，如果没有指定编译器，则会使用默认的编译器</strong> 。在 Unix/Linux 系统上，通常是 gcc/g++；在 Windows 系统上，通常是 CL.exe 编译器。</p></li><li><p>笔者起初有一个疑惑：我们常说的 Linux 下的编译三部曲：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure><p>这个 ./configure 是什么？它和 <code>cmake ..</code> 有什么区别？具体来说，configure 是 Autoconf 的配置文件，Autoconf 通过 configure 文件来生成构建系统，而 cmake 根据 CMakeLists.txt 来生成构建系统。Autoconf 和 cmake 都是跨平台的构建工具，用于自动化配置软件包的编译和安装过程。Autoconf 使用 M4 宏语言和 shell 脚本来编写配置文件，而 CMake 使用自己的 CMake 语言来编写配置文件；M4 宏语言比较复杂，而 CMake 语言简单易懂。选择哪个工具取决于个人的喜好和项目的需求。</p></li><li><p>最后，虽然 cmake 是跨平台构建工具，但如果你想要你的项目能够跨平台运行，首先需要保证你的代码能够兼容多个平台，比如 I/O 复用模块 epoll 只存在于 Linux 下，Windows 对应的为 IOCP，那么你就需要编写不同的代码来适应多个平台。本项目中碰到的跨平台问题是动态链接库的编写，因为 Linux 和 Windows 对动态链接库的处理有所不同，所以也要做一些配置，参见<a href="">静态链接与动态链接</a>。</p></li></ul><p>本文结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何使用VS编译调试一个大型项目?</title>
    <link href="http://jyxcpp.netlify.app/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"/>
    <id>http://jyxcpp.netlify.app/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-05-02T02:43:02.000Z</published>
    <updated>2023-05-13T15:31:20.112Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中 <code>.cpp</code> ，文件位于 <strong>“源文件”</strong> 节点下。 <code>.h</code>文件位于“**头文件”<strong>节点下，<code>.ico</code>文件<code>.rc</code>位于</strong>“资源文件”**下。 此位置由筛选器文件控制。</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/580990312">C/C++网络训练营</a> 、<a href="https://shiyousan.com/post/636441130259624698">.vs的作用</a> 、<code>chatgpt</code> 。</p></blockquote><h2 id="font-color-red-VS-工程概览-font"><font color='red'>VS 工程概览</font></h2><p>你有没有这样一种感受：想学习 github 上的一些优秀项目时不知道怎么开始；拿到源码后不知道如何运行；项目中密密麻麻的文件是怎么被组织起来的…于是，万里长征路，你就被难在了第一步。确实，学习和使用一个大型项目可能会让人感到困难和无从下手。但是，编译和调试大型项目的过程并不是无法掌握的。下面我将为你提供一些有用的建议和技巧，帮助你更好地理解和使用大型项目。</p><p>1）了解项目的结构和依赖关系是非常重要的。在大多数情况下，大型项目都会有一些文档或者说明文件，尤其是 README 文件，它会告诉你项目的基本信息，包括项目的结构、依赖关系、编译和运行方式等等。你可以先仔细阅读这些文件，了解项目的大致框架和组织方式。</p><p>2）了解项目的编译和构建过程也是非常重要的。大多数大型项目都会使用一些构建工具来自动化编译和构建过程，例如 Make、CMake等。你需要了解这些工具的基本使用方法，以及项目中使用的具体配置和参数。同时，你也需要掌握编译与链接的基本原理。</p><p>3）调试大型项目也是需要一些技巧的。一些常见的调试技巧包括使用调试器、打印日志、使用断言等等。你需要了解这些技巧的基本原理和使用方法，以便更好地定位和解决问题。</p><p>4）充分利用 Google 和 chatgpt，尤其是后者，将报错信息发给它，往往会给你极具引导性的答案。</p><p>一个好的 IDE 也是项目分析的关键。这里我们先来了解 Visual Studio 是如何组织项目的。</p><p>Visual Studio 中，最重要的两个概念是 <strong><u><font color='orange'>解决方案</font></u></strong> 和 <strong><u><font color='orange'>项目</font></u></strong>。</p><p>解决方案 (Solution) 是一个包含一个或多个项目的 <strong>容器</strong> 。<strong>它是用来组织、构建和调试项目的一个虚拟项目</strong> 。解决方案可以包含多个项目，这些项目可以是不同类型的，例如 C++ 项目、静态或动态链接库等等。<strong>在解决方案中，可以对不同项目之间的依赖关系进行管理和设置</strong> 。</p><p>项目 (Project) 是一个实际的代码库（lib \ dll）或者可执行文件（.exe）。在 Visual Studio 中，每个项目都有一个独立的项目文件（.vcxproj），其中包含了项目的所有配置信息，包括编译与链接选项。一个项目可以包含多个源文件（source）、头文件（header）、资源文件（resource）等等，它们一起构成了一个可编译的代码库或者可执行文件。</p><p>在 Visual Studio 中，解决方案和项目是紧密结合的。一个解决方案可以包含多个项目，这些项目可以共享同一个解决方案的设置和配置。例如，你可以在解决方案中设置所有项目的编译选项、链接选项、调试选项等等。同时，你也可以在项目级别上进行一些独立的配置和设置，例如项目的特定编译选项、依赖项等等。</p><p>以 teamtalk 这个在线聊天软件为例（），让我们看看它的结构：<br><img src="/2022/img/image-20230502133617307.png" alt=""></p><p>teamtalk 的解决方案下有 11 个项目。直接运行后报错：<br><img src="/2022/img/image-20230502133719222.png" alt=""></p><p>错误提示 <code>DuiLib.dll</code> 不是一个有效的可执行程序。这是因为 DuiLib 项目为默认启动项，但它生成的是动态链接库，而动态链接库是无法直接运行的，因此报错。<strong><font color='orange'>如何知道哪个项目是默认启动项？</font></strong> 看右边窗口，加粗字体的项目即为默认启动项目。<strong>一般将生成 exe 的项目设置为默认启动项</strong> 。右击任何一个项目，然后点击 <code>Set as Startup Project</code> 选项即可把该项目设置为启动项：<br><img src="/2022/img/image-20230502135834519.png" alt=""></p><p><strong><font color='orange'>怎么知道一个项目的目标生成文件是库还是可执行程序？</font></strong> 右击项目，点击最下方的 Property，显示如下窗口：<br><img src="/2022/img/image-20230502140120538.png" alt="image-20230502140120538"></p><p>可见，teamtalk 项目的目标生成文件为 .exe 。<strong><font color='orange'>一般而言，每个项目都有一个目标生成文件，文件名的前缀即为项目名称（图中高亮的上一行，Target Name）。</font></strong> 目标文件的生成路径也可以在图中的 Output Directory 进行修改。既然它的目标文件是 .exe，那就说明可以运行，我们将其设置为启动项，然后运行：<br><img src="/2022/img/image-20230502141050271.png" alt=""></p><p>成功运行！</p><hr><h2 id="font-color-red-区别几种项目文件-font"><font color='red'>区别几种项目文件</font></h2><p>下面看看 teamtalk 项目的项目文件：<br><img src="/2022/img/image-20230502140749981.png" alt=""></p><p>在 Visual Studio 中创建一个新的 C++ 项目时，通常会生成三个文件：.vcxproj、.vcxproj.filters 和 .vcxproj.user。这些文件分别用于存储项目的配置信息、过滤器信息和用户特定的配置信息。</p><p><strong><font color='gree'>1）</font></strong> .vcxproj 文件是 Visual C++ 项目的主要配置文件，它包含了项目的所有配置信息，例如编译选项、链接选项、输出文件、依赖项等等。这个文件是必需的，没有它，你无法编译和构建项目。<strong><font color='orange'>注意，项目中设置的任何相对路径都是以 .vcxproj 所在路径为基准的。</font></strong></p><blockquote><p>有些朋友可能还见过 <code>.vcproj</code> 文件。vcxproj 和 vcproj 都是 Visual Studio 项目文件的扩展名，但它们之间有一些区别：<br>vcproj 是用于 Visual Studio 2002 和 2003 版本的 C++ 项目文件格式，而 vcxproj 是用于 Visual Studio 2005 及更高版本的 C++ 项目文件格式。因此，vcxproj 是 vcproj 的升级版，它使用了更先进的 XML 格式来表示项目文件。</p></blockquote><p><strong><font color='gree'>2）</font></strong> .vcxproj.filters 文件是 Visual C++ 项目的过滤器配置文件，它用于组织和管理项目中的源文件、头文件、资源文件等。这个文件不是必需的，但是它可以帮助你更好地组织和管理项目中的文件，使代码更易于维护和重用。具体而言，它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中， 某些文件位于 “Main” 文件夹下，某些文件位于 “ProjectFils” 文件夹下。 此位置由筛选器文件控制：<br><img src="/2022/img/image-20230502142944601.png" alt=""></p><p>将 .vcxproj.filters 文件删除后，显示如下：<br><img src="/2022/img/image-20230502143614625.png" alt=""></p><p>结果散乱一团。所以 .vcxproj.filters 最好保留（一并添加到版本控制中）。</p><p>另外值得一提的是，我们将现有的文件添加到项目中的 <strong><u>逻辑</u></strong> 文件夹来一并管理，<strong>但这并不改变实际的目录结构</strong> 。</p><p><strong><font color='gree'>3）</font></strong> .vcxproj.user 文件是用户特定的配置文件，它包含了用户特定的配置信息，比如窗体和鼠标位置等。这个文件是可选的，它可以让不同的用户在同一个项目中使用不同的配置，以适应不同的开发需求。此文件无需保存到版本控制中。</p><p><strong><font color='gree'>4）</font></strong> .vs 文件夹（一般是隐藏状态），通常存放在解决方案的目录下，<strong>用来存储当前用户在解决方案中的工作配置，具体包括 VS 关闭前最后的窗口布局、最后打开的选项卡/操作记录/文件文档、某些自定义配置/开发环境、调试断点等这类设置信息和状态。</strong> 这样每当用户关闭解决方案后再重新打开，就能继续之前的工作状态。因此也无需保存到版本控制中。<br><img src="/2022/img/image-20230502151248516.png" alt=""></p><hr><h2 id="font-color-red-基本操作-font"><font color='red'>基本操作</font></h2><p><strong><font color='gree'>1）编译整个解决方案</font></strong><br>有时候右击 solution 然后点击 build 后，不会编译 solution 下的所有项目，这就很坑，调了半天原来压根没编译。调整方法如下：<br><img src="/2022/img/image-20230502151950947.png" alt=""></p><p><strong><font color='gree'>2）查看构建顺序</font></strong><br>某些库项目可能依赖另外一些库，通过查看构建顺序，我们能够更有针对性地解决库的编译问题，查看方法如下：<br><img src="/2022/img/image-20230502153808196.png" alt=""></p><p>这样，当我们单独编译 network 时出了问题，就可以去检查 network 是否依赖了 GifSmiley 和 httpclient，并针对性地去排查错误。</p><p><strong><font color='gree'>3）头文件搜索目录</font></strong><br>在Visual Studio中，头文件的搜索顺序如下：</p><ol><li>当前项目目录：Visual Studio 首先会在当前项目目录中搜索头文件，如果头文件存在于该目录中，则会直接使用该头文件。</li><li>系统目录：如果头文件不在当前项目目录中，则会在系统目录中搜索。这些系统目录包括 Visual Studio 安装目录、Windows SDK 安装目录、以及其他系统级目录。</li><li>环境变量：如果头文件不在系统目录中，则会在环境变量中指定的目录中搜索。例如，如果你在环境变量中设置了 <code>INCLUDE</code> 变量，则 Visual Studio 会在该目录中搜索头文件。</li><li>项目属性：如果头文件仍然无法找到，则会在项目属性中指定的搜索路径里搜寻。</li></ol><p>在项目属性中指定头文件的搜寻路径是高频使用的方法，必须掌握：<br><img src="/2022/img/image-20230502154638921.png" alt=""></p><p><strong><font color='gree'>5）库搜索目录</font></strong><br>库文件的搜索顺序如下：</p><ol><li>当前项目目录。</li><li>系统目录。</li><li>环境变量。例如，如果你在环境变量中设置了“LIB”变量，则 VS 会在该目录中搜索库文件。</li><li>项目属性。</li><li>引用的项目。<u>如果你的项目引用了其他项目，则 VS 会在这些项目的输出目录中搜索库文件。</u></li></ol><p>在项目属性中设置库的搜索目录，方法如下：<br><img src="/2022/img/image-20230502155314071.png" alt=""></p><p>也可以设置依赖项目，方法如下：<br><img src="/2022/img/image-20230502155518589.png" alt=""></p><p><strong><font color='gree'>6）定义宏</font></strong><br>有时候给你的整个项目定义宏会方便许多，如下：<br><img src="/2022/img/image-20230502155709943.png" alt=""></p><p><strong><font color='gree'>7）库依赖</font></strong><br>这也是最常用的方法之一，我们的项目经常会依赖某些库（lib 或 dll），添加方法如下：<br><img src="../../public/2022/img/image-20230503220941281.png" alt=""></p><p>实际上，上面我们设置的搜索目录、库依赖和宏定义都化作了命令行来指导编译和链接：<br><img src="../../public/2022/img/image-20230503220743624.png" alt=""></p><p><img src="../../public/2022/img/image-20230503220759030.png" alt=""></p><hr><p>OK，暂时先到这里，后面我们将会进行几个编译练习，分别是 teamtalk、Nginx、Libevent、电驴和 uwebsocket。</p>]]></content>
    
    
    <summary type="html">何编译调试一个大型项目?</summary>
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>练习1-编译调试teamtalk</title>
    <link href="http://jyxcpp.netlify.app/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/"/>
    <id>http://jyxcpp.netlify.app/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/</id>
    <published>2023-05-01T07:16:41.000Z</published>
    <updated>2023-05-19T06:11:02.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>TeamTalk 是一款蘑菇街开源的企业内部即时通讯软件，代码质量优秀，具有较高的学习价值。<a href="https://github.com/balloonwj/TeamTalk">源码</a>由张小方老师提供，在此表示感谢。<br>此次的任务仍然是在 Visual Studio 中将源码跑起来，这个过程碰到了许多编译和链接的问题，通过不断调整试错终于跑通了代码，实属不易！学习源码，往往就难在这第一步，只要将源码运行起来，我们就成功了一半。后续的代码细节直接边调试边理解，再爽不过！这个过程大大加深了我对编译与链接的理解，也熟悉了 Visual Studio 的开发环境。</p></blockquote><blockquote><p>勘误：文中图片的路径有时候为 TeamTalk，有时为 TeamTalk_test，前者是笔者为写此博客而重新开的项目，后者是之前的项目，由于本人疏忽不小心混淆了，大家直接将 TeamTalk_test 视作 TeamTalk 即可。</p></blockquote><p>1）从 <a href="https://github.com/balloonwj/TeamTalk">github</a> 上拉取源码，然后打开客户端的 <code>.sln</code> 解决方案文件：<br><img src="/2022/img/image-20230501211233465.png" alt=""></p><p>2）VS可能提示我们更新项目的编译工具集，默认即可：<br><img src="/2022/img/image-20230502103951134.png" alt=""></p><p>3）配置 configuration manager，指定 Build Solution 时是将该方案下的所有项目进行编译。</p><p><img src="/2022/img/image-20230501212233009.png" alt=""></p><p>4）点击 Build Solution，编译完成后报错如下：<br><img src="/2022/img/image-20230501212537341.png" alt="">我们一个一个来解决错误。</p><hr><p>先看 &lt;hash_map&gt; 的报错。该错误出现在 <code>network</code> 项目中，提示 &lt;hashmap&gt; 已经被废弃，如果要使用它，请先定义指定的宏。 右击 侧边栏的 <code>network</code> 项目，点击最下方的 property 选项；然后在 C/C++ 栏目中找到 Preprocessor 预处理栏，然后打开 Preprocessor Definitions ，向其中添加提示的宏 <code>_SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS</code> 即可。Modules 和 teamtalk 项目也有此错误，相同操作。<br><img src="/2022/img/image-20230501213353573.png" alt=""></p><hr><p>之前的报错中还提示 ‘function’: is not a member of ‘std’ ，这个简单，直接在对应文件中添加头文件 &lt;functional&gt; 即可。</p><hr><p>再次编译，报错如下：<br><img src="/2022/img/image-20230501214331967.png" alt=""><br><code>mbstate_t</code> 是结构体，无法直接赋值，应该使用初始化列表，将 <code>0</code> 改为 <code>&#123;0&#125;</code> 即可。</p><hr><p>再次编译，报错如下：<br><img src="/2022/img/image-20230501214805977.png" alt=""><br>先看后三个错误。在 utility 项目中无法打开 <code>mfcs120ud.lib</code> 文件，而在 Modules 和 teamtalk 项目中无法打开 <code>utility.lib</code> 。<strong>显然，是因为 <code>mfcs120ud.lib</code> 无法被打开导致 utility 项目无法生成 <code>utility.lib</code> ，继而使得 Modules 和 teamtalk 项目无法使用 <code>utility.lib</code> 。</strong> 所以我们必须先解决 <code>mfcs120ud.lib</code> 的问题。从这个静态链接库的名字我们可以知道，它不由任何项目生成，所以它应该是一个第三方库。打开文件夹，在整个 teamtalk 中搜索该文件，没有找到相关内容：<br><img src="/2022/img/image-20230501220032627.png" alt=""></p><p>所以我们可以大胆猜测这个库应该是系统库或编译器自带库。让 chatgpt 来告诉我们：<br><img src="/2022/img/image-20230501220445545.png" alt="image-20230501220445545"></p><p>ok，我们现在知道它是 MFC 的库，而且对应的版本是 Visual Studio 2013 。而当前我们的 VS 版本为 2022，所以极有可能是版本不匹配的原因。还是不确定，那让我们在 VS 的 VC 目录下搜索 mfcs 的相关内容：<br><img src="/2022/img/image-20230501220913135.png" alt=""></p><p>因此可以推断，2022 版本的对应库为 <code>mfcs140u.lib</code> 而不是 <code>mfcs120ud.lib</code> 。所以我们修改 utility 项目的依赖库，如下：<br><img src="/2022/img/image-20230501221137089.png" alt=""></p><p>然后再次编译：<br><img src="/2022/img/image-20230501221225358.png" alt=""></p><p>果然，utility 的 <code>mfcs120ud.lib</code> 错误解决。Modules 也有相同问题，步骤如法炮制。</p><hr><p>再次编译：<br><img src="/2022/img/image-20230501221431394.png" alt=""></p><p>尼玛！问题又多了，头大！现在提示在 Modules 项目中的 <code>libprotobuf-lite.lib</code> 文件中有<code>_MSC_VER</code> 相关的错误。 <code>_MSC_VER</code> 是什么？chatgpt 告诉你：<br><img src="/2022/img/image-20230501221808184.png" alt=""></p><p>真清晰！OK，现在我们大概知道报错是因为 <code>libprotobuf-lite.lib</code> 的编译版本较低造成的。同样，<code>libprotobuf-lite.lib</code> 依然不是我们的项目生成的库文件，让我们看看它在哪：<br><img src="/2022/img/image-20230501222531477.png" alt=""></p><p>嗯，从路径中的 3rdParty（第三方）也可以看出这是第三方库，而不是我们自己编译的库。那么问题来了，我们应该如何将 <code>libprotobuf-lite.lib</code> 转换为高编译器版本呢？大多数第三方库都是知名库，可以直接从官方下载最新版本，比如这个库就可以在<a href="https://github.com/protocolbuffers/protobuf/tree/main">github</a>下载。不过仔细搜寻后发现第三方库下有相关的压缩包（最下方的 protobuf）：<br><img src="/2022/img/image-20230501233642275.png" alt=""></p><p>解压后进入 vsprojects 目录，使用 VS 打开其中的 <code>libprotobuf-lite.vcxproj</code> ，这是工程文件：<br><img src="/2022/img/image-20230501233840160.png" alt=""></p><p>打开后 Build 这个解决方案，编译成功，最新编译版本的 <code>libprotobuf-lite.lib</code> 的输出位置见图：</p><p><img src="/2022/img/image-20230501233437643.png" alt=""></p><p>由于 Modules 项目的 linker 输入目录（Additional Library Directories）为 <code>D:\VSProjects\TeamTalk\win-client\3rdParty\lib\debug</code> ：<img src="/2022/img/image-20230501235111560.png" alt=""></p><p>所以我们用新的 lib 将久版本的 lib 替换掉：<br><img src="/2022/img/image-20230501235420326.png" alt=""></p><p>然后再次编译，该错误已经消失。teamwork 也有相同错误，同样加上前缀即可：<br><img src="/2022/img/image-20230502002924115.png" alt=""></p><p>啊哦，出现了关于 <code>security.lib</code> 的新错误…还是关于编译版本的问题。不过这次和之前的 <code>libprotobuf-lite.lib</code> 不同，第三方库目录下没有相关的压缩包。不过我们在 <code>3rdParty\src</code> 下发现了 <code>security.cpp</code> 源文件，所以为什么不直接编译呢？将这个源文件作为一个项目引入到 solution 下：<br><img src="/2022/img/image-20230502093523653.png" alt=""></p><p>发现有多个源文件找不到路径，搜索后发现它们位于 <code>\TeamTalk\server\src\libsecurity\src</code> 下，所以将此目录包含进项目的头文件搜寻范围：<br><img src="/2022/img/image-20230502093758527.png" alt=""></p><p>现在头文件已经能够检测到，不过还有些类型报错：<br><img src="/2022/img/image-20230502093855723.png" alt=""></p><p>小问题，<code>typedef unsigned char uchar_t</code> 即可。然后单独编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502094149718.png" alt=""></p><p>预编译头文件？这是什么？还是问问 chatgpt 吧：<br><img src="/2022/img/image-20230502094505883.png" alt=""></p><p>我们无需使用预编译头文件，这里报错是因为项目默认开启了预编译头文件的功能，关闭即可：<br><img src="/2022/img/image-20230502094705556.png" alt=""></p><p>再次编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502094754249.png" alt=""></p><p>好，我们在项目中添加 <code>SECURITY_WIN32</code> 宏：<br><img src="/2022/img/image-20230502094917057.png" alt=""></p><p>于是 security 项目编译成功：<br><img src="/2022/img/image-20230502095015199.png" alt=""></p><p>好，同样，我们用新生成的 <code>security.lib</code> 把之前的替换掉：<br><img src="/2022/img/image-20230502095155732.png" alt=""></p><p>然后编译整个 solution，报错：<br><img src="/2022/img/image-20230502095844929.png" alt=""></p><p>提示在 <code>security.lib</code> 中调用了一些没有定义的函数。回想一下，刚才我们是不是只为 security 项目引入了头文件目录以确保头文件能够找到，却没有把这些头文件对应的源文件包含进来，这样的话，<strong><u>如果 <code>security.cpp</code> 中调用了这些头文件声明的函数，只有声明而没有定义，就一定会导致上图所示的链接错误</u></strong> 。因此我们需要把头文件对应的源文件包含进 security 项目，它们仍位于 <code>\TeamTalk\server\src\libsecurity\src</code> 中：<br><img src="/2022/img/image-20230502100837276.png" alt=""></p><p>ok，编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502101048441.png" alt=""></p><p>问题不大，定义该宏就行。然后再次编译，成功！然后把新的 <code>security.lib</code> 替换掉之前的即可。然后编译整个 solution，报错如下：<br><img src="/2022/img/image-20230502102713327.png" alt=""></p><p><code>Please verify that you have sufficient right to run this command</code> ，权限不够？那我们关闭 VS，以管理员身份重新运行：<br><img src="/2022/img/image-20230502102907161.png" alt=""></p><p>哟呼！跑起来啦！！！！大功告成。</p><p>接下来我们就可以随意打断点，单步调试 teamtalk 了，这样来学习源码真是不要太爽！</p>]]></content>
    
    
    <summary type="html">编译调试teamtalk</summary>
    
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/categories/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
    
    <category term="编译、链接与调试" scheme="http://jyxcpp.netlify.app/tags/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言宏的几处陷阱</title>
    <link href="http://jyxcpp.netlify.app/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/"/>
    <id>http://jyxcpp.netlify.app/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/</id>
    <published>2023-04-28T12:04:23.000Z</published>
    <updated>2023-04-28T12:52:44.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《C与指针》</p></blockquote><ol><li><p><strong>为宏定义中的变量以及宏定义体加上括号：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) ((x)*(y))</span></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) (x*y)</span></span><br></pre></td></tr></table></figure><p>否则按错误方式书写则可能出现如下错误：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL(a+b, c+d);</span><br><span class="line"><span class="comment">//被编译为 a + b * c + d , 显然是错误的</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义多语句宏代码时，请使用 do{…}while() 语句：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) &#123;error_code=x;return false;&#125;</span></span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) do&#123;error_code=x;return false;&#125;while(0);</span></span><br></pre></td></tr></table></figure><p>是否感觉到很莫名其妙，为什么不能使用 <code>&#123;&#125;</code> ？看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)</span><br><span class="line">    ERROR_RET(x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这段代码被编译成：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)&#123;</span><br><span class="line">    error_code=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>显然，第 4 行花括号后面的 <code>;</code> 是一个语法错误。关于 <code>do&#123;&#125;while()</code> 的详细说明，参见<a href="https://jyx-fyh.github.io/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/">do{}while()有什么用？</a> 。</p></li><li><p><strong>如果你不了解所使用的宏，则尽量不要在宏调用中发生动作：</strong><br>什么是 <code>发生动作</code> ？简单解释，就是操作变量或者调用函数，看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">7</span>;</span><br><span class="line">z = MAX(x++, y++);</span><br><span class="line"><span class="comment">//较小的x自增了一次,结果较大的y却自增了两次</span></span><br></pre></td></tr></table></figure><p>这种错误就比较隐蔽。<strong><u>对于宏定义中同一个变量出现多次的情况，更要预防这种错误</u></strong> 。函数调用也可能产生问题：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_lower(ch)  (((ch) &gt; <span class="string">&#x27;a&#x27;</span> &amp;&amp; (ch) &lt; <span class="string">&#x27;z&#x27;</span>) ? 1 : 0)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">is_lower(getchar());</span><br></pre></td></tr></table></figure><p>宏展开后，getchar() 将会被调用两次，也就是说，缓冲区将消耗两个字符，这对后续的文本分析工作可能造成毁灭性影响。</p></li></ol><p>其他注意事项待补充。</p>]]></content>
    
    
    <summary type="html">C语言宏的几处陷阱</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>&lt;转载&gt;do{}while()有什么用?</title>
    <link href="http://jyxcpp.netlify.app/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
    <id>http://jyxcpp.netlify.app/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</id>
    <published>2023-04-26T14:37:58.000Z</published>
    <updated>2023-04-26T15:36:10.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一直以来我都认为 do{}while() 语句十分鸡肋，直到最近才发现它的一些妙用，下面这篇文章总结了 do{}while() 的一些使用场景，希望对各位有所帮助。<br>原文：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3535674.html">do{}while()有什么用?</a></p></blockquote><p>在一些Linux内核和其它的开源代码中，我们经常看到像下面这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;while(0)</span><br></pre></td></tr></table></figure><p>该代码片段并非循环，这样想想似乎使用do…while没有任何意义，那么为什么还要使用它呢？</p><p>实际上，do{…}while(0)的用途并不仅仅是优化你的代码。经过一系列的调研和探索，我们总结出它的一些用途如下。</p><h2 id="font-color-red-帮助定义多语句宏以避免错误-font"><font color='red'>帮助定义多语句宏以避免错误</font></h2><p>如果你是一名 C 程序员，你肯定很熟悉宏，它们非常强大，如果正确使用可以让你的工作事半功倍。然而，如果你在定义宏时很随意没有认真检查，那么它们可能使你发狂，浪费N多时间。在很多的C程序中，你可能会看到许多看起来不是那么直接的较特殊的宏定义。下面就是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __set_task_state(tsk, state_value)      \</span><br><span class="line">    do &#123; (tsk)-&gt;state = (state_value); &#125; while (0)</span><br></pre></td></tr></table></figure><blockquote><p>在Linux内核和其它一些著名的C库中有许多使用do{…}while(0)的宏定义。这种宏的用途是什么？有什么好处？Google 的 Robert Love（先前从事Linux内核开发）给我们解答如下：<br><strong><font color='orange'>do{…}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</font></strong></p></blockquote><p><strong>这句话听起来可能有些拗口，其实用一句话概括就是：<font color='orange'>使用 do{…}while(0) 构造后的宏定义不会受到大括号、分号等的影响，并总是会按你期望的方式调用运行。</font></strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure><p>然后你可能这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(wolf);</span><br></pre></td></tr></table></figure><p>这将被宏扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar(wolf); baz(wolf);</span><br></pre></td></tr></table></figure><p>这的确是我们期望的正确输出。下面看看如果我们这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br></pre></td></tr></table></figure><p>那么扩展后可能就不是你所期望的结果。上面语句将扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    bar(wolf);</span><br><span class="line">baz(wolf);</span><br></pre></td></tr></table></figure><p>显而易见，这是错误的。这里你可能感到迷惑不解了，<strong>为什么不用大括号直接把宏包围起来呢？</strong> 而非得使用 <strong>do/while(0)</strong> 逻辑呢？例如，我们用大括号来定义宏如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure><p>这对于上面举的if语句的确能被正确扩展，但是如果我们有下面的语句调用呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>宏扩展后将变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral) &#123;</span><br><span class="line">    bar(wolf);</span><br><span class="line">    baz(wolf);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>大家可以看出，这就有语法错误了。</p><p><strong><font color='orange'>几乎在所有的情况下，期望写<u>多语句宏</u>来保证正确的结果是不可能的，你不能让宏像函数一样行为——除非使用 do/while(0) 语句。</font></strong></p><h2 id="font-color-red-避免使用goto控制程序流-font"><font color='red'>避免使用goto控制程序流</font></h2><p>在一些函数中，我们在return语句之前可能需要做一些工作，比如释放在函数一开始由malloc函数申请的内存空间，使用goto总是一种简单的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">END:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于 goto 关键字可能会使代码不易读，因此许多人都不推荐使用它，那么我们可以使用 do{…}while(0) 来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用 do{…}while(0) 来包含函数的主要部分，同时使用 break 替换 goto，代码的可读性增强了。</p><blockquote><p>禁止使用 goto 已经成为程序员的教条，但它并非魔鬼，少量使用是有益而无害的——尤其在跳出多重循环时很方便。</p></blockquote><h2 id="font-color-red-避免由宏引起的警告-font"><font color='red'>避免由宏引起的警告</font></h2><p>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用do{…}while(0) 来定义空宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define EMPTYMICRO do&#123;&#125;while(0) </span><br></pre></td></tr></table></figure><p>这样在编译的时候就不会产生警告。</p>]]></content>
    
    
    <summary type="html">do{}while()有什么用?</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>EPOLLHUP/EPOLLRDHUP与read返回0的区别</title>
    <link href="http://jyxcpp.netlify.app/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://jyxcpp.netlify.app/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-04-24T15:13:59.000Z</published>
    <updated>2023-04-25T06:25:12.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：<a href="https://blog.csdn.net/halfclear/article/details/78061771">epoll触发事件的分析</a> 、<a href="https://stackoverflow.com/questions/51833215/why-do-we-need-epollrdhup-when-epollhup-seems-enough">EPOLLHUP&amp;EPOLLRDHUP</a> 、<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">man_page</a></p></blockquote><p>相信很多时候，大家都是通过检测 read/recv 返回 0 来判断对端是否关闭了连接，如果返回 0，我们通常也会 close 该连接。这没有问题，但在很多场景下有个缺陷：FIN 报文和普通数据报文一样，也是需要在缓冲区中排队的，只有当 read 读取到 FIN 以后才会返回 0，而且 FIN 报文无法和数据同时被读取，也就是说，必须将数据 read 完毕后，再调用一次 read 才能读取到 FIN 并返回 0 。这也是为什么在网络读取时需要将 read 放在循环中的原因之一，不仅是为了将数据读取完整，也是为了能够读到 FIN 报文。</p><blockquote><p><strong>注意，FIN 报文虽然会排队，但当本端收到 FIN 后，内核网络栈会立刻回复 ACK，而不会管你是否 read 到这个 FIN 报文。</strong></p></blockquote><p>那么这个缺陷会引发什么问题呢？由于笔者现在也是网络编程初学者，没有太多实战经验，所以这里只提供本人猜想的两个情景：</p><ul><li>在一个高并发网络场景下，服务器收到了对端发来的 FIN 报文（对端 close），但没有立即读取（正忙于处理已接收的数据），所以现在此连接处于半关状态，因为服务器的 read 还没有返回 0。直到服务器处理完其他事情后 read 并返回 0 才会 close 此连接。问题在于，这段时间内该连接被白白占用了，浪费了服务器的端口，这对高并发处理是不利的。服务器完全可以先关闭该连接，再去处理数据。</li><li>客户端向服务器发送文件，而文件的末端是 EOF，所以当服务器 read 到文件末端的 EOF 后返回 0，进而关闭连接。问题来了，万一客户还想继续发送文件呢？也就是说，<strong><font color='orange'>此时 read 返回 0 并不代表客户端想关闭连接</font></strong> 。</li></ul><p>因此，我们应该尽量避免使用 read/recv 返回 0 来判断对端的关闭状态。那还有什么方法？答案是 epoll 的 EPOLLRDHUP 和 EPOLLHUP 事件。这两者很容易混淆，下面略作区分。</p><p>EPOLLRDHUP 最为常用，<strong>当对方关闭（close）连接或者关闭写（shutdown(SHUT_WR)）时，本事件就会被触发</strong> 。所以 EPOLLRDHUP 被用来监听对方的连接状态。与前面 read 不同，<strong><font color='orange'>只要 FIN 报文进入了缓冲区，不管是否读取，都会引发 EPOLLRDHUP 事件</font></strong> 。</p><blockquote><p>那么当 EPOLLRDHUP 发生时，我们该做什么呢？<strong>因为我不知道对方是 close 还是 shutdown(SHUT_WR)，如果是后者，我就还能够将处理好的数据发给对方，如果是前者，则发送数据后则会收到对方发来的 RST 报文，从而直接结束连接。</strong> 该做什么应该取决于应用场景，如果是 http 服务，那就不应该直接关闭连接，因为对端可能是 shutdown，且还需要接收数据（比如请求图片）；如果是上传文件到服务器，那么就可以直接关闭连接，因为服务器不需要再向对端回复数据。</p></blockquote><p>EPOLLHUP 则令人困惑，官方文档的解释是：当套接字挂起时，本事件被激发。然而什么是“挂起”却没有解释，网络讨论也说法不一。笔者给出两种已经被实验证实的情况：</p><ul><li><p><strong>收到对端发来的 RST 报文</strong></p><blockquote><p>RST 报文用来重置连接，当一方发送RST报文后，对端会立即关闭连接，并释放相关资源。所以收到 RST 后，套接字相当于残废，被“挂起”。</p></blockquote></li><li><p><strong>将一个不可能触发该事件发生的套接字加入 EPOLL</strong></p><blockquote><p>比如，使用 socket() 返回了一个套接字，既不 listen 也不 connect，这个套接字将没有任何事情发生（这也许就是“挂起”的含义），此时如果将其加入到 EPOLL 中，则会产生 EPOLLHUP 事件。</p><p><strong><font color='orange'>值得一提的是，对端 close 连接时，不会触发本端的 EPOLLHUP；但对端同时 shutdown 读和写时（即 shutdown(SHUT_RDWR) ），则会触发本端的 EPOLLHUP</font></strong> 。<strong>因为调用 shutdown(SHUT_RDWR) 只会关闭连接的读端和写端，不会释放文件描述符和其他相关资源，但此时该套接字已经处于“聋哑”状态，没有作用了，所以相当与被“挂起”；</strong><font color='orange'><strong>而当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</strong></font> ，如果应用程序需要释放文件描述符和相关资源，还需要调用 close 函数。</p></blockquote></li></ul><p><strong>注意，EPOLLHUP 不能用来监听对方的关闭状态！</strong></p><p>补充说明：</p><ul><li><strong><font color='orange'>对于 EPOLLERR 和 EPOLLHUP，不需要在 epoll_event 时针对 fd 作设置，一样也会触发</font></strong></li><li><strong>对端发来 RST 信号，触发本端的 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件</strong></li><li>如前文，对端不管是 close 套接字，还是 shutdown 写，本端触发的都是 EPOLLIN + EPOLLRDHUP 事件，<strong>因此，本端无从区分对端是 close 了套接字，还是 shutdown 了写</strong> 。但有一点可以区分，如果对端是 close 了套接字，则本端在套接字上发送数据时，本端会收到对端发来的 RST 报文从而本端会触发 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件；而如果对端只是 shutdown 了写，则本端可以正常发送数据不会触发任何信号。</li><li><strong><font color='orange'>当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</font></strong></li></ul>]]></content>
    
    
    <summary type="html">EPOLLHUP/EPOLLRDHUP与read返回0的区别</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>互斥锁、条件变量与信号量的区别及其用法</title>
    <link href="http://jyxcpp.netlify.app/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jyxcpp.netlify.app/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2023-04-23T07:02:07.000Z</published>
    <updated>2023-04-30T04:26:23.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《操作系统导论》《操作系统之哲学原理》《Linux高性能服务器编程》</p></blockquote><p>由于没有具体的应用场景，笔者之前一直对锁、条件变量和信号量感觉迷迷糊糊，总觉得它们很相似但又有所区别。这两天在写线程池时需要用到任务队列，主线程生产任务，工作线程则竞争地从队列中取出任务——也就是我们常说的“生产者/消费者问题”，接触到这个具体的场景后，笔者突然就明白了它们的区别。</p><p><strong><font color='orange'>互斥锁用来保证多线程/进程之间对共享资源的互斥访问，也就是保证同一时刻只有一个执行流在临界区中。</font></strong></p><p>POSIX 的互斥锁操作主要有如下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化锁,将锁的各个字段都初始化为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> pthread_mutexattr* attr)</span>;</span><br><span class="line"><span class="comment">//销毁锁,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//非阻塞上锁,如果锁已经被持有,则返回错误EBUSY</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>除了使用 <code>pthread_mutex_init</code> 初始化锁，也可以采用 <code>PTHREAD_MUTEX_INITIALIZER</code> 如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>注意，这种方式必须在初始化锁使用，不能在声明后赋值。</p></li><li><p><code>attr</code> 是锁的属性，常用的有两种——pshared 和 type，前者指定锁是否跨进程共享，后者指定锁的类型。互斥锁的类型有普通所、检错锁、递归锁，这里笔者没有深入研究，读者可自行了解。正常情况下，attr 设置为 NULL 即可。</p></li><li><p>需要注意，同一个执行流重复持有一个锁会导致死锁，此时需要使用递归锁。两个线程按照不同的顺序来申请两个互斥锁也可能导致死锁，具体情境参见《Linux高性能服务器编程》P278 。</p></li></ul><p><strong><font color='orange'>条件变量则提供了一种线程之间的通知机制，当某个条件满足时再唤醒沉睡在这个条件上的线程。</font></strong> 就笔者遇到的场景来说，只有当任务队列中存在任务时，线程才能获取任务并继续它的工作，否则只能睡眠。相关函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* attr)</span>; <span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>; <span class="comment">// 销毁条件变量,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex)</span>; <span class="comment">//在条件变量上睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒一个线程,具体唤醒哪个则取决于优先级和调度策略</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒所有线程</span></span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>同样可以使用如下方式初始化条件变量：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>我们看到 <code>pthread_cond_wait()</code> 函数的第二个参数是互斥锁，那么为什么在条件变量上等待时还需要上锁呢？</font></strong> 假设等待条件变量时不需要加锁，考虑这样的情形：线程 A 中某个时刻，条件变量 cond 还未成立，于是调用 <code>pthread_cond_wait()</code> 准备睡眠，而在**<u>睡眠前一刻</u>** ，执行流切换到线程 B，B 使条件变量 cond 成立，然后调用 <code>pthread_cond_signal()</code> 唤醒在 cond 上睡眠的线程，但线程 A 还没有完全睡眠，所以等待队列中没有可以唤醒的线程（这也就是所谓的 <strong><u>虚假唤醒</u></strong> ）。问题来了，现在执行流切换到 A，接着 A 完全睡眠。于是，线程 A 错过了 B 发送的唤醒信号，继而引发死锁。<strong>上面的问题在于，从 <code>pthread_cond_signal()</code> 函数被执行到调用线程被放入等待队列的这段时间内条件变量发生了改变。</strong> 所以我们必须保证这段空窗期内条件变量不会被修改，这也就是 <code>pthread_cond_wait()</code> 中锁参数的作用。因此 <strong><font color='red'>调用 <code>pthread_cond_wait()</code> 前必须保证 mutex 已经上锁</font></strong> 。</p><blockquote><p>调用 <code>pthread_cond_wait()</code> 时加锁是强制要求（该函数的第二个参数），但 <code>pthread_cond_signal()</code> 则不一定需要在加锁时调用。<strong><font color='red'>但是作为一般化的规则，在 wait 和 signal 时都持有锁总是正确的</font></strong> 。</p></blockquote></li><li><p><strong><code>pthread_cond_wait()</code> 在睡眠前一刻会释放锁，以使其他线程能够进入临界区；被唤醒后执行流从该函数返回，锁又会被该线程持有，以保证互斥访问临界区。</strong></p></li><li><p><code>pthread_cond_broadcast()</code> 函数有什么应用场景？参见《操作系统导论》 P261</p></li></ul><p>下面我们来看条件变量的局限性。先引入具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    add_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在只有两个线程时能够准确无误的运行，但当线程数多于两个时，就会发生问题：消费者 A 发现没有 food，于是沉睡在条件变量 food 上，然后执行流转移到生产者，生产者 add_food 后唤醒消费者 A，于是消费者 A 进入就绪队列（只是就绪，但没有运行）。问题来了，<u>此时消费者 B 抢先执行</u> ，发现 food 不为空，于是 eat_food 。紧接着切换到消费者 A ，从 17 行返回，由于 food 已经被消费者 B 吃掉，所以执行第 18 行 eat_food() 时将引发错误（只有 food 不为空时才能 eat）。</p><p>我们很容易知道解决上面问题的办法：<strong>不让消费者 B 抢先执行。也就是说，唤醒消费者 A 后立刻调度。</strong> 实际上，这种方式被称为 <code>Hoare</code> 语义，而前面的只唤醒，不保证立刻调度的方式称为 <code>Mesa</code> 语义。然而，由于 <code>Hoare</code> 语义的实现难度较大，几乎所有的操作系统都采用 <code>Mesa</code> 语义。</p><p>那么该如何解决这个问题呢？也很简单，将第 7、16 行的 <code>if</code> 改成 <code>while</code> 即可。消费者被唤醒后，总是再次检查共享变量 food，如果不满足，则再次睡眠。因此，<strong><font color='red'>谨记使用条件变量的通用规则：总是使用 while() 判断条件是否成立</font></strong> 。</p><p>上面的方案依旧存在问题：当消费者 A 发出 signal 时，会唤醒哪个线程呢？按道理来说应该是唤醒生产者，但线程调度不保证这一点。设想，当消费者 A 发出 signal 后唤醒的是消费者 B，而 B 发现 food 仍然为空，于是陷入睡眠；而生产者根本没有被唤醒，于是一直相互等待。<strong>这个问题的原因在于信号没有指向性</strong> ，显然消费者不应该唤醒消费者，而应该唤醒生产者。<strong><font color='orange'>解决办法也很简单——使用两个条件变量：</font></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> empty;</span><br><span class="line"><span class="type">pthread_cond_t</span> filled;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">//如果还有food,就等待被消耗完再添加</span></span><br><span class="line">    add_food(&amp;food); </span><br><span class="line">    pthread_cond_signal(&amp;full);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;filled, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;empty);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们提出下一个问题：为什么还要引入信号量？<strong><u>实际上，信号量不是必须的，它是对互斥锁和条件变量的封装</u></strong> ，看看源码便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE &amp;&amp; sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">while</span> (sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;sem-&gt;cond, &amp;sem-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        sem-&gt;value--;</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        sem-&gt;value++;</span><br><span class="line">        pthread_cond_signal(&amp;sem-&gt;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> pshared;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上源码由 chatgpt 生成。</p></blockquote><p>可以很清楚地看到，信号量内部使用了互斥锁和条件变量。信号量和条件变量的区别在于：</p><ol><li><p>信号量内部使用了 value ，而条件变量是在外部使用 value （也就是上面的 food）来计数。</p><blockquote><p>之前代码中的 food 是二元变量（true\false），实际上你完全可以直接将它改为多值变量。</p></blockquote></li><li><p>由于条件变量是在外部维护的 value，所以操作 value 时必须由程序员负责先持有锁。而信号量也会持有锁，只不过对程序员屏蔽了细节。</p></li><li><p>信号量只能一次唤醒一个特定的线程/进程，而条件变量可以广播。</p></li></ol><p><strong><font color='orange'>二元信号量可以充当互斥锁，也能够充当条件变量。当信号量的 value 初始化为 1 时即为互斥锁。</font></strong></p><p>信号量的 POSIX 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面函数成功时返回 0，失败时返回 -1，并设置 errno。</p></blockquote><ul><li>pshared 表示信号量的类型，可以是 PTHREAD_PROCESS_PRIVATE 或 PTHREAD_PROCESS_SHARED，分别表示进程内私有和进程间共享。value 表示信号量的初始值。</li><li><code>sem_wait()</code> 将信号量的值减 1 。如果信号量的值为 0，则 sem_wait 陷入阻塞，直到信号量大于 0 。参见上面的源码。<br><code>sem_post()</code> 将信号量的值加 1，并唤醒一个线程。</li></ul><p>为了更好地理解信号量，下面使用信号量改写之前的生产者/消费者代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> food; <span class="comment">//food为一个队列,没有食物时队列为空</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> sem; <span class="comment">//信号量的值即为队列中的食物量</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pushback(); <span class="comment">//向队列中添加food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    sem_post(&amp;sem);  <span class="comment">//信号量+1,即食物量+1,并唤醒一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem); <span class="comment">//将信号量-1,如果为0就等待</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pop(); <span class="comment">//从队列中取出food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为当条件可累积时，信号量比条件变量更方便。从上面的代码也能够看出，<strong><u><font color='orange'>即使使用了信号量，在操作共享资源时仍然必须锁来保证互斥访问</font></u></strong> 。</p><blockquote><p><strong><font color='red'>注意，为了避免死锁，请将互斥锁的获取和释放紧贴着临界区，务必不要将 sem_wait 和 sem_post 放入锁范围内</font></strong> ！详细参见《操作系统导论》P271</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络字节序及其注意事项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-04-16T01:37:48.000Z</published>
    <updated>2023-04-16T11:23:45.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网页上有许多关于字节序的讨论，这里就不多说了，只强调笔者认为最重要的两点：</p><ul><li><strong><font color='orange'>字节序与 CPU 相关，或者说与计算机体系架构相关，而与操作系统无关。</font></strong></li><li><strong><font color='orange'>字节序只针对多字节数据（如 int ）才有意义，单字节数据（如 char）不用考虑字节序的问题。</font></strong></li></ul><p>笔者是这样理解上面两点的：<br><strong><font color='red'>字节序就是指 CPU 中的寄存器对数据的解释方式</font></strong> 。32 位 CPU ，其寄存器大小为 4 字节，如果被设计为小端序，那么低地址的字节会被解释为低位数据，高地址的字节会被解释为高位数据：<br><img src="/2022/img/endian-1681633780948-2.png" alt=""></p><p>从上图也能看出，当单字节数据不会被解释方式（大小端）影响，比如 0x11 仍然被解释为 0x11：<br><img src="/2022/img/endian1.png" alt=""><br>那么，如何知道自己主机的大小端呢？很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span>* p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输出 0x44，那么就是小端。有种常见的错误做法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> j;</span><br><span class="line">    i = <span class="number">0x1234</span>;</span><br><span class="line">    j = (<span class="type">char</span>)i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序不论大小端，都会输出 0x34，<strong><font color='orange'>因为数据截断时，总会保留最低有效字节，而不是保留地址处于最低位的字节</font></strong> 。最低有效字节中的“最低”是指的数据的低位，而不是内存地址的低位，比如 4 字节整型 0x11223344 截断为 1 字节的 char 时，就只会保留最低有效字节 0x44。<strong>截断的行为不会被大小端影响</strong> 。</p><hr><p>下面来讨论网络字节序。</p><p>为了保证在不同字节序机器之间传输网络数据时数据能够被正确解释，<strong><font color='orange'>规定网络数据传输的格式一律为大端序</font></strong> 。使用以下函数转换字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line">    net to host,将网络字节序转为主机字节序</span><br><span class="line">    </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line">    host to net,将主机字节序转为网络字节序</span><br></pre></td></tr></table></figure><p>SOCKET 网络编程初学者可能会疑惑，除了为端口和 IP 地址赋值时会用到上面的函数，其他时候我们发送网络数据都没有用到这些函数呀！<strong><font color='orange'>这是因为大多数情况下我们都是发送的字符串数据，而字符都是 char，即单字节数据，因此根本不会被字节序影响</font></strong> 。那么我们来传输一个 int 整型试试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机是小端序，使用 wireshark 抓取网络报文，可见数据仍是以小端序传输的。如果对端机器是大端序，那么字节序列 <code>78 56 34 12</code> 则会被解释为 <code>0x78563412</code> ，从而造成数据错乱。<br><img src="/2022/img/image-20230416181222470.png" alt=""></p><p>所以我们必须先将整型转为大端序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line">    <span class="type">int</span> a = htonl(<span class="number">0x12345678</span>);</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230416181831813.png" alt=""></p><hr><p>从上面我们能得到：跨网络传输字符串或其他单字节数据时，不会受大小端影响；而传输多字节的二进制数据时，如果不提前转为大端序，那么就会发生错误。即使手动将二进制数据（如结构体）转为大端序，也存在以下几个问题：</p><ul><li>两端机器对 C 数据类型的实现不同，比如本端机器的 int 为 4 字节，而对端的机器可能为 2 字节。</li><li>不同实现的结构体对齐方式存在差异。</li></ul><p>可以使用以下两种方法解决以上问题：</p><ul><li>将所有数值类型作为字符串来传递，显然效率很低。</li><li>自己定义一个二进制数据结构（协议）。</li></ul><p>最后补充一点，大小端问题不仅出现在主机之间，在同一主机的不同进程之间也可能出现，比如在Java虚拟机中采用的是网络字节序（即大端字节序），因此在与其他进程进行数据交换时，需要进行字节序转换。</p>]]></content>
    
    
    <summary type="html">网络字节序及其注意事项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三握四挥异常分析</title>
    <link href="http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
    <id>http://jyxcpp.netlify.app/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/</id>
    <published>2023-04-15T11:16:23.000Z</published>
    <updated>2023-04-16T13:51:14.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">全连接与半连接队列</a> 、<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;optval, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    Listen(sock_listen, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    bzero(&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr *) &amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包裹函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(fd, backlog))</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == accept(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-第一次握手异常-font"><font color='red'>第一次握手异常</font></h2><p>第一次握手异常一般有三种情况：<br><strong>1） 目标主机不可达，响应一个 “destination unreachable” 的 ICMP 报文。</strong></p><blockquote><p>这个情况很好模拟，在客户端 connect 一个任意 IP 的地址结构即可。</p></blockquote><p><strong>2）目标主机的指定端口上没有套接字处于监听状态，connect 返回 “Connection refused” 。</strong></p><p><strong>3）接收方丢弃 SYN 报文。</strong></p><p>下面重点说说第三种情况。</p><p><strong><mark class="hl-label blue">什么情况下会丢弃SYN报文？</mark> </strong></p><p>有两种情况是可以确定的：</p><ol><li><strong>半连接队列已满，且没有开启 SYN-Cookie</strong></li><li><strong>全连接队列已满</strong></li></ol><p><strong><font color='orange'>情况一验证：</font></strong></p><blockquote><p><strong>在笔者环境下（Ubuntu 16.04），半连接队列的长度等于全连接长度，即为 <code>min(somaxconn,backlog)</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>); <span class="comment">//backlog为5,则全连接队列容量为6,半连接队列为5</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将 SYN-Cookie 设置为 0（默认为 1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//须在管理员身份下运行</span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/tcp_syncookies </span><br></pre></td></tr></table></figure><blockquote><p>0 值，表示关闭该功能；<br>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；<br>2 值，表示无条件开启功能；</p></blockquote></li><li><p>运行 server 端。</p></li><li><p>运行 hping3，发起 SYN 洪水攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机,即伪造</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><p>发送了 1000 个<u>虚假</u> SYN 报文，而半连接队列中只有 5 个连接（满），说明其他 SYN 确实是被服务端丢弃了。那么如果开启了 SYN-Cookie 会怎么样呢？继续实验：</p><ol><li><p>将 SYN-Cookie 设置为 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>运行 server 端和 hping3</p></li><li><p>查看 SYN_RECV 状态的个数，仍然为 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>查看 ESTABLISHED 状态的个数，为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | wc -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>运行客户端，并查看 ESTABLISHED 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p>这里显示为 12，实际上为 6，这是因为服务器端和客户端都在一个主机上，netstat 命令分别以服务器和客户端的角度进行了输出，所以算重复了一次。<br>已连接状态数为 6 的原因请参见前置文章，这里不再赘述。</p></blockquote></li></ol><p><strong><font color='gree'>所以，若半连接队列已满，且没有开启 SYN-Cookie ，则丢弃 SYN 报文。开启 SYN Cookies 后，就可以在不经过半连接队列的情况下成功建立连接：</font></strong><br><img src="/2022/img/39-1679303729834-1-1679373170821-1.jpg" alt=""></p><p><strong><font color='orange'>情况二验证</font></strong></p><ol><li><p>先后运行服务器端和客户端</p></li><li><p>分别查看 ESTABLISH 和 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>可见，当全连接队列满了后，半连接队列也不再接受 SYN</strong> 。</p></li></ol><p>追问：如果全连接队列仅还有一个空位，那么半连接队列也只会接收一个 SYN 吗？继续实验：</p><ol><li><p>修改 client 的第 23 行代码，将 10 改为 5，即发起 5 次连接（全队列容量为 6，这样就能余下一个空位）</p></li><li><p>先后运行 server 和 client</p></li><li><p>查看 ESTABLISHED 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>即，有 5 个连接已经完成建立，全队列余下一个空位。</p></li><li><p>运行 hping3，并查看 SYN_RECV 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>发现半连接队列也已经满员。</p></li></ol><p>综合以上两种情况，得到下面的流程图：<br><img src="/2022/img/aha.png" alt=""></p><p><strong><mark class="hl-label blue">SYN报文丢失了会怎样？</mark> </strong><br>很简单，重传即可。值得一提的是，<strong><font color='orange'>SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制</font></strong> 。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，即，<strong>每次超时的时间是上一次的 2 倍</strong> 。在笔者环境下，重传次数为 6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>为了更清晰地看到这个过程，我们先关闭 SYN-Cookie，然后发起泛洪，使半连接队列满员，进而只能丢弃新到的 SYN 报文；接着开启一个客户端，此时使用 wireshark 进行抓包，结果如下：<br><img src="/2022/img/image-20230407213529813.png" alt="image-20230407213529813"><br>一共发送 7 次 SYN 报文，其中重传 6 次。看左边的数字小数点的前两位：50 -&gt; 51 -&gt; 53 -&gt; 57 -&gt; 65 -&gt; 81 ，间隔时间分别为 1、2、4、8、16，和我们前面的结论相同。只是最后差了 34s，接近 32s，可能是误差吧，不太清楚这里是怎么回事。</p><hr><h2 id="font-color-red-第二次握手异常-font"><font color='red'>第二次握手异常</font></h2><p>有了第一次异常的分析，第二次握手异常就很容易分析出来了。首先能够确定的是，第一次握手的 SYN 报文仍然会重传，因为 client 压根没有收到 server 的 SYN+ACK 报文。那么 server 会怎么样呢？也容易猜到，由于迟迟没有收到第三次握手的 ACK 报文，server 也一定会重传，<strong><font color='orange'>且重传次数由 <code>tcp_synack_retries</code> 决定</font></strong>（ 在笔者环境下，该值为 5）。实验如下：<br>1）使用 <code>iptables</code> 屏蔽第二次握手：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT -p tcp  --tcp-flags SYN,ACK SYN,ACK -j DROP</span><br></pre></td></tr></table></figure><p>2）运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230415194126268.png" alt=""></p><p>可见，第一次和第二次握手都在重传。</p><h2 id="font-color-red-第三次握手异常-font"><font color='red'>第三次握手异常</font></h2><p>第三次握手就有意思了。看下面的三次握手的过程图：<br><img src="/2022/img/image-20230408101018084.png" alt=""></p><p>可见当第三次握手的 ACK 发出后，客户端已经处于建立连接的状态，而服务器此时还没收到客户端的 ACK 报文，仍处于 SYN_RECV 状态。那么问题来了，如果 client 给 server 发送数据报文，会出现什么情况呢？</p><p>为了模拟server 无法接收 ACK 报文的情况，我们使用 iptables 在防火墙阻截这个 ACK 报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --tcp-flag ACK,SYN  ACK -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>只需知道上述命令的作用为：屏蔽含有 ACK 标记 <strong>且</strong> 不包含 SYN 标记的报文，显然三次握手中只有第三次符合要求，因此会被屏蔽。关于 iptables，请移步本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">iptables</a><br>另外，实验完成后记得把屏蔽去掉，将 -I 改为 -D 重新执行上述命令即可。</p></blockquote><p>结果如下：<br><img src="/2022/img/image-20230408151310936.png" alt=""></p><p>可见，如果第三次握手的 ACK 报文丢失，则会引起第二次握手 ACK+SYN 重传，且重传 5 次，如 <code>tcp_synack_retries</code> 示，然后 clinet 重发 ACK，仍然丢失。再来看看 server 和 client 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep 12345</span><br><span class="line">tcp        0      0 192.168.248.128:59999   192.168.248.128:12345   ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.248.128:12345   192.168.248.128:59999   SYN_RECV   </span><br></pre></td></tr></table></figure><p>表明 client 已处于已连接状态，server 还未连接。而且重传 5 次完毕后不久，SYN_RECV 状态消失，说明 server 已经主动断开连接。如果此时 client 发送数据，这些报文当然也无法得到回复。<strong><font color='orange'>建立连接后（是指在 ESTABLISHED 状态下）发送的报文丢失，则会重传，次数由 <code>tcp_retries2</code> 决定（本机为 15 次，等待大概 15min）</font></strong> ，没有回应则直接关闭连接。</p><blockquote><p><code>tcp_retries1</code> 变量是控制在系统向下级发出信号以尝试验证网络是否可用之前的重试次数，可忽略。</p></blockquote><p>那么如果 client 不发送数据呢？它岂不是会一直保持 ESTABLISHED 状态。并不会，TCP 有保活机制，当一条连接上连续 <strong>两小时</strong> 没有任何动静时，本端就会发送探测报文，若连续几次探测报文都没有得到回应，则直接断开连接。保活时间，探测报文的次数、时间间隔分别由以下三个参数决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75 </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>即，最少需要经过 2 小时 11 分 15 秒才能断开一个死亡连接</font></strong> 。</p><blockquote><p>关于心跳包和保活机制，可参见<a href="https://jyx-fyh.github.io/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/">保活机制与心跳包设计</a> 。</p></blockquote><hr><h2 id="font-color-red-第一次挥手异常-font"><font color='red'>第一次挥手异常</font></h2><p><strong><font color='gree'>FIN 报文丢失的原因之一是因为对方接收缓冲区满导致 FIN 无法被接收。</font></strong></p><p>重传 FIN 报文，次数由 <code>tcp_orphan_retries</code> 控制，超过指定次数则直接关闭。这里有个细节： <code>tcp_orphan_retries</code> 默认为 0，但实际上重传次数为 8，源码向我们解释了原因：<br><img src="/2022/img/28-1680942414542-4.jpg" alt=""></p><p><strong><font color='orange'>为了避免 <code>FIN_WAIT1</code> 状态的连接过多，我们可以调小 <code>tcp_orphan_retries</code> 的值，也可以通过 <code>tcp_max_orphans</code> 限制其数量，</font></strong>  <strong><font color='orange'>如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，<u>而是直接发送 RST 复位报文强制关闭</u>。</font></strong></p><hr><h2 id="font-color-red-第二次挥手异常-font"><font color='red'>第二次挥手异常</font></h2><p>即 ACK 报文丢失，这种情况下会重复第一次挥手。<strong><font color='orange'>注意，pure ACK 报文都不会主动重传！只能被第一次挥手驱动而重传</font></strong></p><h2 id="font-color-red-第三次挥手异常-font"><font color='red'>第三次挥手异常</font></h2><p>则重传 FIN 报文，次数仍由 <code>tcp_orphan_retries</code> 控制，超出指定次数则直接关闭连接。注意，此时 client（主动关闭方） 已经处于 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果 client 是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果 client 是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></p><blockquote><p>关于 close 和 shutdown，参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a></p></blockquote><h2 id="font-color-red-第四次挥手异常-font"><font color='red'>第四次挥手异常</font></h2><p>则重传第三次挥手的 FIN 报文，超过指定次数则直接关闭。第三次挥手成功后，主动关闭方进入了 TIME_WAIT 状态，这在期间如果收到重传的第三次挥手报文则回复 ACK：<br><img src="/2022/img/image-20230416215104213.png" alt=""></p><hr><h2 id="font-color-red-区分连接断开的几种常见情况-font"><font color='red'>区分连接断开的几种常见情况</font></h2><p><strong><mark class="hl-label blue">进程崩溃</mark> </strong><br>进程崩溃可以指是使用 kill 命令杀死进程，此时进程会进行关闭套接字等一系列动作，并向对方发出 FIN 报文，和正常四次挥手无差别。</p><p><strong><mark class="hl-label blue">服务器主机崩溃</mark> </strong><br>服务器主机崩溃可以是断电，这种情况下进程来不及关闭套接字，因此服务器主机直接从网络中消失，那么客户向服务器重传数次后将返回 “destination unreachable” 错误。</p><p><strong><mark class="hl-label blue">服务器主机关机</mark> </strong><br>Unix 系统关机时，init 进程会先给所有进程发送 SIGTERM 信号，等待一小段时间（以给进程清除和终止的时间）后发送 SIGKILL 信号强制终止所有进程。进程终止时会关闭所有描述符，于是进行正常挥手。</p><p><strong><mark class="hl-label blue">服务器主机崩溃后重启</mark> </strong><br>服务器崩溃后重启，之前的 TCP 连接状态信息已经丢失，因此服务器对之前连接上发来的消息都将回复 RST。</p><blockquote><p>参考：《UNP》、<a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">小林网络</a> 、<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptable用法详解</a></p></blockquote>]]></content>
    
    
    <summary type="html">计算机网络</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络学习利器—hping3</title>
    <link href="http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/"/>
    <id>http://jyxcpp.netlify.app/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/</id>
    <published>2023-04-09T07:44:31.000Z</published>
    <updated>2023-04-10T12:15:47.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络学习利器—hping3</p><blockquote><p>参考：<a href="https://techyrick.com/hping3-full-tutorial-for-dummies-to-pro/">hping3-tutorial</a> 、<a href="https://www.anquanke.com/post/id/239641#h2-10">端口扫描浅析</a>、<a href="https://linux.die.net/man/8/hping3">hping3-man</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">  -c  --count     packet count</span><br><span class="line">  -i  --interval  wait (uX for X microseconds, for example -i u1000)</span><br><span class="line">      --fast      alias for -i u10000 (10 packets for second)</span><br><span class="line">      --faster    alias for -i u1000 (100 packets for second)</span><br><span class="line">      --flood   sent packets as fast as possible. Don&#x27;t show replies.</span><br><span class="line">  -n  --numeric   numeric output</span><br><span class="line">  -q  --quiet     quiet</span><br><span class="line">  -I  --interface interface name (otherwise default routing interface)</span><br><span class="line">  -V  --verbose   verbose mode</span><br><span class="line">  -D  --debug     debugging info</span><br><span class="line">  -z  --bind      bind ctrl+z to ttl           (default to dst port)</span><br><span class="line">  -Z  --unbind    unbind ctrl+z</span><br><span class="line">      --beep      beep for every matching packet received</span><br><span class="line">Mode</span><br><span class="line">  default mode     TCP</span><br><span class="line">  -0  --rawip      RAW IP mode</span><br><span class="line">  -1  --icmp       ICMP mode</span><br><span class="line">  -2  --udp        UDP mode</span><br><span class="line">  -8  --scan       SCAN mode.</span><br><span class="line">                   Example: hping --scan 1-30,70-90 -S www.target.host</span><br><span class="line">  -9  --listen     listen mode</span><br><span class="line">IP</span><br><span class="line">  -a  --f      spoof source address</span><br><span class="line">  --rand-dest      random destionation address mode. see the man.</span><br><span class="line">  --rand-source    random source address mode. see the man.</span><br><span class="line">  -t  --ttl        ttl (default 64)</span><br><span class="line">  -N  --id         id (default random)</span><br><span class="line">  -W  --winid      use win* id byte ordering</span><br><span class="line">  -r  --rel        relativize id field          (to estimate host traffic)</span><br><span class="line">  -f  --frag       split packets in more frag.  (may pass weak acl)</span><br><span class="line">  -x  --morefrag   set more fragments flag</span><br><span class="line">  -y  --dontfrag   set don&#x27;t fragment flag</span><br><span class="line">  -g  --fragoff    set the fragment offset</span><br><span class="line">  -m  --mtu        set virtual mtu, implies --frag if packet size &gt; mtu</span><br><span class="line">  -o  --tos        type of service (default 0x00), try --tos help</span><br><span class="line">  -G  --rroute     includes RECORD_ROUTE option and display the route buffer</span><br><span class="line">  --lsrr           loose source routing and record route</span><br><span class="line">  --ssrr           strict source routing and record route</span><br><span class="line">  -H  --ipproto    set the IP protocol field, only in RAW IP mode</span><br><span class="line">ICMP</span><br><span class="line">  -C  --icmptype   icmp type (default echo request)</span><br><span class="line">  -K  --icmpcode   icmp code (default 0)</span><br><span class="line">      --force-icmp send all icmp types (default send only supported types)</span><br><span class="line">      --icmp-gw    set gateway address for ICMP redirect (default 0.0.0.0)</span><br><span class="line">      --icmp-ts    Alias for --icmp --icmptype 13 (ICMP timestamp)</span><br><span class="line">      --icmp-addr  Alias for --icmp --icmptype 17 (ICMP address subnet mask)</span><br><span class="line">      --icmp-help  display help for others icmp options</span><br><span class="line">UDP/TCP</span><br><span class="line">  -s  --baseport   base source port             (default random)</span><br><span class="line">  -p  --destport   [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec</span><br><span class="line">  -k  --keep       keep still source port</span><br><span class="line">  -w  --win        winsize (default 64)</span><br><span class="line">  -O  --tcpoff     set fake tcp data offset     (instead of tcphdrlen / 4)</span><br><span class="line">  -Q  --seqnum     shows only tcp sequence number</span><br><span class="line">  -b  --badcksum   (try to) send packets with a bad IP checksum</span><br><span class="line">                   many systems will fix the IP checksum sending the packet</span><br><span class="line">                   so you&#x27;ll get bad UDP/TCP checksum instead.</span><br><span class="line">  -M  --setseq     set TCP sequence number</span><br><span class="line">  -L  --setack     set TCP ack</span><br><span class="line">  -F  --fin        set FIN flag</span><br><span class="line">  -S  --syn        set SYN flag</span><br><span class="line">  -R  --rst        set RST flag</span><br><span class="line">  -P  --push       set PUSH flag</span><br><span class="line">  -A  --ack        set ACK flag</span><br><span class="line">  -U  --urg        set URG flag</span><br><span class="line">  -X  --xmas       set X unused flag (0x40)</span><br><span class="line">  -Y  --ymas       set Y unused flag (0x80)</span><br><span class="line">  --tcpexitcode    use last tcp-&gt;th_flags as exit code</span><br><span class="line">  --tcp-mss        enable the TCP MSS option with the given value</span><br><span class="line">  --tcp-timestamp  enable the TCP timestamp option to guess the HZ/uptime</span><br><span class="line">Common</span><br><span class="line">  -d  --data       data size                    (default is 0)</span><br><span class="line">  -E  --file       data from file</span><br><span class="line">  -e  --sign       add &#x27;signature&#x27;</span><br><span class="line">  -j  --dump       dump packets in hex</span><br><span class="line">  -J  --print      dump printable characters</span><br><span class="line">  -B  --safe       enable &#x27;safe&#x27; protocol</span><br><span class="line">  -u  --end        tell you when --file reached EOF and prevent rewind</span><br><span class="line">  -T  --traceroute traceroute mode              (implies --bind and --ttl 1)</span><br><span class="line">  --tr-stop        Exit when receive the first not ICMP in traceroute mode</span><br><span class="line">  --tr-keep-ttl    Keep the source TTL fixed, useful to monitor just one hop</span><br><span class="line">  --tr-no-rtt    Don&#x27;t calculate/show RTT information in traceroute mode</span><br><span class="line">ARS packet description (new, unstable)</span><br><span class="line">  --apd-send       Send the packet described with APD (see docs/APD.txt)</span><br></pre></td></tr></table></figure><hr><p>先运行服务器端，在 12345 端口上监听。</p><p><strong>1）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 SYN 报文</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S 192.168.248.128 -p 12345 -c 5</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410122835239.png" alt=""></p><p><strong>2）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 ACK 报文，且窗口大小为 100</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -A  192.168.248.128 -p 12345 -c 5 -w 100</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410123028629.png" alt="image-20230410123028629"></p><blockquote><p><strong><font color='red'>注意：</font></strong><br>我们向开放的 12345 端口发送 SYN 报文，得到的回复是 SYN+ACK 报文，即第二次握手；而发送 ACK 报文，则得到的回复是 RST 。这两种情况能够反应出端口的开放和过滤状态：<br><strong>发送 SYN 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>数次重发未响应</td><td>filtered</td></tr><tr><td>收到ICMP不可达错误</td><td>filtered</td></tr><tr><td>SYN/ACK</td><td>open</td></tr><tr><td>RST</td><td>closed</td></tr></tbody></table><p><strong>发送 ACK 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>收到RST报文</td><td>unfiltered(open/closed)</td></tr><tr><td>未响应</td><td>filtered</td></tr><tr><td>ICMP不可达</td><td>filtered</td></tr></tbody></table><p><strong>也就是说，我们可以通过向指定端口发送 SYN 或 ACK 报文来检测该端口的状态，这称为<font color='red'><u>端口扫描</u></font></strong> 。</p><p>另外，关于报文过滤，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">包过滤工具iptables</a></p></blockquote><p><strong>3）端口扫描模式</strong><br>扫描 <a href="http://baidu.com">baidu.com</a> 的 75~85 和 12345 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 --scan  75-85,12345 -S baidu.com</span></span><br><span class="line">Scanning baidu.com (39.156.66.10), port 75-85,12345</span><br><span class="line">12 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">   80 http       : .S..A... 128 27907 64240    46</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports: (75 ) (76 ) (77 rje) (78 ) (79 finger) (81 ) (82 ) (83 ) (84 ) (85 ) (12345 ) </span><br></pre></td></tr></table></figure><p><strong>4）flood 泛洪攻击</strong><br>向 <code>127.0.0.1:12345</code> 发起泛洪攻击，源 IP 随机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 -S -p 12345 --flood --rand-source </span><br></pre></td></tr></table></figure><p><strong>5）指定源端口为 12345，源 IP 为 1.1.1.1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S baidu.com -a 1.1.1.1 -s 12345</span><br><span class="line">或</span><br><span class="line">hping3 -S baidu.com --spoof 1.1.1.1 --baseport 12345</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下源 IP 为主机地址，源端口随机</p></blockquote><p><strong>6）传输文件</strong><br>Hping3 支持通过 TCP/UDP/ICMP 等包来进行文件传输。相当于借助 TCP/UDP/ICMP 包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为 <code>--listen</code> 后面输入的字符串）的内容进行相应的解析。在接收端开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 127.0.0.1  --listen signature --safe  --icmp</span> </span><br></pre></td></tr></table></figure><p>监听 ICMP 包中的签名，根据签名解析出文件内容。在发送端使用签名打包的 ICMP 包发送文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 --icmp -d 100 --sign signature --file ./data</span><br></pre></td></tr></table></figure><p>注意两点：1）必须指定数据长度 <code>-d</code> ；2）签名字符串必须和接收端相同，这里是字符串 <code>signature</code> 。<br><img src="/2022/img/image-20230410195315834.png" alt="接收端收到文件,并输出文件内容"></p><p>不过没人会使用这种方式来传送文件，因为它是明文发送的：<br><img src="/2022/img/image-20230410201345056.png" alt=""><br><code>--safe</code> 保证的是丢失重传，而不是安全性。</p>]]></content>
    
    
    <summary type="html">网络学习利器—hping3 入门教程</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>“包过滤工具—iptables”</title>
    <link href="http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/"/>
    <id>http://jyxcpp.netlify.app/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/</id>
    <published>2023-04-08T03:21:14.000Z</published>
    <updated>2023-04-15T11:31:11.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>防火墙是保护服务器和基础设施安全的重要工具。在 Linux 生态系统中，<code>iptables</code> 是使用很广泛的防火墙工具之一，它能够用来完成封包过滤、封包重定向和网络地址转换(NAT)等功能。 <strong><code>iptables</code> 基于内核的包过滤框架 <code>netfilter</code></strong> 。如果管理员或用户不了解这些系统的架构，那可能就无法创建出可靠的防火墙策略。</p><p><strong><u>这里我们只简单地使用 iptables 的包过滤功能（后面讨论的命令也仅限于此）</u></strong> ，因为它能够很方便地模拟各种网络状况（<a href="https://jyx-fyh.github.io/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/">TCP 三握四挥的异常处理</a>、报文丢失等），非常有助于我们对网络理论知识的学习。其他功能的详细介绍可以参见<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptables用法规则小结</a> 。</p><hr><p>命令格式：<br><img src="/2022/img/FUCKAHA.png" alt=""></p><blockquote><p><code>ACCEPT</code> 允许数据包通过<br><code>DROP</code>  直接丢弃数据包，不给任何回应信息<br><code>REJECT</code> 拒绝数据包通过，必要时会给数据发送端一个响应的信息</p></blockquote><blockquote><p><strong><font color='red'>注意：</font></strong> 即使我们在输入链 INPUT 上 DROP 了指定报文，tcpdump/wireshark 仍然可以抓到该报文，因为报文的进入顺序是：<code>Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables</code> ；而出站顺序为：<code>iptables -&gt; tcpdump -&gt; NIC -&gt; Wire</code> ，此时 tcpdump/wireshark 才无法抓到指定报文。</p><p>注意，在 INPUT 中丢弃报文后，虽然可以被 tcpdump 捕获，但指定的端口或程序仍然无法收到该报文。</p></blockquote><p>示例：</p><p>1）在 lo 接口上丢弃目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j DROP</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定端口必须放在指定协议之后</strong> 。<br>另外，如果是做实验，那么添加之后记得删除，将 -I 改为 -D 再执行一次即可。</p></blockquote><p>2）拒绝目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝报文后，一般会给发送端发送 IMCP 报文以报告错误：<img src="/2022/img/image-20230409110416756.png" alt=""></p><p>3）拒绝源 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> ，且报文含有 SYN 标志的报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN SYN -j DROP</span><br></pre></td></tr></table></figure><p>这样我们就屏蔽了源 IP 为 <code>192.168.248.128</code> 发向 <code>12345</code> 端口的第一次握手。</p><blockquote><p>这条命令使用了 tcp 扩展模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tcp-flags mask comp</span><br></pre></td></tr></table></figure><p>第一个参数 mask 是我们应该检查的标志，写成由逗号分隔的列表。<br>第二个参数 comp 是必须匹配的标志的列表，列表以逗号分隔。<br>没有被匹配上的标志则要求不能被设置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><p>这条命令只会匹配到设置了 ACK 而没有设置 SYN 的报文。<br>Flags ： SYN ，ACK ，FIN ，RST ，URG ，PSH ，ALL ，NONE</p><p>另外，有时会使用 <code>-m</code> 显式指定模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 -m tcp --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br></pre></td></tr></table></figure></blockquote><p>4）列出 filter 表的所有规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN,ACK/ACK</span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN/SYN</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='orange'>注意，如果不使用 <code>-t</code> 指定表，则默认都为 filter</font></strong></p></blockquote><p>5）删除指定规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables  -D INPUT 1  删除第一条规则</span><br></pre></td></tr></table></figure><p>6）<code>!</code> 取反：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT ! -s 192.168.248.128 -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>丢弃除了源 IP 为 <code>192.168.248.128</code> 的其他所有 TCP 报文。</p><p>7）操作网段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>8）端口范围：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 1000:2000 -j DROP</span><br></pre></td></tr></table></figure><p>9）拒绝 DDOS 攻击：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p>-m limit: 启用limit扩展，限制速度。<br>–limit 25/minute: 允许最多每分钟25个连接<br>–limit-burst 100: 当达到100个连接后，才启用上述25/minute限制</p><p>这种方式似乎不能有效解决 DDOS 攻击。</p></blockquote><p>10）包含指定字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 12345 -m string --algo bm --string &#x27;admin&#x27; -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝目标端口为 12345 且数据中包含 “admin” 字符串的报文。</p>]]></content>
    
    
    <summary type="html">包过滤工具—iptables</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>常用socket选项</title>
    <link href="http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/"/>
    <id>http://jyxcpp.netlify.app/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/</id>
    <published>2023-04-02T12:38:14.000Z</published>
    <updated>2023-05-07T12:23:48.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-获取和设置socket选项-font"><font color='red'>获取和设置socket选项</font></h2><p>使用 <code>getsockopt()</code> 和 <code>setsockopt</code> 来获取和设置 socket 的各种选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(bufsize);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span> <span class="params">(<span class="type">int</span> socket,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">void</span> *option_val,</span></span><br><span class="line"><span class="params">                <span class="type">socklen_t</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</span><br></pre></td></tr></table></figure><ul><li><strong>以上两个函数，成功时均返回 0，出错则返回 -1</strong> 。</li><li>关于第二个和第三个参数，参见《UPN》第 151 页。</li></ul><p>注意，细心的朋友可能已经注意到：上面的例子中，作用的套接字是 sock_listen，即监听套接字。那么，能不能作用于已连接套接字呢？好问题！是这样的，<strong><font color='orange'>以下几个选项是由已连接套接字从监听套接字继承而来：</font></strong> <strong><font color='red'>SO_KEEPALIVE、SO_LINGER、SO_RECVBUF、SO_SNDBUF、SO_RCVLOWAT、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY</font></strong> 、SO_DEBUF、SO_DONTROUTE、SO_OBBINLINE （红色标记为重点选项）。所以，在这几个选项上设置监听套接字，将影响后面的所有已连接套接字。<u>作为对比，getpeername() 函数就必须要作用于已连接套接字</u>。</p><h2 id="font-color-red-SO-RCVBUF-和-SO-SNDBUF-font"><font color='red'>SO_RCVBUF 和 SO_SNDBUF</font></h2><p>这是两个重要的选项。要弄清楚这两个选项，就必须先搞明白 Socket 的缓冲区机制。下面总结了 Socket 缓冲区的关键特性：<br><img src="/2022/img/IMG_0579(20230406-190556).PNG" alt=""></p><ul><li><strong><font color='gree'>每个套接字都有独立的输入/输出缓冲区。</font></strong></li><li><strong><font color='gree'>创建套接字时，自动生成缓冲区。</font></strong></li><li><strong><font color='gree'>如果要写（write）的数据大于发送（输出）缓冲区的最大长度，那么将分批写入。</font></strong></li><li><strong><font color='gree'>如果发送缓冲区全满（分批写入也不能进行），则进程被阻塞（假设套接字是阻塞模式）。</font></strong></li><li><strong><font color='gree'>发送缓冲区的数据将一直保存（以便重发），直到接收到相应 ACK。</font></strong></li><li><strong><font color='gree'>接收（输入）缓冲区的数据将一直保存，直到应用层读取（read）。</font></strong></li><li><strong><font color='gree'>接收缓冲区若满，则直接抛弃新数据（不发送其他任何信息，等待对面重传）。</font></strong></li><li><strong><font color='gree'>TCP 接收窗口大小 &lt;= 接收缓冲区大小。</font></strong></li></ul><blockquote><p>以上几个特性的实验，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">网络数据读取的常见问题</a> ，建议浏览，加深理解。</p></blockquote><p><strong><font color='red'>SO_RCVBUF 直接限制本端 TCP 接收窗口的大小</font></strong> 。下面进行实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF,(<span class="type">void</span>*)&amp;recv_size,&amp;optlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server recv buffer size: %d\n&quot;</span>,recv_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不read,不close</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行运行 server 和 client 后，server 的接收缓冲区的大小为 6000：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server recv buffer size: <span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将 recv_size 设置的为 3000，而实际反馈为 6000，<strong>说明 recv_size 只是一个建议值，操作系统会根据一定条件进行修改（×2）</strong> 。在笔者操作系统上，接收缓冲区最小为 2304 。</p></blockquote><p>然后我们使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230403111812767.png" alt=""></p><p>看第二项，server 发送的 SYN 报文中，<strong>win 为 3000，和我们设置的 SO_RECVBUF 大小相同</strong> ，但这并不意味着窗口大小就一定等于 SO_RECVBUF。<strong><u><font color='gree'>接收窗口会随着网络状况而不断调整，但肯定不会超过缓冲区的大小</font></u></strong> 。</p><blockquote><p>在本机上实验多次发现，<strong>接收窗口始终不会超过接收缓冲区的一半大小</strong> 。</p></blockquote><p>还有以下几点需要注意：</p><ol><li>上面说过，这两个选项是由监听套接字继承而来，<strong><u><font color='orange'>所以对于 server，必须在 listen 前设置选项；对于 client，必须在 connect 前设置选项</font></u></strong> 。对已连接套接字（在 accept 返回之后）设置选项没有任何作用，因为 accept 只是从已连接队列中取出一个连接而已（参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a>）。</li><li>为了避免潜在的缓冲区空间浪费，接收缓冲区大小应该为 MSS 的整数倍，且至少为 MSS 的 4 倍，参见《UNP》P163。</li><li><strong><font color='orange'>为了最大化性能，缓冲区大小应该约等于带宽-延迟积</font></strong> ，参见《UNP》P164 。</li></ol><h2 id="font-color-red-SO-RCVLOWAT-和-SO-SNDLOWAT-font"><font color='red'>SO_RCVLOWAT 和 SO_SNDLOWAT</font></h2><p>这两个选项作用于 select/poll/epoll，目的在于减少网络 I/O 的次数。<code>SO_RCVLOWAT</code> 指定接收缓冲区中的数据量必须达到多少时，才会唤醒 select/poll/epoll 去读取数据，其默认值为 1 。<code>SO_SNDLOWAT</code> 指定当发送缓冲区的<u>空闲空间</u>大于等于低水平位标记时，将唤醒 select/poll/epoll 写数据到socket ，其默认值为 2048（然而本机实测仍为 1） 。</p><h2 id="font-color-red-SO-REUSEADDR-font"><font color='red'>SO_REUSEADDR</font></h2><p>这是服务器最常用的选项之一。该选项有以下几个作用：</p><ol><li><p><strong>可以在 TIME_WAIT 期间重新绑定该端口，这对服务器崩溃重启并快速恢复有至关重要的作用，避免了几十秒甚至几分钟的等待。</strong></p><blockquote><p>需要注意的是，如果没有开启时间戳选项（默认开启），则 TIME_WAIT 期间重新绑定<u>可能</u>失败，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT探究</a>。</p></blockquote></li><li><p><strong>允许在已连接的状态下重新绑定该端口</strong> ，常见情景如下：<br>a）启动监听进程<br>b）连接请求到达，派生一个子进程处理该连接<br>c）监听进程崩溃，子进程仍在运行<br>d）重启监听进程，并绑定之前的端口</p></li><li><p><strong>允许在同一个端口启动多个服务器，前提是每个服务器绑定的本地 IP 不同（IP 别名）</strong></p><blockquote><p>笔者在本机上实验，分别绑定环回地址 <code>127.0.0.1</code> 和本机 IP 地址，两者可以同时绑定同一个端口。如果未开启 SO_REUSEADDR，则无法同时绑定。<br><strong><u>注意，如果某个服务器程序绑定的是通配地址（INADDR_ANY），那么后续在同一端口上启动的服务器程序则无法完成绑定。</u></strong></p></blockquote></li><li><p>其他作用不常见，详见《UNP》P166</p></li></ol><p><strong><font color='orange'>另外注意，不论是否开启该选项，不同传输层协议是可以同时绑定到同一端口的，比如 TCP 和 UDP 程序就能够同时绑定到一个端口。</font></strong></p><p><strong><font color='red'>对于所有 TCP 服务器，都应该在 bind 前开启 SO_REUSEADDR ！</font></strong></p><blockquote><p>另外，还有一个 <code>SO_REUSEPORT</code> 选项，不常用，参见《UNP》P165</p></blockquote><h2 id="font-color-red-SO-LINGER-font"><font color='red'>SO_LINGER</font></h2><p><code>SO_LINGER</code> 用来控制 close 的行为：<br><img src="/2022/img/image-20230407141037746.png" alt=""><br><img src="/2022/img/image-20230407141059416.png" alt=""><img src="/2022/img/IMG_0580(20230407-134909).PNG" alt=""></p><p><strong><u>注意缓冲区的各种情况！</u></strong> 其中第四种关闭方式就是我们常说的“优雅关闭”。</p><p>书中提供了一种有效办法，使发送端能够确认接收端的<u>应用层</u>已收到数据，详见《UPN》P161。</p><p><strong>另外有个细节，上图中 SHUT_RD 后，接收到的任何数据都会被丢弃，这里的丢弃是先确认再丢弃，也就是说，这不会引发对方的重传。</strong></p><h2 id="font-color-red-TCP-NODELAY-font"><font color='red'>TCP_NODELAY</font></h2><p>此选项用来禁止 Nagle 算法。关于 Nagle 算法，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">TCP流量控制</a> 。 有时候我们必须要关闭 Nagle 算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>]]></content>
    
    
    <summary type="html">常用socket选项</summary>
    
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://jyxcpp.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
