<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极简</title>
  
  <subtitle>用时间去沉淀</subtitle>
  <link href="http://jyxcpp.netlify.app/atom.xml" rel="self"/>
  
  <link href="http://jyxcpp.netlify.app/"/>
  <updated>2023-03-12T11:21:29.255Z</updated>
  <id>http://jyxcpp.netlify.app/</id>
  
  <author>
    <name>极简</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Socket网络编程入门笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-05T10:30:46.000Z</published>
    <updated>2023-03-12T11:21:29.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li></ul></blockquote><h3 id="font-color-red-轮廓-font"><font color='red'>轮廓</font></h3><h4 id="font-color-gree-Linux-font"><font color='gree'>Linux</font></h4><h5 id="服务器端">服务器端</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>“门卫”</font>套接字，注意，此时仅指定了该套接字的类型（TCP/UDP）</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='gree'>“门卫”套接字，即监听套接字，该套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</strong> 。<strong>注意，区分监听套接字和已连接套接字非常重要！</strong> 一个服务器程序通常只创建一个监听套接字，而当服务器完成客户端的服务时，相应已连接套接字就会关闭。下图可看到监听套接字和已连接套接字的描述符是不同的，以说明这两个套接字的差异：<br><img src="../../public/2022/img/image-20230309084228825.png" style="zoom:80%;" /></p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><p><strong><mark class="hl-label blue">socket</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>family 参数指定协议族，一般我们只用到 IPv4 协议族，即指定 AF_INET 或 PF_INET，两者完全等效。<br><img src="../../public/2022/img/image-20230308155928020.png" style="zoom:67%;" /></li><li>type 指定套接字类型，一般为字节流类型（SOCK_STREAM）或数据报类型（SOCK_DGRAM）<br><img src="../../public/2022/img/image-20230308160015615.png" alt="" style="zoom: 80%;" /></li><li>protocol 敲定最终协议。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；<br><img src="../../public/2022/img/image-20230308160546219.png" alt="空白表示无效组合"><br>有个小问题，TCP 和 SCTP 重合了，那么如果 protocol 指定为 0，最终协议是 TCP 还是 SCTP 呢？经过实验证明，是 TCP 。</li></ul><p><strong><mark class="hl-label alt=></p>">bind blue %}</strong><br><img src=../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png"</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同，可参见<a href="https://blog.csdn.net/yangbodong22011/article/details/60399728">深入探索 Linux listen() 函数 backlog 的含义</a> ；另外，<strong><u>内核为每个监听套接字维护两个队列：未完成连接队列和已完成连接队列</u></strong> ，详见<a href="">socket等待队列</a> 。</li></ul><p><strong><mark class="hl-label blue">accept</mark> </strong></p><p><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度。<strong>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</strong> 。</li><li></li></ul><p><strong><font color='orange'>要点陈列：</font></strong></p><ul><li><code>&lt;sys/socket.h&gt;</code> 和 <code>&lt;arpa/inet.h&gt;</code> 是网络核心头文件！</li><li>Linux 万物皆文件，Socket 套接字也是如此，所以 socket 函数创建一个套接字，并返回该套接字的文件描述符，即一个整型。</li><li></li></ul><h5 id="客户端">客户端</h5><p><strong><font color='orange'>常错点总结：</font></strong></p><ul><li><p>将 sockaddr_in 敲成 sockaddr</p></li><li><p>忘记 memset</p></li><li><p>accept 的第三个参数不同于 bind，须要对 size 取地址</p></li><li><p>别忘了 close</p></li><li><p>对于Linux，socket函数都是<code>&lt;sys/socket.h&gt;</code> ，某些宏，如<code>IPPROTO_XXX</code> 则是<code>&lt;apar/inet.h&gt;</code> 。</p></li><li><p>通过getsockname()获取套接字的信息。</p></li><li><p><strong>猜想：似乎每次回收套接字都需要一定时间？因为如果不调用close，一定时间内重启程序，客户端并不能再次直接连接。</strong><br>似乎和 TIME_WAIT 有关</p></li><li><p>memset 清零的目的是将 sockaddr_in 的成员 sin_zero 字段清零；该字段没有用，只是为了占位，以便和通用</p></li><li><p>一个socket能同时进行多个连接吗？</p></li><li><p>为什么要sockaddr_in --&gt; sockaddr</p></li></ul><h3 id="font-color-red-网络序-font"><font color='red'>网络序</font></h3><ul><li><strong>端口号就是在同一操作系统下为区分不同套接字而设置的，所以不能将一个端口号分配给不同套接字。但注意，tcp和udp不会共用端口号，所以允许重复，比如。。。</strong></li><li><a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_cookies">SYN cookie</a>是一种用于对抗<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_flood">SYN flood</a>攻击的技术，可以避免在incomplete connection queue被填满时无法建立新的TCP连接。对于使用SYN Cookie的服务来说， 当incomplete connection queue被填满时，<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>会表现得像SYN队列扩大了一样。对于队列填满后的新TCP连接，服务器会返回适当的SYN+ACK响应包，但会丢弃对应的SYN队列条目（因为队列已经满了）。如果服务器收到客户端随后的ACK响应，<strong>服务器能够使用编码在 TCP 序号内的信息重构 SYN 队列条目</strong>。</li><li>等待队列详解博客</li><li>阻塞模式</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>英语外刊超精读笔记</title>
    <link href="http://jyxcpp.netlify.app/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2023-03-04T05:36:46.000Z</published>
    <updated>2023-03-12T11:20:57.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="font-color-3b8dfe-词汇-font"><font color=#3b8dfe>词汇</font></h4><p><strong><mark class="hl-label blue">思考</mark> </strong></p><ul><li>contemplate 沉思</li><li>meditate 冥想</li><li>muse</li><li>ponder （powder-粉末）</li><li>chew over</li><li>think over</li></ul><p><strong><mark class="hl-label blue">支出、花费</mark> </strong></p><ul><li>outlay</li><li>expenditure 一般指政府\机构等支出</li><li>spending</li><li>expense</li></ul><p><strong><mark class="hl-label blue">检查、探究、调查</mark> </strong></p><ul><li>examine</li><li>explore</li><li>investigate</li><li>research</li></ul><p><strong><mark class="hl-label blue">匹敌、媲美</mark> </strong></p><ul><li>rival<br>——Nobody could rival him in this respect.</li><li>match</li></ul><p><strong><mark class="hl-label blue">闲逛</mark> </strong></p><ul><li>wander</li><li>roam</li><li>ramble</li><li>stroll</li><li>hang out</li></ul><p><strong><mark class="hl-label blue">描述、描绘</mark> </strong></p><ul><li>describe</li><li>depict</li><li>portray</li><li>present</li></ul><h4 id="font-color-gree-搭配-font"><font color='gree'>搭配</font></h4><ul><li><p>long since 很久以前，早就</p></li><li><p>banish fears 驱除恐惧</p></li><li><p>be afraid of / have fears about sth 对某事有恐惧</p></li><li><p>in one’s image 以…形象</p></li><li><p>dependence on/upon，be dependent on/upon，independence from，be independent of</p></li><li><p>constitute/pose/present a threat to sb 对…构成威胁<br>considerable/major/great/significant/grave/serious threat 巨大/严重的威胁</p></li><li><p>sb is <strong><u>in charge of</u></strong> sth，sth is <strong><u>in the charge of</u></strong> sb</p></li><li><p>pick up an ailment 得病</p></li><li><p>soap opera 肥皂剧，pulp magazine 低俗杂志，mass tastes 大众品味</p></li><li><p>for the good of sb，for sb’s good 为了某人利益</p></li><li><p>uncritical acceptance （盲目地）全盘接受</p></li><li><p><strong>denfend/guard/secure A against B</strong><br><strong>protect/keep/shield A from B</strong></p></li><li><p><strong>be conscious/aware of sth</strong><br><strong>be alert/alive/awake to sth</strong> 意识到、警觉、了解</p></li><li><table><thead><tr><th>除…外（且包含）</th><th>除了（不包含）</th><th>除了（通用，看语境）</th></tr></thead><tbody><tr><td>in addition to</td><td>except (for)</td><td>apart from</td></tr><tr><td>besides</td><td>not counting</td><td>aside from</td></tr><tr><td></td><td>excluding</td><td></td></tr><tr><td></td><td>other than</td><td></td></tr></tbody></table></li><li><p>a densely/thickly/heavily/highly populated area 人口稠密的地区<br>a sparsely/thinly populated area 人口稀少的地区</p></li><li><p>a(n) element/trace/hint/tinge of ，a wee bit 一点、一丝、少量的</p></li><li><p>at a session on sth 在关于…的会议上</p></li><li><p>annual meeting 年会</p></li><li><p>next to 仅次于</p></li><li><p>be responsible for 对…负责</p></li><li><p>associate A with B 将A和B联系</p></li><li><p>up to speed …的最新消息<br>——Jack will bring you up to speed. 杰克将告诉你最新消息。</p></li><li><p>fit the bill/checklist 满足要求，符合条件</p></li><li><p>come by 顺道拜访，得到</p></li><li><p>let alone 更不用说</p></li><li><p>scientific case 科学论据</p></li><li><p>go too far、take sth too far 把某事做得太过<br>——Have child protection measures gone too far?</p></li><li><p>an expert on sth 某方面的专家</p></li><li><p>be concerned with 关心某事</p></li><li><p>out of a hat 随意、随机；像变魔术般<br>——I will pick up a number out of a hat.</p></li><li><p>like rabbits out of a hat 轻易的，不费吹灰之力</p></li><li><p>before long 不久后；long before 很久以前；</p></li><li><p>for one’s amusement 为了让某人取乐</p></li><li><p>sth is less A than B 与其说某物是A，不如说是B</p></li><li><p><strong>bother with 为…花功夫、费神</strong><br>——It’s so facile that you need not to bother with it at all.</p></li><li><p>translate A as B 将A解释成B</p></li><li><p>at the dawn of 在…初期</p></li><li><p>shape the perception 形成观念</p></li><li><p><strong>years to come 后来（的岁月）</strong></p></li><li><p><strong>ascribe/owe/attribute/credit A to B 将A归因于B</strong></p></li><li><p>play down 贬低</p></li><li><p>national consciousness 民族觉醒</p></li><li><p>pull out 撤离</p></li><li><p>pride onesel on (doning) sth、take pride in、be proud of</p></li><li><p>brand sb as 给某人贴上…的标签<br>——The world has branded the entire Chechen nation as terrists.</p></li><li><p><strong>count on 指望</strong></p></li><li><p>mobilize resources 调动资源</p></li><li><p>bring sth to life 使…变得生动有趣</p></li><li><p>touch the nerve points of 触及…的神经</p></li><li><p>power politics 强权政治</p></li><li><p>warn the reports 报告如此警告到<br>says the girl 女孩这样说<br>concludes a study 一份研究得到这样的结论</p></li><li><p>split from = separate from 从…分离出来</p></li><li><p>put a date to 确定…的日期</p></li><li><p>part ways 分道扬镳</p></li><li><p>in response to 作为对…的反应</p></li><li><p>over time 随着时间的推移</p></li><li><p>zone in on 将精力集中到…</p></li><li><p>now that 既然</p></li><li><p>associate professor 副教授</p></li><li><p>account for 解释，是…的原因</p></li></ul><h4 id="font-color-yellow-句型-font"><font color='yellow'>句型</font></h4><ul><li><strong>The question is whether … 问题在于是否…</strong><br>——The question is whether you are happy to do it.</li><li><strong>But it’s not just sth that matters. 但并非只有…重要</strong></li><li><strong>sb argue that、sb make the argument that. 某人认为、提出论点</strong></li><li><strong>As might be expected 正如所料的那样</strong></li><li><strong>The finding/discovery reinforce the conclusion that 这个发现强化了…的结论</strong></li></ul><h4 id="font-color-orange-长句-font"><font color='orange'>长句</font></h4><ul><li><strong>A sparsely populated country <u>adjoining</u> a densely populated country and <u>sharing</u> with it the same speech and largely the same cutural origins must <u>expect</u> to be dominated for a time.</strong></li><li><strong>Those were the topics of discussion at a session on the ethical and policy implications of dolphin intelligence here today at the annual meeting of the American Association for Advancement of Science.</strong></li><li><strong>That would allow researchers to account for the different human fossil that fall between the divergence and the appearance of more modern-looking people in Africa around 50000 years ago.</strong></li></ul><h3 id="熟词生意">熟词生意</h3><ul><li>see  陪…一起度过<br><strong>My friends saw me through my depression.</strong></li><li>see  经历，遭受<br>Napoleon’s campaigns saw such voracious plundering.</li><li>fall   分布于（区间），属于</li></ul>]]></content>
    
    
    <summary type="html">英语外刊超精读</summary>
    
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://jyxcpp.netlify.app/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>关于CHATGPT的一些想法</title>
    <link href="http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://jyxcpp.netlify.app/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2023-02-10T13:23:48.000Z</published>
    <updated>2023-03-12T11:21:19.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近一个月以来，国内乃至全世界的焦点都汇聚到了chatgpt之上。被chatgpt刷屏后，我个人也不禁产生了一些思考。</p><p><strong><mark class="hl-label blue">chatgpt对我们的生活将造成哪些影响？</mark> </strong><br>很难说。《未来世界的幸存者》中有这样一个观点：未来几十年内，人工智能将使许多传统岗位消失，如客服、信用评估员、市场分析师等；但有些职业是人工智能暂时很难取代的，如画家或律师等艺术性或人文性较强的工作，原因很容易知道，一言以蔽之，机器始终无法替代人类的灵光一闪。之前我也对此观点深信不疑，直到看见了下面这些新闻：<br><img src="/2022/img/b&bo=NwQzBjcEMwYWECA!&rf=viewer_311.jpeg" alt="AI画作：太空歌剧院" style="zoom:80%;" /><br><img src="/2022/img/b&ek=1&kp=1&pt=0&bo=OARgCTgEYAkWECA!&tl=1&vuin=1572676601&tm=1676037600&dis_t=1676037625&dis_k=f9474985ff1e09ce64e0efcb968d67df&sce=50-1-1&rf=viewer_311.jpeg" alt="AI律师" style="zoom:67%;" /></p><p>要知道，该书出版于2018年，至今仅过了短短五年…所以，你很难想象科技的发展速度，谁知道下一个五年将会是什么样呢？就chatgpt而言，虽然目前它的回答尚有较大的瑕疵，但风口已经打开，如周鸿伟所说——“搭不上ChatGPT的企业可能将被淘汰”，大量资本的注入势必会大大增强其性能，所以它的潜力仍然无法预估。不过，有一点我们必须清楚：如果想要避免未来被人工智能取代，就必须从事技术含量高、重复性低、可量化性低的工作。当然，公务员也许不错。</p><p>话说回来，也许不用对未来AI是否会造成失业潮而过度担心呢：<br><img src="/2022/img/image-20230210223238238.png" alt=""><br>本人浅薄地认为，AI过度地取代人工，将生成大量无业游民，进而引发社会动荡，这无疑是政府所不愿看到的。因此，政府可能会进行宏观上的调控。但，即使在调控下AI只会代替少部分人，你又如何保证你不是那倒霉的小部分呢？</p><p><strong><mark class="hl-label blue">由此看到的中外差距</mark> </strong><br>在<a href="https://www.huxiu.com/article/787988.html">《万字拆解：ChatGPT为什么这么强？》</a>论文中，作者向国内同胞们发出了真切的呼吁，此诚危急存亡之秋！包括但不限于人工智能领域，国内外的差距正在不断拉大，而极多数国人却在某些公知不怀好意的误导下，认为我国已经全方位赶英超美，天朝上国无所不能…如此下去，未来中国只有两个方面能够战胜国外——浓香型科技和酱香型科技。</p><p>再来看看我们的企业在干什么：<br><img src="/2022/img/image-20230210231638974.png" style="zoom:50%;" /><br><img src="/2022/img/image-20230210231800724.png" style="zoom:50%;" /><br>国外科技巨头在马不停蹄地创新，国内巨头却在你追我赶地和菜市场的小商贩抢生意。chatgpt爆火后，国内巨头们也争先恐后地计划推出类gpt产品：<br><img src="/2022/img/image-20230210232254477.png" style="zoom:67%;" /><br>个人不认为国内的这场chatgpt争夺战能够分出胜负，反而可能是全军覆没。原因很简单：2022年，OpenAI的算力支出约为4亿美元，人工支出约为9千万美元，光是这两样就达到了惊人的35亿人民币！中国有哪家企业能够下这样的血本？更不要说它的时间成本与技术成本了。在国内浮躁的学术环境和企业环境下，我们很难持续地取得技术创新。下一个5G还有多久？</p><p><strong><mark class="hl-label default">AI可能取代人类吗？</mark> </strong><br><img src="/2022/img/image-20230210222435996.png" alt=""><br>想起了流浪地球2的开头旁白——“起初，没人认为这是一场灾难，直到它和每一个人都息息相关。”</p>]]></content>
    
    
    <summary type="html">关于CHATGPT的一些想法</summary>
    
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://jyxcpp.netlify.app/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深度思维-读书总结</title>
    <link href="http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://jyxcpp.netlify.app/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-27T01:07:46.000Z</published>
    <updated>2023-03-12T11:21:04.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几日，我父亲醉酒后拉着我谈心，不知道是酒后起兴还是愁绪积压太久，向我倾诉了他对前半生的无尽悔恨，悔恨学生时代没有自制力（初中名列前茅，中考前被朋友带着打牌，三个月不眠，因此失利；高中仍名列前茅，又被朋友拉着打乒乓，没下课就跑去占台，耗费大量时间）；悔恨早年赚到钱时，没能听朋友劝告进入房地产；悔恨后来发家时，没能及时在深圳买房…父亲微仰着头，泪光不停地闪烁着，“在那个疯狂的、满地是钱的年代，无数个机会从我们面前闪过，然而我一个也没曾抓住。”</p><p>父亲的这些话，令我感触颇多。那个撒钱的年代，为什么机会遍地，却不曾抓住过？当然，任何一件事都有其时代的局限性，马后炮总是容易的。但话说回来，不依旧有很多人脱颖而出，改变了自己的命运吗？有人说他们靠的是胆量，或说凭的是运气。不可否认，这两者差一个都不行，但笔者认为，更重要的是——认知。与认知同义的，还有我们常说的眼界、格局等。最近有句话在网上传得很火——凭运气赚到的钱，总会凭实力亏掉，这句话的背后也许就体现了认知的重要性。如著名畅销书籍《穷爸爸富爸爸》中提到的，为什么一些运动员、演员等红极一时，短时间内赚到了普通人几辈子都赚不到的钱，而十几年甚至几年后就传出破产消息（拳王泰森、影帝尼古拉斯·凯奇都是例证）？个人认为，其背后深层次的原因都是认知（眼界）的不足。打一场拳或拍一部戏就能拿到一笔难以想象的巨款，相信绝大部分人此时都难以压抑自己的消费欲望，对于出身普通的人而言，更是会出现报复性消费，于是买豪车、置豪宅…不出多久，现金流就为负数了。而对于极少数的另一部分人，他们有更高的认知、更远的眼界，则可能用这些巨款继续创造正现金流（买房买车多数时候都属于负债，即负现金流），进而持有更多的资产。</p><p>那么，作为普通人的我们，怎样才能提升自己的眼界呢？又怎么才能把握时代的机遇呢？《深度思维》这本书也许就给出了答案。这本书给出了几种思维技术和思维格局，配以普通人的事例，让我深刻体会到了思维能力的重要性。下面简单谈谈我读完本书的感受。</p><p><strong>文章首先提到了思维链</strong> 。思维链的形式很简单，就是通过对一个问题进行连续追问，从而推测事物的未来走向（5so思考法），或探究问题的本质根源（5why思考法）。别看其思想和步骤极其简单，但结果往往令人吃惊！比如书中的例子，<strong>如何解决墙被腐蚀的问题——只需关上博物馆的窗帘！</strong> 这便是 5why思考法的威力，而普通的思考往往很难达到如此大的跨度。5so思考法同样令我震惊，书中有个精彩的真实案例：上海自贸区要成立了，so？——上海本地的贸易公司业务会繁荣，相应公司的股票一定上涨，so？——物流业务肯定也会被带动，物流公司的股票也值得购买，so？——物流繁荣，港口也一定繁荣，so？——集装箱租赁业务也肯定火爆…最后事实证明这一逻辑链完全正确，少量窥探先机的人则赚得盆满钵满。<br>既然这种简单到人人都会的思想方法能展现出如此巨大的威力，那为什么实际中，受益的人少之又少呢？个人认为，是因为没有刻意训练。方法再厉害也没有用，<strong>只有形成本能，当任何问题发生时，第一时间用这些方法思考问题，才能发挥作用</strong> 。而想要形成本能，就需要我们刻意训练，每当遇到问题，都先问自己，可以用什么样的方法或角度来解决，久而久之就可形成本能。</p><p><strong>接着提到了换位思维</strong> 。额，这还需要说？俺小学就学会了换位思考！小时候，一个小姐姐护士给我扎针，扎错了好几次，紧张得从脖子红到了耳朵，但我没怪她，因为我换位思考，如果我作为一个实习生护士，连续扎错了针，心里该多么紧张和难受啊！所以需要体谅和理解，想到这，我还安慰了这位护士，果然，一下就扎对了…呵呵，首先，这篇读后感不是小学课文；第二，换位思考不仅用于感受和体谅他人，在营销或其他领域也常有应用。还是书中的例子，一旅行社针对高压力的白领群体推出了一款旅游路线，广告语有以下两个：</p><ol><li><strong>风光无限，畅想人生</strong></li><li><strong>你是愿意待在沉闷的办公室里勉强安慰自己小点压力，还是愿意躺在大理洱海边畅快地呼吸新鲜空气？</strong></li></ol><p>高下立判。显然，第一个广告语是从你自己的角度来描述的，这并不能和白领们产生共鸣。而第二个广告语则是站在白领的角度来考虑的。想想，将自己放置于沉闷、阴暗的办公司，耳边嘈杂声不绝，满屋缭绕着对面男同事呼出的二手烟，桌面上堆满了待处理的文件…此时，你不经意抬头，看见了电脑上的第二则广告语，一幅蓝天白云，海边沙滩的画面立刻出现在你的眼前——OMG！去他妈的工作，这洱海我去定了！</p><p><strong>当我们面向的对象是人时，换位思考几乎是不能避免的</strong> 。<strong>记住，谁能引起共鸣，谁就能赢得了客户的心</strong> 。任何时候，问自己一句：如果我是他，我会想什么？我会做什么？每一份直击人心的文案策划，每一次打开局面的商业谈判，每一个引爆用户的产品设计，背后都对应着成功的换位思维。<br>另外，换位思考的一个精彩应用是爱德华·德·博诺博士提出的六顶思考帽，有专门的一本书——《六顶思考帽》详细介绍了该思想。六顶思考帽是利用换位思考，站在六种极端的角度来分析问题，最终得到一份最优的答案。后面有时间再阅读此书并另写读后感，这里就不多说了。</p><p><strong>在可视化思维一章中，文章提到了一种重要的时间管理原则——容易的事先做，重要的事先做</strong> ，经过大量实践，该原则被认为是解决拖延症的不二良方。嗯？就这么个小原则就能解决我多年的拖延症？这也太小看我了吧！再容易的事我也能拖…当然，这并不能解决你的拖延症，因为作者犀利地指出，<strong>这种时间管理原则最大的问题，在于如何评价事情的容易或重要程度</strong> ，就这点，我深有同感！很多时候，我在评价一件事情的重要性或可能性时，总会直接脱口而出：这件事有 80%~70% 的重要（可能）性！喔？70%~80% ，这些确切的数字是怎么得到的？计算得到的？还是调研得到的？又或者是随口一说？很显然，只是随口说说。通过这种模糊不定的评价标准来决策事情的先后，自己本身也会对其产生怀疑，所以当然就不会严格遵守。因此，作者就提出了一套评价标准：<br><img src="/2022/img/未命名绘图37.png" style="zoom:150%;" /><br>有了这样的确切的评价体系，我们就能够更客观地估计事件的优先级。你甚至可以对以上某一角度加权。注意，一旦决定实施这一评价体系，就必须时刻遵守它的结果。比如，算出 A 事件的优先级大于 B 事件，但你自己更喜欢 B 事件，所以你就违背了这一结果，直接先做 B 事件。长期这样违背只会降低这一方式的权威性，直到最后形同虚设。当然，你完全可以将喜爱程度也加入到这一体系中，并对喜爱度加权。</p><p><strong>令我同样印象深刻的还有秘籍型思维</strong> 。秘籍型思维是指，当我们探寻一个人是怎么成功的，或怎么才能做成一件事，最终会将原因归结到某种秘籍——职场能力、个人背景、贵人相助、思维方式…实际上，这种秘籍型思维已经深入我们的骨髓，我们将原因归结为一点，却忽视了别人在其他方面所作的努力。拿我自己举例，高中时，我一直对数学的奇技淫巧很感兴趣，花费大量时间去追求所谓的秒杀方法，基础却没能重视，最后的结果显而易见——基础不牢，地动山摇，高考数学成绩给了我一记耳光。更重要的是，直到大学，我都没有再提起过对数学的兴趣，甚至对其反感和厌恶，我想，这可能会成为我的一生之痛。<br><strong>秘籍型思维将复杂的东西过于简单化，企图用一个相对简单的秘籍去代替复杂的成功规律，而对其他方面的因素视而不见。</strong> 所有成功都是多方面因素促成的结果，单一考虑某一个方面，则有可能使得我们将鸡蛋全部放入一个篮子，增大了事件的风险性。</p><p>与秘籍型思维相反的是思维方法是全流程优化。全流程优化的最诱人的地方在于它的复利性。爱因斯坦曾说，复利是世界的第八大奇迹。全流程优化是指，将一件事情拆分为多个步骤，如果你每个步骤都做得比别人好那么一点，则成效则可能是别人的几倍！这是真正的在平凡中创造伟大！还是拿书中广告软文的例子来说明：<br>文章标题 --&gt; 正文内容 --&gt; 商品软文 --&gt; 链接跳转 --&gt; 店铺页面 --&gt; 支付界面 --&gt; 收获评价<br>富有吸引力的标题能够带来更多流量，这是第一步；正文内容不会直接谈到商品，而是做一些铺垫，这里必须保证足够吸引读者，或者和读者引发共鸣，这是第二步；接着是商品软文，这里需要承上启下，展现商品用途，需要足够打动读者；然后，读者可能成功被你的软文打动！ta尝试点入链接…<br>在以上步骤中，其他几个步骤你可以很容易地优化，比如将店铺页面装饰得漂亮些、评价反馈服务再做得到位一些…那么，链接跳转和支付页面该怎么优化呢？实际上，这两点是最容易被忽略的点，也是很容易丢失客户的点！拿我自己的感受来说，当我点击跳转链接后，经常会提示：“请复制该链接，并在浏览器中打开”，而这会极大地消耗我的耐心和冲动。本来这些软文广告就是在消费我们读者的冲动，而这些冲动都被繁琐的跳转链接给消耗了，还谈什么购买呢？对于支付页面，我也常有体会，很多时候下定决心要购买商品了，却发现没有微信支付，而只有支付宝支付，这每每令我相当恼火。<br>话转回来，如果我们将每个流程都优化 20%，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>4.29</mn></mrow><annotation encoding="application/x-tex">1.2^7=4.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4.29</span></span></span></span> ，你收获的成果将是别人的 4.29 倍！而你多做的努力只有 20% ！这就是复利的威力。因此，重视每一个细节，是我们成功的关键！</p><p>接着书中讲到了生态思维，生态思维侧重于发现事物之间的关系。《浪潮之巅》一书中介绍了计算机行业的一个著名生态链——以微软为首的软件公司吃掉硬件带来的全部好处（比如你内存越大，那我软件也刻意占用越大的内存），迫使用户更新机器让惠普和戴尔等公司收益，而这些计算机制造商再向英特尔这样的半导体厂商订货。在这条链上，相应公司的股票先后都会上涨，因此华尔街的投资者们都知道，如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔的股票。这些投资者们就深谙生态思维和逻辑链的威力。曾经在知乎上还看见一句令我印象很深刻的话：如果大家都知道某个产业赚钱，那就一定不能再挤进去，那怎么办呢——进入这个产业的上游产业。这也是一种生态思维的体现。生态思维下还有几个著名的模型：<strong>淘金模型、森林模型和平台模型</strong> 。<br>淘金模型的底层考虑是共生——如果恶龙太强，那就当恶龙的马仔！额…说错了——如果对手强大如河马，那我们可以成为牙签鸟！淘金模型来源于全球著名牛仔裤制造商李维斯。在疯狂的淘金热下，想要继续挖到大金矿已经几乎不可能，但大量的挖矿工人需要结实耐磨的裤子，聪明的李维斯便开始在金矿附近买起了牛仔裤，从而发展成了后来的著名牛仔裤品牌。相似的例子还有很多，比如为大量捡贝壳以求珍珠的人们提供坚实的橡胶手套。<br>森林模型强调的是错位竞争；平台模型则是为大量竞争者提供平台，而自己则成为平台的收益者。这些方法和事例看似简单，实践起来仍有很大难度。</p><p>文章最后提到的是大势思维。文章有一段很漂亮的话：</p><blockquote><p>古代诗人罗隐说：“时来天地皆同力，远去英雄不自由。”<br>荀子说：“君子生非异也，善假于物也。”<br>小米创始人雷军说：“站在风口上，猪都能飞起来。”</p></blockquote><p>这几句话都是对大势思维的例证。20年前，中国的富豪大多数是搞矿产的；10年前，中国富豪大多数是搞房地产的；现在，中国富豪则大多数是搞互联网的；那么可以预测，未来几十年，中国的富豪可能是发展人工智能或自动驾驶的。身为普通人的我们，又该如何发现并利用趋势呢？其实，趋势下往往隐藏着深刻的经济学规律，而文章中则给出了三条强大的规律——马太效应、科技进步和人口变化。这三条规律能够压制其他任何心理学或经济学规律，值得我们重视。</p><p>书中还有许多精彩的内容，限于笔者精力有限，就不再总结了，详细还请各位细品此书，定能有所收获。</p><p>在这个充满机遇和挑战的时代，共勉。</p>]]></content>
    
    
    <summary type="html">深度思维</summary>
    
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://jyxcpp.netlify.app/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>更安全的用户进程?</title>
    <link href="http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>http://jyxcpp.netlify.app/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-01-13T06:55:11.000Z</published>
    <updated>2023-03-12T11:21:19.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>data_limit_3gb</code></p></blockquote><p>在<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程</a>一文的文尾，笔者留下了一个思考题：既然要求用户不能直接访问内核，那为什么不将用户代码段的界限设置为 3GB 呢？正如之前所演示的那样，如果用户代码段的界限为 4GB，则用户就可以随意修改内核，包括直接访问显存：<br><img src="/2022/img/image-20230112155046604-1673594986128-1.png" alt=""><br>其实笔者也不知道准确的答案，我粗略参考了 Linux 0.11 的代码，发现 Linux 0.11 <u>似乎</u>也是直接将段界限设置为 4GB 。至于规范的防止用户修改内核的方式，咋们以后遇上了再说，现在我们来看看到底能不能通过将数据段界限改为 3GB 来防止用户直接修改内核数据。</p><p>首先将用户数据段的段界限改为 <code>0xbfffffff</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:tss.c</span></span><br><span class="line"><span class="comment">//函数说明:tss_init()</span></span><br><span class="line">*((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xbffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br></pre></td></tr></table></figure><p>还要修改 syscall：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span></span><br><span class="line">    <span class="params">(<span class="string">&quot;int 0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (retval)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a&quot;</span> (no), <span class="string">&quot;b&quot;</span> (_arg1)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.....其他syscall也需要改为内联汇编</span></span><br></pre></td></tr></table></figure><p>为什么要将之前的静态变量方式改成扩展内联汇编呢？说到这，笔者不禁流下了悔恨的泪水…当初我也是为了少学这点看起来复杂的扩展汇编，所以使用了全局静态变量这样的“巧计”来代替这种复杂的汇编。没办法，未来某些场景必须使用到它，所以，该来的早晚会来。话说回来，目前而言，由于我们还没有真正的加载用户进程（真正的用户进程是从文件中读取，进而载入内存的，而当前我们使用函数代替用户进程的），所以一切代码和数据（的标号，即地址），不论用户进程还是内核，都被链接成了 3GB 以上，这都是下面这行 makefile 指令造成的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><p>这条指令将目前的所有文件全部链接成 kernel.bin，并指定入口的虚拟地址为 <code>0xc0001500</code> ，因此，所有的函数和全局、静态变量的地址实际上都在 <code>0xc0000000</code> 以上！所以，我们将用户段的界限限制在 3GB 以下时，在用户态中就不能再使用任何全局变量和静态变量！所以这里的 _syscallX 就不能使用静态变量来中转啦！于是乎，只有改成扩展内联汇编喽。<br>最后，还得修改系统调用入口函数，因为进入中断并不会自动切换 ds、es、fs（只会切换cs），所以咋们必须手动将这几个寄存器修改为内核态的数据段选择子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;.....</span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   push eax</span><br><span class="line">   mov  ax,0x10   ;内核的数据段选择子</span><br><span class="line">   mov  ds,ax</span><br><span class="line">   mov  es,ax</span><br><span class="line">   mov  fs,ax</span><br><span class="line">   pop  eax</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;.....</span><br></pre></td></tr></table></figure><p>ok，来试试看这下能不能直接在用户态访问显存：</p><p><img src="/2022/img/image-20230114134607206.png" alt="image-20230114134607206"></p><p>显然，发生了 GP 异常，禁止访问。说明这样是能够起到一定的保护作用的。来看看正常运行的效果：<br><img src="/2022/img/image-20230114150332216.png" alt=""></p><p>上图中用户只打印了一次，我就使用 Bochs 断点指令将其打断了，因为后面任务切换时引发了程序崩溃，原因就不细说了。这说明通过限制用户数据段的界限来禁止访问内核的这种方式是不可行的。<strong><font color='orange'>实际上，现代操作系统的内存保护机制并非在段上，而是在页上</font></strong> ，关于这点，以后再说吧。</p>]]></content>
    
    
    <summary type="html">自制操作系统</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>堆管理-实现malloc</title>
    <link href="http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/"/>
    <id>http://jyxcpp.netlify.app/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/</id>
    <published>2023-01-12T07:11:13.000Z</published>
    <updated>2023-03-12T11:21:22.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>k_block_descs</p><ul><li>为什么 1KB 以上就不分块</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="http://jyxcpp.netlify.app/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/"/>
    <id>http://jyxcpp.netlify.app/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</id>
    <published>2023-01-11T02:47:05.000Z</published>
    <updated>2023-03-12T11:21:15.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>printk</code></p></blockquote><h3 id="font-color-red-系统调用与API-font"><font color='red'>系统调用与API</font></h3><p>之前很长一段时间，笔者都将系统调用和 API 函数混为一谈，实际上两者有较大区别。</p><p><strong>API (Application Programming Interface，应用程序接口)</strong> ，其主要功能是提供<u>通用功能集</u>，程序员通过调用 API 对应用程序进行开发，可以减轻编程任务。</p><blockquote><p>API 可以简单的理解为一个通道或者桥梁，是一个程序和其他程序进行沟通的媒介，本质上一个函数。比如我们想往屏幕上打印字符，显然，如果自己从头实现，则需要了解显卡、汇编等知识，无疑相当麻烦。而且 C 库中早就为我们准备了打印函数，即 printf，你只需要按它的要求传入参数就行，无需了解 printf 内部实现。所以 printf 也可以称为 API 。说白了，<strong>接口，就是指两个不同程序之间交互的地方</strong> ，就这么简单。</p></blockquote><p>而系统调用是一种特殊的接口，通过这个接口，用户可以访问内核空间，进而实现一些只有内核才能完成的操作，比如屏幕打印、内存申请（malloc）等。<br>那么这两者有什么区别呢？严格来说，两者没有直接关系，但一般而言，系统调用一般封装在 API 中，但不是所有 API 内部都会进行系统调用。<strong>API 的提供者是运行库，运行库则使用操作系统提供的系统调用接口</strong> ，如果再往下，内核则调用驱动程序，由驱动程序来和硬件打交道。</p><h3 id="font-color-red-系统调用实现原理-font"><font color='red'>系统调用实现原理</font></h3><p>系统调用的直接目的是进入 ring0，以便进行一些只有 ring0 才能完成的工作。我们之前说过，想要从低特权级进入高特权级，则只能通过门完成。由于调用门开销较大，Linux 选择通过中断门进入高特权级，并进行系统调用。<strong><font color='orange'>Linux 系统调用的中断号为 0x80，子功能号存入 eax，而 ebx、ecx、edx、esi 和 edi 则依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中</font></strong> 。</p><blockquote><p>如果要传入五个以上的参数，则需要使用栈传递参数，后文将演示这一过程。</p></blockquote><p>如果细分，Linux 系统调用可以分为三种方式：<br><strong><mark class="hl-label blue">通过 glibc 提供的库函数</mark> </strong><br>glibc 是 Linux 下使用的开源的标准 C 库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了系统调用。比如通过 glibc 提供的 <code>chmod</code> 函数来改变文件 <code>etc/passwd</code> 的属性为 444：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        rc = chmod(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="number">0444</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;chmod failed, errno = %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;chmod success!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用syscall</mark> &quot;</strong><br>syscall 也由库函数提供，但相比于其他调用方式， syscall 则更加灵活，比如你通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，所以你可以利用 glibc 提供的 <code>syscall</code> 函数直接调用，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">syscall</span> <span class="params">(<span class="type">long</span> <span class="type">int</span> sysno, ...)</span></span><br></pre></td></tr></table></figure><p>其中 sysno 是系统调用号（子功能号），每个系统调用都有唯一的系统调用号来标识；<code>...</code> 则是可变参数列表，根据系统调用的不同，可带0~5个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。<br><strong><mark class="hl-label blue">通过int指令调用</mark> </strong><br>直接通过内联汇编进行系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rc;</span><br><span class="line">    <span class="type">char</span> *file_name = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode = <span class="number">0444</span>;</span><br><span class="line">    <span class="keyword">asm</span></span><br><span class="line">    (</span><br><span class="line">     <span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">    :<span class="string">&quot;=a&quot;</span> (rc)</span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (SYS_chmod), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)file_name), <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)mode)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容易知道，这三种方式最终都会使用 <code>int</code> 指令进行系统调用</strong> 。</p><h3 id="font-color-red-实现系统调用-font"><font color='red'>实现系统调用</font></h3><p><strong><mark class="hl-label blue">添加_syscallX</mark> </strong><br>实际上，库函数也是通过操作系统提供的 _syscallX 宏来进行系统调用，其中 X 是参数个数，以 _syscall3 举例，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c)              \</span></span><br><span class="line"><span class="meta">type name(atype a,btype b,ctype c)&#123;                                      \</span></span><br><span class="line"><span class="meta">long __res;                                                              \</span></span><br><span class="line"><span class="meta">asm volatile                                                             \</span></span><br><span class="line"><span class="meta">    (<span class="string">&quot;int $0x80&quot;</span>                                                         \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res)                                                       \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a)),<span class="string">&quot;c&quot;</span> ((long)(b)),<span class="string">&quot;d&quot;</span> ((long)(c))) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res&gt;=0)                                                            \</span></span><br><span class="line"><span class="meta">return (type) __res;                                                 \</span></span><br><span class="line"><span class="meta">errno=-__res;                                                            \</span></span><br><span class="line"><span class="meta">return -1;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>各位无需了解以上代码的含义，咋们会契合自己的操作系统，使用更简单的方式实现。另外，此 _syscallX 已经被 Linux 废弃，但为了简单，我们仍模仿 _syscallX 进行系统调用。</p><p>由于我们的操作系统最多只会使用三个参数的系统调用，所以这里咋们只实现 0~3 个参数的系统调用，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> callno_ret;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg1;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg2;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg3;</span><br><span class="line"><span class="type">uint32_t</span> _syscall0(<span class="type">uint32_t</span> no)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall2(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall3(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2, <span class="type">uint32_t</span> _arg3)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    arg3 = _arg3;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov edx,arg3&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于为什么要使用静态变量，这已在之前的文章多次提及，不再说明。</li></ul><p>啊哈，很简单吧！这里只解释 <code>mov callno_ret,eax</code> ：因为系统调用也遵循 ABI 规范，即，将返回值存入 eax 中，所以我们还要将 eax 转移到静态变量 callno_ret 中，并将其返回（callno_ret 即说明它既用来存放调用号，也用来作为返回值）。</p><p><strong><mark class="hl-label blue">编写中断入口函数</mark> </strong><br>进入 0x80 中断例程后，代码会根据传入的调用号跳转到相应的函数，函数执行完毕后回到中断，再通过 iret 返回到用户态。0x80 中断例程代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;文件说明:interrupt.s</span><br><span class="line">;......上文忽略.......</span><br><span class="line">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;</span><br><span class="line">[bits 32]</span><br><span class="line">extern syscall_table</span><br><span class="line">section .text</span><br><span class="line">global syscall_handler</span><br><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EID</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 为系统调用子功能传入参数</span><br><span class="line">   push edx            ; 系统调用中第3个参数</span><br><span class="line">   push ecx            ; 系统调用中第2个参数</span><br><span class="line">   push ebx            ; 系统调用中第1个参数</span><br><span class="line"></span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;4 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><ul><li>以上代码的格式和之前中断处理的格式完全相同，不再赘述。</li><li><code>syscall_handler</code> 为系统调用的入口，所有系统调用都会通过该入口函数进入到指定的子功能处理函数。</li><li>第 25 行， <code>syscall_table</code> 是在 <code>syscall_init.c</code> 中定义的指针数组，该数组中存放的是各个系统调用的指针。</li><li>第 28 行，将存放返回值的 eax 存入内核栈的相应位置。为什么要这样呢？因为从用户态进入中断时，保存现场，存放调用号的 eax 被存入中断栈；所以从中断返回，恢复现场时，调用号重新被放入 eax；但 eax 必须用来存放返回值，所以必须将返回值提前放入中断栈的相应位置处，这样才能在返回用户态后从 eax 取得返回值。</li></ul><p><strong><mark class="hl-label blue">为 0x80 中断例程建立中断描述符</mark> </strong></p><p>想要通过 0x80 正确进入到相应例程，就必须建立相应的中断描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:idt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_CNT 0x81  <span class="comment">//修改为0x81</span></span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    make_idt_desc(&amp;idt[<span class="number">0x80</span>],IDT_DESC_DPL3,syscall_handler); <span class="comment">//为0x80建立中断描述符</span></span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//........</span></span><br></pre></td></tr></table></figure><p>现在完事具备，就差一个具体的系统调用啦！为了让用户进程能够说话，咋们先实现 write 系统调用，该调用可以在屏幕上打印文字。</p><h3 id="font-color-red-加入write系统调用-font"><font color='red'>加入write系统调用</font></h3><p>write系统调用相当简单，不过是对 console_put_str 的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(str,DEFUALT);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这是实际的子功能函数，是通过 <code>syscall_handler</code> 中断入口函数调用的，而不是被用户直接调用。用户调用的 write 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_WRITE,(<span class="type">uint32_t</span>)str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>SYS_WRITE</code> 为调用号，定义在 syscall.h 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SYSCALL_NR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SYS_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><u>如此一来，整个系统调用的流程就清晰的呈现在我们眼前：</u></font></strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRB(write)--&gt;L(_syscall1)--&gt;G(int 0x80)--&gt;K(syscall_handler)--&gt;A(sys_write)  </pre></div><p>最后，别忘了初始化系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    syscall_table[SYS_WRITE] = sys_write;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;init_all\n&quot;</span>,DEFUALT);</span><br><span class="line">    idt_init();    <span class="comment">// 初始化中断</span></span><br><span class="line">    timer_init();  <span class="comment">// 初始化PIT</span></span><br><span class="line">    thread_init(); <span class="comment">// 初始化线程相关结构</span></span><br><span class="line">    mem_init();   <span class="comment">// 初始化内存管理系统</span></span><br><span class="line">    console_init();<span class="comment">// 初始化终端输出</span></span><br><span class="line">    tss_init();    <span class="comment">// 初始化tss</span></span><br><span class="line">    syscall_init();<span class="comment">// 初始化系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前用户进程无法直接调用 print 系列函数进行打印（否则发生 0xd 号异常），现在实现了 write 系统调用，就可以让它说话啦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line">    process_execute(u_prog_a,<span class="string">&quot;proa&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hi,man\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/protalk.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h3 id="font-color-red-栈传递参数-font"><font color='red'>栈传递参数</font></h3><p>前文说到，如果参数超过五个，那么寄存器就不够用了，此时只能通过栈来传递。其实通过栈传递参数是调用门的原生做法，这点在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中有提到过。对于中断门而言，使用栈传递需要手动实现，但也很简单：进入中断时，处理器自动压入旧栈的 ss 和 esp，由于段基址都为 0，所以我们就能直接根据该 esp 定位到旧栈中的参数（因为旧栈压入参数后，调用中断，旧栈的 ss 和 esp 紧接着就被自动压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断剖析</a>），图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE36-1673590654821-2.png" alt=""><br>根据上图，就很容易知道如何从旧栈获取参数啦，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 获取当前栈中esp的值</span><br><span class="line">   mov ebx,[esp+4+48+4+12]</span><br><span class="line">;3 再将参数压入当前栈中</span><br><span class="line">   push dword [ebx+12]  ; 系统调用中第3个参数</span><br><span class="line">   push dword [ebx+8]   ; 系统调用中第2个参数</span><br><span class="line">   push dword [ebx+4]   ; 系统调用中第1个参数</span><br><span class="line">   mov eax,[ebx]        ; 子功能号</span><br><span class="line">;4 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;5 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><h3 id="font-color-red-思考-font"><font color='red'>思考</font></h3><p>你可能会问，为什么不直接在 API 中进行系统调用呢，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = SYS_WRITE</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式不是更直接吗？为啥还要通过 syscallX 来进行系统调用？答案是代码复用。系统调用有上百上千个，而它们的调用代码都像上面这样相似，如果每个函数都采用这种方式，无疑是相当冗余的。若参数个数相同的系统调用都使用同一种 syscall，如 syscall3，这样不就大大减少了代码量吗？</p>]]></content>
    
    
    <summary type="html">自制操作系统, 系统调用, Linux, syscall, write</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>printf加强-支持short与long long</title>
    <link href="http://jyxcpp.netlify.app/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <id>http://jyxcpp.netlify.app/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/</id>
    <published>2023-01-10T05:53:20.000Z</published>
    <updated>2023-03-12T11:21:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">printf 底层剖析及可变参数探究</a><br>本文参考文章：<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a> ，<a href="https://blog.csdn.net/kjlist2017/article/details/104113265">使用位运算代替取模</a><br>本节对应分支：<code>printk-enhanced</code></p></blockquote><p>上节说到 Linux 0.11 的 printk 不支持输出 short （不是不支持，而是表现得和 int 相同）和 long long，本节修改代码来支持 <code>%hd</code> 和 <code>%lld</code> 。<br>本以为很简单，只需像之前那样对 short 或 long long 数值不断除以基数并取模，依次得到数字字符，然后组成字符串即可。没想到的是，Bochs 的 <strong>32 位 x86 环境不支持 64 位除法和取模运算</strong> ，也就是说无法支持以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = a / b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = a % c;</span><br></pre></td></tr></table></figure><p>否则会报错，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `__divdi3&#x27;</span><br><span class="line">undefined reference to `__moddi3&#x27;</span><br></pre></td></tr></table></figure><p><strong><code>__divdi3</code> 和 <code>__moddi3</code> 是 gcc 为我们准备的 64 位除法和取模函数，当发生以上情况时，就用这两个函数来模拟除法和取模</strong> 。但由于咋们是自己实现操作系统，所以不能引入外部库函数（就算能，俺也不愿意，俺可不想让复杂的库函数来破坏我们操作系统的简洁性，而且链接了一个库，往往会连着其他许多库）。所以，我们要自己实现 64 位除法和取模函数。</p><p>坏消息是，笔者找了一天的相关资料，发现要么实现过于复杂，要么函数有 bug 。绞尽脑汁时，突然在知乎大佬的<a href="https://zhuanlan.zhihu.com/p/112361959">一篇文章</a>中看见了这样一个等式：</p><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x=2^{32}×H+L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></strong></p><p>其中 H 为 64 位整型 x 的高 32 位，L 为低 32 位。笔者狂喜，接着在草稿纸上写下了如下等式：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x/y=(2^{32}×H+L)/y=2^{32}×H/y+L/y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>其中 y 为 32 位整型，因为 y 就是基数 base，范围在 2~32 之间。<br>这样一来，不就将 64 位除法转换为了 32 位除法吗？哇哈哈哈哈，原来不过如此嘛！等着，别急，突然觉得哪有问题…计算机的除法是向下取整的，这也能使用分配律吗？当然不行，反例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">29</span>+<span class="number">32</span>)/<span class="number">8</span>=<span class="number">29</span>/<span class="number">8</span>+<span class="number">32</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span>  <span class="comment">//该等式成立,但换个方式拆分就不行了:</span></span><br><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">31</span>+<span class="number">31</span>)/<span class="number">8</span>=<span class="number">31</span>/<span class="number">8</span>+<span class="number">31</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span>  <span class="comment">//哦豁</span></span><br></pre></td></tr></table></figure><p>所以此方法无效喽，那怎么办？别急，考虑到我们的除法有一定特殊性，除数只为 8、10、16（printf只支持这三种格式打印），这个特性也许能用上。先想想，为什么取整除法不能像上面那样分配？因为拆分方式会影响两方的精度丢失情况，随着双方的精度丢失情况变化，就会影响最终结果。那么，使另一方被整除，从而将精度丢失只划给一方，这样不就能保证结果不受拆分方式而改变了吗？具体做法如下：</p><p>对于八进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>3</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><msup><mn>2</mn><mn>29</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">x/8=(2^{32}×H+L)/2^{3}=2^{32-3}×H+L/8=2^{29}×H+L/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span></span></span></span></font><br>对于十六进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>4</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>28</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">x/16=(2^{32}×H+L)/2^4=2^{32-4}×H+L/16=2^{28}×H+L/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span></span></span></span></font><br>可以发现，精度丢失只发生在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">L/base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span></span></span></span> 上，所以结果一定正确。</p><p>上面解决了 64 位除法的问题，那取模怎么解决呢？使用位运算的一个特性就可以完美解决这个问题：<br><u><strong><font color='orange'>取模运算 (a%b) 在当 b 为 2^n 时可简化为 a &amp; (b - 1)</font></strong></u></p><blockquote><p>简单证明：当 b 为 2^n 时,a/b的意义就是 a 右移 n 位，而右移的 n 位的值，就是 a%b 的值。</p></blockquote><p>以上除法和取模的方法只能用于 2 的幂，而 10 不是 2 的幂，所以只有另找办法了。所幸，那位知乎大佬的代码恰好能解决这个问题，详细参见<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a>。最终代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG    128     <span class="comment">//if long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_10</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = *n % <span class="number">10</span>;</span><br><span class="line">    *n = *n / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_16_8</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *n, <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = base==<span class="number">16</span>?<span class="number">28</span>:<span class="number">29</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> low = *n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hign= (*n)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mod = ((*n)&amp;(base==<span class="number">16</span>?<span class="number">15</span>:<span class="number">7</span>)); <span class="comment">//a &amp; (base - 1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(<span class="number">1</span>&lt;&lt;t) * hign + low / base;</span><br><span class="line">    *n = tmp;</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">long</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;LEFT) type &amp;= ~ZEROPAD;</span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) size--;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">16</span>) size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">16</span> || base==<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> *p = &amp;num;</span><br><span class="line">            *(++p) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div_16_8(&amp;num,base)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">                tmp[i++] = digits[do_div_10(&amp;num)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> low = num;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hign= num&gt;&gt;<span class="number">32</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i++] = ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                low = <span class="number">429496729</span> * (hign % <span class="number">10</span>) + low / <span class="number">10</span> + ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">                hign = hign / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;precision) </span><br><span class="line">        precision=i;</span><br><span class="line">    size -= precision;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line">    <span class="type">int</span> flags;<span class="comment">/* flags to number() */</span></span><br><span class="line">    <span class="type">int</span> field_width;<span class="comment">/* width of output field */</span></span><br><span class="line">    <span class="type">int</span> precision;<span class="comment">/* min. # of digits for integers; max number of chars for from string */</span></span><br><span class="line">    <span class="type">int</span> qualifier;<span class="comment">/* &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields */</span></span><br><span class="line">    <span class="keyword">for</span> (str=buf ; *fmt ; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process flags */</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">        repeat:</span><br><span class="line">        ++fmt;<span class="comment">/* this also skips first &#x27;%&#x27; */</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get field width */</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* get the precision */</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++fmt;</span><br><span class="line">                <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the conversion qualifier */</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            fmt++;</span><br><span class="line">            <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qualifier = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                flags |= LONG;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">                len = <span class="built_in">strlen</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                    precision = len;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                    len = precision;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                    *str++ = *s++;</span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    field_width = <span class="number">8</span>;</span><br><span class="line">                    flags |= ZEROPAD;</span><br><span class="line">                &#125;</span><br><span class="line">                str = number(str,(<span class="type">unsigned</span> <span class="type">long</span>) va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                flags |= SMALL;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)<span class="comment">// %llx</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                flags |= SIGN;</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">                *ip = (str - buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (*fmt)</span><br><span class="line">                    *str++ = *fmt;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --fmt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>do_div_16_8 函数就是处理 16 进制和 8 进制的例程，逻辑和前文所述相同，不再赘述。</p></li><li><p>此版本用 do_div_10 来代替了之前版本的 do_div 函数，没什么原因，只是不喜欢内联。do_div_10 只用来处理 32 位除法。</p></li><li><p>86~88 行用来处理 64 位 10 进制除法。</p></li><li><p>第 198 行，当类型为 long long 时，将 qualifier 赋值为 ‘m’，以便在 switch 中识别并处理</p></li><li><p>第 199 行，当类型为 long long 时，将 LONG 标记加入 flag 。打印 8 进制和 16 进制时，如果不为 long long，第 67~68 行则将 num 的高 4 位置零，只计算低 4 位。为什么要这样做呢？因为打印负的 16 进制和 8 进制的 32 位整型时，由于负数（补码）的首位为 1，传入 number 函数时，该数会发生符号扩展（因为 number 的参数 num 是 long long，而实参是 32 位），比如 32 整型数 -1 的二进制是 <code>0XFFFFFFFF</code> ，符号扩展后就成为 <code>0xFFFFFFFFFFFFFFFF</code> ，因此造成的结果就是：<code>printf(&quot;%x&quot;,-1)</code> 也会打印 <code>0xFFFFFFFFFFFFFFFF</code> ，而正确的结果应该是 8 个 F 。所以要对于 32 位负整型，需要将高 32 位清零。</p><blockquote><p>关于补码，详见[CSAPP][<a href="https://jyx-fyh.github.io/2022/07/08/CSAPP/">https://jyx-fyh.github.io/2022/07/08/CSAPP/</a>]。再次强调， <strong>打印八进制和十六进制的负数时，是直接打印其补码！</strong></p></blockquote></li></ul><p>最终效果如下：<br><img src="/2022/img/image-20230111102501588.png" alt=""><br>本文结束。</p>]]></content>
    
    
    <summary type="html">printf底层剖析, 可变参数, 原理, 源码</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统, C语言" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>printf底层剖析及可变参数探究</title>
    <link href="http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jyxcpp.netlify.app/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-01-07T07:36:00.000Z</published>
    <updated>2023-03-12T11:21:34.414Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/">可变参数列表</a>，<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本文参考文章：<a href="https://book.douban.com/subject/3422332/">《你必须知道的495个C语言问题》</a><a href="https://book.douban.com/subject/1231236/">《Linux内核完全注释》</a>《操作系统真相还原》<a href="https://www.runoob.com/cprogramming/c-function-printf.html">printf-菜鸟教程</a><br>本节对应分支：<code>printk</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>相信每一位 C 选手写下的第一句代码都是下面这句经典的 Hello World 吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理所应当的，其中的 <code>printf</code> 函数也成为了咋们认识的第一个函数。对笔者个人而言， <code>printf</code> 是一个熟悉而陌生的函数，说熟悉是因为它伴随了我整个 C 语言的学习生涯；说陌生是因为学习过程中一直对它存疑，模模糊糊，始终没能一探究竟，不知道各位读者是否也是像笔者一样呢？记得 C 语言萌新阶段时，我时常吐槽 <code>printf</code> 中的那些格式符，如 <code>%d</code>、<code>%s</code>、<code>%c</code>、<code>%x</code> 等，乱七八糟的，实在是太难记啦！入门阶段时，我赞叹 <code>printf</code> 强大的格式处理能力，比如左右对齐、输出宽度、输出精度等；进阶阶段时，我又开始疑惑 <code>printf</code> 是如何做到参数可变的，但因为基础不足，就暂时搁浅。现在，天时地利人和，让我们对 <code>printf</code> 一网打尽吧！</p><p>本文将从以下几个方向逐个击破 <code>printf</code> ：</p><ul><li><strong><font color='gree'>默认参数提升</font></strong></li><li><strong><font color='gree'>可变参数的类型检查</font></strong></li><li><strong><font color='gree'>可变参函数实现原理</font></strong></li><li><strong><font color='gree'>其他注意事项</font></strong></li><li><strong><font color='gree'>printf源码详解</font></strong></li></ul><h3 id="font-color-red-默认参数提升-font"><font color='red'>默认参数提升</font></h3><p><strong><font color='orange'>注意，默认参数提升仅对可变参数列表有效</font></strong> ，其规则是：<strong><font color='orange'>char 和 short 自动提升为 int，float 自动提升为 double</font></strong> 。<br>比如我们一定知道，<code>%f</code> 用来输出 float，<code>%lf</code> 则用来输出 double；但实际上 <code>%f</code> 可以同时表示 float 和 double 类型，而无需专门指定 <code>%lf</code> 来表示 double（因为 printf 只能看到双精度），如下图：<br><img src="/2022/img/image-20230108145958396.png" alt=""></p><blockquote><p>本操作系统未支持浮点（难度较大，非常麻烦），且笔者对浮点的硬件支持不太了解，所以下面不讨论浮点。</p></blockquote><p>将 char/short 提升为 int 的原因是：<strong><u>可变参函数的原型无法提供参数个数以及参数类型，所以编译器无法针对各个参数生成相应代码，因此只好统一为 int 类型</u></strong> 。</p><blockquote><p>比如 <code>printf</code> 的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span></span><br></pre></td></tr></table></figure><p>显然，<code>...</code> （即可变参数列表）无法提供参数的个数和类型。值得一提的是，<code>printf</code> 中的 <code>f</code> 就是指的 <code>format</code> 。</p></blockquote><p>这么说原因大家可能还不太明白什么意思，下面笔者用代码进行解释，先来看普通函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">    test(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件生成的反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line">   4:   83 e4 f0                and    esp,0xfffffff0</span><br><span class="line">   7:   ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line">   a:   55                      push   ebp</span><br><span class="line">   b:   89 e5                   mov    ebp,esp</span><br><span class="line">   d:   51                      push   ecx</span><br><span class="line">   e:   83 ec 14                sub    esp,0x14</span><br><span class="line">  11:   c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">  18:   66 c7 45 f2 02 00       mov    WORD PTR [ebp-0xe],0x2</span><br><span class="line">  1e:   c6 45 f1 03             mov    BYTE PTR [ebp-0xf],0x3</span><br><span class="line">  22:   0f be 55 f1             movsx  edx,BYTE PTR [ebp-0xf]</span><br><span class="line">  26:   0f bf 45 f2             movsx  eax,WORD PTR [ebp-0xe]</span><br><span class="line">  2a:   83 ec 04                sub    esp,0x4</span><br><span class="line">  2d:   52                      push   edx</span><br><span class="line">  2e:   50                      push   eax</span><br><span class="line">  2f:   ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line">  32:   e8 fc ff ff ff          call   33 &lt;main+0x33&gt;</span><br><span class="line">  37:   83 c4 10                add    esp,0x10</span><br><span class="line">  3a:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3f:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">  42:   c9                      leave  </span><br><span class="line">  43:   8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line">  46:   c3                      ret    </span><br><span class="line"></span><br><span class="line">00000047 &lt;test&gt;:</span><br><span class="line">  47:   55                      push   ebp</span><br><span class="line">  48:   89 e5                   mov    ebp,esp</span><br><span class="line">  4a:   83 ec 08                sub    esp,0x8</span><br><span class="line">  4d:   8b 55 0c                mov    edx,DWORD PTR [ebp+0xc]</span><br><span class="line">  50:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">  53:   66 89 55 fc             mov    WORD PTR [ebp-0x4],dx</span><br><span class="line">  57:   88 45 f8                mov    BYTE PTR [ebp-0x8],al</span><br><span class="line">  5a:   c7 45 08 0a 00 00 00    mov    DWORD PTR [ebp+0x8],0xa</span><br><span class="line">  61:   66 c7 45 fc 0b 00       mov    WORD PTR [ebp-0x4],0xb</span><br><span class="line">  67:   c6 45 f8 0c             mov    BYTE PTR [ebp-0x8],0xc</span><br><span class="line">  6b:   90                      nop</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   c3                      ret  </span><br></pre></td></tr></table></figure><p>从第 34~36 行就可以看出参数类型的区别：int、short、char 对应的反汇编分别为 DWORD、WORD、BYTE ，也就是说，编译器为不同的类型生成了不同的代码。</p><blockquote><p>笔者以前想当然地认为函数参数类型影响的是压栈的字节数，比如将 char 压入栈，对应的反汇编就应该为 <code>push BYTE PTR [xxx]</code> ；实际上并非如此，<strong><font color='orange'>不论是 char、short、int 或是 long、long long，编译器都会压入 4 字节（对于 long long 8 字节，分两次压入）</font></strong> ，这点从 15~17 行就能体现。所以参数类型影响的不是压栈，而影响的是从栈中取值或赋值。</p></blockquote><p>那么对于可变参数列表，默认参数提升是如何体现的呢？待会讲解 <code>printf</code> 源码时再回过头来说这点。</p><h3 id="font-color-red-可变参数的类型检查-font"><font color='red'>可变参数的类型检查</font></h3><p>还是由于可变参数列表无法提供参数类型，所以编译器无法对参数进行类型检查，换句话说，<strong>编译器不能执行默认的类型转换，通常也不会报错</strong> 。对于普通函数而言，如果实参和形参类型不匹配，编译器会将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153040201.png" alt=""></p><p>而对于可变参数函数，编译器则无法将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153229945.png" alt=""><br>所以程序员必须自己确保参数类型的匹配或手动强制转换。</p><h3 id="font-color-red-可变参数函数实现原理-font"><font color='red'>可变参数函数实现原理</font></h3><p>想要实现可变参数，最重要的是明白其函数的调用方式，如果没有特定的<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>，可变参数将无从谈起。<strong><u>可变参数函数的调用方式必须满足以下两个条件：</u></strong></p><ol><li><p><strong><font color='orange'>从右向左压栈</font></strong></p><blockquote><p>为什么要从右往左入栈？ 因为如果从左向右，编译器就不知道用户传入了多少实参。参数的信息是由第一个参数 <code>fmt...</code> 确定的（如 <code>printf (“% s % s”,str1 ,str2)</code> 的参数信息是通过检测两个 <code>%s</code> 来获取的）。若从左向右压栈，<code>fmt...</code> 就被放入了栈底，而 esp 由于不清楚参数个数和类型，就无法跨过这些参数来指向 <code>fmt...</code> ，因此无法获取各个参数的信息。相反，若从右向左压栈，<code>fmt...</code> 就存放在栈顶，这样就可以直接通过它得知参数的个数和类型，进而准确从栈中取得各个参数。</p></blockquote></li><li><p><strong><font color='orange'>外平栈（调用者平栈）</font></strong></p><blockquote><p>必须由调用者平栈的原因是：只有调用者才知道压入了几个参数，所以也只能由调用者进行平栈。读者可能感到疑惑，为什么只有调用者才知道压入了几个参数？仍然拿 <code>printf</code> 举例，是这样的：<code>printf</code> 作为库函数，是提前被编译好了的（一般作为动态链接库），最后直接与我们自己编写生成的可重定位文件链接在一起，从而生成可执行文件；所以 <code>printf</code> 完全不知道实际压入了多少个参数（因为压参是由我们的编译器进行的）！因此也就无法由 <code>printf</code> 自己来完成平栈。相反，如果是调用方本身来调用的 <code>printf</code> ，理所应当地，调用方就知道自己向栈中压入了多少个参数，所以调用方就可以承担平栈任务，如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d  %c&quot;, 1, 2);</span><br><span class="line">&#125;</span><br><span class="line">//对应汇编：</span><br><span class="line">//......省略</span><br><span class="line">00BF17E1  push        2  </span><br><span class="line">00BF17E3  push        1  </span><br><span class="line">00BF17E5  push        offset string &quot;%d\n&quot; (0BF7BD8h)  </span><br><span class="line">00BF17EA  call        _printf  </span><br><span class="line">00BF17EF  add         esp,0Ch  </span><br><span class="line">//......省略</span><br></pre></td></tr></table></figure><p>call 之前，编译器 push 了三次，所以它当然知道平栈需要 add esp,0xC ！而 printf 是已经编好的库，它就不知道 push 了几次。</p></blockquote></li></ol><p>而 __cdel 调用约定就符合以上两个规则，所以可变参函数必须使用此方式。值得一提的是，__cdel 是 C/C++ 默认方式。<br>有了以上两种条件的支持，现在无非就是处理 <code>fmt...</code> 获取参数信息，然后从栈中取得参数即可。这就是咋们接下来要干的事。</p><h3 id="font-color-red-其他注意事项-font"><font color='red'>其他注意事项</font></h3><p><strong><mark class="hl-label blue">需要打印%咋办？</mark> </strong><br>这点相信大部分读者都清楚，打印百分号需要再加个百分号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是百分号%%&quot;</span>);</span><br></pre></td></tr></table></figure><p>很多小白会在 <code>%</code> 前加 <code>\</code> ，即 <code>printf(&quot;\%&quot;)</code> 来输出百分号。出现这种想法是因为没有理解转义字符的意义，要知道，<code>\n</code> 是一个 ASCII 码（10），由编译器负责将 <code>\n</code> 转为 10 。而 <code>\%</code> 可不是转义字符，对 <code>%</code> 的处理是由我们的代码负责，而不是由编译器负责！</p><p><strong><mark class="hl-label blue">printf实参问题</mark> </strong><br>很多读者应该都像下面这种方式调用过 printf 吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>这种方式有什么不对吗？结果正确，但这种调用方式十分危险。这是因为，<code>110</code> 没有指明类型，所以根据前面的默认参数提升，<code>110</code> 被视为 int，这符合 <code>%d</code> ，所以能够正确输出。但是碰到下面这种情况呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>结果就变得诡异，输出如下：<br><img src="/2022/img/image-20230110115919374.png" alt=""><br>这是因为 <code>110</code> 被编译器视为 int（4字节)，但 printf 内部代码根据 <code>%lld</code> 将 <code>110</code> 视为 long long（8字节)，在定位参数时，将 long long* 指针指向 <code>110</code> 所在的位置，那么用该指针解释数据的时候，将会把 <code>110</code> 后面的四字节包含进去，而这四字节中的数据是未定义的，所以造成以上错误。再来看下面的调用：<br><img src="/2022/img/image-20230110130458876.png" alt=""><br>怎么这种情况又能够正确显示呢？这是因为编译器判定 <code>0xfffffffff</code> 无法用 int 装下，所以该值的类型就变为了 long long，因此能够正确输出。正确的调用方式需要加上强制转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>看完 printf 源码后，你会对上述行为有深刻理解。</p><h3 id="font-color-red-printf源码剖析-font"><font color='red'>printf源码剖析</font></h3><blockquote><p><strong>说明：</strong></p><ul><li>以下源码来自 Linux 0.11 ，也就是 Linus Torvalds 编写的初代 Linux ，所以其功能肯定不如现在的 printf 强大，这点读者需要清楚。</li><li>printk（print kernel）和 printf 的功能完全相同，只不过前者是在内核中使用的打印函数，而后者是在用户态中使用的打印函数。</li><li>为了契合咋们的操作系统，笔者会将 printk 作轻微修改，使其能够在用户态下使用（此时也就变成了 printf ），这不会影响对 printf 的理解。</li></ul></blockquote><p>以下是原版的 <code>printk</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">va_start(args, fmt);</span><br><span class="line">i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">va_end(args);</span><br><span class="line">__asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $_buf\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;call _tty_write\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>提供原版的 printk 只是为了与下面咋们改进后的 printf 形成对比，大家无需纠结上面的代码</u>。以下是我们操作系统的 <code>printf</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> </span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="type">int</span> i = write(buf);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可见，除了第 9 行外，其他完全相同。实际上，第 9 行将最终的字符串传给我们之前实现的系统调用 write，由 write 进行打印。另外，<strong><font color='orange'>正因为 write 是系统调用，所以该 printf 既可以供内核使用，也可以供用户使用</font></strong> 。</li><li><code>printf</code> 返回字符个数。</li></ul><p>接下来重点说明处理可变参数的四个宏： <code>va_list</code> 、<code>va_start</code> 、<code>va_end</code> 和 <code>va_arg</code> 。</p><p><strong><mark class="hl-label blue">可变参数宏</mark> </strong><br>首先要破除大家的先入为主，别以为这四个宏是用来处理可变参数的，就觉得它们高大上，有什么特异功能，实际上这四个家伙的本质就普普通通：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(p, fmt) (p = (char*)&amp;fmt + sizeof(char*))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(p)        (p = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(p, type)  (p += __va_rounded_size(type), *((type*)(p - __va_rounded_size (type))))</span></span><br></pre></td></tr></table></figure><ul><li><p><em><em><code>va_list</code> <u>就是 char</em> 指针类型，该指针（args）用来在栈中依次遍历各个参数</u></em>* 。</p></li><li><p><strong><code>va_start</code> <u>的作用是将 args 指针指向参数列表（即 <code>...</code> ）中的第一个参数</u></strong> 。</p><blockquote><p><code>p = (char*)&amp;fmt + sizeof(char*)</code> 就是令 p 跳过栈中的 fmt ，指向栈中的下一个参数，即参数列表中的第一个参数。注意必须对 fmt 取地址，得到该指针的地址，也就是该指针在栈中的位置，<code>&amp;fmt</code> 为二级指针，还需要强制转换为一级指针 char* 。</p></blockquote></li><li><p><strong><code>va_end</code> <u>的作用是将 args 指针置 NULL</u></strong> 。</p></li><li><p><code>va_arg</code> 出现在下面的 <code>vsprintf</code> 函数中，<strong><u><code>va_arg</code> 的作用是返回当前 args 指向的参数的值，然后 args 向后移动，指向下一个参数</u></strong> 。</p><blockquote><p><code>__va_rounded_size(type)</code> 也是一个宏，<strong><u>用来得到取整后的 type 类型的大小，是 int 的整数倍</u></strong> ，比如 type 为 char，则返回 4；type 为 long long，则返回 8 ，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __va_rounded_size(type)  \</span></span><br><span class="line"><span class="meta">  (((sizeof (type) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span></span><br></pre></td></tr></table></figure><p>注意，va_arg 宏定义是一个逗号表达式，第一个表达式<u>根据目前所指参数 A 的大小</u>，将指针 p 移向了下一个参数 B（+=，p的值已经被改变）；接着将 A 的值返回（逗号表达式中的最后一个式子作为返回值）。顺便提一下，如果按照《操作系统真相还原》中的代码，将无法应对 long long 的情况。</p></blockquote></li></ul><p>接着来看 vsprintf 。</p><p><strong><mark class="hl-label blue">vsprintf</mark> </strong><br><strong>vsprintf 的作用是格式化字符串，也就是将参数列表中的所有参数值填入到 fmt 中的对应位置，并将最终的字符串存入 buf</strong> 。<code>fmt</code> 中的格式符，如 <code>%d</code> 、<code>%s</code> 等都在此函数中进行处理。在讲解该函数代码前，有必要先复习 printf 的用法，否则看代码时将一头雾水。</p><p>我们将 <code>%s</code> 这样的格式称之为一个 format 标签，format 标签的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure><p>比如下面这样的 printf 调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10ld&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中的 <code>-</code> 为 flags，即指明左对齐；<code>10</code> 为 width，即指明输出宽度；<code>l</code> 为长度，对于 <code>d</code> 而言，即输出长整型 long；<code>d</code> 为 specifier，指明输出整型。<br>具体规则如下：</p><table><thead><tr><th><strong>flags</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>-</strong></td><td>在给定的字段宽度内左对齐，默认是右对齐</td></tr><tr><td><strong>+</strong></td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td><strong>空格</strong></td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td><strong>#</strong></td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。由于本操作系统暂不支持小数，所以不说明 # 对 f、e、g 等说明符的影响。</td></tr><tr><td><strong>0</strong></td><td>在左边填充零，而不是空格</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>width</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>number</strong></td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充；如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定宽度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>.number</strong></td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 <br />对于 s：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 <br />对于 c：没有任何影响。 当未指定任何精度时，默认为 1。</td></tr><tr><td style="text-align:left"><strong>.</strong>*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定精度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>length</strong></th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>h</strong></td><td style="text-align:left">参数被解释为短整型或无符号短整型 short（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left"><strong>l</strong></td><td style="text-align:left">参数被解释为长整型或无符号长整型 long，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left"><strong>L</strong></td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。本操作系统不支持。</td></tr><tr><td style="text-align:left"><strong>ll</strong></td><td style="text-align:left">本操作系统中，ll 仅被解释为 <strong>无符号 long long</strong>，适用于整数说明符。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">和 d 完全相同</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">到目前为止成功写入缓冲区的字符数，此值存储在指定的整数中，其地址作为参数给出。</td></tr></tbody></table><p>下面做几个示范：<br><img src="/2022/img/image-20230109092042387.png" alt=""><br><img src="/2022/img/image-20230109092442698.png" alt=""><br><img src="/2022/img/image-20230109094520482.png" alt="由于安全原因，VS默认禁止使用%n，所以此处用 Bochs 代替"></p><p>了解以上格式后，再来看 vsprintf 就十分轻松啦，总的来说，该函数就是在依次处理 flags --&gt; width --&gt; .precision --&gt; length --&gt; specifier 。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成2的倍数,是因为我们将flag变量视为位图,将属性保存到各个二进制位上</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">int</span> flags;          <span class="comment">// flags to number() </span></span><br><span class="line"><span class="type">int</span> field_width;    <span class="comment">// width of output field </span></span><br><span class="line"><span class="type">int</span> precision;      <span class="comment">// min of digits for integers; max number of chars for from string </span></span><br><span class="line"><span class="type">int</span> qualifier;      <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (str=buf ; *fmt ; ++fmt) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//如果不是format标签,则直接复制到str</span></span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//处理flags</span></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">repeat:</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理输出宽度</span></span><br><span class="line">field_width = <span class="number">-1</span>; <span class="comment">//默认为-1,即未指示宽度,因为 flag | -1 = flag</span></span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">field_width = skip_atoi(&amp;fmt); <span class="comment">//skip_atoi将字符转为数字,后文给出</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则width由下一个参数给出 </span></span><br><span class="line"><span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)  <span class="comment">//若宽度参数小于0,则左靠齐,和&#x27;-&#x27;号效果相同</span></span><br><span class="line">&#123;</span><br><span class="line">field_width = -field_width;</span><br><span class="line">flags |= LEFT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理精度</span></span><br><span class="line">precision = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">precision = skip_atoi(&amp;fmt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">precision = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则precision由下一个参数给出 </span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理长度描述符符</span></span><br><span class="line">qualifier = <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">qualifier = *fmt;  <span class="comment">//实际上,后面就没有用到qualifier了,显得鸡肋</span></span><br><span class="line">++fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理格式字符</span></span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT)) <span class="comment">//如果不是左靠齐,则左边补field_width-1个空格</span></span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">*str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) <span class="comment">//否则后方补空格</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) <span class="comment">//如果字符串长度大于精度,则丢弃超过精度的部分</span></span><br><span class="line">len = precision;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">*str++ = *s++;</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)<span class="comment">//如果执行了上面的while,此处就不会再执行</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:  <span class="comment">//number函数用来将数字转换为字符串</span></span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="comment">//按十六进制输出指针,宽度为8,宽度不足则补前导0</span></span><br><span class="line"><span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">field_width = <span class="number">8</span>;</span><br><span class="line">flags |= ZEROPAD;</span><br><span class="line">&#125;</span><br><span class="line">str = number(str,(<span class="type">unsigned</span> <span class="type">int</span>)va_arg(args,<span class="type">void</span>*), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">flags |= SMALL;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">flags |= SIGN;  <span class="comment">//%d和%i都是有符号数</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">*ip = (str - buf); <span class="comment">//返回目前字符串的宽度</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若格式转换符不是&#x27;%,则表示格式字符串有错,直接将一个%写入输出串中;如果格式转换符的位置处还有字符,则也直接将该字符写入输</span></span><br><span class="line">        <span class="comment">//出串中,并返回到107行继续处理格式字符串;否则表示已经处理到格式字符串的结尾处,则退出循环。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt)</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">--fmt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释得比较清楚，对照之前的规则来看代码就很容易理清其中的逻辑，不再详细说明。提一点，看第 90 行，<code>va_arg(args, int)</code> ，这说明从栈中取字符时，是以 int 大小来取的（ <strong><u><font color='orange'>这里就体现了默认参数提升</font></u></strong> ），然后再被强制转换为 char 。为什么不能 <code>va_arg(args,char)</code> 呢？实际上这样完全能够准确获取栈中字符的值，但如果这样的话，下一次使用 va_arg 宏取参数时，args 指针就指向了该字符的下一字节，但下一个参数应该是在该字符的四字节后，这无疑将引发错误，图示如下：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE35.png" alt=""></p><p>代码中还用到了 skip_atoi() 和 number() 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//判断是否为数字字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \    <span class="comment">// n=n/base,并返回n%base</span></span></span><br><span class="line"><span class="type">int</span> __res; \                   <span class="comment">//宏定义采用大括号的方式,最后一条语句作为返回值</span></span><br><span class="line">__asm__(<span class="string">&quot;div %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (n),<span class="string">&quot;=d&quot;</span> (__res):<span class="string">&quot;0&quot;</span> (n),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),<span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">__res; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span><span class="comment">//pointer to fmt,即fmt的指针,所以该指针为二级指针</span></span><br><span class="line">&#123;                                      <span class="comment">//为什么要用二级指针?因为咋们要在函数中修改fmt的值(不仅是修改形参,实参也要修改)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;                           <span class="comment">//由于fmt是指针,所以要修改指针的值,就需要用二级指针</span></span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//(*fmtp)++,就是fmt++</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SMALL) </span><br><span class="line">digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;LEFT) </span><br><span class="line">type &amp;= ~ZEROPAD; <span class="comment">//如果为左对齐,则无需0填充</span></span><br><span class="line"><span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>) <span class="comment">//仅支持2~36进制,否则返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">num = -num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);<span class="comment">//要么+,要么空1格</span></span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">size--; <span class="comment">//如果有符号或空格,则占一位</span></span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">size -= <span class="number">2</span>; <span class="comment">//0x占两位</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">size--;    <span class="comment">//0占一位</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 以下开始处理数字</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">tmp[i++]=digits[ do_div(num,base) ]; <span class="comment">//依次取得num的最低位数字,并填入tmp,</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;precision)                     <span class="comment">//此时顺序是反的,第72行会调整顺序</span></span><br><span class="line">precision=i; <span class="comment">//如果数字个数大于精度,不会截断,精度成鸡肋</span></span><br><span class="line">size -= precision;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">*str++ = sign;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">&#123;</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">*str++ = digits[<span class="number">33</span>]; <span class="comment">//&#x27;X&#x27;或&#x27;x&#x27;,取决于digit的指向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>) <span class="comment">//如果是右靠齐,则补前导0或前导空格</span></span><br><span class="line">*str++ = c;</span><br><span class="line"><span class="keyword">while</span>(i&lt;precision--)<span class="comment">//精度大于数字个数,则补前导0</span></span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = tmp[i];<span class="comment">//i--,str++,调整数字顺序</span></span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果67行已经执行,此处就不会再执行</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释详尽，不再说明。<br>值得一提的是，该版 printf 有许多不足，例如不支持 <code>%hd</code> (short)，<code>%lld</code> (long long) ，下节<a href="https://jyx-fyh.github.io/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/">printf加强版</a>中我们会增加这两个功能。<br><img src="/2022/img/image-20230110134655302.png" alt=""></p><p>本文结束。</p>]]></content>
    
    
    <summary type="html">printf, 底层, 剖析, Linux, 可变参数</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="C语言, 自制操作系统" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80-%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实现用户进程-代码详解</title>
    <link href="http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jyxcpp.netlify.app/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-01-06T09:17:36.000Z</published>
    <updated>2023-03-12T11:21:04.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程-进入用户态</a><br>本节对应分支：<code>userprog</code></p></blockquote><h3 id="font-color-red-初始化TSS、C语言接管GDT-font"><font color='red'>初始化TSS、C语言接管GDT</font></h3><p>下面是 <code>global.h</code> 中添加的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="comment">//=============用户进程的段选择子================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_CODE   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span></span><br><span class="line"><span class="comment">// ===============GDT描述符属性=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_G_4K    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_D_32    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_L     0<span class="comment">// 64位代码标记，此处标记为0便可。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_AVL     0<span class="comment">// cpu不用此位，暂置为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_P     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_1   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_2   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_3   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_CODE1       <span class="comment">// s为1时表示存储段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_DATADESC_S_CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_SYS0       <span class="comment">// s为0时表示系统段.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_CODE8<span class="comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_DATA  2<span class="comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_TSS   9<span class="comment">// B位为0,不忙</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ATTR_HIGH     ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_CODE_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_DATA_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span></span><br><span class="line"><span class="comment">//================ TSS描述符属性===================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_DESC_D  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_LOW ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_TSS ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2 ) + RPL0)</span></span><br><span class="line"><span class="comment">//================ GDT描述符 =====================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit_low_word;</span><br><span class="line">    <span class="type">uint16_t</span> base_low_word;</span><br><span class="line">    <span class="type">uint8_t</span>  base_mid_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  attr_low_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  limit_high_attr_high;</span><br><span class="line">    <span class="type">uint8_t</span>  base_high_byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第 3~5 行定义了用户进程的段选择子，其中代码段选择子索引为 5，即用户代码段的描述符位于 GDT 的第 5 号描述符的位置处；数据段和栈段共享一个描述符，选择子索引为 6 。你可能会疑惑，为什么只定义了一套用户的选择子，万一将来有多个用户进程同时运行，这几个选择子岂不是不够用？实际上只需要一套用户选择子就可以了，<strong><font color='orange'>因为所有用户进程都共享这一套选择子</font></strong> 。为什么可以共享呢？这便体现出虚拟空间下平坦模型的优越性了。<strong><font color='orange'><u>因为每个进程都有自己独立的虚拟地址空间，平坦模型下数据段和代码段描述符的基址直接设为 0，所以执行流只取决于 EIP 而依赖 CS。反观分段模型，由于没有虚拟地址空间，各个用户进程被分配到不同区域的物理内存中，所以为了隔离它们，每个用户进程的段基址都不相同，因此需要为每个用户进程都分配一套段选择子和段描述符</u></font></strong> ，不仅管理繁琐，而且效率低下。<br>另外，当初咋们在 <code>loader.s</code> 中设计 GDT 表时，并没有为用户和 TSS 预留段描述符，所以现在必须在 <code>loader.s</code> 中加上一行代码以预留空间：<br><img src="/2022/img/image-20230103153548106.png" style="zoom:100%;" /></li><li>之前是在 <code>loader.s</code> 中直接书写 GDT ，为了方便，现在我们使用 C 语言接管 GDT，以方便在 GDT 中添加和修改段描述符。所以在头文件中定义了段描述符和 TSS 描述符的各个属性以及段描述符的结构体 <code>gdt_struct</code> 。关于各个位的解释，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">GDT</a> 。</li></ul><p>下面是 <code>tss.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">gdt_operand</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> tss_slt;</span><br><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> backlink;</span><br><span class="line">    <span class="type">uint32_t</span>* esp0;</span><br><span class="line">    <span class="type">uint32_t</span> ss0;</span><br><span class="line">    <span class="type">uint32_t</span>* esp1;</span><br><span class="line">    <span class="type">uint32_t</span> ss1;</span><br><span class="line">    <span class="type">uint32_t</span>* esp2;</span><br><span class="line">    <span class="type">uint32_t</span> ss2;</span><br><span class="line">    <span class="type">uint32_t</span> cr3;</span><br><span class="line">    <span class="type">uint32_t</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> ldt;</span><br><span class="line">    <span class="type">uint32_t</span> trace;</span><br><span class="line">    <span class="type">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新tss中esp0字段的值为pthread的0级线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tss_esp</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    tss.esp0 = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建gdt描述符 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gdt_desc <span class="title function_">make_gdt_desc</span><span class="params">(<span class="type">uint32_t</span>* desc_addr, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> attr_low, <span class="type">uint8_t</span> attr_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> desc_base = (<span class="type">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="type">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="type">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在gdt中创建tss并重新加载gdt */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tss_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"><span class="comment">/* gdt基址为0x910,把tss放到第4个位置,也就是0x910+0x20的位置 */</span></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">   *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000930</span>)  = make_gdt_desc((<span class="type">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000940</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    load_xdt(&amp;gdt_operand,<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>,<span class="number">0xc0000910</span>);</span><br><span class="line">    tss_slt = SELECTOR_TSS;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lgdt gdt_operand&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ltr tss_slt&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init and ltr done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4~33 行定义了 TSS 结构，这没有太多要说的，有个小问题是，结构体定义不应该放在头文件中吗，这里为什么要放在 C 文件中呢？是不是不太规范？这也是笔者之前的误解，原以为只要是宏定义或者结构体定义一类的都应该放在头文件，而 C 文件中只放函数定义，这样才显得规范。实际上并不是如此，原则应该是：<strong><font color='orange'>如果其可见性超出一个 .c 文件，那么应当放入 .h 中，如果只是某一个 .c 里需要这么一个结构作为辅助，直接放入这个.c中更好一些</font></strong> 。放在 .c 还是 .h 取决于该结构是否要暴露给其他 .c，能放 .c 绝不放 .h 。而 TSS 结构只会在此文件中使用，所以就定义在此 .c 文件中。</li><li>第 37 行，update_tss_esp() 用来将 TSS 中 esp0 字段的值更新为 pthread 的内核线。如上节内容所说，所有任务共享一个 TSS，只是在任务切换时更新 ESP0 的值。</li><li>第 61 行，将 TSS 的 io_base 字段设置为 TSS 的大小，这表示此 TSS 中没有 IO 位图。</li><li>第 62 行，GDT 的基址为 0x910，这是如何确定的？见下面 <code>loader.s</code> 的片段即可知道。<br><img src="/2022/img/image-20230105121240944.png" style="zoom:67%;" /></li><li>第 69 行的 load_xdt 函数，咋们之前用它设置过 IDTR，定义在 global.h 中。gdt_operand 是加载 GDT 时用的操作数，设置好 gdt_operand 的基址和界限后，第 71 行便使用内联汇编 <code>lgdt</code> 指令加载 GDTR。至于为什么要将 gdt_operand 和 tss_slt 定义为全局静态变量，这在之前的文章中反复提及过，不再赘述。同理，第 72 行使用 <code>ltr</code> 指令将 TSS 的选择子 tss_slt 加载进 TR 寄存器，由于 TSS 只有一个，所以只会加载这一次，以后就不会再修改 TR 了。</li></ul><h3 id="font-color-red-用户进程的虚拟地址空间-font"><font color='red'>用户进程的虚拟地址空间</font></h3><p>在<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础篇</a>中，我们划出了三个内存池：内核物理内存池、内核虚拟内存池、用户物理内存池。为了实现用户进程的虚拟地址空间，我们还需要给每个进程设置私有的用户虚拟内存池。见以下步骤。</p><p><strong><mark class="hl-label blue">在task_struct中添加虚拟内存池</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       <span class="comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> <span class="comment">// general_tag的作用是用于线程在一般队列中的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span><span class="comment">// all_list_tag的作用是用于线程队列thread_all_list中的结点</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              <span class="comment">// 进程页表</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span>   <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 14 行即为用户进程的虚拟内存池。</p><p><strong><mark class="hl-label blue">用户虚拟内存管理</mark> </strong><br>在 <a href="">内存管理-进阶</a>中，我们留下了部分内容等到实现用户进程时补充，如下：<br><img src="/2022/img/image-20230105154723658.png" style="zoom:67%;" /><br>第 33 行的作用和其上内核部分的代码相似，都是在申请虚拟内存。以下代码补齐这部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct* cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">        <span class="comment">/*0xc0000000-PAGE_SIZE作为3级用户栈已经在start_process中被分配*/</span></span><br><span class="line">        assert((<span class="type">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>逻辑清晰，不再解释。另外还添加了几个必要的内存管理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_user_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="type">void</span>* vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将地址vaddr与pf池中的物理地址关联,仅支持一页空间分配 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_a_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="type">int32_t</span> bit_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;pgdir != <span class="literal">NULL</span> &amp;&amp; pf == PF_USER)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;pgdir == <span class="literal">NULL</span> &amp;&amp; pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span></span><br><span class="line">        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        panic(<span class="string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">    <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">    lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址映射到的物理地址 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">addr_v2p</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"><span class="comment">/* (*pte)的值是页表所在的物理页框地址,</span></span><br><span class="line"><span class="comment"> * 去掉其低12位的页表项属性+虚拟地址vaddr的低12位 */</span></span><br><span class="line">    <span class="keyword">return</span> ((*pte &amp; <span class="number">0xfffff000</span>) + (vaddr &amp; <span class="number">0x00000fff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>get_user_pages 和 get_kernel_page 的逻辑完全相同，不再赘述。提一下，笔者在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶</a>中提到过如下内容：</p><blockquote><p>扫描和设置位图必须连续，中间不能切换线程 。这里和线程切换有关，简单解释：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题 。因此扫描和设置位图必须保证原子操作。需要注意的是，此处代码并没有保证原子性，未来我们会用锁来实现 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></blockquote><p>现在咋们已经实现了锁机制，所以这里申请内存时用锁来保证原子性。锁加在 pool 结构体中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span>                      //管理物理内存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 本内存池字节容量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>            <span class="comment">// 保证内存申请时的原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第 13 行定义 get_a_page 函数，该函数与 get_kernel_page 或 get_user_page 的差别在于前者能够申请指定位置的虚拟内存，而后者则无法指定位置。该函数待会用来指定在 0xc0000000 处申请一页虚拟内存作用户栈。</p></li><li><p>addr_v2p 函数，其中 2 和 to 同音，即 addr_v_to_p，功能是将虚拟地址 vaddr 转换为对应的物理地址。下面咋们马上就会用到此函数。</p></li></ul><p><strong><mark class="hl-label blue">创建用户进程</mark> </strong><br>这部分内容很多，打起精神啦！</p><p>在中断栈中构建用户进程的上下文时，需要设置 eflags 寄存器，所以在 global 中定义好 eflags 的属性位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:global.h</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_MBS(1 &lt;&lt; 1)        <span class="comment">// 该位保留,总是为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_1(1 &lt;&lt; 9)        <span class="comment">// if为1,开中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_00               <span class="comment">// if为0,关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_3(3 &lt;&lt; 12)   <span class="comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_0(0 &lt;&lt; 12)   <span class="comment">// IOPL0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_ROUND_UP(X, STEP) ((X + STEP - 1) / (STEP)) <span class="comment">//用于除法的向上取整,如2/3=1</span></span></span><br></pre></td></tr></table></figure><p>下面则开始创建用户进程，<strong><font color='orange'>注意上节中的进程创建流程图对比</font></strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:process.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">proc_stack</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pagedir_phy_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">intr_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_process</span><span class="params">(<span class="type">void</span>* filename_)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* function = filename_;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);   <span class="comment">//跨过thread_stack,指向intr_stack</span></span><br><span class="line">    proc_stack = (<span class="keyword">struct</span> intr_stack*)cur-&gt;self_kstack; <span class="comment">//可以不用定义成结构体指针</span></span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>;          <span class="comment">// 不允许用户态直接访问显存资源,用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function; <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="type">void</span>*)((<span class="type">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,proc_stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;jmp intr_exit&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 击活页表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_dir_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">     * 执行此函数时,当前任务可能是线程。</span></span><br><span class="line"><span class="comment">     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,</span></span><br><span class="line"><span class="comment">     * 否则不恢复页表的话,线程就会使用进程的页表了。</span></span><br><span class="line"><span class="comment">     ********************************************************/</span></span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    pagedir_phy_addr = <span class="number">0x100000</span>;  <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)  <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov eax,pagedir_phy_addr&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov cr3,eax&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 激活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0特权级,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0*/</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建页目录表,将当前页表的表示内核空间的pde复制,</span></span><br><span class="line"><span class="comment"> * 成功则返回页目录的虚拟地址,否则返回-1 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">create_page_dir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页目录表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">&quot;create_page_dir: get_kernel_page failed!&quot;</span>,FT_RED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span>*<span class="number">4</span>), (<span class="type">uint32_t</span>*)(<span class="number">0xfffff000</span>+<span class="number">0x300</span>*<span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_user_vaddr_bitmap</span><span class="params">(<span class="keyword">struct</span> task_struct* user_prog)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_execute</span><span class="params">(<span class="type">void</span>* filename, <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 **/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, DEFUALT_PRIO);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);<span class="comment">//start_process(filename)</span></span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>start_process 中，proc_stack 结构体指向中断栈，并初始化进程上下文。</p></li><li><p>第 9 行，需要说明的是，用户进程一般是硬盘中的一段程序，需要加载到内存，然后再运行，所以进程的定义就是“运行中的程序”。<strong>但目前我们还没有实现硬盘驱动程序和文件系统，所以用户进程只能由一个函数代替</strong> ，实际上，这两者也没有本质区别。</p></li><li><p>第 15 行，由于 <strong><font color='orange'>用户不能直接使用显存</font></strong>，所以将 gs 直接初始化为 0，则用户使用该选择子时，会索引到 GDT 的第 0 号描述符而引发异常。</p></li><li><p>第 20 行，调用 get_a_page() 在指定位置，即用户空间 3GB 顶端处申请一页内存用来作用户栈，这在之前有所提及。</p><blockquote><p>用户栈只有一页吗？笔者暂不清楚当栈使用超过一页会发生什么，后续补充。</p></blockquote></li><li><p>第 23 行，intr_exit 是从 <code>interrupt.s</code> 引入的函数，专门处理中断返回。这没有什么好说的，只是为了复用代码，也可以直接在 23 行处使用内联汇编连续弹栈并 <code>iret</code> 。<code>iret</code> 后执行流就转移到用户进程啦！</p></li><li><p>第 27 行，page_dir_active，页表激活函数。从流程图中可以看见，该函数在 schedule() 中被调用，如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.c</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    process_activate(next);</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong><u>每当任务切换(swtich_to)前，都会重新激活页表</u></strong> ，这不禁引发我们的疑惑：不是进程才有独立的地址空间吗？怎么连线程都要激活页表了呢？其实这可以在上节<a href="">进程的实现方式</a>找到答案。在 Linux 中，<strong><u>多个地址空间相同的线程组成了一个进程</u></strong> ，所以线程也需要记录页表。需要注意的是，<strong><font color='gree'>目前我们只实现了内核线程(thread_start) 和用户进程 (process_execute)，还未实现用户线程</font></strong>  (未来看情况按需添加)，所以 task_struct 中的 pgdir 只分为两种情况：NULL 和其他值；如果为 NULL，则说明该任务为内核线程；如果为非 NULL，则说明该任务为用户进程。<br>另外，<strong>第 40 行加载 cr3 有大坑！</strong> 还记得吗，在<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>一文中，笔者将内核的起始虚拟地址设置为了 0x1500，并提醒读者未来这个 0x1500 会留下问题。这个问题就在此处浮现：首次切换页表之前，执行流一直位于内核进程中，而内核进程虚拟空间的低 1MB 和高 3GB 处都是内核（这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中早有说明，忘记的读者请回头复习）。又因为之前将内核的起始虚拟地址设置为了 0x1500，所以一直以来内核始终运行在低端 1MB 处，而非高 3GB 处。关键来了，当内核执行流运行到第 40 行切换页表时，切换前执行流位于 1MB 下，切换后当然也仍位于 1MB 下（因为代码中的地址都是提前编译好的），但是，切换到用户进程的页表后，低端 1MB 就不再是内核啦（对于用户进程而言，内核只位于高 3GB 处）之前说过，用户进程的低端 128MB 为保留，没有任何东西，所以执行流运行在用户进程虚拟空间的低端 1MB 下将必定出错！因此，为了保证切换页表前后执行流能够统一，我们必须将内核的起始虚拟地址设置为 0xc0001500，这样对于内核进程和用户进程来说，内核都运行在高 3GB 上，切换页表前后执行流就不会改变。修改如下：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><blockquote><p>这里也是卡了笔者很久，如果当初不作死修改 Ttext，也不会引发这些问题，但实际上，不就是这些找 Bug 的过程加深了我们对程序的理解吗？</p></blockquote></li><li><p>第 51 行，只有用户进程才会更新 TSS 中的 ESP0，因为从内核进入中断不涉及特权级转移，从用户进程进入中断才会切换到对应的内核栈。</p></li><li><p>第 58 行是笔者期待已久的页表创建函数 create_page_dir()，该函数为用户进程创建对应的页目录表，其任务很简单：1）<strong>申请一页内存用来存放页目录表 <strong>；2）</strong><u>将内核页目录的第 768~1022 项复制到用户页目录表的相同位置，从而实现所有用户进程共享内核</u></strong> （这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中重点提到过）；3）将用户进程页目录表的物理地址写入第 1023 号页目录项，这是为了访问页目录表和页表本身，详细原因仍请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。注意，<strong><u>用户进程的页目录表和页表不能安装在用户空间中，而是安装在内核空间里</u></strong> ，否则用户就可能自己修改页表，映射任意的内存地址，访问任何内存，进程间、内核的隔离保护就失去了意义。</p><blockquote><p>另外，不知道读者是否和我一样有这样的疑惑：为什么没有为用户程序本身开辟页表？也就是说，现在只映射了 3~4GB 的内核，而没有映射 0~3GB 的用户空间，那用户程序本身运行在哪？笔者从两个方面来解释此问题：<br>1）由于现在还没有完成硬盘驱动和文件系统，所以只能使用函数（如下面的u_prog_a、u_prog_b）来代替用户程序。而这些函数也是同样定义在 main.c 中，所以它们都会被链接进 kernel.bin，然后载入内核。换句话说，这些函数虽然是用户进程，但也位于 3~4GB 空间中（即使位于内核空间，特权级仍然为 3）。<strong>这只是目前为了演示用户进程而作的妥协</strong> 。<br><img src="/2022/img/image-20230106150001512.png" style="zoom:67%;" /></p><p>2）真正的用户进程加载是从硬盘读取程序并载入内存，进而运行，大致流程是这样的：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  &gt; graph LR&gt; A{创建独立的虚拟空间}--&gt;B{读取可执行文件头}--&gt;C{建立虚拟空间和可执行文件的映射关系}--&gt;D{将EIP设置为可执行文件的入口地址，开始运行}&gt;   </pre></div><p>啊啥？这不是还没将程序加载进内存吗？怎么就开始运行啦？是这样的，比如入口地址为 <code>0x08048000</code> ，<strong><font color='orange'>当执行流运行到该地址时，发现页面 <code>0x08048000~0x08049000</code> 是空页面，于是陷入缺页异常，异常处理程序通过第三步建立的映射关系找到可执行文件中缺失页面对应的部分代码，然后再将该部分载入内存，最后重新运行</font></strong> 。相关详细内容可参考《链接、装载与库》。<br>综上两点考虑，当前无需建立其他部分的映射。</p></blockquote></li><li><p>第 78 行，create_user_vaddr_bitmap() 函数用来为用户进程创建虚拟内存池，以便管理内存空间。其中 USER_VADDR_START 的值即为 <code>0x08048000</code> 。该函数逻辑清晰，不做说明。</p></li><li><p>第 88 行便是 process_execute() 函数。需要说明的是，该函数是在内核中被调用来创建用户进程的，而 fork 函数则是在用户程序中来创建子进程的，两者有巨大区别，将来实现 fork 时还会提到这一点。</p></li></ul><p>大功告成，了解了具体实现后，再来回顾进程创建的整个过程，思路也许会变得更清晰：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><h3 id="font-color-red-运行用户进程-font"><font color='red'>运行用户进程</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> test_var_a = <span class="number">0</span>, test_var_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;argA &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_b&quot;</span>, <span class="number">31</span>, k_thread_b, <span class="string">&quot;argB &quot;</span>);</span><br><span class="line">    process_execute(u_prog_a, <span class="string">&quot;user_prog_a&quot;</span>);</span><br><span class="line">    process_execute(u_prog_b, <span class="string">&quot;user_prog_b&quot;</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_int(test_var_a,FT_RED,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        console_put_int(test_var_b,FT_YELLOW,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而运行结果不尽人意：<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br>可见，运行一段时间后任务就停止了切换。这个 Bug 目前还没有找到，只知道这是锁引起的问题，没办法，只能将锁改为开关中断了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:console.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//console_acquire();</span></span><br><span class="line">    CLI;</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    STI;</span><br><span class="line">    <span class="comment">//console_release();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>再次运行：</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro1.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>现在好多了。关于这个锁的问题，笔者调试了两天还是不知道原因，请知道原因的读者朋友们在评论区留言，感谢！<br>需要说明的是，print 和 console 系列打印函数只能在内核，即 ring0 下使用，在用户进程中调用则会引发 0xd 号异常：<br><img src="/2022/img/image-20230112092402708.png" alt=""><br>所以这里使用两个变量 test_var_b、test_var_a 来间接反映进程的调度情况。</p><p>最后留下一个问题：既然禁止用户直接访问内核，那为什么还要将用户代码段描述符的界限设置为 4GB 呢？这样用户不就能轻松访问高地址的内核了吗？就像下面这样直接在用户态访问显存：<br><img src="/2022/img/image-20230112155046604.png" alt=""><br>既然这样，为什么不将用户代码段的界限设置为 3GB 呢？留给读者思考，笔者将在后续文章给出答案。</p><p>本文结束，下节实现系统调用。</p>]]></content>
    
    
    <summary type="html">自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实现用户进程—进入用户态</title>
    <link href="http://jyxcpp.netlify.app/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>http://jyxcpp.netlify.app/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-12-26T01:08:59.000Z</published>
    <updated>2023-03-12T11:21:04.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>本文前置内容(必看)：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> ，<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a></strong> ，<a href="https://markrepo.github.io/kernel/2018/08/22/memory/">进程的虚拟内存布局</a>、《装载、链接与库》<br>本节对应代码讲解：<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程-代码详解</a></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong><font color='gree'>操作系统有三大核心功能：内存管理、进程管理、文件管理</font></strong> 。截至目前，我们已经完成了内存管理和进程管理的部分内容，对于内存管理，咋们还差内存回收机制；对于进程管理，由于线程是进程的基础，之前咋们实现了线程，所以进程也就完成了一半；文件管理将在不久后实现文件系统后再进行。</p><h3 id="font-color-red-任务切换的原生方式-font"><font color='red'>任务切换的原生方式</font></h3><p>在 <a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 一文中，我们简单了解过 TSS 与 LDT 的作用，明白了 TSS 和 LDT 只是理想中的任务管理和切换的工具： <strong><font color='orange'>Intel 建议用 TSS 来保存并恢复任务的状态，用 LDT 来保存任务的实体资源</font></strong> 。而考虑到效率问题，现代操作系统并未（完全）使用 TSS 和 LDT 来进行任务切换。至于为什么效率低下，看看其任务切换的具体过程便能体会到：<br>CPU <strong>原生支持</strong> 的任务切换方式有两种：1）中断 + 任务门；2）call / jmp + 任务门；下面分别介绍这两种方式。</p><p><strong><mark class="hl-label blue">中断+任务门</mark> </strong><br>既然是通过中断调用，那么调用方式只能通过中断信号或 int 指令进行，此时任务门也当然是在 IDT 中注册。<br><strong>调用过程如下：</strong></p><ol><li><p>时钟中断发生，处理器自动从该任务门描述符中取出新任务的 TSS 选择子。</p><blockquote><p>之前咋们的时钟中断的向量号对应的是中断门描述符，对应时钟中断处理程序（schedule），而现在我们要使用任务门来切换任务，所以时钟中断向量号就应该指向任务门描述符：<br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>这里笔者有个问题，时钟中断号为 0x20，如果 0x20 指向任务门描述符，那岂不是每次发生时钟中断时，都会切换到同一个任务？那还如何实现任务调度呢？由于我们的操作系统不会使用任务门来进行任务切换（Linux也不会)，所以这里就不深究了，直到答案的读者还请麻烦在评论区指点一二。</p></blockquote></li><li><p>用 TSS 选择子在 GDT 中索引 TSS 描述符。</p></li><li><p>判断该 TSS 描述符的 P 位是否为 1，为 0 则表示对应的 TSS 不在内存中，这将引发异常。</p></li><li><p>从 TR 寄存器中获取旧任务（当前任务）的 TSS 位置，将当前寄存器状态保存到该 TSS 中。</p></li><li><p>将新任务 TSS 中的值加载进相应寄存器。</p></li><li><p>将新任务的 TSS 段选择子加载进 TR 寄存器，这由 CPU 自动完成。</p></li><li><p>将当前任务的 B 位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 。</p></li><li><p>将新任务标志寄存器的 NT  位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>将旧任务的 TSS 选择子写入到新任务 TSS 的 <code>上一个任务的TSS指针</code> 字段中。</p></li><li><p>开始执行新任务。</p></li></ol><p><strong>返回过程如下：</strong></p><ol><li>调用 <code>iret</code> ，检查 NT 位，如果为 1，则应该返回旧任务而非中断返回。</li><li>将当前任务的 NT 位置 0 。</li><li>将当前任务的 TSS 描述符中的 B 位置 0 。</li><li>将寄存器现场保存到当前 TSS 中。</li><li>获取当前 TSS 中 <code>上一任务的TSS指针</code> 字段，将选择子加载进 TR 。</li><li>根据 TR 指向的 TSS 恢复寄存器现场。</li></ol><p><strong><mark class="hl-label blue">call、jmp切换任务</mark> </strong><br>任务门除了可以在 IDT 中注册，还能在 GDT 和 LDT 中注册，当在后两者中注册时，就可以通过 call、jmp 指令来切换任务。call 和 jmp 有所不同，前者有去有回，<strong>所以通过 call 调用的新任务可以认为是旧任务的分支，本质上它们算是同一个任务</strong> ；而 jmp 则是有去无回，新旧任务之间没有关系。<strong><font color='orange'>此二者的区别体现在是否将旧任务的 B 位置 0</font></strong> ，先以指令 <code>call 0x0018:0x1234</code> 来看 call 的任务调用过程：</p><ol><li><code>0x0018</code> 表示在 GDT 中索引第 3 号描述符，即任务门描述符。不同于普通段描述符，任务门描述符中记录的是 TSS 选择子，所以处理器自动忽略 <code>0x1234</code> 。</li><li>检查 P 位，为 0 则表示该描述符不在内存中，抛出异常。</li><li>检测 S 和 TYPE 位，判断描述符类型，如果是任务门描述符，则检查 B 位，若为 1 则抛出异常。</li><li>特权级检查，数值上 CPL 和 TSS 选择子中的 RPL 都要小于或等于 TSS 描述符的 DPL，关于特权级检查与 RPL、CPL、DPL 的区别，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a> 。</li><li>将当前任务的现场保存到 TR 寄存器所指向的 TSS 中。</li><li>将新任务的 TSS 选择子加载到 TR 寄存器中。</li><li>将新任务 TSS 中的寄存器载入到相应寄存器中，并进行特权级检查。</li><li>将新任务的 NT 位置 1，表示为任务嵌套，以便 iret 时从新任务返回到旧任务，而非从中断返回。</li><li>将旧任务的 TSS 选择子写入到新任务 TSS 中 <code>上一任务的TSS指针</code> 字段中，以便能够返回。</li><li>将新任务的 B 位置 1 以表示当前任务忙，<strong><u>但旧任务的 B 位仍然为 1，不会置零</u></strong> ；</li><li>切换完成，新任务开始。</li></ol><p>任务返回则同上文中断调用相同。</p><p>jmp 的任务调度过程和 call 几乎相同，只是第 10 步 B 位置零有所不同：<strong><u>由于 jmp 有去无回，所以新旧任务不构成链式关系，因此会将旧任务的 B 位置 0</u></strong> 。<br>从以上过程便能看出，CPU 原生的任务调度方式很是繁杂，这降低了任务切换的效率和灵活性，因此现代操作系统都没有采用这种方式。</p><h3 id="font-color-red-任务切换的现代方式-font"><font color='red'>任务切换的现代方式</font></h3><p>虽然咋们没有用 Intel 建议的方式来进行任务调度，但这也不是说 TSS 就一无是处了（LDT 是真的完全成孤儿了），Linux 在以下两个地方还是会用到 TSS：</p><ul><li><p><strong><font color='gree'>I/O 特权级控制</font></strong><br>我们一直认为用户进程无法直接访问硬件，必须通过操作系统才行；但是，为了在某些场景下快速反应，TSS 中的 I/O 位图为用户程序直接控制硬件提供了途径。</p><blockquote><p>提示：我们的操作系统并不会使用 IO 位图。</p></blockquote></li><li><p><strong><font color='gree'>将进程的内核栈记录在 TSS 中的 SS0 和 ESP0 位置处</font></strong><br>我们通过时钟中断来进行任务调度，在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>一文中提到，<strong><u><font color='orange'>当发生中断并引用中断门描述符时，会检查是否发生特权级转移，如果特权级改变，则会自动转移到新栈，这个新栈就从 TSS 中获取</font></u></strong> 。换句话说，一个任务分为用户部分和内核部分，从用户转移到内核时，CPU 就会 <u><strong>自动</strong></u> 切换到内核自己的栈。</p></li></ul><p>同时注意，<strong><u>Linux 只使用一个 TSS ，任务切换时并不会随之切换 TSS，而是只修改 TSS 中的 ESP0</u></strong> ，这样也会大大提高任务切换的效率。后文解析代码时，读者朋友就能清楚地看到这一过程。</p><h3 id="font-color-red-进程的实现方式-font"><font color='red'>进程的实现方式</font></h3><p><strong>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。<font color='orange'>而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务（这点对于理解进程和线程的关系至关重要）</font>，这在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程基础</a>中有代码说明</strong> 。<strong><font color='red'>每个任务都类似于单线程，具有内存空间、执行实体（寄存器）、文件资源等，<u>但不同的任务可以选择共享同一虚拟内存空间，因此，共享了同一个内存空间的任务集合构成了一个进程</u></font></strong> 。</p><p>我们的操作系统是仿 Linux 系统，所以咋们实现用户进程就能够以线程为基础，具体方式如下：<br>先回顾线程创建的大概流程：</p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，调用 get_kernel_page() 向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息（task_struct），包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>要以线程为基础实现进程，<strong>就只需要将执行普通任务的线程函数替换成创建进程的新函数（即start_progress）即可</strong> 。那么，具体创建进程的流程是怎么样的呢？见下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><p>以上函数具体的实现待会再说，先来看看程序是如何进入到用户进程的。我们已经知道如下几点：</p><ol><li>用户进程运行在 3 特权级（ring3），而内核则运行在 ring0；</li><li>在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中我们了解到，除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上。<br><img src="/2022/img/image-20230103141410952.png" style="zoom:67%;" /></li><li>一直以来我们都在内核中运行，即执行流一直停留在 ring0 。</li></ol><p>那么现在，要在内核中，即 ring0 下创建用户进程，并进入到 ring3 用户态，该怎么做呢？显然，只能通过中断返回，即 <code>iret</code> 进入用户态。<u>所以我们采用的具体办法是：利用之前的方式创建线程，将线程里运行的函数设置为 start_progress() ；然后在 start_progress 中初始化该线程的中断栈（也就是将用户进程的寄存器现场提前写入中断栈）；最后 <code>iret</code> 中断返回，即可 ring0 -&gt; ring3，进入用户态</u>。</p><p>其实这种方式可以说是瞒天过海，妥妥地欺骗了 CPU。我们用 <code>iret</code> 指令使 CPU 以为咋们处于中断处理环境中，于是便假装从中断返回，顺利通过特权级检查并进入用户态。</p><h3 id="font-color-red-用户进程的虚拟内存分布-font"><font color='red'>用户进程的虚拟内存分布</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE34-1672909464756-2.png" alt="未命名绘图34"><br><strong>上图是经典的 Linux 用户进程内存布局(内核2.4版本)</strong> ，下面依次对各个部分作简单阐述：</p><ul><li><p>3GB~4GB 虚拟内存映射为内核空间，由所有进程共享。</p></li><li><p>用户内存的顶部是用户栈。一般而言，用户栈的最大空间为 8MB，详见<a href="https://www.tiehichi.site/2020/10/22/Linux%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/#%E5%86%85%E6%A0%B8%E6%A0%88">Linux进程栈空间大小 - Tiehichi’s Blog</a>。另外，用户栈的最高处会用来保存命令行参数和环境变量，这些数据是由 C 运行库压入的，后续从文件系统加载进程时会再提及此处。</p></li><li><p>用户栈下面是共享库的内存映射区域。共享库就是动态链接库，一个共享对象（即.so文件）由所有用户进程共享。举个例子，A 进程用到了 math 库，B进程也用到了 math 库，则 math 库会被加载到物理内存中，进而被映射到各个进程的虚拟内存空间中，由此实现共享，大大节省了内存，这便是动态链接库相对于静态链接库的优势。</p></li><li><p>接着是运行时堆，用于满足程序运行时的动态内存需求。</p></li><li><p>.bss 用于保存未初始化的数据，如未初始化的静态变量和全局变量。</p></li><li><p>.data 段用来保存已初始化且可读写的数据。实际上还有 .rodata 用来存放只读数据，此段并未体现在图中。</p></li><li><p>.text 则是代码区。IA-32 体系结构中，进程空间的代码段都从 <code>0x08048000</code> 开始，这与最低可用地址 <code>0x00000000</code> 有 128M 的间距。</p><blockquote><p>关于 <code>0x08048000</code> 这个值有许多解释，<a href="">Linker And Loader</a>一书给出的解释如下：<br>在 386 系统上，代码的起始虚拟地址是 <code>0x08048000</code> ，这允许在代码下方有一个相当大的堆栈；同时保持在地址0x08000000上方，允许大多数程序使用单个二级页表（回想一下，在 386 上，每个页目录项映射 0x00400000 大小的空间）。其他原因可参见<a href="https://www.cnblogs.com/l2017/p/11879310.html">0x08048000由来</a></p></blockquote></li></ul><p>关于进程的虚拟内存分布，这将在《 <strong>链接、装载与库</strong> 》系列笔记中详细阐述，敬请期待。</p>]]></content>
    
    
    <summary type="html">自制操作系统, 实现用户进程, 操作系统真相还原, 任务切换, linux, 进程切换, 用户进程的虚拟内存分布</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>锁机制—代码实现</title>
    <link href="http://jyxcpp.netlify.app/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jyxcpp.netlify.app/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-23T09:06:47.000Z</published>
    <updated>2023-03-12T11:21:03.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/">浅谈锁机制</a><br>本节对应分支：<code>lock</code></p></blockquote><p>在上节内容中我们提到，当线程申请锁时，如果该锁已经被其他线程拥有，则此线程必须在该锁上陷入睡眠，直到锁的拥有者将其叫醒。所以我们先实现进程的睡眠与觉醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_block</span><span class="params">(<span class="keyword">enum</span> task_status stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line">    cur_thread-&gt;status = stat;</span><br><span class="line">    schedule();                  <span class="comment">//将当前线程换下处理器</span></span><br><span class="line">    intr_set_status(old_status); <span class="comment">//待当前线程被解除阻塞后才继续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_unblock</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));</span><br><span class="line">    <span class="keyword">if</span> (pthread-&gt;status != TASK_READY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag))</span><br><span class="line">            panic(<span class="string">&quot;thread_unblock: blocked thread in ready_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4 行，只有为 TASK_BLOCKED、TASK_WAITING、TASK_HANGING 三种状态才会进行睡眠。</li><li>第 20 行，为了使觉醒的线程尽快得到调度，使用 list_push 而非 list_append 。</li><li>注意，thread_block() 是由当前线程主动执行来进入睡眠的，如果要觉醒，则只能等待其他线程来唤醒，此时是被动的。</li></ul><p>再来看锁的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>  //信号量</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  value;       <span class="comment">//锁的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">waiters</span>;</span>  <span class="comment">//在此信号量上等待的线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span>       //锁结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">task_struct</span>* <span class="title">holder</span>;</span>    <span class="comment">// 锁的持有者</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span>    <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">    <span class="type">uint32_t</span> holder_repeat_nr;    <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>holder_repeat_nr</code> 是同一线程对锁的申请次数。这是为了 1）防止重复申请锁导致陷入死锁；2）防止多次释放锁而出错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    psema-&gt;value = value;       <span class="comment">// 为信号量赋初值</span></span><br><span class="line">    list_init(&amp;psema-&gt;waiters); <span class="comment">//初始化信号量的等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;</span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_init(&amp;plock-&gt;semaphore, <span class="number">1</span>);  <span class="comment">// 信号量初值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="keyword">while</span>(psema-&gt;value == <span class="number">0</span>)<span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag))</span><br><span class="line">        &#123;</span><br><span class="line">            panic(<span class="string">&quot;sema_down: thread blocked has been in waiters_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">        list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);</span><br><span class="line">        thread_block(TASK_BLOCKED);    <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">    psema-&gt;value--;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread_blocked</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));</span><br><span class="line">        thread_unblock(thread_blocked);</span><br><span class="line">    &#125;</span><br><span class="line">    psema-&gt;value++;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line"><span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder != running_thread()) &#123;</span><br><span class="line">        sema_down(&amp;plock-&gt;semaphore);    <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">        plock-&gt;holder = running_thread();</span><br><span class="line">        plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;   <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_up(&amp;plock-&gt;semaphore);   <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第 60 行，如果自己已经持有该锁，则仅将 holder_repeat_nr 加 1，不做其他操作，否则重复进行 sema_down 会导致死锁！</p><blockquote><p><strong>为什么重复申请同一把锁会产生死锁？</strong><br>在已经持有锁的情况下继续申请该锁，若仍 sema_down ，则线程会陷入睡眠，等待锁的持有者将自己叫醒。而锁的持有者又是其本身，自己可不能叫醒自己，因此系统陷入死锁。</p></blockquote><p>所以这里为了应对重复申请锁的情况，当第二次申请时（内层），仅 holder_repeat_nr++ ；当释放锁时，肯定是先从内层释放，所以仅 holder_repeat_nr-- ；外层释放时，再 sema_up 。</p></li><li><p>第 70 行，<strong>必须将置空操作放在 sema_up 之前</strong> 。如果顺序放反，则可能出现这样的情况：线程 A 刚执行完 sema_up 还没来得及置空 holder 就被换下了处理器，轮到线程 B 执行。线程 B 申请该锁，因为线程 A 已经释放，所以 B 申请成功，成为该锁的持有人。当线程 B 还没来得及释放锁时，线程 A 重新被换上 CPU，执行的第一条语句就是置空 holder，然而此锁现在依然属于线程 B ，这就引发了错误。</p></li><li><p>第 19 行为什么使用 while 而非 if，这是因为锁也是通过抢占来获得的，一次抢占可能无法获得锁，举个例子：线程 A 执行 down 操作时发现锁已经被 B 占用，于是陷入睡眠；线程 B 解锁，叫醒 A ；而线程 C 却排在 A 之前，优先被调度，所以锁又被 C 占用，A 继续陷入睡眠。<br>但这里也可以用 if 呢？见上面 thread.c 第 20 行，我们把叫醒的线程放在了首位，不存在线程 C 排在 A 之前的情况，所以可以用 if 。</p><blockquote><p>再次强调，叫醒并不是立刻调度，而是将其放入 thread_ready_list 中。</p></blockquote></li></ul><p>本文件代码在源代码基础上删除了许多 assert 断言，因为笔者发现即使没有触发这些断言，程序最终总会停留在某个任务中，不再调度其他任务，这令笔者非常疑惑，怎么 assert 还会影响程序结果？即使其没有被触发？这里折磨了我很久，最终也是胡乱改，把这些 assert 删除之后才得到了满意的结果。有明白其原理的朋友麻烦在评论区指点一二，感谢！</p><h3 id="font-color-red-实现终端输出-font"><font color='red'>实现终端输出</font></h3><p>emm，终端输出，这玩意儿听起来高端，实际就是给打印函数添了个锁，来看实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">// 控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_init(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str, <span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_str(str,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_int(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_uint</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_uint(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这么简单。直接看结果吧：</p><div id="dplayer10" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer10"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/lock.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>本文结束。</p>]]></content>
    
    
    <summary type="html">操作系统真相还原, 锁, 代码</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈锁机制</title>
    <link href="http://jyxcpp.netlify.app/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://jyxcpp.netlify.app/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-22T02:50:21.000Z</published>
    <updated>2023-03-12T11:21:02.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-前言-font"><font color='red'>前言</font></h3><p>在上节<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程 - 进阶 - 任务调度</a>的末尾，笔者演示了当删去 <code>put_str()</code> 上下的 <code>STI</code> 和 <code>CLI</code> 后发生的错误情况（打印不规律，且发生 GP 异常）这是为什么呢？这里就不卖关子了，直接原因是 <strong>线程不同步</strong> 。这样说了也当白说，让我们仔细还原现场：</p><ol><li>k_thread_a 在 put_char 中读取了字符打印的光标位置 p 。</li><li>当 k_thread_a 准备更新光标位置时，中断发生，切换到 k_thread_b 。</li><li>k_thread_b 读取光标位置，由于 k_thread_a 还未更新光标，所以此时光标值仍为 p 。</li><li>于是，k_thread_b 在相同地方打印字符，覆盖了 k_thread_a 的字符。</li></ol><p>因此才出现少字符的情况。对于其他错误，比如一大串空格以及 GP 异常，就不详细说明原因了，只需明白，它们的罪魁祸首都是线程不同步造成的。为了进一步解释什么叫线程不同步，先来看看下面几个概念：</p><ul><li><p><strong><font color='gree'>临界区</font>：</strong> 是指包含有共享数据的一段 <strong><u>代码</u></strong> ，这些代码可能被多个线程访问或修改。临界区的存在就是为了保证当有一个线程在临界区内执行的时候，不能有其他任何线程被允许在临界区执行。</p><blockquote><p><strong>注意，临界区是代码，不是受访的静态公共资源。</strong></p></blockquote></li><li><p><strong><font color='gree'>互斥</font>：</strong> 某一时刻公共资源只能被一个任务访问，即，不允许多个任务同时出现在临界区中。</p></li><li><p><strong><font color='gree'>竞争条件</font>：</strong> 多个任务以竞争的方式（非互斥）进入临界区，其最终的的结果依赖于多个进程的指令执行顺序。<br>举例：假设两个进程 P1 和 P2 共享了变量 a。在某一执行时刻，P1 更新 a 为 1，在另一时刻，P2 更新 a 为 2。因此两个任务竞争地写变量 a。在这个例子中，竞争的失败者（最后更新的进程）决定了变量 a 的最终值。多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p></li></ul><p>显然，我们代码中的临界区就应该为 put_char（准确来说，是 put_char 中操作光标的代码部分），而 k_thread_a 和 k_thread_b 两个线程以竞争的方式访问临界区，从而产生竞争条件，最终引发不同步导致错误。那么，如何才能实现互斥访问呢？<strong><u>最简单的方式就是像视频演示中的那样开关中断，但现实的方式是采用锁</u></strong> 。关于这两种方式的比较，请见文末。</p><p>下面我们来看看锁的进化历程，以此加深读者对锁的理解。</p><h3 id="font-color-red-锁的进化-font"><font color='red'>锁的进化</font></h3><p>情景：金鱼有个很奇怪的特点，就是没有饱的感觉，如果你不停地给它喂食，它就会一直进食直到把自己撑死。现在线程 A 和线程 B 共同喂养一条金鱼，要求只能由其中一个线程进行喂食，即，若 A 线程已经投喂，那么 B 就不能再继续投喂；如果 B 线程已经投喂，则 A 线程也不能再投喂，否则金鱼被撑死。除了不能多次投喂外，也不能不进行投喂，即 A 和 B 线程中总有一者必须投喂金鱼，否则金鱼被饿死。</p><p><strong><mark class="hl-label blue">第一阶段</mark> </strong></p><p>使用全局变量 if_feed 标记喂食情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能防止多次投喂了吗？<br><img src="/2022/img/未命名绘图29.png" style="zoom:67%;" /><br>哦豁，依旧投喂了两次，金鱼被撑死。这里的原因在于，A、B 两线程同时进入了临界区。</p><p><strong><mark class="hl-label blue">第二阶段</mark> </strong></p><p>经过第一阶段的失败，我们吸取了教训：要防止金鱼胀死，就必须避免多个线程同时进入临界区，即需要做到互斥。下面通过留字条的方式来互斥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>以上代码无论按什么顺序穿插执行 A、B 线程，都不会再造成金鱼胀死了，但却可能饿死！如下：</p><img src="/2022/img/未命名绘图30.png" style="zoom:80%;" />哈哈，即使饿死，也比撑死好。这是因为几个线程同时获得一个资源，最终出现崩溃几乎是必然的事；如果谁都获取不了资源，则可能只是停止推进，而不一定产生错误结果。让我们继续改进。<p><strong><mark class="hl-label blue">第三阶段</mark> </strong></p><p>为了保证投喂，我们让某个线程一直等着，直到确认对方投喂之后再离开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(noteB == <span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这样一来就能够保证金鱼能够被投喂了。但即使如此，以上方式仍存在较大问题：</p><ol><li>程序不对称。功能完全相同，程序却不一样，这加大了代码的难度。</li><li>浪费 CPU 资源。线程 A 的 while 完全是白占着 CPU 资源。</li><li>可能造成优先级倒挂。</li></ol><p><strong><mark class="hl-label blue">第四阶段</mark> </strong><br>那么现在，我们又该怎么办呢？仔细思考后其实可以发现，第 2、3 个阶段的重心都落在字条上，即留字条是为了防止两个线程同时投喂或都不投喂金鱼。既然留字条不能完美地解决办法，那有没有其他方法来进行互斥呢？有，当要投喂时，进入房间，把门锁上，投喂金鱼，打好标记，解锁并离开房间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><p>这种为房间上锁的方式实际上是对第一种方案的改善，即，将检查标记和打标记合并为一个原子操作（投喂金鱼也被合并了）。如此一来，似乎就完美了。但再仔细观察后仍可以发现一个问题：如果线程 A 喂鱼的动作很慢，那么线程 B 将会被锁很长一段时间，这种等待不仅浪费 CPU 资源，也会降低系统效率。而且，喂鱼这个动作并非临界区，对标记的操作才是，所以完全可以将喂鱼的动作移出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">    noteA = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteA = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">    noteB = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteB = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>谨记，临界区的动作越少越好！</font></strong> 另外，当其他线程被锁在临界区外时，只能苦等锁被打开，除此之外无法进行任何动作，<strong><font color='orange'>所以这些线程就不应该再占用 CPU 资源，即，在锁被打开前，CPU 不再调度这些任务，直到锁被打开后再恢复调度</font></strong> 。这就涉及到线程的 <strong><font color='orange'>睡眠</font></strong> 与 <strong><font color='orange'>觉醒</font></strong> 。</p><h3 id="font-color-red-睡眠与觉醒：生产者和消费者问题-font"><font color='red'>睡眠与觉醒：生产者和消费者问题</font></h3><p><strong>线程的睡眠和觉醒是指：当对方持有锁，将你锁在外面时，你无需一直敲门，而是可以在门口睡觉，等到对方解锁之后再来叫醒你</strong> 。下面用线程中经典的生产者和消费者问题来演示睡眠与觉醒。我们知道，一般来说，生产者（厂家）会将商品批发给超市，然后消费者在超市进行购买。如果没有超市这个中转站，生产者就无法独立操作，必须拿到消费者的订单才能生产；消费者也必须在每次订货后且等待商品完工后才能拿到货。显然，超市扮演着重要的缓冲区角色。现在抛出两个问题：1）当超市没货了怎么办？2）当超市货太多装不下怎么办？</p><p>现实的实际做法一般是：<strong>当超市没货了，如果有顾客上门购买商品，则告知顾客缺货并让顾客回家等候通知；当超市货满了，则通知厂商暂时不要再生产</strong> 。用代码表示即如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100  <span class="comment">//超市最多能存下的商品数</span></span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//超市中现存的商品数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            sleep();         <span class="comment">//不再生产</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            wakeup(consumer);<span class="comment">//通知客户取货</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            sleep();         <span class="comment">//回家等通知</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)     <span class="comment">//如果count==N-1,说明厂家一定处于睡眠状态</span></span><br><span class="line">            wakeup(producer);<span class="comment">//通知厂家生产</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，wakeup() 只是叫醒对方线程，即让其重新在 thread_ready_list 中，而不是立刻调度！</strong></p></blockquote><p>以上代码看上去正确无误，实际上存在着巨大问题：<strong><font color='red'>可能造成死锁！</font></strong></p><blockquote><p>死锁，即生产者和消费者均无法向前推进。</p></blockquote><p>例如，若消费者先来，此时 count=0，则去睡觉，但在<u>睡下的前一刻</u>，CPU 任务调度，执行流转移到生产者。生产者开始运行，生产一件商品后发现 count=1，于是叫醒消费者。但此时消费者并没有睡觉（还在 thread_ready_list 中），所以这个叫醒信号无用。缓冲区满后，生产者转入睡眠，执行流转移到消费者。而消费者执行的第一个操作就是 sleep()，于是消费者也转入睡眠。最后两者都陷入睡眠状态并等待彼此叫醒自己，显然，它们都无法再醒来，系统死锁发生。</p><p>解决上述问题的方法也很简单。很容易发现，造成死锁的原因是因为叫醒信号的丢失。那我们想个办法将信号收集起来不就OK了嘛！消费者换上 CPU 执行 sleep 后，生产者发送的叫醒信号依然保留，因此消费者检测到该信号而觉醒。<strong><font color='gree'>这种能够累积的信号就叫做信号量</font></strong> 。</p><h3 id="font-color-red-信号量-font"><font color='red'>信号量</font></h3><p>实际上，信号量是操作系统中一个极其重要，威力巨大的概念，它不仅可以用来线程同步，还能用于进程间通信。我们现在仅讨论其作为锁的用途。<strong>当信号量的取值限制在 0 和 1 时，则获得了一把锁，也称二元信号量</strong> 。对信号量有 up、down 两种操作：</p><p><strong><font color='orange'>up：</font></strong> 1）将信号量加 1；2）唤醒在此信号量上等待的线程。<br><strong><font color='orange'>down：</font></strong> 1）判断信号量是否大于 0；2）若信号量大于 0，则将信号量减 1；3）若信号量等于 0，则在此信号量上睡眠。</p><blockquote><p>因为信号量是荷兰科学家 Dijkstra 发明的一种程序设计规范，所以 up 和 down 也被称为 PV 操作，即荷兰语中的 Proberen 和 Verhogen 。</p></blockquote><p><strong><u><font color='orange'>down 即获得锁，up 即解锁</font></u></strong> 。<strong>初始状态下信号量值为 1，某线程获得锁后，其值减为 0，当其他线程申请锁时，则只能在此锁上陷入睡眠，直到该线程解锁。</strong></p><p>值得一说的是，信号量也不是完美的解决方案，当二元信号量多起来后，死锁也有极大的概率会发生，但由于我们的操作系统非常简单，不会发生如此复杂的情况，所以不考虑这些情况，详细内容请参考《操作系统之哲学原理》。</p><h3 id="font-color-red-死锁-font"><font color='red'>死锁</font></h3><p>有大概如下几种情况会产生死锁：</p><ul><li><strong>忘记释放锁</strong></li><li><strong>单线程重复申请锁</strong></li><li><strong>多线程多锁申请</strong></li></ul><h3 id="font-color-red-锁比开关中断好在哪？-font"><font color='red'>锁比开关中断好在哪？</font></h3><p>前文提到，关中断是避免资源竞争最简单的方式，那为什么还需要锁呢？<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE31.png" alt=""><br>从上图可见，当红色箭头进入临界区时，关闭中断，虽然这避免了资源竞争，但却令红色箭头在整个临界区内独占 CPU，其他任务得不到调度，从而导致系统效率下降。这是关中断的方式，下面来看看用锁是什么情况：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE32.png" alt=""><br>锁就不一样了，当红色箭头获得锁进入临界区后，绿色箭头仍然能够得到 CPU 调度，直到到达临界区才会被锁住而进入睡眠。因此，<strong>相比于开关中断，锁机制在任务调度上的效率更高</strong> 。</p><blockquote><p>以上是笔者的个人想法，若读者还有其他想法，不妨在评论区提出。</p></blockquote><p>本文就到这里，下节我们将实现锁机制。</p>]]></content>
    
    
    <summary type="html">锁, 操作系统, 信号量, 死锁的几种情况</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程-进阶-任务调度</title>
    <link href="http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
    <id>http://jyxcpp.netlify.app/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</id>
    <published>2022-12-16T08:50:00.000Z</published>
    <updated>2023-03-12T11:20:59.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a><br>本节分支：<code>thread-schedule</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>任务链表</font></strong><br>通常使用链表来维护任务队列。链表本身不是本节的重点，所以笔者将其放在文末。</li><li><strong><font color='gree'>任务调度基础</font></strong><br>基于上节内容对 <code>thread.c</code> 和 <code>thread.h</code> 进行改进。</li><li><strong><font color='gree'>任务切换</font></strong><br>改进时钟中断，添加任务调度器，开始任务切换。</li></ul><h3 id="font-color-red-任务调度基础-font"><font color='red'>任务调度基础</font></h3><p><strong><mark class="hl-label blue">thread.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              </span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              </span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>thread.h 中只对 <code>task_struct</code>  添加了一些成员：</p><ul><li><strong>ticks：</strong> 时间片，任务刚被调度时，时间片被初始化为 priority，随后每发生一次时钟中断 ticks 就减 1，减到 0 后被换下 CPU 。</li><li><strong>elapsed_ticks：</strong> 记录该任务一共被运行了多少 CPU 滴答数。它和 ticks 的区别是：ticks 减到 0 时任务被换下 CPU，但此时任务可能还未执行完毕，所以重新加入到任务队列等待下一次被调度。所以，elapsed_ticks 记录的是从任务初次被调度到任务执行结束所经过的总滴答数，而 ticks 只是任务的一次倒计时。</li><li><strong>general_tag：</strong> <font color='orange'>当任务处于<u>就绪或其他等待状态</u>时，需要把该 tag 添加到 thread_ready_list 或其他相应等待队列中</font>。将 tag 加入到队列就相当于将 task_struct 加入到队列吗？是的，可以通过 tag 来定位 task_struct，原因很简单，因为这些 tag 本来就位于 task_struct 内存中，只需要根据成员的偏移量就能反向推断出 task_struct 的地址。文末会演示这一过程。<br><img src="/2022/img/image-20221217171337120.png" alt="通过tag将各个PCB连接成队列" style="zoom:67%;" /></li><li><strong>all_list_tag：</strong> thread_all_list 用来管理所有任务，所有任务的 all_list_tag 都需要加入到 thread_all_list 中。</li><li><strong>pgdir：</strong> 上节提到过，对于进程，pgdir 指向自己的页目录表；对于线程，pgdir 被初始化为 NULL 。注意，pgdir 中装的是虚拟地址，经过手动转换变成物理地址后才会加载进 CR2 ，这是后话。</li></ul><p><strong><mark class="hl-label blue">thread.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">main_thread</span>;</span>    <span class="comment">// 主线程PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span>    <span class="comment">// 就绪队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span>    <span class="comment">// 所有任务队列</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">thread_tag</span>;</span><span class="comment">// 用于保存队列中的线程结点</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> tmp_esp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前线程pcb指针 */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">running_thread</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov tmp_esp,esp&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">/* 取esp整数部分即pcb起始地址 */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> task_struct*)(tmp_esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由kernel_thread去执行function(func_arg) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">    intr_enable();</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程栈thread_stack,将待执行的函数和参数放到thread_stack中相应的位置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再留出线程栈空间,可见thread.h中定义 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread)</span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    </span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">/* 加入就绪线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">/* 加入全部线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将kernel中的main函数完善为主线程 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_main_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 因为main线程早已运行,咱们在guide.S中进入内核时mov esp,0xc009f000,</span></span><br><span class="line"><span class="comment">已经为其预留了pcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/</span></span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">&quot;main&quot;</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数就是当前线程,当前线程不在thread_ready_list中,</span></span><br><span class="line"><span class="comment"> * 所以只将其加在thread_all_list中. */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务调度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING)    <span class="comment">// 若当前线程只是时间片到了,将其加入到就绪队列尾,等待重新被调度</span></span><br><span class="line">    &#123;  </span><br><span class="line">        assert(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">        cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">        cur-&gt;status = TASK_READY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前线程是被阻塞了,则不需要将其加入到就绪队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!list_empty(&amp;thread_ready_list));</span><br><span class="line">    thread_tag = <span class="literal">NULL</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu.</span></span><br><span class="line">    thread_tag = list_pop(&amp;thread_ready_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;thread_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    list_init(&amp;thread_ready_list);</span><br><span class="line">    list_init(&amp;thread_all_list);</span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">    make_main_thread();</span><br><span class="line">    put_str(<span class="string">&quot;thread_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老规矩，讲解以上代码前先理理脉络：</p><ol><li><strong>开启线程机制前需要调用 <code>thread_init()</code> 来初始化线程环境，内容包括初始化就绪任务链表和所有任务链表、创建 main 线程。</strong></li><li><strong>初始化线程环境后即可调用 <code>thread_start()</code> 创建线程。在此函数中进入如下动作：</strong><br><strong>1）调用 <code>init_thread()</code> 初始化线程信息，</strong><br><strong>2）调用 <code>thread_create()</code> 将线程函数及其参数写入到线程栈中。</strong><br><strong>3）将该线程加入到 thread_ready_list 和 thread_all_list 中。</strong></li><li><strong>随后等待调度。</strong></li></ol><p>下面进行代码讲解：</p><ul><li><p>第 12 行，使用内联汇编取得当前 esp 的值。和之前一样，内联汇编中用到的 C 变量必须是全局或者全局静态变量，因此使用全局静态变量 tmp_esp 中转。</p></li><li><p>第 14 行，因为栈位于 PCB 中，而 PCB 大小为一页，所以将 esp 向下取页框，即得 PCB 起始地址。</p></li><li><p>第 21 行，进入线程函数 <code>function()</code> 前需要先打开中断，这里需要重点说明其原因：任务切换是由时钟中断驱动的，也就是说，<code>schedule()</code> 是在时钟中断里被调用的，任务调度后直接进入 <code>function()</code> 执行任务 ，<strong><u>并不会返回中断（iret）</u></strong> ，这样一来，就相当于任务的调度和执行都发生在中断里。咋们之前说过，进入中断后 <code>IF</code> 位自动置 0，也就是屏蔽外部中断，如此一来，进入该任务后就无法发生时钟中断来调度其他任务啦，于是，该任务独占了 CPU 控制权！为了防止这种情况发生，<strong><font color='orange'>我们需要在进入任务前手动开启中断</font></strong> ！！！</p></li><li><p>第 68 行，<strong>只有将该任务加入到 thread_ready_list 队列中，才会被 CPU 调度</strong> ；目前还没有体现到 thread_all_list 的作用，后续才会用到该队列。</p></li><li><p>第 77 行，从 CPU 被启动的那一刻，执行流就一直在按我们的代码运行。现在，<strong>我们要将该执行流也包装成线程（即kernel_main线程）并加入到队列中，否则调度其他任务后就没法回到主线程了</strong> 。注意 <code>guide.s</code> ：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[BITS 32]</span><br><span class="line">extern kernel_main</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov esp, 0xc009f000</span><br><span class="line">    jmp kernel_main</span><br></pre></td></tr></table></figure><p>第 6 行，<strong>进入内核前必须将 esp 指向主线程 PCB 的顶端，即 0xc009f00 处，否则无法根据 esp 定位到 PCB</strong> 。</p></li><li><p>第 92 行，<code>schedule()</code> 函数可能在时钟中断里被调用，也可能被后续将要说到的 <code>thread_block()</code> 函数调用。<strong><font color='orange'>因此，在 <code>schedule()</code> 中需要考虑当前线程是出于什么原因才被换下 CPU 的，是因为时间片到期？还是说被阻塞了？所以必须针对不同的状态做出相应的应对措施</font></strong> 。另外，最下方调用的 <code>switch_to</code> 是汇编函数，下文会重点讲解。</p></li><li><p>第 109 行，由于我们还未实现 idle 线程，所以就绪队列可能为空，为了避免无线程可调度的情况，暂用 assert 来保障。</p></li><li><p>第 114 行，<code>elem2entry()</code> 是宏函数，用来将 general_tag 或 all_list_tag 转换为对应的 task_strcut 指针。此函数在文末介绍链表时会谈到。</p></li></ul><p>其他就没什么好说的了，下面进入正题。</p><h3 id="font-color-red-任务切换-font"><font color='red'>任务切换</font></h3><p>我们采用的调度方式是 <strong><font color='red'>轮询（Round-Robin，RR）</font></strong> ，这是一种基础的调度方式。轮询，说白了就是按先进先出（FIFO）的顺序一个一个调度。切换任务时，从 thread_ready_list 弹出队首，并将其调度上 CPU 。注意，正在执行的任务的状态是 RUNNING，该任务不在 thread_ready_list 中，而在 thread_all_list 中。</p><p><strong>完整的任务调度分为三个大步：</strong></p><ol><li><strong>进入时钟中断</strong></li><li><strong>时钟中断调用 <code>schedule()</code></strong></li><li><strong><code>schedule()</code> 调用 <code>switch_to()</code></strong></li></ol><p><strong><mark class="hl-label blue">1.进入时钟中断</mark> </strong><br>还记得吗？在<a href="https://jyx-fyh.github.io/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加入中断</a>一文中，我们将每个中断处理函数都统一初始化为 <code>general_intr_handler()</code> ，这是一般化函数，只是用来告诉我们发生了什么中断，以便于排错。现在咋们就需要将时钟中断专门化了，见以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idt.c</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_handler</span><span class="params">(<span class="type">uint8_t</span> vector_no, intr_handler function)</span></span><br><span class="line">&#123;</span><br><span class="line">    interrupt_handler_table[vector_no] = function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> ticks;          <span class="comment">// ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"><span class="comment">/* 时钟的中断处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intr_timer_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line"></span><br><span class="line">    assert(cur_thread-&gt;stack_magic == <span class="number">0x19870916</span>);  <span class="comment">// 检查栈是否溢出</span></span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;elapsed_ticks++;                    <span class="comment">// 记录此线程占用的cpu时间嘀</span></span><br><span class="line">    ticks++;  <span class="comment">//从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_thread-&gt;ticks == <span class="number">0</span>)                     <span class="comment">// 若进程时间片用完就开始调度新的进程上cpu</span></span><br><span class="line">        schedule();</span><br><span class="line">    <span class="keyword">else</span>                                            <span class="comment">// 将当前进程的时间片-1</span></span><br><span class="line">        cur_thread-&gt;ticks--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;timer_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);</span><br><span class="line">    register_handler(<span class="number">0x20</span>, intr_timer_handler);  </span><br><span class="line">    put_str(<span class="string">&quot;timer_init done: Clock interrupt frequency increased to 100Hz\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局变量 ticks 用来记录自中断开启后经历的总滴答数，类似于系统运行时长的概念。该变量当前保留，未来可能会用到。</li><li>第 14 行，<strong>cur_thread-&gt;ticks == 0 意味着<u>该任务还未结束，但时间片已经到期</u></strong> ，所以进入 <code>schedule()</code> ，将该任务重新放入队尾等待下一次调度。</li><li>第 25 行，注册专门的时钟中断。</li></ul><p><strong><mark class="hl-label blue">进入schedule()</mark> </strong></p><p>上文已作讲解，不再说明。</p><p><strong><mark class="hl-label blue">进入switch_to</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">section .text</span><br><span class="line">global switch_to</span><br><span class="line">switch_to:</span><br><span class="line">   ;栈中此处是返回地址</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ebx</span><br><span class="line">   push ebp</span><br><span class="line"></span><br><span class="line">   mov eax, [esp + 20]     ; 得到栈中的参数cur, cur = [esp+20]</span><br><span class="line">   mov [eax], esp          ; 保存栈顶指针esp</span><br><span class="line">                           </span><br><span class="line">                           </span><br><span class="line">;------------------  以上是保存当前线程的栈，下面是恢复下一个线程的栈  ----------------</span><br><span class="line">   mov eax, [esp + 24]     ; 得到栈中的参数next, next = [esp+24]</span><br><span class="line">   mov esp, [eax]          ; 恢复esp</span><br><span class="line">                           </span><br><span class="line">   pop ebp</span><br><span class="line">   pop ebx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret                     ;第一次执行时会返回到kernel_thread</span><br><span class="line">                           ;后续执行则会返回到schedule函数</span><br></pre></td></tr></table></figure><ul><li>关于 esi、edi、ebx、ebp 的压栈问题已在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a>中阐述。</li><li>参数 cur 和 next 分别是当前任务和下个任务的 task_struct 指针，需要强调的是，<strong>由于 task_struct 的首个成员是 self_kstack，所以可以认为 cur 和 next 指针也是指向 self_kstack</strong> ！这样一来，<strong><font color='orange'>self_kstack 的真正作用便清晰了——记录线程被换下瞬间的 esp 值</font></strong> 。</li></ul><p><strong><code>switch_to</code> 是任务调度的核心，它向我们直接展示了操作系统是如何通过栈切换来完成任务调度的</strong> 。不过，大家可能还是很迷糊，不急，让我们看看实际的调度过程：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE28-1671258856847-2.png" alt="以下解析的步骤和上图的序号相对应"></p><ol><li><p>当前执行流位于 kernel_main() 主线程，esp 当然也位于 kernel_main 的 PCB 顶端。某一时刻，时钟中断发生，<strong>中断压栈保护任务现场</strong> ，接着进入 <code>schedule()</code> ，进而到 <code>switch_to()</code> 。<code>switch_to()</code> 前半段将当前 esp 的值保存到 kernel_main 的 self_kstack 中。</p><blockquote><p>为什么 cur 和 中断栈之间还有个省略号？这只是想告诉大家，实际的线程栈情况和 <code>thread_stack</code> 结构体并不能一一对应，比如，调用 <code>schedule()</code> 函数还需要将返回地址压栈呢，而这个并没有考虑进 <code>thread_stack</code> 或 <code>intr_stack</code> ，所以栈中的数据实际上是错位的！不能通过该结构体取得栈内对应的值。<code>intr_stack</code> 也同样不能对应，比如，在 kernel_main() 中调用了一个函数，执行此函数时发生中断，此时的 esp 就不是从 0xc009f000 开始的啦！</p></blockquote></li><li><p>执行 <code>mov esp,[eax]</code> 后即完成栈切换。<strong><font color='orange'>注意，这个新任务是首次被调度的，它的线程栈已经在 <code>thread_create()</code> 中被我们设计好了</font></strong> 。</p><blockquote><p>为啥没省略号了？因为现在对齐啦！！！要知道，在 <code>thread_create()</code> 中，我们跳过了中断栈和线程栈，将 self_kstack 不偏不倚地指向了线程栈的起点，所以这里是完全对齐了的，也是基于这一点，下面的 pop 和 ret 才能正确执行。</p></blockquote></li><li><p>四次 pop 并 ret，成功进入 eip 对应的 <code>kernel_thread()</code> ，进而 <code>function()</code> ，任务开始执行。</p></li><li><p>某时刻，中断再次发生，中断压栈，再一路来到 <code>switch_to()</code> 上半部分，即保存当前栈。<strong><font color='orange'>注意，由图可见，此时中断压栈是发生在线程栈中而非中断栈中！</font></strong></p><blockquote><p><strong><font color='orange'>注意步骤 3 和步骤 4 的栈中的 eip 差异，这点差异非常重要！步骤 3 中的 eip 是我们设计好的，指向 <code>kernel_thread()</code> ；而步骤 4 中的 eip 是 <code>schedule()</code> 中调用 <code>switch_to()</code> 时留下的返回地址，也就是说将来会通过这个 eip 回到 <code>schedule()</code></font></strong> 。<br>另外再次强调，中断之所以能够再次发生，是因为我们进入 <code>function()</code> 前手动打开了中断，这并不是 <code>iret</code> 的功劳。</p></blockquote></li><li><p>执行 <code>switch_to()</code> 的下半部分，<code>mov esp,[eax]</code> ，切换任务栈。</p></li><li><p>接着 pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复 kernel_main() 的任务。</p></li><li><p>一段时间后，中断发生，保存当前栈。</p></li><li><p>恢复之前的栈。此时的 eip 是 <code>schedule()</code> 留下的返回地址（而非 kernel_thread 的地址）。</p></li><li><p>pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复线程任务。</p><blockquote><p>可见，该线程的线程栈栈底将一直存留这三个参数，这并不重要。问题是，当任务结束后，<code>kernel_thread()</code> 该如何返回呢？这个占位符原本应该是 <code>switch_to</code> 调用 <code>kernel_thread()</code> 留下的返回地址，但现在它仅是一个占位符，<strong><font color='orange'>这意味着任务结束后 kernel_thread() 将无法正常返回！</font></strong> 所以，<strong><u>在我们的操作系统中，线程返回不能通过普通 return 的方式进行</u></strong> ，而要专门调用一个线程退出函数（ <code>thread_exit()</code> ）来结束任务，这是后话，目前我们的策略是强制要求在任务末端放一个 <code>while(1)</code> ，以避免任务结束。关于这点的实验演示见以下视频。</p></blockquote></li></ol><blockquote><p><strong>为什么使用 <code>ret</code> 来调用 kernel_thread() ？</strong><br>从上面的过程你可以发现，<code>switch_to</code> 的最后一句 <code>ret</code> ，在线程首次被调度时，是进入 <code>kernel_thread()</code> ；后续被调度时，则是返回到主调函数 <code>schedule()</code> 中。<strong><font color='orange'>所以此处的 <code>ret</code> 有双重作用！而你可以通过 ret 调用 kernel_thread，也可以使用 ret 来返回 schedule，但你可不能使用 call 来返回 schedule 吧？这也是为什么要使用 <code>ret</code> 而非 <code>call</code> 来调用 <code>kernel_thread()</code> 的原因！</font></strong></p></blockquote><div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_exit.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>可见，一旦任务退出，就引发缺页异常。不知道有没有眼尖的小伙伴看见 while 语句中，打印语句上下的 <code>STI</code> 和 <code>CLI</code> ？为什么要在 <code>put_str()</code> 的上下分别放置这两条语句呢？先让我们看看，如果去掉这两条语句会发生什么：</p><div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>看见了吗？若去掉 <code>STI</code> 和 <code>CLI</code> ，则会发生 0xd 号异常。这涉及到锁相关的内容，将在下节内容详细介绍。</p><p>另外，说说笔者在这里遇见的一个大坑，看下面的 <code>interrupt.s</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的interrupt.s</span></span><br><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>上面是修改后的 <code>interrupt.s</code> ，也就是现在的版本。而之前，笔者是像下面这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>嗯？只是处理 EOI 的代码改变了位置，有什么影响吗？影响可大了！前文已经强调，任务调度在时钟中断处理函数(第11行)中进行的，调度完成后直接开始执行任务，并不会返回到中断内并执行末尾的 <code>iret</code> 指令；而中断发生后 CPU 会自动将 IF 位置零来屏蔽外部中断，因此，为了防止任务独占 CPU，任务（即<code>function()</code>)正式开始前还要手动开中断。问题来了，<strong><font color='orange'>8259A 芯片发送中断信号后，必须要收到 CPU 发来的 EOI 结束命令后才会继续发送中断，否则即使你开了中断也没用！</font></strong> 所以，按上面的写法，进入第 11 行时钟中断处理函数后，压根不会执行后面的 EOI 发送代码，时钟中断无法产生，后续的任务调度也就没法进行了！这里坑了笔者两天之久！</p><h3 id="font-color-red-链表-font"><font color='red'>链表</font></h3><p>双向链表是用来维护任务队列的核心数据结构。数据结构不是本系列博客的重点，所以就不详细展开了，仅强调几个要点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset(struct_type,member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line"><span class="meta">        (struct_type*)((int)elem_ptr - offset(struct_type, struct_member_name))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">prev</span>;</span>  <span class="comment">// 前躯结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">next</span>;</span>  <span class="comment">// 后继结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span>   <span class="comment">//头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span>   <span class="comment">//尾节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数类型function,用于在list_traversal中做回调函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">bool</span> <span class="params">(function)</span><span class="params">(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_iterate</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>offset</code> 宏用来计算结构体内的某成员相对于该结构体起始处的偏移量。这个操作很骚，可以说将指针运用得炉火纯青了：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)(&amp;((struct_type*)<span class="number">0</span>)-&gt;member)</span><br></pre></td></tr></table></figure><p>将 0 强制转换为 struct_type* 指针，换句话说，<strong><u>该指针指向 struct_type 类型的结构体，而该结构体位于地址 0x0000 处</u></strong> 。如此一来，由于是以地址 0x0000 为基准，所以该结构体中成员的地址即为此成员相对于该结构体的偏移量。</p></li><li><p><code>elem2entry</code> 宏就好说了，用 tag 指针减去 tag 偏移量即得结构体的起始地址。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag); <span class="comment">//thread.c第114行</span></span><br></pre></td></tr></table></figure><blockquote><p>那么，为什么这两个操作设计成宏而非函数呢？留给读者自己思考。</p></blockquote></li><li><p>注意，list 中的 head 是头节点，而非首元节点；尾节点同理；节点只会插在 head 与 tail 之间。</p><blockquote><p>头节点是一个不存放任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，<strong>它的作用只是为了方便解决某些实际问题</strong> ；<br>首元节点是链表中第一个存有数据的节点；首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p></blockquote></li><li><p>第 19 行，自定义函数类型，该类型在 <code>list_traversal()</code> 中作为回调函数的类型。如果不使用 typedef，那么第 30 行声明就需改成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="type">bool</span> (func)(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>), <span class="type">int</span> arg)</span>;</span><br></pre></td></tr></table></figure><p>显然，这种方式没有上一种方式好看。<code>list_traversal()</code> 函数当前还未使用，后续用到了再介绍。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="comment">/* 初始化双向链表list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = &amp;<span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.prev = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把链表元素elem插入在元素before之前 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    before-&gt;prev-&gt;next = elem;</span><br><span class="line">    elem-&gt;prev = before-&gt;prev;</span><br><span class="line">    elem-&gt;next = before;</span><br><span class="line">    before-&gt;prev = elem;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加元素到列表队首 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(plist-&gt;head.next, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 追加元素到链表队尾 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(&amp;plist-&gt;tail, elem); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使元素pelem脱离链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    pelem-&gt;prev-&gt;next = pelem-&gt;next;</span><br><span class="line">    pelem-&gt;next-&gt;prev = pelem-&gt;prev;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将链表第一个元素弹出并返回,类似栈的pop操作 */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    list_remove(elem);</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == obj_elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把列表plist中的每个元素elem和arg传给回调函数func,</span></span><br><span class="line"><span class="comment"> * arg给func用来判断elem是否符合条件.</span></span><br><span class="line"><span class="comment"> * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的元素返回元素指针,否则返回NULL. */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(plist))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(elem, arg))   </span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        elem = elem-&gt;next;     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回链表长度 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断链表是否为空,空时返回true,否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (plist-&gt;head.next == &amp;plist-&gt;tail ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数都是常规的链表操作，不再解释。</p><p>本文结束。经过这两节的煎熬，想必读者朋友们也憔悴了吧？哈哈，休息再战！</p>]]></content>
    
    
    <summary type="html">线程, 操作系统, 任务调度, 自制操作系统, 真相还原</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>内存管理-进阶-分配页内存</title>
    <link href="http://jyxcpp.netlify.app/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/"/>
    <id>http://jyxcpp.netlify.app/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/</id>
    <published>2022-12-08T03:01:27.000Z</published>
    <updated>2023-03-12T11:21:07.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节前置内容：<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础-初始化内存池</a><br>本节对应分支：<code>memory-alloc</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>对笔者而言，内存分配一直是操作系统最神秘的部分之一，从学习编程开始，就一直能在耳边听到这个词，所以这也是本人最期待的部分，不知读者是否也是如此呢？本节我们实现的内存分配是“整页分配”，这与 malloc 函数不同，后者能申请任意大小的内容，而前者的申请单位则是以页为计。不过，malloc 也是基于“整页分配”进行的，所以未来我们也会借助本节内容来实现 malloc 函数。</p><p>本节的函数逻辑也都很简单，只是它们的数量较多，关系稍显复杂，所以贴心的笔者（手动狗头^_^）献上一幅函数关系图以供大家参考：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE22.png" alt=""><br>上图就是内存申请的全过程，大括号中包含的函数即为括号所指函数中调用的函数，且从上到下依次调用。上图只是为了让大家稍微熟悉页分配的过程，具体过程咋们还是来看代码吧。</p><h3 id="font-color-red-代码解析-font"><font color='red'>代码解析</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pool_flags</span> &#123;</span></span><br><span class="line">   PF_KERNEL = <span class="number">1</span>,    <span class="comment">// 内核内存池</span></span><br><span class="line">   PF_USER = <span class="number">2</span>     <span class="comment">// 用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_1  1<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_0  0<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_R  0<span class="comment">// R/W 属性位值, 读/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_W  2<span class="comment">// R/W 属性位值, 读/写/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_S  0<span class="comment">// U/S 属性位值, 系统级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_U  4<span class="comment">// U/S 属性位值, 用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">mem_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">malloc_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br></pre></td></tr></table></figure><ul><li>pool_flags 为枚举，用来指明当前的操作对象是内核内存池还是用户内存池。</li><li>第 18~23 行为页表项/目录项的属性，这将在我们创建页表项和页目录项时用到。读者可能已经忘了页表项/页目录项的格式：<br><img src="/2022/img/IMG_0526(20221115-170651)-1670564791259-2.png" alt="" style="zoom:67%;" /><br>关于这些属性的详细介绍，请回顾<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr对应的页目录表索引,其实直接addr&gt;&gt;22也是可以的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr对应的页表索引</span></span></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START   0xc0100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,</span></span><br><span class="line"><span class="comment"> * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pf == PF_KERNEL) </span><br><span class="line">   &#123;</span><br><span class="line">      bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">      <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span>(cnt &lt; pg_cnt)       <span class="comment">//将申请到的位置1,表示已使用</span></span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">      vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pte指针*/</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pde的指针 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 0xfffff是用来访问到页目录表本身所在的地址 */</span></span><br><span class="line">   <span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在m_pool指向的物理内存池中分配1个物理页,</span></span><br><span class="line"><span class="comment"> * 成功则返回页框的物理地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 扫描和设置位图要保证原子操作 */</span></span><br><span class="line">   <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>); <span class="comment">// 找一个物理页面</span></span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);       <span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">   <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>  vaddr = (<span class="type">uint32_t</span>)_vaddr;</span><br><span class="line">   <span class="type">uint32_t</span>  page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">   <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">   <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,可能会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">   <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">   <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>)           <span class="comment">//页目录项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">   &#123;                            <span class="comment">//如果存在，则添加映射(安装页表项)</span></span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);  <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                             <span class="comment">//如果页目录项对应的页表不存在,则先创建页表再创建页表项. </span></span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="comment">/* 页表所用页框一律从内核空间分配 */</span></span><br><span class="line">      <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool); <span class="comment">//申请页表空间</span></span><br><span class="line">      *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);     <span class="comment">//安装页目录项</span></span><br><span class="line">      <span class="comment">/* 以下将分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">       * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">       * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">       * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">       * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);    <span class="comment">//将申请到的页表清零</span></span><br><span class="line">      assert(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">//注册页表项</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   assert(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);       <span class="comment">//3840页内存=15MB</span></span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line">   <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">   <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">void</span>* page_phyaddr = palloc(mem_pool);      <span class="comment">//palloc每次申请一个物理页</span></span><br><span class="line">      <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)   <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">      &#123;  </span><br><span class="line">          <span class="comment">//回滚,后续补充</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射 </span></span><br><span class="line">      vaddr += PG_SIZE;                          <span class="comment">// 下一个虚拟页</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   <span class="type">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>)  <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">      <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">   <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==========以下是mem_pool_init和mem_init函数,上节已做解析,不再展示。=====================</span></span><br></pre></td></tr></table></figure><p>建议看官阅读代码时，按上面给的函数关系图的顺序进行，这样思路会更加清晰。注释很详细，下面只对几个点做强调：</p><ul><li><p>第 41 行，获取虚拟地址对应的 PTE 地址。如何根据给定的虚拟地址定位相应的页目录和页表？这在<a href="">开启分页-代码详解</a>中提到过，请各位回顾该节，此处不再赘述。</p></li><li><p>第 57 行，“扫描和设置位图要保证原子操作”，这句话的意思是，<strong>扫描和设置位图必须连续，中间不能切换线程</strong> 。这里和线程切换有关，简单作下阐述：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。<strong>由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题</strong> 。因此扫描和设置位图必须保证原子操作。需要注意的是，<strong><font color='orange'>此处代码并没有保证原子性，未来我们会用锁来实现</font></strong> 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></li><li><p>同样是申请页，为什么 vaddr_get() 有申请页数的参数，而 palloc() 没有呢？这个答案在第 100 行 malloc_page() 函数中。这是因为申请的 <strong>虚拟地址必须连续，即必须是一整块虚拟内存；而申请的物理内存则无需连续</strong> （如果要求物理内存连续，则分页机制将彻底变成鸡肋）。所以，申请一大块虚拟内存时，填写你所需的页数参数即可；而申请一大块物理内存时，则需要通过第 115 行的 while() 进行。同时注意，第 58 行的位图扫描，申请个数被指定为 1 。</p></li><li><p><strong><u><font color='gree'>第 79~96 行是需要重点强调的内容</font></u></strong> 。<br>（1）第 79 行判断该 vaddr 对应页目录项是否存在，这句话并不精确，应该是：判断该页目录项对应的页表是否存在。原因是，页目录项一定是存在的（因为页目录表是完整的），不管是现在的内核进程或是将来的用户进程，创建进程时我们都为其开辟一张完整的页目录表内存，<u>只是说可能并不会为所有的页目录项填写信息（安装页目录项）</u>。有人会问，既然并非每个页目录项都记录了信息，那怎么还能通过 79 行的 if 语句判断目录项对应的页表是否存在呢？好问题！<strong>这就是第 133 行将申请到的页内存全部清零的原因</strong> 。将来我们为用户进程开辟页目录表时，会通过 get_kernel_pages() 申请一页内存，并将其作为页目录表。此时页目录表所占字节全为 0（第133行），因此每个页目录项中的 P 位也为 0（表示不对应任何页表），如此一来，就可以通过 P 位来判断该目录项对应的页表是否存在。也就是说，如果不显式安装页目录项，则 P=0，无对应页表。<br>（2）第 85 行注释，<strong><font color='orange'>不论是内核页表还是用户页表，所用页框一律从内核空间分配</font></strong> 。注意，用户进程的页目录表/页表存放在内核空间而非用户空间中，否则恶意用户进程就可以通过某些方式修改内存映射，从而访问内核或其他进程的物理内存。<strong>因此，内存管理都由内核负责！</strong><br>（3）第 93 行，与前类似，须将申请到的页表内存初始化为 0，这样访问某虚拟地址时，如果对应的页表项不存在，即 P=0，则引发缺页异常。注意，笔者最初很疑惑为什么不直接利用 pde_phyadd 清零页表：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pde_phyadd, <span class="number">0</span>, PG_SIZE);</span><br></pre></td></tr></table></figure><p>这是因为：<strong><font color='orange'>由于开启了分页，即使 pde_phyadd 为页表的物理地址，编译器也会将其看作虚拟地址</font></strong> ，所以此方式清零的内存并非物理地址 pde_phyadd！经过第 87 行安装页目录项后，<code>(void*)((int)pte &amp; 0xfffff000)</code> 对应的物理地址才是 pde_phyadd 。这里很绕，请读者反复理解！</p><blockquote><p>内核的页目录被创建时也被初始化为 0，参见<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中 loader.s 的第 122 行代码。</p></blockquote><blockquote><p>在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">分页机制</a>中我们说过，页目录表必须完整，通过以上解析，大家理解了其中的原因吗？由于页目录表已经覆盖所有地址，页表才能够按需创建，这相比于一级页表，大大节省了页表所占用的内存。</p></blockquote><blockquote><p>实际上，只有在用户进程中才会出现页目录项对应的页表不存在的情况。内核代码只运行在 1MB 内，内核堆的约 1GB 空间也已经提前创建好了页表（第769~1022号页表），所以内核不会出现此情况。</p></blockquote></li><li><p>vaddr_get()、palloc()、page_table_add() 均被声明为静态函数，这是因为这三个函数仅供 malloc_page() 函数使用，对外部不可见。</p></li></ul><p><img src="/2022/img/image-20221211151606411.png" alt=""></p><p>OK，本节就到这里，内容少但密度大，注意消化。</p>]]></content>
    
    
    <summary type="html">内存管理, 操作系统, 分配页内存</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>详解字符串操作函数</title>
    <link href="http://jyxcpp.netlify.app/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
    <id>http://jyxcpp.netlify.app/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</id>
    <published>2022-12-05T13:23:06.000Z</published>
    <updated>2023-03-12T11:20:58.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>string</code></p></blockquote><p>下节我们将要实现内存管理，这不可避免地要频繁使用到 memcpy、memset 等函数，有了内存操作函数就很容易实现字符串操作函数 strcpy、strcat 等。所以这节我们来实现内存操作和字符串操作函数。本节内容虽然简单，但有许多代码规范需要注意，还请读者不可掉以轻心。</p><p><strong><mark class="hl-label blue">memset</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst, <span class="type">char</span> var, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((size--) &gt; <span class="number">0</span>)</span><br><span class="line">        *tmp++ = var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，<code>void*</code> 是无法直接作指针运算的，因为编译器无法确定其步长及其解释方式</font></strong> 。因此，需要定义 <code>unsigned char* tmp</code> 来代替 <code>void* dst</code> ，tmp 指针的步长即为 1 字节。以下同理。</p><blockquote><p>什么是指针的步长？就是指 <code>++</code> 或 <code>--</code> 时指针移动的字节数。<br>什么是解释方式？就是指定编译器如何去解释指针所指向的这个数据。</p></blockquote><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">void</span>* src, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    src = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">    dst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(size--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">        dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有以下两点需要注意：</p><ol><li>规范问题：能直接 <code>assert(dst!=NULL &amp;&amp; src!=NULL)</code> 吗？<br>当然可以，但出问题时，你怎么确定是 dst 还是 src 的问题？所以最好细化，便于追踪错误。</li><li>解决了 <strong><font color='orange'>内存重叠</font></strong> 的问题，参考<a href="https://jyx-fyh.github.io/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/">memcpy和memmove</a> 。</li></ol><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* mem1, <span class="type">const</span> <span class="type">void</span>* mem2, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(mem1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(mem2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp1 = mem1;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp2 = mem2;</span><br><span class="line">    <span class="keyword">while</span>((size++) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp1 != *tmp2)</span><br><span class="line">            <span class="keyword">return</span> *tmp1 &gt; *tmp2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        tmp1++;</span><br><span class="line">        tmp2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst,<span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串 src 是不会被改变的，所以要声明为 const 。</li><li>注意第 5 行的检查，这是我们容易忽略的地方。</li><li>第 8 行，赋值运算符也是有返回值的，其返回所赋的值，即 <code>*src</code> 。</li></ul><p>上面代码看上去无懈可击，实际上也存在内存重叠的问题：<br><img src="/2022/img/image-20221205235315941.png" alt="存在内存重叠时，报错"></p><p>因此将代码改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src)+<span class="number">1</span>); <span class="comment">//+1是包括&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20221205235435072.png" alt="修改代码后，正常运行"></p><p><strong><mark class="hl-label blue">strlen</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp++);</span><br><span class="line">    <span class="keyword">return</span> tmp-str<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 -1 可别忘了。</p><blockquote><p>这种方式很容易忽略 1，保险可采用此方式：<code>while(*tmp) tmp++;</code> ；如此就无需减 1 。</p></blockquote><p><strong><mark class="hl-label blue">strcmp</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *dst==*src)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *dst &lt; *src ? <span class="number">-1</span> : *dst &gt; *src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第 10 行，把 0、1、-1三种情况都概括了，很漂亮的方式。</p><p><strong><mark class="hl-label blue">strchr与strrchr</mark> </strong><br>strchr ：参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str &amp;&amp; *str != ch)</span><br><span class="line">        str++;</span><br><span class="line">    <span class="keyword">if</span> (*str == ch)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strrchr ：参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* last_char = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch) </span><br><span class="line">            last_char = str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)last_char;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcat</mark> </strong><br>string-concatenate：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//通过strcpy来实现strcat函数</span></span><br><span class="line">    <span class="built_in">strcpy</span> (dst + <span class="built_in">strlen</span> (dst), src);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strchrs</mark> </strong><br>string-char-reserch：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strchrs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = src;</span><br><span class="line">    <span class="keyword">while</span>(*tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == ch)</span><br><span class="line">            cnt++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">详解字符串操作函数</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程-基础-加载线程</title>
    <link href="http://jyxcpp.netlify.app/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://jyxcpp.netlify.app/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-03T12:47:40.000Z</published>
    <updated>2023-03-12T11:21:00.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://blog.csdn.net/qq_26442553/article/details/78729793">并发和并行</a>，<a href="https://cloud.tencent.com/developer/article/1688297">区分进程和线程</a>，《操作系统真相还原》《操作系统哲学原理》<br>本节分支：<code>thread</code></p></blockquote><p>嚯，跨过千山万水，咋们终于要实现线程啦！这是既内存管理后，笔者最期待的部分。正式开干前，先让我们了解一下本节的学习框架。</p><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>并发和并行、同步与异步</font></strong><br>这是常见而又容易混淆的几种关于任务执行的概念，它们与线程、进程息息相关。</li><li><strong><font color='gree'>任务、进程、线程</font></strong><br>任务是 CPU 的最小调度单元；任务既可以是线程，也可以是进程；<strong>线程是在进程基础上进行的第二次并发</strong> 。</li><li><strong><font color='gree'>PCB</font></strong><br>进程/线程的身份证，用于存放进程/线程的管理和控制信息。</li><li><strong><font color='gree'>线程的内核态与用户态实现</font></strong><br>粗略了解这两种方式的优缺点以及现代操作系统对线程的实现模型。</li><li><strong><font color='gree'>线程实现</font></strong><br>初步实现线程，这是下节实现任务调度的基础。</li></ul><h3 id="font-color-red-并发与并行、同步与异步-font"><font color='red'>并发与并行、同步与异步</font></h3><p><strong><mark class="hl-label blue">并发和并行</mark> </strong><br><strong>并发又称“伪并行”</strong> ，<strong>并发的实质是一个物理 CPU 在若干道程序之间来回切换，每一刻都只有一个任务在 CPU 上执行</strong> ，但因为切换任务的速度相当快，所以看上去是多个任务同时执行。</p><blockquote><p>需要注意的是，伪并行降低的是任务的平均响应时间，也就是说，并发让执行时间短的任务可以不必等待那些执行时间长的任务完全结束后再被调度，因此任务的响应速度快了许多；然而，<strong>所有任务的总执行时间实际上不减反增，这是因为任务切换也需要时间</strong> 。但显然，如果能让后面的紧急任务能够及时完成，这点时间成本是微不足道的。</p></blockquote><p><strong>并行则是真正意义上的多个任务同时执行，这必须建立在多核处理器的基础上，每个任务在不同的核上进行</strong> 。<br>另外，还有一个常见的名字是“串行”，并行和串行都指任务的执行方式。<strong>串行是指存在多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个</strong> ，并发的工作方式即为串行。</p><p><strong><mark class="hl-label blue">同步和异步</mark> </strong></p><p>同步和异步，以及阻塞和非阻塞，这两组概览看上去简单，实际上有很多细节需要区分。笔者尚未有讲解该知识点的能力，详细请参考<a href="https://www.zhihu.com/question/19732473/answer/241673170">同步和异步、阻塞与非阻塞</a> 。</p><h3 id="font-color-red-任务、进程、线程-font"><font color='red'>任务、进程、线程</font></h3><p>任务是一个相对而言比较抽象的概念，它是软件发起的某一个活动，其既可以是线程，也可以是进程。<strong><u>任务是独立的执行流，每个任务都具备自己的一套资源（栈、寄存器映像等），这些资源是保证该任务能够被 CPU 单独执行的关键</u></strong> ！什么叫做被 CPU 单独执行呢？举个例子：在 A 任务中调用了 func() 函数，这个 func() 函数是随 A 任务一块被带上处理器的，实际的调度单元是 A 任务而非该函数，换句话说，这个函数是在更大的执行流（A任务）中被“夹杂着、捎带着”执行的，甚至有可能没有等到执行该函数，任务 A 就被换下了 CPU 。在这个例子中，任务 A 为调度单元，即被 CPU 单独执行。如果我们想让 func() 函数成为单独的执行流，就必须为它分配上下文环境，使其成为任务。</p><p><strong><u>线程是任务调度的基本单位</u></strong> ，是独立的执行流，而进程则是多个线程的集合。它们的联系与区别如下：</p><ul><li><p>进程是对运行时程序的封装，是 <strong><font color='gree'>系统进行资源调度和分配的的基本单位</font>，实现了操作系统层面上的并发</strong> ；线程是进程的子任务，<strong><font color='gree'>是 CPU 任务调度和分派的基本单位</font>，是在进程基础上实现的第二次并发</strong> 。</p></li><li><p>一个进程可以有多个线程，<strong><font color='gree'>同一进程的所有线程共享该进程的资源</font></strong> ，如<u>地址空间</u>、代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）；<strong><font color='gree'>但是每个线程拥有自己的栈段，用来存放所有局部变量和临时变量</font></strong> 。</p><blockquote><p>需要强调的是，每个进程都有自己的 4GB 虚拟空间，同一进程内的线程共享该虚拟空间。</p></blockquote></li><li><p>进程可分为单线程进程与多线程进程，在我们平时写的程序中，<u>如果没有显式创建线程，那么该程序就是单线程进程</u>。线程不能独立于进程而存在。</p></li><li><p><strong><font color='gree'>进程=资源+线程</font></strong> 。</p></li></ul><blockquote><p><strong><font color='red'>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务。这个task_struct 数据结构囊括了进程管理生命周期中的各种信息</font></strong> 。</p></blockquote><p>刚才我们提到，在某个任务中调用 func() 函数，则此函数是随该任务一起被放上 CPU 执行的，并非单独的执行流。那么有没有方法能够使某个函数成为单独的执行流呢？有，就是通过线程。<strong>在高级语言中，线程是运行函数的一种方式</strong> ，与普通函数的执行方式不同，线程机制可以为函数创造它所依赖的上下文环境，使函数代码具有独立性，进而能被 CPU 单独调度。下面是 Linux 下 C 语言创建线程的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ThreadFun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg is NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">char</span> * url = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="comment">//定义两个表示线程的变量（标识符）</span></span><br><span class="line">    <span class="type">pthread_t</span> myThread1,myThread2;</span><br><span class="line">    <span class="comment">//创建 myThread1 线程</span></span><br><span class="line">    res = pthread_create(&amp;myThread1, <span class="literal">NULL</span>, ThreadFun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>暂不深究 pthread_create() 函数，有兴趣的同学请自行研究。</p></blockquote><p><strong><mark class="hl-label blue">有了进程为什么还要引入线程？</mark> </strong></p><ul><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，线程之间切换的开销小。所以线程的创建、销毁、调度性能远远优于进程。</li><li>同一进程内的线程共享资源，因此它们之间相互通信无须调用内核，比进程间通信更方便。</li><li>进程采用多个线程（执行流）和其他进程抢占处理器资源，从而节省单个进程的总时间。</li><li>避免某些阻塞使整个进程都被挂起。</li></ul><blockquote><p>那么，在同一个进程下，哪些资源被线程共享，哪些又是线程私享的呢？一般的评判标准是：如果资源独享会导致线程运行错误，则该资源由线程共享。下表给出一般情况下的共享与独享资源划分：</p><table><thead><tr><th>线程共享资源</th><th>线程独享资源</th></tr></thead><tbody><tr><td>地址空间</td><td>栈</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开的文件</td><td>状态字</td></tr><tr><td>子进程</td><td>程序计数器</td></tr><tr><td>堆</td><td>…</td></tr><tr><td>…</td><td></td></tr></tbody></table></blockquote><h3 id="font-color-red-PCB-font"><font color='red'>PCB</font></h3><p>PCB(Process Control Block，程序控制块)，用于唯一地标识一个进程和记录进程的相关信息。<strong><u>PCB 的具体格式并不固定，这取决于操作系统厂商</u></strong> 。PCB 的一些基本信息如下：</p><table><thead><tr><th>内核栈</th><th><strong>内核栈指针</strong></th><th>优先级</th><th>PID</th><th>时间片</th><th>页目录表指针</th><th><strong>进程状态</strong></th><th>…</th></tr></thead></table><p>现代操作系统的 PCB 已经相当复杂，加之笔者也没有深入了解，因此本文不再对其展开，只说我们后面将要用到的东西以及重点内容：</p><ul><li><p>我们的操作系统较小，<strong>PCB 只会占到一页内存</strong> 。<strong><font color='orange'>在 PCB 的顶部是内核栈，内核栈分为中断栈与任务栈；PCB 底端则是 PCB 的相关信息，如栈指针、PID、时间片等</font></strong> 。这点在 <a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理基础</a>中说过，忘记的同学还请回头看看。</p><blockquote><p>既然是内核栈，<strong><font color='gree'>说明此栈是在 ring0 下使用的栈，而非 ring3 下的用户栈</font></strong> 。就因为栈在 PCB 中，所以 PCB 才会占一页的大小。<u>为什么要为每个线程都分配一个内核栈呢</u>？大概有以下原因：</p><ul><li>线程切换就是通过栈切换来实现的（下节内容），如果所有线程共享一个栈，就没法完成任务调度啦。</li><li>将线程相关的所有资源的集中在一起，方便管理。比如线程执行后需要销毁，由于 PCB 中存放着该任务的所有资源，所以直接回收该 PCB 就行了，无需其他多余动作（当然，堆管理另说，这由程序员自己负责 free，否则内存泄漏）。</li></ul></blockquote></li><li><p>不是说同一个进程下的线程共享虚拟空间吗，那为什么 PCB 中还会有页目录表指针呢？是这样的，<strong><font color='gree'>Linux 中不论线程还是进程，都统一由 task_struct 结构体管理，对于线程，页目录表指针被初始化为 NULL；对于进程，页目录表指针指向该进程的页目录表起始地址</font></strong> 。这是线程和进程的最大区别。另外，在进程创建之初，会重新加载 CR2 寄存器（该寄存器中存放的是页目录表的物理地址），这将在后续实现用户进程时提到。</p></li><li><p>优先级并不是说谁先执行，而是指定每次任务执行时所经历的中断次数。初始状态下，时间片等于优先级。之前说过，<strong><u>任务切换是由时钟中断驱动的，也就是说任务调度是在时钟中断处理函数中进行的</u></strong> 。当 A 任务刚被调度上 CPU 时，时间片被初始化为优先级，之后每发生一次中断，时间片就自减 1，当时间片等于 0 时，该任务被换下 CPU 。因此，<strong>优先级越大，占用 CPU 的时间就越长</strong> 。</p></li><li><p>严格来说，<strong><font color='gree'>内核栈指针并不是用来指向内核栈的（内核栈永远位于 PCB 顶端），它是用来指向内核寄存器现场的</font></strong> 。读者看完这句话一定是一头雾水，不急，该指针是任务切换的核心，下节我们会重点剖析该指针的作用，敬请期待。</p></li><li><p><strong>PID就是各进程的身份标识</strong> ，程序一运行系统就会自动分配给进程一个独一无二的 PID 。<strong>PID 只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程</strong> 。PID 将在后续添加，目前暂时不用。</p></li><li><p>一般来说，<strong><font color='gree'>按进程在执行过程中的不同情况至少要定义三种不同的进程状态：运行态(running)、就绪态(ready)、阻塞态(blocked)</font></strong>  。在我们的操作系统中，定义了六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead)。这几态的作用将在后续实现一一体现。</p><blockquote><p>虽然叫做“进程状态”，但这可不意味着只有进程才能使用这个信息，线程同样能使用。</p></blockquote></li></ul><h3 id="font-color-red-线程的内核态与用户态实现-font"><font color='red'>线程的内核态与用户态实现</font></h3><p>由于线程依附于进程而存在，所以其储存方案无需额外设计，而是直接使用进程的储存方案（这就是 Linux 中进程和线程都是用 task_struct 结构体作为任务信息存储结构的原因）。虽然进程与线程采用了相同的储存方案，但两者的调度方式却有所不同。线程产生于进程，理所当然的，其调度就可以由进程负责（用户态）；另一方面，线程调度也可以交给操作系统来管理（内核态）。</p><blockquote><p>进程调度只能由操作系统负责，并不存在用户态一说。</p></blockquote><p><strong><mark class="hl-label blue">内核态实现</mark> </strong><br><strong>优点：</strong></p><ol><li><p>并发性高。采用与进程类似的调度方式，从而使线程实现进程级并发。</p><blockquote><p>什么是进程级并发？由于操作系统直接控制进程，所以当某个进程被阻塞时，操作系统能够立刻检测到这个情况并将其他进程调度上 CPU 。对于内核态实现的线程而言，当某个线程被阻塞，操作系统也可以立即反应过来，并将其他线程调度上 CPU。</p></blockquote></li><li><p>简化用户编程。线程的复杂性由操作系统承担，程序员无需关心线程的调度。</p></li><li><p>提升了进程的速度。当进程内的线程较多时，该进程占据的 CPU 资源就更多，执行时间就越短。</p></li></ol><p><strong>缺点：</strong></p><ol><li>效率较低。每次调度都需要进入内核态，多了些现场保护的栈操作，因此减小了效率。</li><li>占用稀缺的内核资源。线程的数量远多于进程数，因此随着线程的数量增加，内核空间将迅速被耗尽。</li><li>内核态的实现需要修改操作系统。这在提出线程的初期是很难办到的，操作系统厂商可不会轻易将一个未被证明的新概念加入到操作系统中。因此，最初只能由用户自己管理线程。</li></ol><p><strong><mark class="hl-label blue">用户态实现</mark> </strong><br><strong>优点：</strong></p><ol><li>灵活性高。操作系统不知道线程的存在，其仅对用户可见，因此在任何操作系统上都能够实现此方式。</li><li>切换效率高。无需进入内核态，减少了栈操作。</li></ol><p><strong>缺点：</strong></p><ol><li>编程变得复杂。不同于由时钟中断驱动的内核态任务调度，程序员必须时刻考虑什么时候主动让出 CPU ，将控制权交给其他线程。实际上，一旦线程多起来，人为管理将是巨大麻烦。</li><li>无法实现进程级并发。用户态实现下，当进程中的某个线程被阻塞，这将使整个进程都被阻塞！这是致命的缺点。</li></ol><p><strong><mark class="hl-label blue">现代操作系统的线程实现模型</mark> </strong><br>现代操作系统对以上两种实现取其精华、剔其糟粕，将二者有机结合：<strong><u>用户态负责进程内部在非阻塞时的切换；内核态负责线程阻塞时的切换</u></strong> 。同时，每个内核态线程可以负责多个用户态线程，比如，某进程有 5 个线程，操作系统将这 5 个线程划分为两组，一组 2 个，另一组 3 个，每组使用一个内核线程，如下图：</p><img src="/2022/img/IMG_0564(20221216-100357).PNG" style="zoom:67%;" />当某个线程阻塞时，同组的线程皆被阻塞，当另一组仍可继续执行。如此一来，该模型就缓解了以上两种方式的缺点：<ol><li>不必为每个线程都创建对应的内核线程，减小了内核资源的压力。</li><li>不会因为一个线程的阻塞而使整个进程被挂起。</li><li>用户态线程的切换无需经过内核，提高了效率。</li></ol><p><strong>注意，为了简单，本操作系统仅使用内核态实现。</strong></p><h3 id="font-color-red-实现线程-font"><font color='red'>实现线程</font></h3><p>本节是对线程的简单实现，主要让大家理解操作系统是如何 <strong><font color='orange'><u>通过栈切换来完成线程切换的</u></font></strong> 。下面先看 thread.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>*)</span>; <span class="comment">//使用typedef自定义函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TASK_RUNNING,</span><br><span class="line">    TASK_READY,</span><br><span class="line">    TASK_BLOCKED,</span><br><span class="line">    TASK_WAITING,</span><br><span class="line">    TASK_HANGING,</span><br><span class="line">    TASK_DIED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> vec_num;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esp_dummy;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="comment">//------以下为CPU自动压入------------</span></span><br><span class="line">    <span class="type">uint32_t</span> err_code;</span><br><span class="line">    <span class="type">void</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="comment">//------以下为发生特权级转移时自动压入-----</span></span><br><span class="line">    <span class="type">void</span>* esp;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*eip) (thread_func* func, <span class="type">void</span>* func_arg);</span><br><span class="line">    <span class="type">void</span>* unused_retaddr;</span><br><span class="line">    thread_func* function;</span><br><span class="line">    <span class="type">void</span>* func_arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程或线程的pcb,程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;   <span class="comment">//内核栈指针</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span> <span class="comment">//任务状态</span></span><br><span class="line">    <span class="type">uint8_t</span> priority;        <span class="comment">//优先级</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];           <span class="comment">//任务名</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;    <span class="comment">//魔数，用于检测PCB是否被栈破坏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span>;</span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第 4 行 task_status 枚举定义了前文提到的六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead) 。</p></li><li><p>第 14 行定义了中断栈。注意，结构体中靠前的成员位于内存低地址，靠后的成员位于高地址，所以可发现，结构体成员的声明顺序和 <code>interrupt.s</code> 中的压栈顺序是对应的：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE25.png" alt=""><br><strong>必须要说明的是，虽然这两者是一一对应的关系，但我们并不会通过 <code>intr_stack</code> 结构体来取得栈中寄存器的值</strong> ！原因有两点：</p><p>1）没必要取得这些寄存器的值，它们仅用来保护现场。为了安全，也不建议获取它们的值；<br>2）无法保证一定是一一对应的关系。比如，最下方的 SS 和 ESP，此二者仅在发生特权级转移时才会压入，所以是否发生特权级转移将直接影响其对应关系。因此，无法通过该结构体获取栈中的值。那为什么还要声明这个结构体呢？没有其他原因，<strong><u>只是为了得到该中断栈的大小</u></strong> ，以便后续跳过该栈。</p></li><li><p>第 39 行是线程栈，该栈有两个作用：<br>1）保存任务调度的现场，即 ebp、ebx、edi、esi 这四个寄存器。为什么只保存这四个寄存器？这涉及到 ABI，见<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C与汇编混合编程</a>。<br>2）指定线程中要运行的函数及其参数。即最后四个成员。下面重点说说这几个成员：</p><ul><li><p>eip：创建线程时，我们会将 eip 指向 kernel_thread() 函数，通过 kernel_thread 来调用想运行的函数：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span>&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unused_retaddr：这是用来占位的，没有其他作用。为什么要占位？说来话长。进入 kernel_thread() 时，并不是通过 <code>call</code> 指令来调用的，而是 <code>ret</code> 指令。什么不伦不类、莫名其妙的玩意儿？？？干嘛用 <code>ret</code> 来调用函数？读者朋友请别急，笔者初学此处时也是一脸懵逼，现在暂时无法解释，等到下节任务调度时笔者会专门解析这一点，现在只需记住，<u>kernel_thread() 是在 <code>switch.s</code> 中通过 <code>ret</code> 指令进入的</u> 。那么问题来了，<strong>kernel_thread() 是 C 语言写的函数，C 默认这个函数是 call 调用的，所以在寻参时会跳过 call 指令留下的返回地址（call下一条指令的地址）</strong> 。正常调用 kernel_thread() 函数时，其反汇编大致如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push  func_arg</span><br><span class="line">push  function</span><br><span class="line">call  kernel_thread </span><br><span class="line">;------------------进入kernel_thread后</span><br><span class="line">push  [esp-8]</span><br><span class="line">call  function</span><br></pre></td></tr></table></figure><p>其中 <code>[esp-8]</code> 就是寻参，寻的是 func_arg 参数，<strong><u>减 8 则是跳过返回地址和 function 参数</u></strong> 。由于我们用的是 <code>ret</code> 而非 <code>call</code> ，所以必须手动为 kernel_thread() 营造是 call 指令的假象，即，将原本的返回地址用占位符代替，以确保能够正确寻参。</p><blockquote><p>爱思考的读者可能会问，既然我们将返回地址用占位符代替，那这岂不是意味着 kernel_thread() 运行完毕后无法正确地返回？是的，它不能像普通函数那样返回，因为它本身可不普通，它可是运行在线程里的、高贵的函数。哈哈，开个玩笑，这点我们也会在下节中剖析。</p></blockquote></li><li><p>function 和 func_arg 的作用见上一点。值得一提的是，<strong>线程函数(function)的参数必须为 void</strong>* ！<strong>这是为了应对需要向线程函数传递多个参数的情况：<font color='gree'>当需要传递多个参数时，需要将这些参数包装成结构体，并将结构体指针传入即可。如果不使用此方式，想传几个参数就传几个，那么栈操作就无法统一，任务切换也无从谈起。</font></strong></p></li></ul></li><li><p>第 53 行的 task_struct 就是我们的线程控制块啦！前三个成员在前文提到过，这里重点讲解 stack_magic 是如何检测 PCB 是否被破坏的。我们已经知道，内核栈在 PCB 的顶部（高地址处），任务信息在 PCB 的底部（低地址处），由于栈是由高地址向低地址扩展的，所以在某些情况下栈可能会覆盖低地址的 task_struct ：<br><img src="/2022/img/未命名绘图26.png" style="zoom:80%;" /><br>可见，只要 task_struct 被破坏，那么最先被覆盖的一定是 stack_magic（这也是为什么将 stack_magic 声明在最后的原因） ，所以可以通过检测该魔数来判定是否发生破坏。stack_magic 任由你自己决定，应适当复杂。</p></li></ul><p>接着来看 thread.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>* <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line">    pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE); <span class="comment">//将栈指针指向PCB顶端,即栈底</span></span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  name:线程名</span></span><br><span class="line"><span class="comment">*  prio:线程优先级</span></span><br><span class="line"><span class="comment">*  function:执行函数</span></span><br><span class="line"><span class="comment">*  func_arg:函数参数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>); <span class="comment">//pcb都位于内核空间,包括用户进程的pcb也是在内核空间</span></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="built_in">stack</span> = thread-&gt;self_kstack;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebp&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebx&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop edi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop esi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ret&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='gree'>先理理线程创建的整体思路：</font></strong></p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息，包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>代码逻辑比较清晰，下面讲解重点内容：</p><ul><li><p>第 40 行，向内核申请一页内存用来存放 PCB 。之前说过，<strong><u>我们的线程采用内核态实现，由内核管理所有线程，所以必须从内核空间申请</u></strong> 。</p></li><li><p>第 12、13 行减去中断栈和线程栈，使 self_stack 指向线程栈的起点，这是为了让线程栈与 self_stack 结构体一一对应，使相关信息能够准确写入线程栈的正确位置。<strong><font color='orange'>注意，不同于中断栈，我们不会通过 inr_stack 结构体向中断栈赋值或取值；而对于线程栈，我们必须精确赋值，不能将位置搞错，一旦错位，就无法进入线程函数来实行任务啦</font></strong> ！</p></li><li><p>第 18 行，此四个寄存器可初始化为 0，下节你明白为什么。</p></li><li><p>第 44 行就是我们之前常听到的栈切换了，这是任务切换的最关键一步。切换栈很简单，就是通过修改 esp 的指向来完成的。对了，为什么要用静态全局变量 stack 来中转呢？这种用法在<a href="https://jyx-fyh.github.io/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/">assert断言</a>中已经提到过了，由于第 44 行是内联汇编，<strong>汇编只认识全局符号</strong> ，所以我们要使用一个全局变量来中转。经过下面的 4 次 pop 后，esp 便指向了 eip，而 eip 在 <code>thread_create()</code> 中被指向了 <code>kernel_thread()</code> 函数，所以接下来的 <code>ret</code> 指令就会进入到此函数中。之后，<code>kernel_thread()</code> 调用 <code>function()</code> ，开始执行任务。图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE27.png" alt=""></p><blockquote><p>这几句汇编这是我们这节临时使用的方案，下节实现任务切换时会使用正规方法。</p></blockquote></li><li><p>读者朋友可能已经发现，<code>thread_create()</code> 第三个参数是一个 void 指针，用来传递线程函数所需要的参数。问题是，为什么要用 void 指针来传递参数呢？而且万一要传递多个参数，那怎么办？很简单，将多个参数封装成一个结构体，然后将该结构体的指针传入该函数，然后在线程函数中解包就ok了。那么，传指针是唯一的方法吗？能不能学习 printf，使用可变参数列表来进行传参呢，这样可多方便呐！好问题！当你彻底理解任务调度和切换后（本小节和下一小节），你将明白为什么不能使用可变参数列表。</p></li></ul><p><img src="/2022/img/image-20221216210636536.png" alt=""></p><p>本文结束，休息一会，请移步<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程-进阶-任务调度</a> 。</p>]]></content>
    
    
    <summary type="html">自制操作系统, 线程, 实现, 线程切换, 操作系统真相还原</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>内存管理-基础-初始化内存池</title>
    <link href="http://jyxcpp.netlify.app/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://jyxcpp.netlify.app/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-12-02T11:48:14.000Z</published>
    <updated>2023-03-12T11:21:07.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>memory</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong>操作系统内存管理可以说是操作系统中最重要的部分</strong> ，它是未来所有工作的基础。内存管理相当复杂，大约有如下内容：<br><img src="/2022/img/v2-4c9fcddd65b35e84c4c6783aaeee3826_720w.jpg" alt="操作系统—内存管理"></p><p>但本节并不会讨论以上全部内容，而是根据我们自制操作系统的需要来进行。我们当前的任务是完成操作系统的内存划分（本节）以及虚拟内存的申请（下节），即虚拟空间到物理内存的映射，其他内容咋们后续按需补充。本节内容如下：</p><ol><li><strong><font color='orange'>通过 BIOS 中断获取内存容量</font></strong><br>既然要分配内存，就一定需要知道系统的内存容量有多大，这通过 BIOS 中断来获取。</li><li><strong><font color='orange'>通过位图来管理内存</font></strong><br>管理内存时，肯定需要知道哪些内存已经被使用，哪些还没有使用，这些信息通过我们自己维护的位图来获取。</li><li><strong><font color='orange'>规划内存池</font></strong><br>管理内存前，当然还需要对内存做出规划，比如，哪些内存给内核使用，哪些内存又给用户使用。</li><li><strong><font color='orange'>向页表填写映射关系</font></strong><br>我们早就实现了分页机制，就差向其中填入映射关系啦！笔者期待已久，让我们开始吧。</li></ol><h3 id="font-color-red-获取内存容量-font"><font color='red'>获取内存容量</font></h3><p>获取内存容量的例程已经由操作系统厂商写好并存入了 BIOS 中，因此我们只需要调用 BIOS 中断即可。现在问题是，进入保护模式后，BIOS 中断无法再被调用，这怎么办呢？不得已，<strong>我们只能回到 loader.s 中，即进入保护模式之前调用 BIOS 中断</strong> 。</p><blockquote><p><strong>为什么进入保护模式后不能再使用 BIOS 中断</strong> ？</p><ol><li>BIOS 中断例程的地址存放在中断向量表（IVT）中，实模式下使用 <code>int</code> 指令调用中断时，会跳转到 IVT 描述符指向的例程地址；而保护模式下使用 <code>int</code> 指令调用中断时，则是跳转到 IDT 描述符所指向的例程。因此，IVT 不再有效。</li><li>BIOS 中断例程是在实模式，即 16 位模式下运行的代码，这些代码并不能直接运行在 32 位保护模式下。</li></ol></blockquote><p>Linux 采用了三种方式来检测内存容量，如果一种方式失败，就调用下一种，全部失败则挂起。这三种方式都是通过调用 0x15 号 BIOS 中断来进行的，它们的功能号及其特点为：</p><ul><li>EAX = 0xE820 ：遍历主机所有内存。</li><li>AX   = 0xE801 ：最大支持 4GB 。</li><li>AH   = 0x88     ：最大支持 64 MB 内存。</li></ul><blockquote><p>功能号需要装在 EAX 或 AX 中。</p></blockquote><p>由于咋们的操作系统最大不会超过 100 KB，因此我们只使用第三种方式，即 0x88 功能号。因为该部分只需要调用中断，没有其他需要强调或理解的地方，所以此处笔者就不详细记录这三个功能号的中断参数和用途了，详情还请读者朋友移步《操作系统真相还原》第 177 页。下面只贴出我们要用到的 0x88 功能号：<br><img src="/2022/img/IMG_0561(20221206-184055).PNG" alt=""><br><strong>需要注意两点：</strong></p><ul><li><strong>0x88 功能号返回的内存不包括低端 1 MB，因此我们算总内存时还需要加上 1MB 。</strong></li><li>返回后 AX 中的值以 1KB 为单位，所以还需要换算成以 1 字节为单位。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">total_mem_bytes dd 0</span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88:</span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt     ;CF为0则跳转</span><br><span class="line">   and eax,0x0000FFFF;加上1024,即低端的1MB(1024KB)</span><br><span class="line"></span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16       ;把dx移到高16位</span><br><span class="line">   or edx, eax       ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line">   jmp prepare       ;跳转,准备进入保护模式</span><br><span class="line"></span><br><span class="line">.error_hlt:          ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure><p>代码逻辑很简单，注释也足够清晰，不再赘述。需要强调的是，标号 <code>total_mem_bytes</code> 用来存放所得结果，此结果待会会在 memory.c 中使用，因此，我们还得手动算出该标号所代表的地址，以方便在 C 文件中通过指针引用该值。有读者可能会疑惑了，为什么还得手动算地址呢？难道不能像我们之前那样，使用 <code>global</code> 关键字导出 <code>total_mem_bytes</code> ，然后在 C 文件中声明 <code>extern total_mem_bytes</code> 来直接引用这个变量吗？是的，不能。原因在于，我们链接时并没有将 loader.o 包含进来，看下面的 makefile 语句：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KERNEL=build/guide.o  build/print.o  build/main.o build/interrupt.o build/idt.o build/port_io.o \</span><br><span class="line">       build/timer.o  build/intrmgr.o  build/debug.o  build/string.o  build/memory.o  build/bitmap.o \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0x00001500</span><br></pre></td></tr></table></figure><p>其中并没有包含 loader.s 。我猜到你要说什么了：那就包含 loader.s 呗…昂，kernel.bin 可是咋们的内核呀，现在又将 loader 包含进去，可谓不伦不类啦。所以，我们需要手动算出 <code>total_mem_bytes</code> 的地址值，它的位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段</span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06]</span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;检测出的总内存大小,位于0x90c处.前面一共0xc，即12字节</span><br><span class="line">    total_mem_bytes dd 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;BASE_ADDR=0X900</span><br><span class="line">;dd=4bytes, dw=2bytes</span><br><span class="line">BASE_ADDR+4+2+4+2=0x90c</span><br></pre></td></tr></table></figure><p>因此，<code>total_mem_bytes</code> 的地址为 0x90c 。如此，咋们就轻松获取了内存容量的大小，为 32MB，即 0x2000000<br><img src="/2022/img/image-20221207201205263.png" alt=""></p><h3 id="font-color-red-位图-font"><font color='red'>位图</font></h3><p>位图并不止用于内存管理，<strong><u>它是一种映射，用一个位来表示一个对象的状态</u></strong> 。在之前我们也接触过位图，比如 8259A 中的各个寄存器就是关于 IRQ 的位图。现在，我们要使用位图来管理内存，即用一个位来表示某片内存的状态（是否已经使用）。问题是，一个位应该映射成多大的一片内存呢？通过前面内存分页的学习，我们知道内存是按页来分隔的，一页的大小是 4KB，出于这个原因，我们将一个位映射为 4KB 内存，即一个位管理一页内存。<strong><font color='orange'>如果某位为 1，则表示对应的页已经被使用；为 0 则表示该页为空闲状态，可以使用</font></strong> 。<br><img src="/2022/img/IMG_0562(20221206-193514).PNG" style="zoom:67%;" /></p><p>位图结构体的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> btmp_bytes_len;</span><br><span class="line"><span class="comment">/* 在遍历位图时,整体上以字节为单位,细节上是以位为单位,所以此处位图的指针必须是单字节 */</span></span><br><span class="line">    <span class="type">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>btmp_bytes_len</code> 表示位图的长度，包含的总位数为 btmp_bytes_len*32 。该值由位图所管理的内存大小决定。</li><li><code>bits</code> 为位图的指针。<strong>位图也当然是存放在内存中的，所以我们用 <code>bits</code> 指针来记录位图的起始地址</strong> 。</li></ul><p>需要注意，虽然 <code>bits</code> 是 <code>uint8_t*</code> 型的指针，步长为 1 字节，但实际操作时我们会细化为按位处理，即通过掩码来判断相应位是否为 1 。<br>位图的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>bitmap_init</code> ：用来初始化位图，<strong><u>根据传入的 btmp 参数来决定将哪片内存视为位图，并将其初始化为 0</u></strong> 。</li><li><code>bitmap_scan_test</code> ：用来检测位图中第 <code>bit_idx</code> 位是否为 1，该函数只在 <code>bitmap_apply</code> 中调用。</li><li><code>bitmap_set</code> ：用来将位图中的第 <code>bit_idx</code> 位赋值为 0/1 。</li><li><code>bitmap_apply</code> ：在位图中申请<u>连续</u> <code>cnt</code> 个位，若成功则返回起始位的索引(下标)，失败则返回 -1 。</li></ul><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bitmap.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 7</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断bit_idx位是否为1,若为1则返回true，否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line">    <span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &gt;&gt; bit_odd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line"><span class="comment">/* 先逐字节比较,蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> (( <span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len)</span><br><span class="line">    &#123;  <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位，</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对,返回空闲位的索引。*/</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &gt;&gt; idx_bit) &amp; btmp-&gt;bits[idx_byte])</span><br><span class="line">        idx_bit++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;    <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);  <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>;      <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;      <span class="comment">// 先将其置为-1,若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((bit_left--) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit)))  <span class="comment">// 若next_bit为0</span></span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt)     <span class="comment">//若找到连续的cnt个空位</span></span><br><span class="line">        &#123;</span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将位图btmp的bit_idx位设置为value */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(value == <span class="number">1</span>);</span><br><span class="line">    assert(value == <span class="number">0</span>);</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/</span></span><br><span class="line">    <span class="keyword">if</span> (value)    <span class="comment">// 如果value为1</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 若为0</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释较清晰，下面挑重点解释：</p><ul><li><p>第 13 行，重点理解这个按位检测，逻辑也比较简单。需要说明的是，《真相还原》中的原代码是：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));</span><br><span class="line"><span class="comment">//.......</span></span><br></pre></td></tr></table></figure><p>这和我们的代码效果是相同的，笔者之所以作如此改动，是因为改动之后的逻辑更符合我们直觉，即，位是按顺序排列的：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE23.png" alt=""></p><p>而原代码的逻辑是：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE21.png" alt=""></p></li><li><p>第 41 行，为什么要把 cnt==1 的情况单独拿出来呢？因为后面我们申请物理内存时，物理内存池中的页可以不连续，所以传参时 cnt=1；申请虚拟内存时，必须连续，所以 cnt 不必为 1 。由于会大量用到 cnt=1 的情况，所以单独拿出来，避免再做后续处理以提高效率。</p><blockquote><p>没懂上述解释的同学不用慌，下节内存管理进阶我们还会说到这点。</p></blockquote></li><li><p>第 54 行，每当连续的位被断开时，cnt 就需要清零，因为函数要求的是找出连续的 cnt 个位。</p></li></ul><p>位图的介绍就是这些，下面我们用位图来规划内存。</p><blockquote><p>值得一提的是，位图只是内存管理的一种方法，其他常用的方式还有链表，参见<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">空闲内存管理，位图，空闲链表-CSDN</a></p></blockquote><h3 id="font-color-red-规划内存池-font"><font color='red'>规划内存池</font></h3><p><strong><mark class="hl-label blue">什么是内存池？</mark> </strong></p><p>说得高深一点，内存池是内存集合的抽象；说白了，内存池就是上面所说的用来管理内存的位图。所以，内存池的职责就是管理内存，需要内存时，从内存池（位图）中申请；回收内存时，则归还内存池。</p><blockquote><p>可以将位图理解成内存池的物理形式。既然将内存池等同于位图，就说明<strong>内存池的存取粒度和位图一样，都是以 4KB 为单位</strong> 。</p></blockquote><p><strong><mark class="hl-label blue">如何规划内存池</mark> </strong><br>规划内存池，分为两个大的方向：</p><ol><li><strong><font color='orange'>物理内存和虚拟内存的规划</font></strong></li><li><strong><font color='orange'>用户内存和内核内存的规划</font></strong></li></ol><p>这两者必须结合在一起讨论。我们已经知道，虚拟内存这个概念，其本身是针对于进程而言的，每个进程都有 4GB 的虚拟内存，<u>其中一部分</u>虚拟地址会映射到物理内存。那么，我们就不得不考虑如下两点：</p><ul><li><p>这么多进程都有各自的虚拟空间，它们都会争用物理内存，所以<u><strong>操作系统必须知道哪些物理内存被用了，哪些还未被使用</strong></u> ，因此，我们需要建立物理内存池，以管理物理内存的使用情况。</p></li><li><p>虽然每个进程都有自己的虚拟 4GB 空间，但在进程内部，虚拟内存也不能重复使用，即，<strong><u>虚拟地址在进程内是唯一的</u></strong> 。同样，为了管理虚拟地址的使用情况，我们需要建立虚拟内存池。</p><blockquote><p><strong><font color='orange'>注意，虚拟内存在进程是唯一的，但多个进程之间，可以使用相同的虚拟地址，各自的虚拟地址对外是不可见的，相互独立的！</font></strong></p></blockquote></li></ul><p>除此之外，我们还需要将物理内存分为内核内存和用户内存，这是基于以下两点原因：</p><ul><li>操作系统会占用较多内存，毕竟它是其他用户进程的载体，不仅要引导用户程序的运行，还要负责任务调度，内存开辟等诸多重要任务。</li><li>为了内核的正常运行，<u>不能用户申请多少内存就给多少，否则有可能因为物理内存不足而导致内核自己都不能正常运行</u>。</li></ul><p>因此，咋们专门分出内核的专属内存，其他物理内存则划给用户。</p><p>综上所述，我们最后划出三个内存池：<strong><font color='gree'>1）内核物理内存池；2）内核虚拟内存池；3）用户物理内存池</font></strong> 。<br><strong><font color='red'>有了前两者，当内核申请内存时，便会先从内核虚拟地址池中申请发配虚拟地址，接着从内核物理地址池中申请分配物理地址，最后在内核自己的页表中建立虚拟地址到物理地址的映射关系</font></strong> 。这个过程我们很快就会用代码展现出来。接着，你一定会问，为什么只有用户物理内存池，而没有用户虚拟内存池呢？是这样的，用户物理内存池是供所有用户进程使用的，用户共享这一片物理内存池；而 <strong>用户虚拟内存池则是每个用户进程私有的，当创建用户进程时，也会在其内部开辟虚拟池给自己使用</strong> 。用户虚拟内存池将在我们实现用户进程时介绍。</p><p><strong><mark class="hl-label blue">规划细节</mark> </strong><br>话不多说，先放出本操作系统的具体内存安排：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE20.png" alt=""></p><p>下面对以上内存规划进行阐述：</p><ul><li><p>低端 1 MB 完全给内核使用，内核的代码只运行在这 1MB 内，且低端 1MB 物理内存和虚拟内存是一一映射的。这点在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中讲解过。</p></li><li><p>为什么将这三个内存池位图放在低端 1MB 内呢？因为 <strong><font color='orange'>低端 1MB 是不会放入内存池中的</font></strong> ，这 1MB 空间相当于是上帝视角，不受内存管理约束，原因很简单——它自己就是管理者。内存池用于管理其他内存，而不用关心自己所在的内存，否则就是自己管理自己啦，这么说来，将自己所在内存的对应位置 1，岂不是相当于自杀了？哈哈哈哈开个玩笑，原因大概就是如此。</p></li><li><p>PCB (Process Control Block, 进程控制块)，用来管理进程，每个进程的信息（pid、进程状态等）都保存在各自的 PCB 内。关于 PCB 的详细内容会在后面讲线程时提到，现在读者只需记住两点：</p><ul><li><p><strong><u>PCB 需要用一个自然页存放</u></strong> ，即 PCB 的起始地址必须为 0xXXXXX000，结尾必须是 0xXXXXXfff 。</p><blockquote><p>这就是为什么 0x9f000~0x9fbff 未使用的原因——为了凑一个自然页。这么说大家可能还不清楚什么叫做未使用，放一张图各位就知道了：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70-1670387128776-1.png" alt=""><br>原本 0x7E00~0x9FBFF 都是空闲区域，咋们大可以将 PCB 放在 0x9E000~0x9FBFF 处，但无奈 PCB 只能占用一个自然页，所以 0x9F000~0x9FBFF 只能被废弃。</p></blockquote></li><li><p><strong>PCB 的最高处 0xXXXXXfff 以下用于进程/线程在 <u>ring0 下使用的栈</u></strong> 。为什么将栈放置于 PCB 内以及为什么只用于 ring0，这会在后面实现线程时详细阐述。现在读者仍只需知晓，<strong><u>我们的内核代码本身就是一个线程（主线程，或者说单线程进程），所以它也有自己的 PCB</u></strong> ，没错，就是上上图的那个 PCB。因此，在进入内核前（guide.s），我们会将 esp 指向 PCB 的顶端（栈底），即 <code>mov esp,0x9f000</code> 。</p><blockquote><p><strong>先向读者透露一下，PCB 中的栈与线程切换息息相关，可以说，线程切换就是通过栈操作来进行的。</strong></p></blockquote></li></ul></li><li><p>注意，在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>中，我们将页目录表和页表放在了 1MB 地址之上，刚好占用了 1MB~2MB 地址。<u>这里的目录表和页表是供内核进程使用的，已经被占用</u>，<strong><font color='orange'>所以这部分内存也不能划入用户/内核物理内存池</font></strong> 。</p></li><li><p>除开低 2MB 的内存外，<strong><font color='orange'>剩下的 30MB 物理内存<u>平均</u>(各自15MB)分给用户/内核物理内存池</font></strong> 。注意，内核物理内存池位图管理 15MB 物理内存（kernel_pool），所以内核虚拟内存池位图也管理 15MB 虚拟内存；用户物理内存池位图虽然管理 15MB 物理内存（user_pool），用户虚拟内存池位图（位于用户进程中）却管理 4GB 虚拟内存。</p></li><li><p>注意，虽然图示中 0x9a000~0x9e000 用来存放这三个位图，但实际上并没有完全放满。因为我们的操作系统目前就 32MB，压根用不了这么多，这个位图空间我们只用了一小部分（三个位图一共才占 0x5a0 字节），其他剩余空间是预留的，以便于未来扩展此操作系统。</p></li></ul><p><strong><mark class="hl-label blue">内存规划代码剖析</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>virtual_addr</code> 结构体目前仅用于内核<u>虚拟</u>内存池，后期还会用该结构管理用户虚拟内存池。</li><li><code>pool</code> 结构体用于内核与用户<u>物理</u>内存池的管理。为什么 <code>pool</code> 比 <code>virtual_addr</code> 多一个 pool_size 成员呢？这是因为，物理内存是很有限的（本OS为32MB），虽然虚拟地址最大为 4GB，但相对而言却是无限的，因此 virtual_addr 无需记录容量。</li><li>至于为什么还需要指定起始地址，阅读下面的代码后你就会彻底明白。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"><span class="comment">/* 初始化内存池 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_pool_init</span><span class="params">(<span class="type">uint32_t</span> all_mem)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;         <span class="comment">// 为什么乘256,详见下文解析</span></span><br><span class="line">    <span class="type">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;   <span class="comment">// 低端1M内存+页表/目录表都不算入内存池</span></span><br><span class="line">    <span class="type">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="type">uint16_t</span> all_free_pages = free_mem / PG_SIZE;     <span class="comment">// 1页为4k,不管总内存是不是4k的倍数,</span></span><br><span class="line">    <span class="comment">// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。</span></span><br><span class="line">    <span class="type">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;  <span class="comment">// 平均分给内核物理内存池和用户物理内存池</span></span><br><span class="line">    <span class="type">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span></span><br><span class="line">    <span class="type">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;      <span class="comment">// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> ubm_length = user_free_pages   / <span class="number">8</span>;      <span class="comment">// User BitMap的长度.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> kp_start = used_mem;                     <span class="comment">// Kernel Pool start,内核内存池的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;  <span class="comment">// User Pool start,用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start   = up_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = PG_SIZE * kernel_free_pages;</span><br><span class="line">    user_pool.pool_size  = PG_SIZE * user_free_pages  ;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len   = ubm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********    内核内存池和用户内存池位图   ***********</span></span><br><span class="line"><span class="comment">    *   位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    *   全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    *   而我们需要根据总内存大小算出需要多少字节。</span></span><br><span class="line"><span class="comment">    *   所以改为指定一块内存来生成位图.</span></span><br><span class="line"><span class="comment">    *   ************************************************/</span></span><br><span class="line">    <span class="comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span></span><br><span class="line">    <span class="comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="type">void</span>*)MEM_BITMAP_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span></span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line">    <span class="comment">/******************** 输出内存池信息 **********************/</span></span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits + kernel_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_start:      &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_end:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start + kernel_pool.pool_size,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_start:          &quot;</span>,DEFUALT);</span><br><span class="line"></span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_end:            &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits + user_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start + user_pool.pool_size,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将位图置0*/</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span></span><br><span class="line">    <span class="comment">// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.start: &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.end:   &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits + kernel_vaddr.vaddr_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理部分初始化入口 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;mem_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> mem_bytes_total = *((<span class="type">uint32_t</span>*)MEM_SIZE_ADDR);</span><br><span class="line">    put_str(<span class="string">&quot;memory size:&quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(mem_bytes_total,DEFUALT,HEX);</span><br><span class="line">    mem_pool_init(mem_bytes_total);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;<span class="comment">/* 初始化内存池 */</span></span><br></pre></td></tr></table></figure><p>上面的代码配合注释以及之前的讲解，是完全能够看懂的，便不再挨个解释了，只对部分内容进行说明：</p><ul><li><p>第 12 行，<code>MEM_SIZE_ADDR</code> ，即 0x90c ，这就是前文我们存放内存容量的地址；第 98 行，通过对该地址解引用，取得内存大小，随后传参给 <code>mem_pool_init()</code> ，开始初始化内存池。</p></li><li><p>第 19 行，为什么页目录和页表所占内存大小是 <code>PG_SIZE*256</code> ？（1）页目录表，占 1 页；（2）第0、768号页目录项都指向第 0 号页表，此页表占 1 页；（3）第 769~1022 号页目录项一共指向 254 个页表，占 254 页。因此，所占内存大小为 <code>4096*(1+1+254)=PG_SIZE*256</code> 。</p><blockquote><p>有人肯定纳闷了，我们之前不是仅为 769~1022 号页目录项安装了页表的地址吗？并没有创建页表页呀？那为什么还要算入这 254 页的内存大小呢？就是因为我们提前指向了这些页表的地址，每个地址相差 4096 字节，所以才必须为这些页表预留空间哒！笔者起初对这点很疑惑，想了好一会才反应过来，不知道读者会不会有这样的问题。另外，我们在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中也提到过，提前为 769~1022 号页目录项安装页表的地址是为了实现内核的完全共享，忘记的朋友不妨回头看看。</p></blockquote></li><li><p>第 35 行，<strong>物理内存池所管理的物理内存被规定为从 2MB 开始</strong> ，那么为什么要跳过这 2MB 呢？这在前文已经详细说明，0~1MB 是内核空间，1~2MB 是内核进程的页目录和页表，因此这部分物理内存不能再使用，所以不可划入内存池。</p></li><li><p>第 86 行，为什么将内核虚拟起始地址设为 <code>K_HEAP_START</code> ，即 0xc0100000 ？这是因为在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中，<strong>我们已经将虚拟空间高 1GB 处的起始 1MB 直接映射到物理内存的低 1MB 了，所以 0x0~0xc0100000 实际上是运行的内核代码（内核镜像）。因此，内核虚拟池中对应的起始虚拟地址必须跳过这 1MB，即从 0xc0100000 开始分配</strong> 。另外，从 <code>K_HEAP_START</code> 应该也能看出，<strong><font color='gree'><u>内核物理池是用来存放内核开辟的堆</u></font></strong> ，读者应该对堆很熟悉了吧，这就是程序在运行时动态开辟的内存。<strong>内核代码都存放在 0x9a000 内，注意，代码是不会运行在内核物理池中的！</strong></p></li></ul><p><img src="/2022/img/image-20221208113835640.png" alt=""></p><p>好了，本节内容大致就是如此，各位一定还有未能想明白的问题，可在评论区留言。同时也请别着急，进入下一节<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶-分配页内存</a>后，也许你就会恍然大悟。</p>]]></content>
    
    
    <summary type="html">操作系统, 内存管理, 虚拟地址</summary>
    
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/categories/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="自制操作系统" scheme="http://jyxcpp.netlify.app/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>string</title>
    <link href="http://jyxcpp.netlify.app/2022/12/01/string/"/>
    <id>http://jyxcpp.netlify.app/2022/12/01/string/</id>
    <published>2022-12-01T14:13:57.000Z</published>
    <updated>2023-03-12T11:21:28.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://blog.csdn.net/u013354805/article/details/50057139">https://blog.csdn.net/u013354805/article/details/50057139</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言中的#和##</title>
    <link href="http://jyxcpp.netlify.app/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
    <id>http://jyxcpp.netlify.app/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/</id>
    <published>2022-11-30T03:28:05.000Z</published>
    <updated>2023-03-12T11:21:42.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-字符串化-font"><font color='red'>字符串化#</font></h3><p>C 语言中，<code>#</code> 号可用于将宏参数转为字符串，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(x)  #x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(STR(age)); <span class="comment">//输出字符串age,而非18</span></span><br><span class="line">    <span class="built_in">printf</span>(STR(<span class="number">18</span>));  <span class="comment">//输出字符串18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法有什么使用场景呢？如下，有时候我们需要取得宏函数参数（表达式/变量）的字面内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">warn(a==<span class="number">0</span>);    <span class="comment">//打印&quot;a==0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在某些情况下很有用，参见<a href="">assert剖析</a>。</p><p><strong>另外需要注意，当宏参数是另一个宏的时候，宏定义里有用 <code>#</code> 的地方宏参数不会再展开</strong> ，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;Π==3.14&quot;而不是&quot;3.14==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要宏参数展开，则需要使用以下两步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)   _warn(expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;3.14==3.14&quot;而不是&quot;Π==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 warn(expr) 展开时会扩展它的参数，即替换 expr 中的宏变量。</p><h3 id="font-color-red-符号粘贴-font"><font color='red'>符号粘贴##</font></h3><p><code>##</code> 用于拼接两个符号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ponit(x,y) x##.##y </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,point(<span class="number">12.32</span>));  <span class="comment">//输出12.32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，从以上结果可见，转换后的结果不是字符串！</strong> 而是正常的代码或数字。如果想将结果转为字符串，可以采用如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTR(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONT(a,b) TOSTR(a)##TOSTR(b)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(CONT(<span class="number">12</span>,<span class="number">32</span>)); <span class="comment">//输出&quot;1232&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window 下对 <code>##</code> 的一个简单使用是指定字符编码方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) L##x</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) x</span></span><br></pre></td></tr></table></figure><p>当定义了 <code>_UNICODE</code> 时，则 <code>TEXT(&quot;hello&quot;)</code> 为 <code>&quot;hello&quot; </code> ，否则为 <code>L&quot;hellp</code> 。</p><blockquote><p><code>L&quot;str&quot;</code> 是 C/C++ 对宽字节字符的原生支持，表示字符串中的每个字符都是双字节。</p></blockquote><p>另外需要强调的是，<code>#</code> 和 <code>##</code> 都只能用于预处理宏扩展，不能在普通源码中使用。</p>]]></content>
    
    
    <summary type="html">C语言中的#和##, 字符拼接</summary>
    
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://jyxcpp.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
