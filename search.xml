<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>希尔排序</title>
      <link href="/2023/09/09/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/09/09/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：<a href="https://www.zhihu.com/question/24637339/answer/84079774">知乎-冒泡</a> 、<a href="https://zh.wikipedia.org/zh-cn/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">wiki</a> 、chatGPT、<a href="https://www.zhihu.com/question/24637339/answer/3159556193">知乎-helloCode</a></p></blockquote><p>希尔排序是一种不稳定排序算法，最坏复杂度为 O(N^2^) ，但它是插入排序的改进版本，是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，<strong><font color='orange'>因为插入排序每次只能将数据移动一位，即每次只能消除一个逆序对</font></strong></li></ul><blockquote><p><strong><u>假设我们要从小到大排序，一个数组中取两个元素如果前面比后面大，则为一个逆序，容易看出排序的本质就是消除逆序数，可以证明对于随机数组，逆序数是O(N^2^) 的，而如果采用交换相邻元素的办法来消除逆序，每次正好只消除一个，因此必须执行O(N^2^)的交换次数，这就是为啥冒泡、选择、插入等算法只能到平方级别的原因，反过来，基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，使得一次交换能消除一个以上的逆序，希尔、快排、堆排等等算法都是交换比较远的元素，只不过规则各不同罢了。</u></strong><br>——引自<a href="https://www.zhihu.com/question/24637339/answer/84079774">知乎-冒泡</a></p><p>这段总结真是醍醐灌顶！！！不过有个问题，插入排序并非交换相邻元素，为什么其复杂度仍为 O(N^2^) 呢？</p></blockquote><p>那么希尔排序是如何进行的呢？概括其思路： <strong>先将数组分为多个（不连续）小数组，对每个小数组排序（以尽可能多地消除逆序对），从而使大数组相对有序，最终对整个数组进行插入排序，而此时数组已经大概有序了，插入排序就能高效地进行</strong> 。看以下图解：<br><img src="/2022/img/v2-e7da344ba84144f716e7e0cb87148f13_1440w.webp" alt="本图引自知乎-土豆"></p><p>第一次步长为 7，那么一次交换就可能消除最多 7 个逆序对！这或许就是比插入排序更高级的原因吧。下面直接给出 C++ 描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> cmptor&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T* vec, <span class="type">int</span> len, cmptor cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> g = <span class="number">0</span>; g &lt; gap; g++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//insert sort</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = g+gap; i &lt; len; i += gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k -= gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k-gap &gt;= <span class="number">0</span> &amp;&amp; !<span class="built_in">cmp</span>(vec[k-gap], vec[k]))</span><br><span class="line"><span class="built_in">swap</span>(vec[k-gap], vec[k]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><font color='orange'>步长=组数！见上示意图</font></strong></li><li><strong><font color='orange'>i 相当于每组的起始下标</font></strong></li><li><strong><font color='orange'>8 行后参见<a href="https://jyx-fyh.github.io/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">插入排序</a></font></strong></li><li><strong><font color='red'>第 13 行务必检查下标是否越界！！！</font></strong></li></ul><p>另外，这里我们的步长 gap 每次递减 1/2 ，实际上这并不高效。<strong><font color='orange'>步长的选择是希尔排序的重要部分，将直接影响最终的排序效率！</font></strong> 常用步长序列有以下几种：常用的步长序列有以下几种：</p><ol><li>希尔原始序列：希尔最初提出的间隔序列是使用 n/2 作为初始间隔，然后每次缩小一半，直到间隔为 1 。</li><li>Hibbard 序列：Hibbard 序列使用 2^k - 1 作为间隔，其中 k 从初始间隔递减到 1 。例如，对于数组长度为 n 的序列，Hibbard 序列为1, 3, 7, 15, …, 2^k - 1。</li><li>Sedgewick 序列：Sedgewick 序列是由 Robert Sedgewick 提出的一种间隔序列。它结合了希尔原始序列和 Hibbard 序列的优点，并且在实践中表现良好。Sedgewick 序列的具体定义较为复杂，可以参考相关文献进行了解。</li></ol><p><strong>优点</strong></p><ol><li>相对于传统的插入排序，希尔排序通过将元素分组进行排序，减少了逆序对的数量，从而加快了排序过程。</li><li>希尔排序是原地排序算法，只需在原始数组上进行元素的交换和移动，不需要额外的辅助空间。</li></ol><p><strong>缺点</strong></p><ol><li>希尔排序的最坏情况时间复杂度并不稳定，通常在 O(N^2^) 到 O(NlogN) 之间。虽然平均情况下性能较好，但在某些特定情况下，性能可能不如其他高级排序算法。</li><li>步长序列的选择对性能产生影响，选择不当可能导致排序效率下降。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑vim</title>
      <link href="/2023/09/07/%E5%85%A5%E5%9D%91vim/"/>
      <url>/2023/09/07/%E5%85%A5%E5%9D%91vim/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th><font color='red'>插入文本</font></th><th></th></tr></thead><tbody><tr><td>vim -R filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>i</td><td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td></tr><tr><td>I</td><td>在光标所在行的行首插入随后输入的文本</td></tr><tr><td>o</td><td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td></tr><tr><td>O</td><td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td></tr><tr><td>a</td><td>在当前光标所在位置之后插入随后输入的文本</td></tr><tr><td>A</td><td>在光标所在行的行尾插入随后输入的文本</td></tr></tbody></table><table><thead><tr><th><font color='red'>查找文本</font></th><th></th></tr></thead><tbody><tr><td>/abc</td><td>从光标所在位置向前查找字符串 abc</td></tr><tr><td>/^abc</td><td>查找以 abc 为行首的行 <strong>（^表示行首）</strong></td></tr><tr><td>/abc$</td><td>查找以 abc 为行尾的行 <strong>（$表示行尾）</strong></td></tr><tr><td>?abc</td><td>从光标所在为主向后查找字符串 abc</td></tr><tr><td>n</td><td>向同一方向重复上次的查找指令</td></tr><tr><td>N</td><td>向相反方向重复上次的查找指定</td></tr><tr><td>:set ic</td><td>忽略大小写</td></tr><tr><td>:set noic</td><td>不忽略大小写</td></tr></tbody></table><table><thead><tr><th><font color='red'>替换文本</font></th><th></th></tr></thead><tbody><tr><td>r</td><td>替换光标所在位置的字符</td></tr><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td>:s/a1/a2/g</td><td>将当前光标所在行中的所有 a1 用 a2 替换</td></tr><tr><td>:n1,n2s/a1/a2/g</td><td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td></tr><tr><td>:%s/a1/a2/</td><td>将文件中所有的 a1 都用 a2 替换</td></tr></tbody></table><table><thead><tr><th><font color='red'>删除文本</font></th><th></th></tr></thead><tbody><tr><td>x</td><td>删除光标所在位置的字符</td></tr><tr><td>X</td><td>删除光标前一个位置字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除当前行（包括此行）后 n 行文本</td></tr><tr><td>dG</td><td>删除光标所在行一直到文件末尾的所有内容</td></tr><tr><td>D</td><td>删除光标位置到行尾的内容</td></tr><tr><td>:a1,a2d</td><td>函数从 a1 行到 a2 行的文本内容</td></tr></tbody></table><blockquote><p>被删除的内容都放在了剪贴板中，按下 “p” 键粘贴。</p></blockquote><table><thead><tr><th><font color='red'>复制文本</font></th><th></th></tr></thead><tbody><tr><td>p</td><td>将剪贴板中的内容粘贴到光标后</td></tr><tr><td>P</td><td>将剪贴板中的内容粘贴到光标前</td></tr><tr><td>y</td><td>复制已选中的文本到剪贴板</td></tr><tr><td>nyy</td><td>将从光标所在行及其以下共 n 行复制到剪切板</td></tr><tr><td>yy</td><td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td></tr><tr><td>yw</td><td>将光标位置的单词复制到剪贴板</td></tr><tr><td>: n,m y</td><td>将 n 到 m 行复制到剪切板</td></tr></tbody></table><table><thead><tr><th><font color='red'>撤销操作</font></th><th></th></tr></thead><tbody><tr><td>u</td><td>撤销上一次操作</td></tr><tr><td>ctrl + r</td><td>反撤销</td></tr><tr><td>U</td><td>第一次会撤销对光标所在行文本做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。</td></tr></tbody></table><table><thead><tr><th><font color='red'>移动光标</font></th><th></th></tr></thead><tbody><tr><td>h</td><td>左移</td></tr><tr><td>j</td><td>下移（j 像下箭头）</td></tr><tr><td>k</td><td>上移</td></tr><tr><td>l</td><td>右移</td></tr><tr><td>w 或 W</td><td>光标移动至下一个单词的单词首</td></tr><tr><td>b 或 B</td><td>光标移动至上一个单词的单词首</td></tr><tr><td>e 或 E</td><td>光标移动至下一个单词的单词尾</td></tr><tr><td>fx</td><td>光标移动至当前行中下一个 x 字符处</td></tr><tr><td>Fx</td><td>光标移动至当前行中上一个 x 字符处</td></tr><tr><td>gg</td><td>光标移动到文件开头</td></tr><tr><td>G</td><td>光标移动至文件末尾</td></tr><tr><td>:n</td><td>可以将光标快速定义到指定行的行首</td></tr><tr><td>0</td><td>光标移到行首非空白字符处</td></tr><tr><td>$</td><td>光标移到行尾非空白字符处</td></tr></tbody></table><table><thead><tr><th><font color='red'>可视化模式</font></th><th></th><th></th></tr></thead><tbody><tr><td>v</td><td>字符可视化模式，此模式下目标文本的选择以字符为单位</td><td></td></tr><tr><td>V</td><td>行可视化模式，此模式化目标文本的选择以行为单位</td><td></td></tr><tr><td>Ctrl+shift+v</td><td>块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本</td><td></td></tr></tbody></table><table><thead><tr><th><font color='red'>多窗口模式</font></th><th></th></tr></thead><tbody><tr><td>:sp filename</td><td>横向窗口</td></tr><tr><td>:vs filename</td><td>竖向窗口</td></tr><tr><td>ctrl+ww</td><td>切换窗口</td></tr><tr><td>:q</td><td>关闭该窗口</td></tr></tbody></table><table><thead><tr><th><font color='red'>注释</font></th><th></th></tr></thead><tbody><tr><td>:line1,line2 s/^/#/g</td><td>在line1到line2的行首添加&quot;#&quot;注释符</td></tr><tr><td>:line1,line2 s/^#//g</td><td>在line1到line2的行首去掉&quot;#&quot;注释符</td></tr><tr><td>:line1,line2 s/^////g</td><td>在line1到line2的行首添加&quot;//&quot;注释符（特殊字符须转义）</td></tr></tbody></table><blockquote><p>可见添加 <code>//</code> 注释符是异常麻烦的事，为此我们有以下两种快捷方式：<br><strong>1、单行注释快捷键映射</strong><br>在 home 目录下的 .vimrc 配置文件中定义快捷键：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-m&gt;</span> I//<span class="symbol">&lt;Esc&gt;</span> </span><br><span class="line">将 ctrl+<span class="keyword">m</span> 映射为 I//<span class="symbol">&lt;Esc&gt;</span> ,其中I进入INSERT模式并在行首插入文本,插入//后退出编辑模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-k&gt;</span> :s/^\/\///g<span class="symbol">&lt;Esc&gt;</span></span><br><span class="line">去除行首的//注释符</span><br></pre></td></tr></table></figure><p><strong>2、多行注释函数</strong><br>在 home 目录下的 .vimrc 配置文件中定义以下函数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">COM</span><span class="params">(b1, b2)</span></span><br><span class="line"> <span class="keyword">execute</span> <span class="variable">a:b1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">a:b2</span>.<span class="string">&#x27;s/^/\/\//g&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">DCOM</span><span class="params">(b1, b2)</span></span><br><span class="line"> <span class="keyword">execute</span> <span class="variable">a:b1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">a:b2</span>.<span class="string">&#x27;s/^\/\///g&#x27;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>其中 <code>COM(b1,b2)</code> 功能是为 b1 到 b2 行的行首添加 // 注释符，<code>DCOM(b1,b2)</code> 反之。以下几点供大家了解：</p><ul><li>调用函数的方式为：<code>:CALL COM(X1,X2)</code></li><li>函数名可以自定义，但首字母必须大写</li><li>函数内部使用参数时，参数名前必须有 <code>a:</code> ，这是在表明作用域</li><li>execute 函数用来执行命令（命令行模式）</li><li><code>.</code> 是连接符</li></ul><p><strong><font color='orange'>多插一句，编写此类脚本语言，多使用 chatGPT，甚是方便！</font></strong></p></blockquote><table><thead><tr><th><font color='red'>文件配置</font></th><th></th></tr></thead><tbody><tr><td>:set nu<br />:set nonu</td><td>设置与取消行号</td></tr><tr><td>:syn on<br />:syn off</td><td>是否依据语法显示相关的颜色</td></tr><tr><td>set hlsearch<br />set nohlsearch</td><td>设置是否将査找的字符串高亮显示</td></tr><tr><td>set autoindent</td><td>设置自动缩进，即每行的缩进同上一节相同</td></tr><tr><td>set tabstop=4</td><td>设置 Tab 键宽度为 4 个空格， <strong>强烈建议</strong></td></tr><tr><td>set mouse=a<br />set selection=exclusive<br />set selectmode=mouse,key</td><td>Vim 编辑器里默认是不启用鼠标的，通过此设置即可启动鼠标。</td></tr></tbody></table><blockquote><p>用户配置文件位于主目录 ~/.vimrc</p></blockquote><table><thead><tr><th><font color='red'>文件备份</font></th><th></th></tr></thead><tbody><tr><td>: set backup</td><td>备份该文件到指定目录</td></tr><tr><td>set backupdir=指定目录</td><td>在 .vimrc 中设置备份文件的保存目录</td></tr><tr><td>: w filename</td><td>将当前文件保存到 filename 文件</td></tr></tbody></table><table><thead><tr><th><font color='red'>执行外部命令</font></th><th></th></tr></thead><tbody><tr><td>!!命令（normal模式下）</td><td>执行命令并将输出结果写入到光标位置</td></tr></tbody></table><table><thead><tr><th><font color='red'>其他</font></th><th></th></tr></thead><tbody><tr><td>J</td><td>合并本行和下一行文本</td></tr><tr><td>ctrl+z 和 fg</td><td>使用 ctrl+z 挂起当前窗口，fg 命令快速返回此窗口</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板问题小记</title>
      <link href="/2023/09/05/%E5%90%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BC%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/09/05/%E5%90%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%BC%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写排序函数时遇到一个关于模板的问题，有一定记录价值。需求如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* vec, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> function&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortTester</span><span class="params">(function fun)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 mySort 是我自己编写的排序函数，vec 是数组，len 是数组长度；sortTester 是对数器，用来生成随机样例来检测传入的排序函数，参数 fun 为我们要传入并检测的函数。</p><p>当我想当然地进行如下调用时，编译器报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sortTester</span>(mySort);</span><br></pre></td></tr></table></figure><p>这是很容易犯的一种错误，其实稍加思索后就能发现问题所在： <strong>sortTester 的参数类型 function 是一个模板类型，而传入的参数 mySort 是一个函数模板，所以 sortTester 当然就无法进行函数类型推断，因而报错。所以我们必须传入一个确定的函数类型，而非函数模板，即，将函数模板实例化。</strong></p><p>有下面两种方式将函数模板实例化（这里实例化为 int ）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">auto</span> funcPtr = mySort&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="built_in">sortTester</span>(funcPtr);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="built_in">sortTester</span>([](<span class="type">int</span>* arr, <span class="type">int</span> len)&#123;<span class="built_in">mySort</span>(arr, len);&#125;);</span><br></pre></td></tr></table></figure><p>尤其是第二种 lambda 方式值得学习！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23天英语背诵</title>
      <link href="/2023/07/22/23%E5%A4%A9%E8%8B%B1%E8%AF%AD%E8%83%8C%E8%AF%B5/"/>
      <url>/2023/07/22/23%E5%A4%A9%E8%8B%B1%E8%AF%AD%E8%83%8C%E8%AF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-引言-font"><strong><font color='red'>引言</font></strong></h2><p>大学已经过了两年，这期间好几次下定决心学好英语，然而每次都半途而废。</p><h2 id="font-color-red-DAY-1-font"><font color='red'>DAY 1 </font></h2><p><strong>Reach the goals  必须达成目标</strong></p><ol><li><p>My life has been a trade-off.</p><p>我的人生是一场交易。</p></li><li><p>If I wanted to reach the goals I set for myself, I had to get at it and stay at it everyday.</p><p>如果我想达到我给自己设定的目标，就必须每天为之奋斗，坚持不懈。</p></li><li><p>I had to think about it all the time.</p><p>必须时刻把它放在心上。</p></li><li><p>I had to get up everyday with my mind set on improving something.</p><p>我每天一起床，脑子里就想着要去改进些什么。</p></li><li><p>I was driven by a desire to always be on the top of the heap.</p><p>我一直被一种想要追求卓越的渴望驱策着。</p></li></ol><hr><h2 id="font-color-red-DAY-2-font"><strong><font color='red'>DAY 2</font></strong></h2><p><strong>Mean something  成为举足轻重的人，而不是废物</strong></p><ol><li><p>I want to do good.</p><p>我想做好的事情。</p></li><li><p>I want the world to be better because I was here.</p><p>我要这个世界因为我而变得更好。</p></li><li><p>I want my life, my work, and my family to mean something.</p><p>我想让我的生活、工作和家庭都因为我而变得更有意义。</p></li><li><p>If you’re not making someone else’s life better then you’re wasting your time.</p><p>如果你没有给他人的生活带来改变，那你就是在浪费自己的时间！</p></li><li><p>Your life will become better by making other lives better.</p><p>改善他人的生活，你的生活也会变得更好！</p></li><li><p>I want to represent an idea.</p><p>我想要再现一种理念。</p></li><li><p>I want to represent possibilities.</p><p>我想再现人生的各种可能性。</p></li><li><p>I want to represent the idea that you really can make what you want.</p><p>我想再现的理念是，你真的可以做成你想要的东西！</p></li></ol><hr><h2 id="font-color-red-DAY-3-font"><strong><font color='red'>DAY 3</font></strong></h2><p><strong>Protect your dream  捍卫你的梦想</strong></p><ol><li><p>Don’t ever let someone tell you that you can’t do something.<br>不要让任何人告诉你，你做不成事。</p></li><li><p>Not even me.<br>即便是我也不行。</p></li><li><p>You got a dream, you gotta protect it.<br>如果你有梦想，你要保护它。</p></li><li><p>When people can’t do something themselves, they’re gonna tell you that you can’t do it.<br>当人们自己做不到的时候，他们会说你也成不了大器。</p></li><li><p>You want something, go get it.<br>如果你要什么，去得到它。</p></li><li><p>Period.<br>绝不迟疑。</p></li></ol><hr><h2 id="font-color-red-DAY-4-font"><strong><font color='red'>DAY 4</font></strong></h2><p><strong>Good artists copy, great artists steal.  优秀者模仿，伟大者剽窃。</strong></p><ol><li><p>How do you know what’s the right direction?<br>你怎么知道哪个方向是正确的？</p></li><li><p>Ultimately it comes down to taste.<br>其实归根到底是品位的问题。</p></li><li><p>It comes down to taste.<br>那终究是品味问题。</p></li><li><p>It’s a matter of trying to expose yourself to the best things that humans have done.<br>你要尽量让自己接触到这个世界上最优秀的事物。</p></li><li><p>And then try to bring those things into what you are doing.<br>并把它运用到自己的工作中去。</p></li><li><p>Picasso had a saying, “Good artists copy, great artists steal.”<br>毕加索说过，“优秀者模仿, 伟大者剽窃。”</p></li><li><p>We have always been shameless about stealing great ideas.<br>当我们剽窃别人的卓越的创意的时候，从不觉得羞愧。</p></li></ol><hr><h2 id="font-color-red-DAY-5-font"><strong><font color='red'>DAY 5</font></strong></h2><p><strong>Failed over and over and over again 一次一次又一次的失败</strong></p><p>【1】I’ve missed more than 9000 shots in my career.</p><p>我的职业生涯投篮失误超过9000次。</p><p>【2】I’ve lost almost 300 games.</p><p>我输了大约300场比赛。</p><p>【3】26 times I’ve been trusted to take the game winning shot and missed.</p><p>有26次我被委以重任投制胜一球，但失手了。</p><p>【4】I’ve failed over and over and over again in my life.</p><p>我这一生，一次一次又一次失败。</p><p>【5】And that is why I succeed.</p><p>那就是我为什么能够成功的原因。</p><hr><h2 id="font-color-red-DAY-6-font"><strong><font color='red'>DAY 6</font></strong></h2><p><strong>Pushing through the pain 穿越痛苦</strong></p><ol><li><p>As a magician, I try to create images that make people stop and think.<br>作为一个魔术师，我总是尝试去创造一个现象，可以让人们驻足思考。</p></li><li><p>I also try to challenge myself to do things that doctors say are not possible.<br>我也试着挑战自己，做一些医生看来不可能的事情。</p></li><li><p>As a magician, I try to show things to people that seem impossible.<br>作为一个魔术师，我试着展示一些东西，那些看似不可能的事。</p></li><li><p>And I think magic, whether I’m holding my breath or shuffling a deck of cards, is pretty simple.<br>我认为魔术，不管是水下屏气，还是捣鼓一副纸牌，道理都很简单。</p></li><li><p>It’s practice, it’s training.<br>就是练习，训练。</p></li><li><p>And It’s practice, it’s training and experimenting, while pushing through the pain to be the best that I can be.<br>就是练习，训练，以及不断尝试。去强忍过那些极痛苦的时刻，做自己能做的一切。</p></li><li><p>And that’s what magic is to me, so, thank you. (Applause)<br>这就是魔术对于我的意义。谢谢你们。（掌声）</p></li></ol><hr><h2 id="font-color-red-DAY-7-font"><strong><font color='red'>DAY 7</font></strong></h2><p><strong>nasty place 残酷世界</strong></p><p>以下是按照第二篇格式修改后的文章：</p><ol><li><p>Then the time come for you to be your own man and take on the world and you did.<br>然后就是你自己奋斗的人生了，自己去承担自己的事情，你也确实做得很好。</p></li><li><p>But somewhere along the line, you changed.<br>但是有些时候，你变了。</p></li><li><p>You stopped being you.<br>你不再是你。</p></li><li><p>You let people stick a finger in your face and tell you you’re no good.<br>你让别人指着你的脸说你不好。</p></li><li><p>And when things got hard, you started looking for something to blame like a big shadow.<br>而且遇到不顺心的事时，你开始怪罪于其他事情，就像巨大的阴影。</p></li><li><p>Let me tell you something you already know.<br>让我告诉你一些你已经知道的事。</p></li><li><p>The world ain’t all sunshine and rainbows.<br>这世界不完全是阳光和彩虹。</p></li><li><p>It’s a very mean and nasty place, and I don’t care how tough you are…<br>这是一个非常刻薄艰险的世界，我不在乎你是多么坚强……</p></li><li><p>It will beat you to your knees and keep you there permanently if you let it.<br>如果你屈服的话，它会永远把你打趴下的。</p></li></ol><hr><h2 id="font-color-red-DAY-8-font"><strong><font color='red'>DAY 8</font></strong></h2><p><strong>hit 打击</strong></p><ol><li><p>You, me or nobody is gonna hit as hard as life.<br>你，我，没人能够击打得比生活还重。</p></li><li><p>But it ain’t about how hard you hit.<br>但是这并不在于你击打得多重。</p></li><li><p>It’s about how hard you can get hit and keep moving forward.<br>而在于无论你被击打的有多重，但却能继续向前。</p></li><li><p>How much you can take and keep moving forward.<br>你能承受多少，并且继续前进。</p></li><li><p>That’s how winning is done!<br>这才是真正的胜利。</p></li><li><p>If you know what you’re worth, go and get what you’re worth.<br>如果你知道你的价值，那么就前进，去实现你的价值。</p></li><li><p>But you gotta be willing to take the hits, and not pointing fingers saying you ain’t where you wanna be, because of him or her or anybody!<br>但是你必须乐意承受打击，而不是没能实现目标时却指着别人说，是因为他或她的原因。</p></li><li><p>Cowards do that, and that ain’t you!<br>懦夫才会那么做，你不是！</p></li><li><p>You’re better than that!<br>你远比那个出色！</p></li></ol><hr><h2 id="font-color-red-DAY-9-font"><strong><font color='red'>DAY 9</font></strong></h2><p><strong>Will you fight?</strong></p><ol><li><p>I am William Wallace.<br>我是威廉华莱士。</p></li><li><p>And I see a whole army of my countrymen here in defiance of tyranny.<br>我看到我族组成的军队向暴政宣战。</p></li><li><p>You’ve come to fight as free men.<br>你们来到这里作为自由人参战。</p></li><li><p>And free men you are.<br>你们确实是自由人。</p></li><li><p>What will you do with that freedom?<br>你们如何对待自由？</p></li><li><p>Will you fight?<br>你们愿意作战吗？</p></li><li><p>Fight, and you may die.<br>作战，你们可能会死。</p></li><li><p>Run, and you’ll live … at least awhile.<br>逃走，你会活着……至少一阵子。</p></li><li><p>And dying in your beds many years from now.<br>几年后在床上老死。</p></li><li><p>Would you be willing to trade all the days from this day to that.<br>你们是否愿意用所有的这些日子来换取。</p></li><li><p>For one chance, just for one chance.<br>为了一个机会，仅仅为了一个机会。</p></li><li><p>To come back here and tell our enemies that they may take our lives,<br>回到这里，告诉我们的敌人他们或许会夺走我们的生命，</p></li><li><p>But they’ll never take our freedom!<br>但他们永远夺不走我们的自由！</p></li></ol><hr><h2 id="font-color-red-DAY-10-font"><strong><font color='red'>DAY 10</font></strong></h2><p><strong>Never surrender</strong></p><ol><li><p>We shall not flag or fail.<br>我们绝不投降，也不会失败。</p></li><li><p>We shall go on to the end.<br>我们将战斗到底。</p></li><li><p>We shall fight in France.<br>我们将在法国作战。</p></li><li><p>We shall fight on the seas and oceans.<br>我们将在海洋中作战。</p></li><li><p>We shall fight with growing confidence and growing strength in the air.<br>我们将以越来越大的信心和越来越强的力量在空中作战。</p></li><li><p>We shall defend our island, whatever the cost may be.<br>我们将不惜一切代价保卫本土。</p></li><li><p>We shall fight on the beaches.<br>我们将在海滩作战。</p></li><li><p>We shall fight on the landing grounds.<br>我们将在敌人的登陆点作战。</p></li><li><p>We shall fight in the fields and in the streets.<br>我们将在田野和街头作战。</p></li><li><p>We shall fight in the hills.<br>我们将在山区作战。</p></li><li><p>We shall never surrender.<br>我们绝不投降。</p></li></ol><hr><h2 id="font-color-red-DAY-11-font"><strong><font color='red'>DAY 11</font></strong></h2><p><strong>Without victory, there is no survival 没有胜利，无法生存</strong></p><ol><li><p>I would say to the House, as I said to those who have joined this government: “I have nothing to offer but blood, toil, tears and sweat.”<br>正如我曾对参加本届政府的成员所说的那样，我要向下院说：“我没什么可以奉献，有的只是热血、辛劳、眼泪和汗水。”</p></li><li><p>We have before us an ordeal of the most grievous kind.<br>摆在我们面前的，是一场严峻的极为痛苦的考验。</p></li><li><p>We have before us many, many long months of struggle and of suffering.<br>在我们面前，有许多许多漫长的斗争和苦难的岁月。</p></li><li><p>You ask, what is our policy?<br>你们问：我们的政策是什么？</p></li><li><p>I will say: It is to wage war, by sea, land and air, with all our might, with all the strength that God has given us; to wage war against a monstrous tyranny, never surpassed in the dark, and lamentable catalogue of human crime.<br>我要说，我们的政策就是用我们全部能力，用上帝所给予我们的全部力量，在海上、陆地和空中进行斗争，同一个在人类黑暗悲惨的罪恶史上从未有过的穷凶极恶的暴政进行斗争。</p></li><li><p>That is our policy.<br>这就是我们的政策。</p></li><li><p>You ask, what is our aim?<br>你们问：我们的目标是什么？</p></li><li><p>I can answer in one word: victory.<br>我可以用一个词来回答：胜利。</p></li><li><p>Victory at all costs, victory in spite of all terror, victory, however long and hard the road may be.<br>不惜一切代价，去赢得胜利；无论多么可怕，也要赢得胜利，无论道路多么遥远和艰难，也要赢得胜利。</p></li><li><p>For without victory, there is no survival.<br>因为没有胜利，就没有生存。</p></li></ol><hr><h2 id="font-color-red-DAY-12-font"><strong><font color='red'>DAY 12</font></strong></h2><p><strong>It takes a strong man to save himself, and a great man to save another.</strong></p><p><strong>强者自救，圣者渡人</strong></p><ol><li><p>These walls are funny.<br>（监狱里的高墙）实在是很有趣。</p></li><li><p>First you hate them, then you get used to them.<br>刚入狱的时候你痛恨周围的高墙，慢慢地，你习惯了生活在其中；</p></li><li><p>Enough time passes, you depend on them. That’s institutionalized.<br>最终你会发现自己不得不依靠它而生存。这就是体制化。</p></li><li><p>I guess it comes down to a simple choice: get busy living or get busy dying.<br>生命可以归结为一种简单的选择：要么忙于生存，要么赶着去死。</p></li><li><p>In 1966, Andy Dufresne escaped from Shawshank Prison.<br>1966年，安迪.杜弗兰从肖申克监狱脱逃。</p></li><li><p>All they found (of him) was a muddy set of prison clothes, a bar of soap, and an old rock-hammer damn near worn down to the nub.<br>他们只发现了他的一套沾满泥浆的狱服，一条肥皂和一把磨得几乎只剩下把儿的石锤。</p></li><li><p>I remember thinking it would take a man six hundred years to tunnel through the wall with it. Old Andy did it in less than twenty.<br>我曾经想过一个人用这把锤头在墙上挖通隧道，需要花六百年，安迪用了不到二十年。</p></li></ol><hr><h2 id="font-color-red-DAY-13-font"><strong><font color='red'>DAY 13</font></strong></h2><p><strong>Lay this brick perfectly 砌好这块砖</strong></p><ol><li><p>One summer his dad tore down a brick wall in the front of his business and told 12-year-old Will and his 9-year-old brother to rebuild it.<br>一年夏天威尔的父亲推到了自家商店门前的一面墙，让12岁的威尔和他9岁的弟弟重建它。</p></li><li><p>A job they said was impossible.<br>他们认为这是一个不可完成的工作。</p></li><li><p>It took them a year and a half, but they did it.<br>那花了他们一年半的时间，但是，他们做到了。</p></li><li><p>And he said, “now don’t you ever tell me there’s something that you can’t do.”<br>威尔的父亲说，“那么，永远不要跟我说有什么事你做不到”。</p></li><li><p>You don’t set out to build a wall.<br>你不要想着去造一堵墙。</p></li><li><p>You don’t say, “I’m going to build the biggest, baddest, greatest wall that’s ever been built.”<br>不要想着说，我要造世界上最大，最厉害，最宏伟壮观的墙。</p></li><li><p>You don’t start there.<br>不要抱着这种态度开始。</p></li><li><p>You say, “I’m going to lay this brick as perfectly as a brick can be laid.”<br>你要说，我要砌好这块砖，砌的尽可能完美无缺。</p></li><li><p>You do that every single day.<br>你每天都要这样去做。</p></li><li><p>And soon you have a wall.<br>很快，你就有了一堵墙。</p></li></ol><hr><h2 id="font-color-red-DAY-14-font"><strong><font color='red'>DAY 14</font></strong></h2><p><strong>14.</strong> <strong>Do what you need to do 做你需要做的事情</strong></p><ol><li><p>I have a great time with my life, and I want to share it.<br>我的生命中有美好的时光，我想要分享。</p></li><li><p>I love living.<br>我爱生活。</p></li><li><p>I think that’s infectious, it’s something you can’t fake.<br>我认为那是有感染力的，那是无法伪装的。</p></li><li><p>Greatness is not this wonderful, esoteric elusive god-like feature that only special people possess.<br>伟大不是那么崇高辉煌、深奥难测、难以捉摸、上天钟爱的特质，不只是少数特别的人才具备。</p></li><li><p>It’s something that truly exists within all of us.<br>这种东西其实潜藏在我们每一个人身上。</p></li><li><p>It’s very simple.<br>它非常简单。</p></li><li><p>This is what I believe, and I’m willing to die for it.<br>这就是我的信念，我愿意用生命来证明这一点。</p></li><li><p>Period.<br>毫不迟疑。</p></li><li><p>It’s that simple.<br>就是这么简单。</p></li><li><p>I know who I am, I know what I believe, and that’s all I need to know.<br>我知道我是谁，我知道我的信念，那就是我需要知道的全部。</p></li><li><p>From there, you do what you need to do.<br>因此，你只要做你需要做的事情。</p></li><li><p>You know.<br>你知道。</p></li><li><p>I think what happens is we make the situation more complex.<br>我认为实际发生的事，我们自己把事情弄复杂了。</p></li></ol><hr><h2 id="font-color-red-DAY-15-font"><strong><font color='red'>DAY 15</font></strong></h2><p><strong>Sickening work ethic 病态的职业精神</strong></p><ol><li><p>The separation of talent and skill is one of the greatest misunderstood concepts for people who are trying to excel, who have dreams, who want to do things.<br>天赋和技能之间的差别是那些追求成功、追求梦想、想做事的人最容易误解的观念之一。</p></li><li><p>Talent you have naturally.<br>天赋是与生俱来的。</p></li><li><p>Skill is only developed by hours and hours and hours of beating on your craft.<br>技能只能通过成千上万小时锤炼而来。</p></li><li><p>I’ve never really viewed myself as particularly talented.<br>我从来不认为自己有特殊的天赋。</p></li><li><p>And where I excel is ridiculous, sickening, work ethic.<br>我擅长的是，荒唐的，病态的，职业精神。</p></li><li><p>You know, while the other guy’s sleeping? I’m working.<br>你知道，当别人睡觉得时候，我在工作。</p></li><li><p>While the other guy’s eatin’? I’m working.<br>当别人吃饭的时候，我在工作。</p></li><li><p>There’s no easy way around it.<br>成功从来没有容易的路可走。</p></li><li><p>No matter how talented you are, your talent is going to fail you if you’re not skilled.<br>不管你的天赋有多么出色，再好的天赋也会让你失败，如果你没有练出技能来。</p></li><li><p>If you don’t study, work really hard and dedicate yourself to getting better every single day.<br>如果你没有非常用心的学习，工作，没有致力于让自己每天进步一点点。</p></li><li><p>You’ll never be able to communicate your artistry to people the way that you want.<br>那你怎能让别人确信你能过自己想要的生活呢。</p></li><li><p>The only thing that I see that is distinctly different about me is that I’m not afraid to die on a treadmill.<br>我觉得我唯一不同的一点就是，我永远不怕在跑步机上坚持到底。</p></li><li><p>You might have more talent than me, you might be smarter than me, but if we get on a treadmill together, there’re two things.<br>你可能天赋比我强，你也可能比我聪明，但是如果我们同时踏上跑步机，那只有两个结果。</p></li><li><p>You’re getting off first, or I’m gonna die.<br>你会先下去，而我会跑到最后一刻。</p></li><li><p>It’s really that simple.<br>就是这么简单。</p></li></ol><hr><h2 id="font-color-red-DAY-16-font"><strong><font color='red'>DAY 16</font></strong></h2><p><strong>Bend your universe 驱动你的宇宙</strong></p><ol><li><p>Our thoughts, feelings, dreams, and ideas are physical in the Universe.<br>我们的想法、情感、梦想、理念在宇宙中都是物质的。</p></li><li><p>If we dream something, if we picture something, and if we commit ourselves to it – that is a physical thrust towards realization that we send out into the universe.<br>如果我们有了梦想，如果我们有了图像，如果我们让自己与它一致，那么，它们就是物质层面的延伸，使得我们可以在宇宙中实现它们。</p></li><li><p>The universe is not a thing that’s going to push us around.<br>宇宙并不是把我们推来推去的东西。</p></li><li><p>The world, people, and situations are not going to push us around.<br>人们，世界和环境并不会改变我们的追求。</p></li><li><p>We are going to bend the universe.<br>我们将驱动宇宙。</p></li><li><p>We are going to command and DEMAND that the universe become what we want it to be.<br>我们能够命令和要求宇宙成为我们希望成为的样子。</p></li><li><p>I studied the patterns of the universe.<br>我研究过宇宙的模式。</p></li><li><p>There’s a redemptive power that making a choice has.<br>人做选择的时候会产生一种救赎的力量。</p></li><li><p>Rather than feeling like you’re just affected by all the things happening, make a choice.<br>不要感到你的命运仅仅是被发生的事情所影响，做出你的选择！</p></li><li><p>Just DECIDE what you’re gonna be, who you’re gonna be, and how you’re gonna do it.<br>你必须决定，只要决定，你要成为什么，你要成为谁，你将做什么。</p></li><li><p>Just decide.<br>做出你的决定！</p></li><li><p>From that point on, the Universe is gonna get out of your way.<br>到那时，整个宇宙都会自动为你让路。</p></li></ol><hr><h2 id="font-color-red-DAY-17-font"><strong><font color='red'>DAY 17</font></strong></h2><p><strong>super hard</strong></p><ol><li><p>The first is you need to work, if you, depending on how well you want to do.<br>首先，你需要行动，这依赖于你究竟想要做的多好。</p></li><li><p>Particularly if you’re starting a company, you need to work super hard.<br>特别是对于创立公司的人，你需要超级努力地工作。</p></li><li><p>So what does super hard mean? 超级努力是什么意思呢？</p></li><li><p>Well, when my brother and I were starting up our first company, instead of getting an apartment, we just rented a small office.<br>我弟弟和我一起开创第一家公司的时候，我们租不起公寓，只租了一间小办公室。</p></li><li><p>And we slept on the couch.<br>我们都睡在沙发上。</p></li><li><p>And we showered at the YMCA.<br>我们在基督教青年会洗澡。</p></li><li><p>We were so hard up.<br>我们很拮据。</p></li><li><p>We had just one computer.<br>只买得起一台电脑。</p></li><li><p>The website was up during the day, and I was coding at night, seven days a week, all the time.<br>网站在白天运行，而我在晚上写代码，一周七天没有间歇。</p></li><li><p>And I briefly had a girlfriend at that period.<br>这期间我短暂交过一位女友。</p></li><li><p>And in order to be with me, she had to sleep in the office.<br>为了和我一起，她不得不也睡办公室。</p></li><li><p>So I worked hard at every waking hour.<br>我工作努力到醒着的时间都用于工作。</p></li><li><p>That’s the thing I would say particularly if you are starting a company.<br>特别是对于要开公司的人，这就是我的建议。</p></li><li><p>And if you do simple math, say like, if somebody else is working 50 hours, and you’re working 100, you’ll get twice as much done in the course of a year as the other company.<br>你可以简单算算，如果别人工作50小时，而你工作100小时，你公司在一年之内的成果肯定会比别人公司多一倍。</p></li></ol><hr><h2 id="font-color-red-DAY-18-font"><strong><font color='red'>DAY 18</font></strong></h2><p><strong>Think different 非同凡响</strong></p><ol><li><p>Here’s to the crazy ones.<br>向那些疯狂的家伙致敬。</p></li><li><p>The misfits.<br>他们我行我素。</p></li><li><p>The rebels.<br>桀骜不驯。</p></li><li><p>The troublemakers.<br>惹是生非。</p></li><li><p>The round pegs in the square holes.<br>就像方孔中的圆桩。</p></li><li><p>The ones who see things differently.<br>他们用不同的角度来看待事物。</p></li><li><p>They’re not fond of rules.<br>他们既不墨守成规。</p></li><li><p>And they have no respect for the status quo.<br>也不安于现状。</p></li><li><p>You can quote them, disagree with them, glorify or vilify them.<br>你尽可以引用他们，否定他们，颂扬抑或是诋毁他们。</p></li><li><p>About the only thing you can’t do is ignore them.<br>但唯独不能漠视他们。</p></li><li><p>Because they change things.<br>因为他们改变了事物。</p></li><li><p>They push the human race forward.<br>他们让人类向前跨越了一大步。</p></li><li><p>And while some may see them as the crazy ones, we see genius.<br>他们是别人眼里的疯子，却是我们眼中的天才。</p></li><li><p>Because the people who are crazy enough to think they can change the world, are the ones who do.<br>因为，只有疯狂到认为自己能够改变世界的人，才能真正地改变世界。</p></li></ol><hr><h2 id="font-color-red-DAY-19-font"><strong><font color='red'>DAY 19</font></strong></h2><p><strong>I always knew I was going to be rich 我一直知道我会富有</strong></p><ol><li><p>I always knew I was going to be rich.<br>我一直知道我会富有。</p></li><li><p>I don’t think I ever doubted it for a minute.<br>我一分钟都没怀疑过。</p></li><li><p>Einstein is reputed to have said that “compound interest is the eighth wonder of the world”. Or something like that.<br>据说爱因斯坦曾说过，“复利是世界的第八大奇迹”，或者类似的话。</p></li><li><p>And it goes back to that story, you probably learned when you were in grade school.<br>这总会追溯到那个故事，你可能在学校里听说过的故事。</p></li><li><p>Where somebody did something for the king.<br>有人为国王做了一些事情。</p></li><li><p>And the king said, “What can I do for you?”<br>国王说，“我能为你做什么。”</p></li><li><p>And he said, “Well, let’s take a chessboard, and put one kernel of wheat on the first square, and then double it on the second, and double it on the third.”<br>他说，“拿个棋盘，第一个格子里放一颗谷粒，第二个格子放两颗，第三个格子里再翻倍。”</p></li><li><p>And the king readily agreed to it, and by the time he figured out what two to the 64th amounted to, he was giving away the entire kingdom.<br>那国王立即同意了，而当他算出从第2个格子到第64个格子里总共是多少时，他就已经把整个王国的粮食给出去了。</p></li><li><p>So it’s a pretty simple concept, but over time, it accomplishes extraordinary things.<br>这是一个很简单的概念，但是随着时间的推移，就会有非凡的结果。</p></li></ol><hr><h2 id="font-color-red-DAY-20-font"><strong><font color='red'>DAY 20</font></strong></h2><p><strong>Compound interest 复利法则</strong></p><p>以下是按照第二篇格式修改后的文章：</p><ol><li><p>And very early, probably when I was seven or so, I took this book out of the Bensen Library, called “A thousand ways to make a $1,000.”<br>很早的时候，大概7岁时，我从本森图书馆借出一本书，《赚一千美元的一千种方法》。</p></li><li><p>And one of the ways in this book was having penny weighing machines.<br>书中的方法之一，就是拥有一台投币体重计。</p></li><li><p>I sat and calculated how much it would cost to buy the first weighing machine, and then how long it would take for the profit from that one to buy another one.<br>我坐下算了算我要花多少钱去购买第一台体重计，第一台体重计赚得的利润能购买另外一台需要花多长时间。</p></li><li><p>And I would sit there and create these compound interest tables to figure out how long it would take me to have a weighing machine for every person in the world.<br>我会坐在那里做复利表，去计算让世界上每个人都拥有一台体重秤需要多长时间。</p></li><li><p>I had everybody in the country weighing themselves ten times a day, and me just sitting there like John D. Rockefeller of weighing machines.<br>我要让所有美国人每天称十次体重，我只要坐在那里，像体重计行业的洛克菲勒。</p></li><li><p>That allowance when I was a little boy was a nickel a week,<br>但我想让我一个星期的零花钱不止五美分，</p></li><li><p>But I liked the idea of having a little more than a nickel a week to work with.<br>但我喜欢做我自己的老板。</p></li><li><p>And I went into business very early.<br>我很早就进入商业领域了。</p></li><li><p>I started selling Coca-Cola door to door.<br>我挨家挨户卖可口可乐。</p></li><li><p>I sold gum door to door.<br>我挨家挨户卖口香糖。</p></li><li><p>I sold “Saturday Evening Post,” “Liberty” Magazine, “Ladies Home Journal,” you name it.<br>我卖《星期六晚报》，卖《自由杂志》，《妇女家庭杂志》，凡是你想到的。</p></li><li><p>I think I enjoyed the game almost right from the start.<br>我觉得我从一开始就很喜欢这项游戏。</p></li><li><p>But I like being my own boss.<br>但我喜欢做我自己的老板。</p></li><li><p>That’s one thing I liked about delivering papers.<br>这是我喜欢投递报纸的原因之一。</p></li><li><p>I could arrange the route I wanted.<br>我可以安排我喜欢的路线。</p></li><li><p>Nobody was bothering me at 5.00 or 6.00 in the morning.<br>在早上五六点钟没人打扰我。</p></li><li><p>I was delivering 500 papers a day.<br>我一天投递500份报纸。</p></li><li><p>And I made a penny a paper, but in terms of compounding, that penny has turned into something else.<br>一份报纸赚一便士，但是通过复利法则，那一便士便换成了其他东西。</p></li></ol><hr><h2 id="font-color-red-DAY-21-font"><strong><font color='red'>DAY 21</font></strong></h2><p><strong>Method of learning 只有学习了学习方法才能进步</strong></p><ol><li>Alfred North Whitehead said it one time that “the rapid advance of civilization came only when man invented the method of invention.”<br>阿尔弗雷德·诺斯·怀特海曾经说过一句很正确的话，他说只有当人类“发明了发明的方法”之后，人类社会才能快速地发展。</li><li>And of course he was referring to the huge growth of GDP per capita and all the other good things that we now take for granted which started a few hundred years ago and before that all was stasis.<br>他指的是人均GDP的巨大增长和其他许多我们今天已经习以为常的好东西。人类社会在几百年前才出现了大发展，在那之前，每个世纪的发展几乎等于零。</li><li>So if civilization can progress only when it invents the method of invention, you can progress only when you learn the method of learning.<br>人类社会只有发明了发明的方法之后才能发展，同样的道理，你们只有学习了学习的方法之后才能进步。</li><li>I was very lucky.<br>我非常幸运。</li><li>I came to law school having learned the method of learning and nothing has served me better in my long life than continuous learning.<br>我读法学院之前就已经学会了学习的方法。在我这漫长的一生中，没有什么比持续学习对我的帮助更大。</li><li>And if you take Warren Buffett and watched him with a time clock, I would say half of all the time he spends is sitting on his ass and reading.<br>再拿沃伦·巴菲特来说，如果你们拿着计时器观察他，会发现他醒着的时候有一半时间是在看书。</li><li>And a big chunk of the rest of the time is spent talking one on one, either on the telephone or personally, with highly gifted people whom he trusts and who trust him.<br>他把剩下的时间大部分用来跟一些非常有才干的人进行一对一的交谈，有时候是打电话，有时候是当面，那些都是他信任且信任他的人。</li><li>In other words, it looks quite academic, all this worldly success.<br>换句话说，沃伦在世俗生活中的巨大成功，是通过很学术的方法获得的。</li></ol><hr><h2 id="font-color-red-DAY-22-font"><strong><font color='red'>DAY 22</font></strong></h2><p><strong>Change mindset change brain 改变思维模式，改变大脑</strong></p><ol><li>Just the words ‘yet’ or ‘not yet,’ we’re finding, give kids greater confidence, give them a path into the future that creates greater persistence.<br>我们发现，注重过程的思维模式，会赋予孩子们更多自信，指引他们不断向前，越发坚持不懈。</li><li>And we can actually change students’ mindsets.<br>事实上，我们能够改变学生的思维模式。</li><li>In one study, we taught them that every time they push out of their comfort zone to learn something new and difficult, the neurons in their brain can form new, stronger connections, and over time they can get smarter.<br>在一项研究中，我们告诉学生们，每当他们迫使自己走出舒适区，学习新知识，迎接新挑战，大脑中的神经元会形成新的更强的连接，他们会逐渐变得越来越聪明。</li><li>Look what happened.<br>看看后面发生了什么吧。</li><li>In this study, students who were not taught this growth mindset continued to show declining grades over this difficult school transition, but those who were taught this lesson showed a sharp rebound in their grades.<br>在这项研究中，没有接受成长型思维模式训练的学生，在这一困难的过渡阶段，成绩持续下滑，但那些受过该训练的学生，成绩强势反弹，卓有起色。<br>We have shown this now, this kind of improvement, with thousands and thousands of kids, especially struggling students.如今，我们已证实这一结论，通过成千上万个孩子的实例，尤其是那些在学业上挣扎的孩子。</li></ol><hr><h2 id="font-color-red-DAY-23-font"><strong><font color='red'>DAY 23</font></strong></h2><p><strong>Grit is the key to success 毅力是成功的关键</strong></p><ol><li>So I left the classroom, and I went to graduate school to become a psychologist.<br>所以我离开了讲台，回到研究院成为一名心理学家。</li><li>I started studying kids and adults in all kinds of super challenging settings, and in every study my question was, who is successful here and why?<br>我开始研究在各种非常具有挑战性的情况下的孩子和大人，在各项研究中，我的问题是：谁才是成功者，为什么他们会成功？</li><li>My research team and I went to West Point Military Academy.<br>我和我的研究团队前往西点军校展开调研。</li><li>We tried to predict which cadets would stay in military training and which would drop out.<br>我们试图预测哪些学员能够耐得住军队的训练，哪些会被淘汰出局。</li><li>We went to the National Spelling Bee and tried to predict which children would advance farthest in competition.<br>我们前去观摩全国拼字比赛，同时也试着预测哪些孩子会晋级到最后的比赛。</li><li>We studied rookie teachers working in really tough neighborhoods, asking which teachers are still going to be here in teaching by the end of the school year, and of those, who will be the most effective at improving learning outcomes for their students?<br>我们研究在恶劣的工作环境下工作的，刚入行的老师，询问他们哪些老师决定会在学年结束后继续留下来任教，以及他们之中谁能最快地提高学生的学习成绩。</li><li>We partnered with private companies, asking, which of these salespeople is going to keep their jobs?<br>我们与私企合作，向他们询问哪些销售人员可以保住工作。</li><li>And who’s going to earn the most money?<br>哪些人可以赚钱最多？</li><li>In all those very different contexts, one characteristic emerged as a significant predictor of success.<br>在所有那些不同的情境下，一种性格特征凸显了出来，这种特征在很大程度上预示了成功。</li><li>And it wasn’t social intelligence.<br>而且它并不是社交智力。</li><li>It wasn’t good looks, physical health, and it wasn’t I.Q.<br>不是漂亮的外表，强健的体魄，也不是很高的IQ。</li><li>It was grit.<br>它是毅力。</li><li>Grit is passion and perseverance for very long-term goals.<br>毅力是对长远目标的激情和坚持。</li><li>Grit is having stamina.<br>毅力是拥有持久的恒劲。</li><li>Grit is sticking with your future, day in, day out, not just for the week, not just for the month, but for years, and working really hard to make that future a reality.<br>毅力是你对未来的坚持，日复一日，而不仅仅是持续一个星期或者一个月，而是几年甚至几十年努力奋斗着让自己的梦想变为现实。</li><li>Grit is living life like it’s a marathon, not a sprint.<br>毅力是把生活当成一场马拉松而不是一次短跑。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试-基础</title>
      <link href="/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是对以下文章的摘录：<br><a href="http://c.biancheng.net/gdb/">C语言中文网-gdb调试</a></p></blockquote><h3 id="font-color-red-调试前提-font"><font color='red'>调试前提</font></h3><p>只有具备调试信息的可执行文件才可被调试，即，编译时需要添加 <code>-g</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gcc main.c main -g</span></span><br></pre></td></tr></table></figure><p>调试时最好不要优化代码，使用 <code>-O0</code> 默认级别即可。对 GDB 调试器更友好的是 <code>-Og</code> 选项，-Og 对代码所做的优化程序介于 O0 ~ O1 之间，真正可做到“在保持快速编译和良好调试体验的同时，提供较为合理的优化级别”。</p><hr><h3 id="font-color-red-常用命令-font"><font color='red'>常用命令</font></h3><table><thead><tr><th>调试指令</th><th>作 用</th></tr></thead><tbody><tr><td>(gdb) help</td><td><code>help commands</code> 能够显示 commands 命令的具体用法</td></tr><tr><td>(gdb) file program</td><td>调试 program 程序</td></tr><tr><td>(gdb) break xxx <br />(gdb) b xxx</td><td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置，可以是函数名、行号（当前源文件）、指定文件中的行号（b main.c:3）等</td></tr><tr><td>(gdb) run <br />(gdb) r</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。其后可以传入参数</td></tr><tr><td>(gdb) start</td><td>执行到 main 函数中的第一条指令停止。其后可以传入参数</td></tr><tr><td>(gdb) continue <br />(gdb) c</td><td>当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束</td></tr><tr><td>(gdb) next <br />(gdb) n</td><td>令程序一行代码一行代码的执行，也可指定一次执行的行数，不步入函数</td></tr><tr><td>(gdb) step<br />(gdb) s</td><td>令程序一行代码一行代码的执行，也可指定一次执行的行数，遇到函数则步入</td></tr><tr><td>(gdb) until<br />(gdb) u</td><td>使 GDB 调试器快速运行完当前的循环体，并运行至循环体外停止，可指定在某行停下</td></tr><tr><td>(gdb) finish</td><td>直接执行完当前函数</td></tr><tr><td>(gdb) return</td><td>立即跳出当前函数（即使有剩余代码也不会继续执行），并返回指定值</td></tr><tr><td>(gdb) print var <br />(gdb) p var</td><td>打印指定变量的值，也可以修改变量值：print var=1，高级用法参见<a href="http://c.biancheng.net/view/vip_8513.html">print</a></td></tr><tr><td>(gdb) display</td><td>每次程序暂停后都打印指定变量，使用 undisplay 或 disable 来取消显示</td></tr><tr><td>(gdb) list <br />(gdb) l</td><td>显示源程序代码的内容，包括各行代码所在的行号</td></tr><tr><td>(gdb) delete</td><td>删除指定编号的断点，不指定则删除全部</td></tr><tr><td>(gdb) clear</td><td>删除指定行的断点，不指定则删除当前行的断点</td></tr><tr><td>(gdb) disable</td><td>禁用指定编号的断点，不指定则禁用所有断点</td></tr><tr><td>(gdb) enable</td><td>开启指定编号的断点，不指定则开启所有断点</td></tr><tr><td>(gdb) quit <br />(gdb) q</td><td>终止调试</td></tr><tr><td>-q <br />-quiet <br />-silent</td><td>取消启动 GDB 调试器时打印的介绍信息和版权信息</td></tr><tr><td>–args prog arg1<br />(gdb) set args arg1 …</td><td>调试可执行程序 prog 并传入参数 arg1</td></tr><tr><td>(gdb) cd</td><td>修改 GDB 调试器的工作目录</td></tr><tr><td>(gdb) path xx/xx</td><td>临时修改环境变量</td></tr><tr><td>(gdb) info xxx</td><td>提供有关程序状态和调试环境的信息</td></tr><tr><td>(gdb) bt<br />(gdb) backtrace<br />(gdb) info stack</td><td>显示函数的调用堆栈</td></tr><tr><td>(gdb) info frame</td><td>显示当前函数栈帧的详细信息</td></tr><tr><td>(gdb) up</td><td>返回上一函数栈帧</td></tr><tr><td>(gdb) down</td><td>返回下一函数栈帧</td></tr><tr><td>(gdb) x</td><td>显示指定地址处的值，有多种格式，详细可在 gdb 中输入 help x 查看</td></tr><tr><td>(gdb) disassemble</td><td>反汇编指定地址处的代码，不指定则反汇编当前函数</td></tr><tr><td>(gdb) layout asm</td><td>以汇编格式调试整个程序，可以使用 layout src 切换到源代码模式</td></tr></tbody></table><blockquote><p><code>(gdb)</code> 表示已经运行 gdb，目前是 gdb 中的命令行。</p></blockquote><h3 id="font-color-orange-break-font"><font color='orange'>break</font></h3><p><strong>gdb 中有三种断点——普通断点、观察断点、捕捉断点。</strong></p><p>break 属于普通断点，其常用的语法格式有以下 2 种。</p><ul><li>(gdb) break location</li><li>(gdb) break … if cond</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号，行号通过 list 命令可以看到。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 表示具体行数。</td></tr><tr><td>+ offset - offset</td><td>offset 为整数（假设值为 2），+offset 表示以当前程序暂停位置（例如第 4 行）为准，向后数 offset 行处（第 6 行）打断点。</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 7 if num&gt;10</span><br><span class="line">(gdb) b 8 if p==null</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>break 还有两种变体：tbreak 和 rbreak</font></strong></p><p>tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，<strong>使用 tbreak 命令打的断点仅会作用 1 次</strong> 。</p><p><strong>rbreak 命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点</strong> 。rbreak 命令的使用语法格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rbreak regex</span><br></pre></td></tr></table></figure><p>其中 regex 为一个正则表达式，程序中函数的函数名只要满足 regex 条件，rbreak 命令就会其内部的开头位置打断点。该方法的一个妙用可参见<a href="https://jyx-fyh.github.io/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/">gdb调试-进阶</a> 。</p><p>使用 delete 命令清除所有断点，info breakpoints 查看所有断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete</span><br><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-watch-font"><font color='orange'>watch</font></h3><p>watch 断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch var</span><br><span class="line">(gdb) watch var if cond</span><br></pre></td></tr></table></figure><p>watch 的变体还有 rwatch 和 awatch：</p><ul><li>rwatch 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；</li><li>awatch 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。</li></ul><p>watch 命令有 <strong>硬件断点</strong> 和 <strong>软件断点</strong> 两种实现方式。软件断点监控目标变量后，GDB 调试器会以单步执行的方式运行程序，并且每行代码执行完毕后，都会检测该目标变量的值是否发生改变，因此软件断点会影响调试效率。硬件断点通过使用少量的寄存器（例如 32 位的 Intel x86 处理器提供有 4 个调试寄存器）来监控变量的值，而无需每次都主动检测变量是否改变，因此硬件断点不影响调试效率。</p><p>大多数 PowerPC 或者基于 x86 的操作系统，都支持采用硬件观点。<strong>并且 GDB 调试器在建立观察断点时，会优先尝试建立硬件观察点，只有当前环境不支持硬件观察点时，才会建立软件观察点。</strong></p><h3 id="font-color-orange-catch-font"><font color='orange'>catch</font></h3><p><strong>catch 捕捉断点的作用是监控程序中某一事件的发生</strong> ，例如程序发生某种异常时、某一动态库被加载时等等，一旦目标时间发生，则程序停止执行。 tcatch 命令只监控一次事件的发生。</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">catch exec</td><td style="text-align:center">捕获对exec的调用。</td></tr><tr><td style="text-align:center">catch fork</td><td style="text-align:center">捕获对fork的调用。</td></tr><tr><td style="text-align:center">catch load</td><td style="text-align:center">捕获共享库的加载。</td></tr><tr><td style="text-align:center">catch unload</td><td style="text-align:center">捕获共享库的卸载。</td></tr><tr><td style="text-align:center">catch signal</td><td style="text-align:center">按名称和/或编号捕获信号。</td></tr><tr><td style="text-align:center">catch syscall</td><td style="text-align:center">按名称、组和/或编号捕获系统调用。</td></tr><tr><td style="text-align:center">catch throw</td><td style="text-align:center">捕获被抛出的异常。</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>break、watch 有 if 形式，而 catch 则没有，如果想要使其成为条件断点，则需要用到 <strong>condition 命令</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type            Disp Enb Address                        What</span><br><span class="line">1       breakpoint      keep y     0x00005555555552d0  in main() at main.cpp:9    breakpoint already hit 1 time</span><br><span class="line">2       read watchpoint keep y                                       num</span><br><span class="line">3       catchpoint      keep y                                           exception throw      matching: int</span><br><span class="line">(gdb) condition 1 num==3             &lt;-- 为普通断点添加条件表达式</span><br><span class="line">(gdb) condition 2 num==5             &lt;-- 为观察断点添加条件表达式</span><br><span class="line">(gdb) condition 3 num==7             &lt;-- 为捕捉断点添加条件表达式</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-frame-font"><font color='orange'>frame</font></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb)info frame                              &lt;-- 打印当前栈帧的详细信息</span><br><span class="line">Stack level 0, frame at 0x7fffffffe240:      &lt;-- 栈帧编号0,地址 0x7fffffffe240</span><br><span class="line">rip = 0x4004cf in func (main.c:3); saved rip 0x4004e9   </span><br><span class="line">                                             &lt;-- 函数的存储地址0x4004cf,返回后的地址为0x4004e9</span><br><span class="line">called by frame at 0x7fffffffe260            &lt;-- 当前栈帧的上一级栈帧（编号 1 的栈帧）的地址为 0x7fffffffe260</span><br><span class="line">source language c.                           &lt;-- 当前栈帧使用的编程语言</span><br><span class="line">Arglist at 0x7fffffffe230, args: num=4       &lt;-- 函数参数的地址和值</span><br><span class="line">Locals at 0x7fffffffe230, Previous frame&#x27;s sp is 0x7fffffffe240  </span><br><span class="line">                                             &lt;--函数内部局部变量的存储地址</span><br><span class="line">Saved registers:                             &lt;-- 栈帧内部存储的寄存器</span><br><span class="line">  rbp at 0x7fffffffe230, rip at 0x7fffffffe238</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-info-font"><font color='orange'>info</font></h3><p>常见的 info 命令如下：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">info breakpoints</td><td style="text-align:center">列出当前设置的所有普通断点</td></tr><tr><td style="text-align:center">info watchpoints</td><td style="text-align:center">列出当前设置的所有观察断点</td></tr><tr><td style="text-align:center">info registers</td><td style="text-align:center">显示所有寄存器的当前值</td></tr><tr><td style="text-align:center">info address</td><td style="text-align:center">显示符号对应的地址</td></tr><tr><td style="text-align:center">info threads</td><td style="text-align:center">列出当前正在运行的所有线程</td></tr><tr><td style="text-align:center">info functions</td><td style="text-align:center">列出程序中定义的所有函数</td></tr><tr><td style="text-align:center">info variables</td><td style="text-align:center">列出 <strong>当前所有可见</strong> 的变量</td></tr><tr><td style="text-align:center">info locals</td><td style="text-align:center">打印当前函数中所有局部变量的值</td></tr><tr><td style="text-align:center">info args</td><td style="text-align:center">打印参数值</td></tr><tr><td style="text-align:center">info source</td><td style="text-align:center">显示当前源文件的名称和行号</td></tr><tr><td style="text-align:center">info sources</td><td style="text-align:center">显示此程序包含的所有源文件</td></tr><tr><td style="text-align:center">info frame</td><td style="text-align:center">显示当前帧的信息，包括函数名称和参数</td></tr><tr><td style="text-align:center">info stack</td><td style="text-align:center">显示调用堆栈</td></tr><tr><td style="text-align:center">info program</td><td style="text-align:center">显示正在调试的程序的名称和进程ID</td></tr><tr><td style="text-align:center">info sharedlibrary</td><td style="text-align:center">列出当前加载的共享库</td></tr><tr><td style="text-align:center">info target</td><td style="text-align:center">显示当前目标的信息，例如目标文件或核心转储文件</td></tr><tr><td style="text-align:center">info display</td><td style="text-align:center">display 命令查看的目标变量或表达式</td></tr></tbody></table><p><strong>更多 info 参数可输入 help info 进行查看。</strong></p><hr><h3 id="font-color-red-调试方式-font"><font color='red'>调试方式</font></h3><ol><li><p>调试尚未运行的程序：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb program</span></span><br><span class="line">或者 </span><br><span class="line">(gdb) file program</span><br></pre></td></tr></table></figure></li><li><p>调试正在运行的程序</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach program</span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb -p 进程号</span></span><br></pre></td></tr></table></figure><p>这种方式可能需要 root 权限。调式完毕后可执行 <code>detach</code> 指令，使 GDB 调试器和程序分离：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(gdb) detach</span></span><br><span class="line">或者直接退出</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(gdb) q</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-核心转储-font"><font color='red'>核心转储</font></h3><p>在 Linux 操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为 core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。当程序发生异常崩溃时，通过 GDB 调试 core 文件，往往可以更快速的解决问题。</p><p>默认情况下，Linux 系统不开启 core dump 这一功能，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>如果 core file size（core 文件大小）对应的值为 0，表示当前系统未开启 core dump 功能。这种情况下，可以通过执行如下指令改变 core 文件的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# ulimit -c unlimited</span><br><span class="line">[root@bogon demo]# ulimit -a</span><br><span class="line">core file size     (blocks, -c) unlimited</span><br></pre></td></tr></table></figure><p>假设执行 main.exe 发生数组越界错误生成 core 文件，则调试方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon demo]# gdb main.exe core</span><br></pre></td></tr></table></figure><p>如果没有生成 core，请参考<a href="https://www.jianshu.com/p/70e5b762386c">此处</a> 。</p><p>注意，Core文件中包含了程序运行时的内存映像（代码、数据和堆栈信息）、进程状态、系统信息、调试符号等，如果程序在崩溃时使用了大量的内存，那么 Core 文件可能会很大，可以使用 ulimit 命令来限制 Core 文件的最大大小。</p>]]></content>
      
      
      <categories>
          
          <category> 编译、链接与调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译、链接与调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试-进阶</title>
      <link href="/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/20/gdb%E8%B0%83%E8%AF%95-%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C:/Users/JiangYuxuan/Desktop/Typora/img/</p><h2 id="font-color-red-查看系统调用与库调用-font"><font color='red'>查看系统调用与库调用</font></h2><h2 id="font-color-red-跟踪每一次函数调用-font"><font color='red'>跟踪每一次函数调用</font></h2><p>这是一个非常常见的需求</p><h2 id=""></h2><ul><li><pre><code>  readelf -s 程序路径 | gawk '  &#123;     if($4 == &quot;FUNC&quot; &amp;&amp; $2 != 0) &#123;       print &quot;# code for &quot; $NF;       print &quot;b &quot; $NF;       print &quot;commands&quot;;       print &quot;silent&quot;;       print &quot;bt 1&quot;;       print &quot;c&quot;;       print &quot;end&quot;;       print &quot;&quot;;&#125;     &#125;' &gt; 输出文件  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>  gdb --command=输出文件 调试文件 -q</code></pre></li></ul><h2 id="font-color-red-跟踪一类函数调用-font"><font color='red'>跟踪一类函数调用</font></h2><p>rbreak</p><h2 id="font-color-red-信号处理-font"><font color='red'>信号处理</font></h2><p>参见<a href="http://c.biancheng.net/view/8291.html">handle</a> 。</p><h2 id="font-color-red-多线程调试-font"><font color='red'>多线程调试</font></h2><h2 id="font-color-red-多进程调试-font"><font color='red'>多进程调试</font></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>练习2-编译调试Nginx</title>
      <link href="/2023/05/16/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/"/>
      <url>/2023/05/16/%E7%BB%83%E4%B9%A02-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/">练习1-编译调试teamTalk</a>，<a href="https://jyx-fyh.github.io/2023/05/05/cmake%E5%85%A5%E9%97%A8/">cmake入门笔记</a>，对 makefile 有一定了解。<br>参考：<a href="https://www.jianshu.com/p/14c81fbcb401">nginx依赖库</a>，<a href="https://cloud.tencent.com/developer/article/2205549?from=article.detail.1476984&amp;areaSource=106000.16&amp;traceId=il-m4ntHJ8HD5tlLzMjN_">Windows下编译Nginx</a>，<a href="https://www.jianshu.com/p/3c2fdb06de9e">gdb远程调试</a>，《深入剖析Nginx》，chatgpt 。</p></blockquote><h2 id="font-color-red-前言-font"><font color='red'>前言</font></h2><p>Nginx 是一款高性能的开源Web服务器和反向代理服务器，其特点是占用内存少、并发能力强、处理静态文件快、可扩展性好、稳定性高、配置简单等。毫无疑问，花时间学习它将是一笔划算的投资，那么第一步便是编译、运行并调试它。本文给出以下几种途径来编译调试 Nginx：</p><ul><li><strong>原生 gdb 调试</strong></li><li><strong>CLion 编译数据库组织项目 + 远程 gdb 调试</strong></li><li><strong>CLion 原生支持 CMake 管理项目并调试</strong></li><li><strong>（转载）VS 编译调试 Nginx</strong></li></ul><p>在上节<a href="https://jyx-fyh.github.io/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/">练习1-编译调试teamTalk</a>中，我们熟悉了 Windows 的 Visual Studio 开发环境，本节我们则重点讲述 Linux 下的 CLion 开发环境，本机 Linux 环境为 Ubuntu 20.4.6 。</p><h2 id="font-color-red-原生-gdb-调试-font"><font color='red'>原生 gdb 调试</font></h2><p>此方式直接对包含调试信息的可执行程序 nginx 进行 gdb 调试，这种方式当然是最简单的，也当然是最痛苦的，没人希望在黑洞洞的狭窄界面中调试跟踪几万行的大型项目。<strong><font color='red'>下面先说明如何编译并配置 Nginx，此内容也是后续方法的前提步骤</font></strong> 。</p><h3 id="font-color-orange-1-安装依赖库-font"><font color='orange'>1.安装依赖库</font></h3><ul><li><p>pcre 库，以支持正则表达式。如果我们在配置文件 nginx.conf 中使用了正则表达式，那么必须链接此库。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev  </span><br></pre></td></tr></table></figure></li><li><p>zlib 库，用于对 HTTP 包的内容做 gzip 格式的压缩。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 库，用于支持 SSL 协议。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssl libssl-dev </span><br></pre></td></tr></table></figure></li></ul><h3 id="font-color-orange-2-安装-Nginx-font"><font color='orange'>2.安装 Nginx</font></h3><ol><li><p>在<a href="https://nginx.org/download/">官方</a>下载源码，考虑到《深入剖析Nginx》这本书采用的是 1.2.0 版本进行讲解，为了方便后续对照学习，笔者也下载的此版本。</p></li><li><p>在你喜欢的地方解压并进入该目录，使用以下配置生成 makefile：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-debug --prefix=<span class="string">&quot;/home/jyx/CLionProjects/nginx&quot;</span> --with-cc-opt=<span class="string">&quot;-Wno-error&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>--with-debug</code> ：添加调试信息，这是我们后续调试的前提！</strong></li><li><strong><code>--prefix=&quot;/home/jyx/CLionProjects/nginx&quot;</code> ：1）指定安装目录，如果不指定，则默认安装在 <code>usr/local/nginx</code> 下。2）<font color='orange'>每次启动 nginx 时，程序会首先从该位置的 conf 目录下读取 nginx.conf 配置文件。</font></strong><br>为了方便后续统一在 CLion 下编辑整个项目，我们不打算 make install，所以将路径设置为该目录本身，这样读取配置时就直接从该目录下的 conf 目录读取配置文件。<strong><font color='red'>注意，不能有中文路径！</font></strong></li><li><code>--with-cc-opt=&quot;-Wno-error&quot;</code> ：指定编译选项以忽略下面的错误：<br><img src="/2022/img/image-20230519150021172.png" alt=""></li></ul><blockquote><p><strong>输入 <code>./configure --help</code> 以查看其他选项。</strong></p></blockquote></li><li><p>执行 make ，你可能会遇到报错：<br><img src="/2022/img/webp.webp" alt=""><br>这是版本问题，不用慌，<strong>注释掉这行代码即可</strong> 。</p></li><li><p>使用 sudo 权限运行 objs/nginx，报错：<br><img src="/2022/img/image-20230519151235867.png" alt=""><br>小问题，我们在 nginx 目录下创建 logs 目录即可，重新运行，成功：<br><img src="/2022/img/image-20230519151351688.png" alt="成功访问本地服务器"></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps -aux | grep nginx</span><br><span class="line">jyx         1916  0.0  0.1 175184  8988 ?        Sl   May18   0:00 /usr/libexec/ibus-engine-simple</span><br><span class="line">root       15773  0.0  0.0   7324  1184 ?        Ss   00:38   0:00 nginx: master process /home/jyx/Downloads/nginx-1.2.0/objs/nginx</span><br><span class="line">nobody     15774  0.0  0.0   7960  3104 ?        S    00:38   0:00 nginx: worker process</span><br><span class="line">jyx        18578  0.0  0.0  17672   720 pts/1    S+   02:01   0:00 grep --color=auto ngi</span><br></pre></td></tr></table></figure><p>可见 Nginx 开启了多个进程。<strong><font color='gree'>注意，nginx 以后台方式运行，后续重启调试 nginx 时需要先关闭所有相关进程，否则会提示 bind 函数调用失败。关闭方法如下：</font></strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-orange-3-调试-nginx-font"><font color='orange'>3.调试 nginx</font></h3><p>在默认情况下， Nginx 会有多个进程，即一个主进程和多个工作进程（由 nginx.conf 决定）。如果要调试 Nginx 对客户端发过来请求的处理过程， 那么要注意请求是否被交付给另外一个工作进程处理而导致绑定到 gdb 的这个工作进程实际没有动作，为了方便，<strong><font color='gree'>我们直接指定工作进程的数量为 1 ：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure><p>同时，Nginx 默认以 daemon 形式运行， 即它会调用 fork 创建子进程并且把父进程直接 exit(0)丢弃， 而 gdb 默认将跟踪 fork() 之后的父进程， 这将导致跟踪丢失：<br><img src="/2022/img/image-20230519155524035.png" alt=""></p><p><strong>所以我们<font color='gree'>关闭 daemon 模式：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">daemon off;</span><br></pre></td></tr></table></figure><p>这样设置后，我们调试的是监控进程（master）的流程。工作进程（worker）由 master 进程 fork 而来，如果要调试 worker 进程，则需要在进入 gdb 后执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fbrk-mode child</span><br></pre></td></tr></table></figure><p>也就是让 gdb 跟踪 fork 之后的子进程。如果我们想要同时跟踪 master 和 worker，<strong>则直接将它们<font color='gree'>合并到一个进程中</font></strong> ，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf文件</span><br><span class="line">master_process off;</span><br></pre></td></tr></table></figure><p>这样，我们就将监控进程逻辑和工作进程逻辑全部合在了一个进程里。通过这三处配置，调试难度就大大降低了。</p><p>接下来我们使用 gdb 调试 objs 目录下的 nginx 程序即可，<strong><font color='orange'>注意使用 sudo 运行</font></strong> ：</p><p><img src="/2022/img/image-20230519151646848.png" alt="run起来后,程序被阻塞在某处，我们中断它(ctrl+c)，可以看到上图,程序执行流阻塞在epoll中"></p><p>接下来就开始你的调试之路吧。</p><hr><h2 id="font-color-red-CLion-编译数据库-gdb远程调试-font"><font color='red'>CLion 编译数据库+gdb远程调试</font></h2><p>Nginx 使用 makefile 来构建项目，而 CLion 本身使用 cmake 来组织管理项目，对 makefile 的支持还不够到位，因此无法直接接管 Nginx 项目。所幸的是，CLion 支持编译数据库（compile_commands.json），我们能够通过它来组织管理项目。读者朋友们可能不太熟悉编译数据库，下面是 chatgpt 对它的简单介绍：</p><blockquote><p>compile_commands.json 是一个 JSON 格式的文件，它包含了编译器生成的编译命令以及相关的源文件和编译选项。这个文件通常用于辅助代码分析工具，如代码编辑器、代码静态分析工具等，以便这些工具能够理解代码的编译过程，从而提供更好的代码提示、错误检查和重构等功能。<br><strong><font color='orange'>注意，它只能用来组织项目以便提供代码分析功能（比如代码跳转、代码提示等），其本身不是类似于 cmake 和 makefile 一类的构建文件，无法用来构建或生成项目</font></strong> 。</p></blockquote><ol><li>这里我们使用 compiledb 工具来生成 compile_commands.json，首先下载它：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过pip安装compiledb </span></span><br><span class="line">pip install compiledb </span><br></pre></td></tr></table></figure><ol start="2"><li>如之前所述，仍然先生成 makefile：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-debug --prefix=<span class="string">&quot;/home/jyx/CLionProjects/nginx&quot;</span> --with-cc-opt=<span class="string">&quot;-Wno-error&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>生成编译数据库 compile_commands.json ：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ compiledb -nf make</span><br><span class="line"><span class="comment">#-n选项表示执行make命令时不实际执行编译过程,只输出编译命令;-f选项指定Makefile文件的路径,如果不指定则默认使用当前目录下的Makefile文件.该命令利用make输出的编译信息来生成数据库.</span></span><br></pre></td></tr></table></figure><ol start="4"><li>通过 CLion 打开该编译数据库，open as projecct ：</li></ol><p><img src="/2022/img/image-20230519164056329.png" alt=""></p><p>这样我们就能利用 CLion 分析整个 Nginx 项目了。你可以试试点击头文件跳转的功能（CTRL+点击），如果不使用编译数据库，是无法跳转的（除非该头文件和目前文件在同一目录）。</p><p>此时我们仅获得了代码分析功能，还无法调试该项目，还需要借助 gdb 的远程调试功能。我们先使用 make 编译该项目生成 objs/nginx 可执行文件，然后开启 gdbserver：<br><img src="/2022/img/image-20230519170654151.png" alt=""></p><p>然后回到 CLion 添加配置选项：<br><img src="/2022/img/image-20230519170830143.png" alt=""></p><p><img src="/2022/img/image-20230519170923113.png" alt=""></p><p>点击 OK，接下来见证奇迹，点击右上方的 debug 虫子图标，开始调试：<br><img src="/2022/img/image-20230519172054271.png" alt=""><br>程序在断点处停了下来，调试成功。<strong>另外，如果我们想让程序中断下来，则需要在 gdbserver 处执行 CTRL+C，在 CLion 中的 gdb 窗口执行 CTRL+C 将没有任何反应。</strong></p><blockquote><p><strong>这里调试时依然别忘了我们之前的三处配置。</strong></p></blockquote><hr><h2 id="font-color-red-CLion-CMake-管理项目并调试-font"><font color='red'>CLion + CMake 管理项目并调试</font></h2><p>使用 gdb 远程调试总感觉有些别扭，而且中断程序时也不方便，所以下面我们尝试用 CLion 原生支持的 cmake 来管理项目。首先我们需要将 makefile 转换为 CMakeLists.txt ，这里有几点说明：</p><ul><li>cmake 比 makefile 更抽象，具备一些 makefile 没有的东西，所以不存在一种统一（或者说官方）的工具来将 makefile 转为 CMakeLists.txt 。</li><li>一般来说，采用 makefile 管理的项目中，其 makefile 都比较简单（不像 cmake 生成的 makefile，那可不是人看的），完全可以手动将其转换为 CMakeLists.txt 。</li></ul><p>就 objs 目录下的 makefile 来说（执行 configure 后），其表达的功能就三个：</p><ol><li><p>将指定源文件生成目标文件，如：</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CORE_INCS)</span> </span><br><span class="line">-o objs/src/core/nginx.o \</span><br><span class="line">src/core/nginx.c</span><br><span class="line"><span class="comment">#nginx.c --&gt; nginx.o</span></span><br></pre></td></tr></table></figure></li><li><p>将所有目标文件和库文件链接成可执行文件（第 208 行）：</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(LINK)</span> -o objs/nginx 所有目标文件 \</span><br><span class="line">-lpthread -lcrypt -lpcre -lcrypto -lcrypto -lz <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure></li><li><p>至于第 1068 行之后的就不用管了，它们是用来处理文档和安装任务的。</p></li></ol><p>所以转 CMakeLists.txt 是很轻松的，当然，前提是你需要有一定的 makefile 和 cmake 基础（头秃），下面给出笔者转换的 CMakeLists.txt ：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(nginx_cmake)</span><br><span class="line"><span class="keyword">set</span>(    SRC</span><br><span class="line">        src/core/nginx.c</span><br><span class="line">        src/core/ngx_log.c</span><br><span class="line">        src/core/ngx_palloc.c</span><br><span class="line">        src/core/ngx_array.c</span><br><span class="line">        src/core/ngx_list.c</span><br><span class="line">        src/core/ngx_hash.c</span><br><span class="line">        src/core/ngx_buf.c</span><br><span class="line">        src/core/ngx_queue.c</span><br><span class="line">        src/core/ngx_output_chain.c</span><br><span class="line">        src/core/ngx_string.c</span><br><span class="line">        src/core/ngx_parse.c</span><br><span class="line">        src/core/ngx_inet.c</span><br><span class="line">        src/core/ngx_file.c</span><br><span class="line">        src/core/ngx_crc32.c</span><br><span class="line">        src/core/ngx_murmurhash.c</span><br><span class="line">        src/core/ngx_md5.c</span><br><span class="line">        src/core/ngx_rbtree.c</span><br><span class="line">        src/core/ngx_radix_tree.c</span><br><span class="line">        src/core/ngx_slab.c</span><br><span class="line">        src/core/ngx_times.c</span><br><span class="line">        src/core/ngx_shmtx.c</span><br><span class="line">        src/core/ngx_connection.c</span><br><span class="line">        src/core/ngx_cycle.c</span><br><span class="line">        src/core/ngx_spinlock.c</span><br><span class="line">        src/core/ngx_cpuinfo.c</span><br><span class="line">        src/core/ngx_conf_file.c</span><br><span class="line">        src/core/ngx_resolver.c</span><br><span class="line">        src/core/ngx_open_file_cache.c</span><br><span class="line">        src/core/ngx_crypt.c</span><br><span class="line">        src/event/ngx_event.c</span><br><span class="line">        src/event/ngx_event_timer.c</span><br><span class="line">        src/event/ngx_event_posted.c</span><br><span class="line">        src/event/ngx_event_busy_lock.c</span><br><span class="line">        src/event/ngx_event_accept.c</span><br><span class="line">        src/event/ngx_event_connect.c</span><br><span class="line">        src/event/ngx_event_pipe.c</span><br><span class="line">        src/os/unix/ngx_time.c</span><br><span class="line">        src/os/unix/ngx_errno.c</span><br><span class="line">        src/os/unix/ngx_alloc.c</span><br><span class="line">        src/os/unix/ngx_files.c</span><br><span class="line">        src/os/unix/ngx_socket.c</span><br><span class="line">        src/os/unix/ngx_recv.c</span><br><span class="line">        src/os/unix/ngx_readv_chain.c</span><br><span class="line">        src/os/unix/ngx_udp_recv.c</span><br><span class="line">        src/os/unix/ngx_send.c</span><br><span class="line">        src/os/unix/ngx_writev_chain.c</span><br><span class="line">        src/os/unix/ngx_channel.c</span><br><span class="line">        src/os/unix/ngx_shmem.c</span><br><span class="line">        src/os/unix/ngx_process.c</span><br><span class="line">        src/os/unix/ngx_daemon.c</span><br><span class="line">        src/os/unix/ngx_setaffinity.c</span><br><span class="line">        src/os/unix/ngx_setproctitle.c</span><br><span class="line">        src/os/unix/ngx_posix_init.c</span><br><span class="line">        src/os/unix/ngx_user.c</span><br><span class="line">        src/os/unix/ngx_process_cycle.c</span><br><span class="line">        src/os/unix/ngx_linux_init.c</span><br><span class="line">        src/event/modules/ngx_epoll_module.c</span><br><span class="line">        src/os/unix/ngx_linux_sendfile_chain.c</span><br><span class="line">        src/core/ngx_regex.c</span><br><span class="line">        src/http/ngx_http.c</span><br><span class="line">        src/http/ngx_http_core_module.c</span><br><span class="line">        src/http/ngx_http_special_response.c</span><br><span class="line">        src/http/ngx_http_request.c</span><br><span class="line">        src/http/ngx_http_parse.c</span><br><span class="line">        src/http/ngx_http_header_filter_module.c</span><br><span class="line">        src/http/ngx_http_write_filter_module.c</span><br><span class="line">        src/http/ngx_http_copy_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_log_module.c</span><br><span class="line">        src/http/ngx_http_request_body.c</span><br><span class="line">        src/http/ngx_http_variables.c</span><br><span class="line">        src/http/ngx_http_script.c</span><br><span class="line">        src/http/ngx_http_upstream.c</span><br><span class="line">        src/http/ngx_http_upstream_round_robin.c</span><br><span class="line">        src/http/ngx_http_parse_time.c</span><br><span class="line">        src/http/modules/ngx_http_static_module.c</span><br><span class="line">        src/http/modules/ngx_http_index_module.c</span><br><span class="line">        src/http/modules/ngx_http_chunked_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_range_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_headers_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_not_modified_filter_module.c</span><br><span class="line">        src/http/ngx_http_busy_lock.c</span><br><span class="line">        src/http/ngx_http_file_cache.c</span><br><span class="line">        src/http/modules/ngx_http_gzip_filter_module.c</span><br><span class="line">        src/http/ngx_http_postpone_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_ssi_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_charset_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_userid_filter_module.c</span><br><span class="line">        src/http/modules/ngx_http_autoindex_module.c</span><br><span class="line">        src/http/modules/ngx_http_auth_basic_module.c</span><br><span class="line">        src/http/modules/ngx_http_access_module.c</span><br><span class="line">        src/http/modules/ngx_http_limit_conn_module.c</span><br><span class="line">        src/http/modules/ngx_http_limit_req_module.c</span><br><span class="line">        src/http/modules/ngx_http_geo_module.c</span><br><span class="line">        src/http/modules/ngx_http_map_module.c</span><br><span class="line">        src/http/modules/ngx_http_split_clients_module.c</span><br><span class="line">        src/http/modules/ngx_http_referer_module.c</span><br><span class="line">        src/http/modules/ngx_http_rewrite_module.c</span><br><span class="line">        src/http/modules/ngx_http_proxy_module.c</span><br><span class="line">        src/http/modules/ngx_http_fastcgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_uwsgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_scgi_module.c</span><br><span class="line">        src/http/modules/ngx_http_memcached_module.c</span><br><span class="line">        src/http/modules/ngx_http_empty_gif_module.c</span><br><span class="line">        src/http/modules/ngx_http_browser_module.c</span><br><span class="line">        src/http/modules/ngx_http_upstream_ip_hash_module.c</span><br><span class="line">        src/http/modules/ngx_http_upstream_keepalive_module.c</span><br><span class="line">        objs/ngx_modules.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        src/core</span><br><span class="line">        src/event</span><br><span class="line">        src/event/modules</span><br><span class="line">        src/os/unix</span><br><span class="line">        objs</span><br><span class="line">        src/http</span><br><span class="line">        src/http/modules</span><br><span class="line">        src/mail</span><br><span class="line">        src/core</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(nginx <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(nginx pthread crypt pcre crypto z)</span><br></pre></td></tr></table></figure><p>是不是感觉太简洁了？没错，就是这么简单。将这个 txt 放在项目的根目录下。</p><p>接下来执行 configure，还是之前的选项（注意修改路径），然后进入 objs 目录，执行 <code>cmake ..</code> 生成 makefile，最后 <code>make</code> 生成可执行文件，一切顺利！<br>此时我们用 CLion 打开该项目（如果之前已经打开过，记得删除项目根目录下的 .idea 文件，避免项目缓存而检测不到 CMakeLists.txt），可以发现此时 CLion 就是使用 cmake 来管理项目的：<br><img src="/2022/img/image-20230519195102239.png" alt=""></p><p>然后点击右上角的运行图标，报错如下：<br><img src="/2022/img/image-20230519195155896.png" alt="image-20230519195155896"></p><p>这是提示权限不够，我们使用管理员权限来运行，修改步骤如下：<br><img src="/2022/img/image-20230519195504657.png" alt="image-20230519195504657"></p><p>然后运行，成功！<br><img src="/2022/img/image-20230519195605854.png" alt=""></p><p>再试试调试，效果不错！<br><img src="/2022/img/image-20230519195719650.png" alt="image-20230519195719650"></p><p>而且我们可以直接在 <code>Console</code> 中断程序来看目前执行流阻塞在哪，下图指出程序阻塞在 epoll_wait 中：<br><img src="/2022/img/image-20230519195904875.png" alt=""></p><p>笔者认为这种方式是最优雅的方式，读者朋友喜欢哪一种呢？</p><hr><h2 id="font-color-red-VS调试Nginx-font"><font color='red'>VS调试Nginx</font></h2><p>参考<a href="https://www.taurusxin.com/nginx-windows-build/#%E9%85%8D%E7%BD%AE-64-%E4%BD%8D-openssl">Windows编译Nginx</a>、<a href="https://cloud.tencent.com/developer/article/2205549?from=article.detail.1476984&amp;areaSource=106000.16&amp;traceId=il-m4ntHJ8HD5tlLzMjN_">VS调试Nginx</a> 。</p><hr><h2 id="font-color-red-注意事项-font"><font color='red'>注意事项</font></h2><p>有人发现 CLion 能够直接为外部导入的项目生成 CMakeLists.txt，如下：<br><img src="/2022/img/image-20230520124805926.png" alt=""></p><p><strong>自动创建 CMakeLists.txt 会将项目中的所有 .h 和 .c 文件都包含进来，这是不应该的！</strong> 我们应该根据执行 ./configure 后产生的 makefile 来按需引入 .c 和 .h 文件，即根据配置来引入，这是因为可能你明明指定了不需要某个功能，但却引入了相关的文件，这会在编译时产生大量报错，令人头疼不已！</p><hr><h2 id="font-color-red-总结-font"><font color='red'>总结</font></h2><ul><li>查看 README，了解项目功能、选项、依赖。</li><li>运行 <code>./configure --help</code> 来查看编译选项。</li><li>项目编译出错时，看看配置是否对的上，比如你没有配置某个功能，却引入了相关的源文件。</li><li>一些莫名奇妙的问题多问问 google 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译、链接与调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译、链接与调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非阻塞套接字及其注意事项</title>
      <link href="/2023/05/07/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/05/07/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同时，如果对这种套接字进行读操作，那么 read/recv 将返回 -1 。</p><p>《高》P163，清除错误。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake学习-从实例入手</title>
      <link href="/2023/05/05/cmake%E5%85%A5%E9%97%A8/"/>
      <url>/2023/05/05/cmake%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-概要-font"><font color='red'>概要</font></h2><p>本篇笔记从实例出发，逐步分析 cmake 的使用方法。为了更好地拟合真实项目，本实例有如下功能：</p><ul><li><p>添加项目版本号</p></li><li><p>添加编译选项，可选择使用 myMath 库或第三方 3rdMath 库</p></li><li><p>使用了静态链接库和动态链接库，既有项目生成的库，也有第三方库</p></li><li><p>提供了安装功能</p></li><li><p>能够在 Windows 和 Linux 下成功编译运行</p><blockquote><p>读者可能认为 cmake 本来就是跨平台的，所以支持 Windows 和 Linux 应该是理所当然的。实际上，支持跨平台还需要注意一些问题，后文会提到它们。</p></blockquote></li></ul><blockquote><p>项目地址：<a href="https://github.com/jyx-fyh/cmakeLearn/tree/master">cmake实例</a></p></blockquote><p>另外，初学 cmake 的朋友们可以在 Linux 下试试 CLion ，其本身就是用 cmake 管理项目，很容易上手。</p><p>分析本项目之前，先来简单了解一下 cmake 。</p><h2 id="font-color-red-cmake、nmake、make、makefile-font"><font color='red'>cmake、nmake、make、makefile</font></h2><p><img src="/2022/img/v2-497f031761c929e5c036138f938508c6_1440w.webp" alt=""></p><p>make 是 Unix/Linux 下的一个构建工具，用于自动化构建和编译过程。它可以读取一个名为 Makefile 的文件，根据其中的指令来编译和链接源代码文件，生成可执行文件或库文件。实际上，make 最后也是调用的 gcc 和 ld 来完成编译和链接任务。Makefile 最早由程序员直接编写，但很快凸显出瓶颈：1）对于大型项目，手写 Makefile 文件相当费时费力；2）Makefile 和 make 都是 Unix/Linux 下管理工程的工具，无法跨平台使用。于是 cmake 应运而生，利用 cmake，<strong>可以根据 CMakelist.txt 在不同的平台下上产生不同的<u><font color='orange'>构建文件</font></u></strong>，<strong>比如 Linux 下产生 Makefile，Windows 下则产生 .sln 解决方案文件和 .vcxproj 项目文件等</strong> 。那么 nmake 呢？在 Linux 下，make 根据 Makefile 来构建项目，而 Windows 下则是 nmake 根据 Makefile 来构建项目。</p><h2 id="font-color-red-目录结构-font"><font color='red'>目录结构</font></h2><p>为了使后续的讲解更加具体，先给出本项目的目录结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="number">3</span>rdParty</span><br><span class="line">│   ├── lib3rdMath</span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   │   └── lib3rdMath.a</span><br><span class="line">│   │   └── include</span><br><span class="line">│   │       └── <span class="number">3</span>rdMath.h</span><br><span class="line">│   └── libplay</span><br><span class="line">│       ├── bin</span><br><span class="line">│       │   └── libplay.a</span><br><span class="line">│       └── include</span><br><span class="line">│           └── play.h</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── config.h.in</span><br><span class="line">├── include</span><br><span class="line">│   └── student.h</span><br><span class="line">├── libs</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── myMath</span><br><span class="line">│   │   ├── include</span><br><span class="line">│   │   │   └── myMath.h</span><br><span class="line">│   │   └── src</span><br><span class="line">│   │       └── myMath.c</span><br><span class="line">│   └── work</span><br><span class="line">│       ├── include</span><br><span class="line">│       │   └── work.h</span><br><span class="line">│       └── src</span><br><span class="line">│           └── work.c</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── student.c</span><br></pre></td></tr></table></figure><ul><li><code>src</code> 目录用来存放项目的主要逻辑代码，<code>include</code> 则存放对应头文件。</li><li><code>lib</code> 目录用来存放项目自己的库的源代码，<strong>myMath是静态库，work是动态库</strong> 。</li><li><code>3rdParty</code> 目录存放第三方库文件，包含静态链接库和对应头文件。</li><li><code>config.h.in</code> 用来配置项目，后文细说。</li><li><code>README</code> 用来简单说明项目的使用方法，必不可少。</li><li><code>CMakeLists.txt</code> 当然是用来指挥整个项目的编译啦，注意，文件名严格区分大小写。</li></ul><h2 id="font-color-red-外部构建-font"><font color='red'>外部构建</font></h2><p>通常我们不会在 <strong>根目录（最外层的 CMakeLists.txt 所在的目录）</strong> 中直接编译项目，这样的话生成文件会和源文件会混杂在一起凌乱不堪。常见的做法是在根目录下创建一个 build 目录，然后在 build 中进行编译，这就叫做 <strong>外部构建</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样所有的生成文件都会存放在 build 中，不会影响原来的目录结构。</p><p>提到构建目录，就不得不说 cmake 的内置变量 <code>PROJECT_BINARY_DIR</code> 。<strong><code>PROJECT_BINARY_DIR</code> 指向的是我们执行 <code>cmake</code> 命令时所处的目录，对于本项目，就指向 build 目录。<code>PROJECT_SOURCE_DIR</code> 指向的是根目录。</strong> 其他变量见后文。</p><h2 id="font-color-red-构建顺序与传播规律-font"><font color='red'>构建顺序与传播规律</font></h2><p>cmake 根据 CMakeLists.txt 来生成 Makefile 。<strong>项目的不同目录中可以存在多个 CMakeLists.txt ，它们之间存在一定的联系和依赖关系</strong> 。就本项目而言，内层的 CMakeLists.txt 指导生成 myMath 静态库和 work 动态库，外层的 CMakeList.txt 则需要使用这两个库。<br>CMakeLists.txt 文件还可以定义一些全局变量或宏，<strong>这些变量或宏可以在不同的CMakeLists.txt文件之间共享和使用</strong> ，以便在整个项目中保持一致性，本项目中外层就向内层传递了 USE_MYMATH 宏，内层判断此宏是否被定义，若定义则会生成 myMath 库，细节后文详述。</p><p>内外层的 CMakeLists.txt 是怎么联系起来的呢？很简单，使用 cmake 的内置命令 <code>add_subdirectory</code> 。外层 CMakeLists.txt 中使用此命令来添加内层 CMakeLists.txt 所在的目录，然后 cmake 就会自动搜索该目录下的 CMakeLists.txt 并建立联系。</p><p><strong><font color='orange'>绝大多数教程会忽略但又必须提到的一点：cmake 构建项目时采用的是深度优先遍历</font></strong> ，也就是说，扫描 CMakeLists.txt 时只要碰到 <code>add_subdirectory</code> 就会立刻进入内层 CMakeLists.txt 并继续扫描。证明这个结论很简单，利用 cmake 的打印命令 <code>message</code> 即可，如下构建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir0</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── dir3</span><br><span class="line">│       └── CMakeLists.txt</span><br><span class="line">├── dir2</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure><p>各自目录的 CMakeLists.txt 如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dir0</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(untitled C)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir0-before&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir2)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir0-after&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir1</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir1-before&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir3)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir1-after&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir2</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dir3</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;dir3&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建并进入 build 目录，构建项目，提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/CLionProjects/dir0$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/dir0$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/dir0/build$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">.....省略......</span><br><span class="line">dir0-before</span><br><span class="line">dir1-before</span><br><span class="line">dir3</span><br><span class="line">dir1-after</span><br><span class="line">dir2</span><br><span class="line">dir0-after</span><br></pre></td></tr></table></figure><p>可见，确实是按深度优先顺序来构建的：<br><img src="/2022/img/ahshita.png" alt=""></p><p>笔者强调这个不起眼的顺序问题是因为它很多时候会影响构建结果，而且错误很难排查。具体而言，<strong><font color='orange'>局部变量（自定义变量）在各层 CMakeLists.txt 中的共享情况就会受构建顺序的影响</font></strong> 。那么，局部变量是如何在各个 CMakeLists.txt 中传递并共享的呢？笔者总结了一个前提条件和两个约束条件：</p><p><strong>前提条件：</strong></p><ul><li>如果想要变量向下层传递，则必须在调用 <code>add_subdirectory</code> 前定义变量。</li></ul><p><strong>约束条件：</strong></p><ul><li>作用域：变量只能从外层向内层传递。</li><li>继承链：变量只能沿着父（外）子（内）继承链传播，兄弟之间不能共享。</li></ul><blockquote><p><strong><font color='orange'>注意，以上规则只适用于自定义变量，不适用于全局变量，即 cmake 的内置变量。</font></strong></p></blockquote><p>用下面的图来表示也许更加直观，其中红色箭头代表不能传播，绿色箭头代表可以传播：<br><img src="/2022/img/mdfuck.png" alt="dir0定义了A变量,dir1定义了B变量"></p><p>另外，<strong><font color='orange'>不仅变量有这样的规则，某些函数也符合此规律</font></strong> ，比如 add_definition，使用此函数定义 C/C++ 宏后，该宏也会按照以上规则传播，同样的还有 option 和 configure_file 函数，下文还会提到这个问题。</p><blockquote><p><strong><font color='red'>声明：这三个条件是由笔者实践得出，如有错误，敬请指正！</font></strong></p></blockquote><h2 id="font-color-red-项目分析-font"><font color='red'>项目分析</font></h2><p>本项目的目录结构已经在上面给出，下面是内外层的 CMakeLists.txt 和 configure.in.h ：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#外层CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>) <span class="comment">#要求cmake最低版本</span></span><br><span class="line"><span class="keyword">project</span>(cmake VERSION <span class="number">3.0</span>) <span class="comment">#指定项目名称和版本</span></span><br><span class="line"><span class="comment"># 是否使用自己的Math库</span></span><br><span class="line"><span class="keyword">option</span> (USE_MYMATH <span class="comment">#添加编译选项,这是变量而不是宏</span></span><br><span class="line">        <span class="string">&quot;Use provided math implementation&quot;</span> <span class="comment">#打印信息</span></span><br><span class="line">        <span class="keyword">ON</span>) <span class="comment">#变量默认值为 ON</span></span><br><span class="line"><span class="keyword">configure_file</span> (<span class="string">&quot;config.h.in&quot;</span> <span class="string">&quot;config.h&quot;</span>) <span class="comment">#添加配置文件,上面的编译选项就记录在配置文件中</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(libs) <span class="comment">#关联子目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src/ SRC) <span class="comment">#自动搜索src下的所有文件并赋值给SRC变量</span></span><br><span class="line"><span class="keyword">set</span>(LIB play work) <span class="comment">#将play和work库赋值给LIB变量</span></span><br><span class="line"><span class="comment"># 是否加入 myMath 库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span> (<span class="string">&quot;libs/myMath/include&quot;</span>) <span class="comment">#添加头文件搜索目录</span></span><br><span class="line">    <span class="keyword">set</span> (LIB <span class="variable">$&#123;LIB&#125;</span> myMath) <span class="comment">#向LIB变量中添加myMath</span></span><br><span class="line">    <span class="comment">#推荐使用list(APPEND LIB myMath)代替上行</span></span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">include_directories</span> (<span class="string">&quot;3rdParty/lib3rdMath/include&quot;</span>)</span><br><span class="line">    <span class="keyword">link_directories</span>(<span class="string">&quot;3rdParty/lib3rdMath/bin&quot;</span>) <span class="comment">#添加库文件搜索目录</span></span><br><span class="line">    <span class="keyword">set</span> (LIB <span class="variable">$&#123;LIB&#125;</span> <span class="number">3</span>rdMath)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        <span class="string">&quot;include&quot;</span></span><br><span class="line">        <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span> <span class="comment">#config.h</span></span><br><span class="line">        <span class="string">&quot;libs/work/include&quot;</span></span><br><span class="line">        <span class="string">&quot;3rdParty/libplay/include&quot;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">&quot;3rdParty/libplay/bin&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin) <span class="comment">#指定可执行文件的输出目录</span></span><br><span class="line"><span class="keyword">add_executable</span>(ctest <span class="variable">$&#123;SRC&#125;</span>) <span class="comment">#利用SRC变量中的源文件生成可执行文件ctest</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ctest <span class="variable">$&#123;LIB&#125;</span>) <span class="comment">#将库文件链接到ctest可执行文件</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS ctest DESTINATION bin) <span class="comment">#安装ctest到目录bin</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内层CMakeLists.txt</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(myMath/src/ myMathSrc)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(work/src workSrc)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin) <span class="comment">#设置库文件的输出目录</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH) <span class="comment">#该变量是在上层txt中定义</span></span><br><span class="line">    <span class="keyword">add_library</span>(myMath STATIC <span class="variable">$&#123;myMathSrc&#125;</span>) <span class="comment">#生成myMath静态链接库</span></span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"><span class="keyword">if</span>(WIN32) <span class="comment">#如果是在Windows下构建</span></span><br><span class="line">    <span class="keyword">add_definitions</span>(-D_WIN32_) <span class="comment">#则编译源文件时定义宏_WIN32_</span></span><br><span class="line">    <span class="keyword">set</span>(LIB_POS bin)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(LIB_POS lib)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_library</span>(work SHARED <span class="variable">$&#123;workSrc&#125;</span>) <span class="comment">#生成work共享库</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS work DESTINATION &#123;LIB_POS&#125;) <span class="comment">#将work库安装到&#123;LIB_POS&#125;中</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//configure.h.in</span><br><span class="line">#cmakedefine USE_MYMATH //如果USE_MYMATH变量为ON,则定义该宏,否则不定义</span><br><span class="line">#define PROJECT_VERSION_MAJOR @PROJECT_VERSION_MAJOR@ //用cmake中的版本变量来定义宏</span><br><span class="line">#define PROJECT_VERSION_MINOR @PROJECT_VERSION_MINOR@ //用cmake中的版本变量来定义宏</span><br><span class="line">#define PROJECT_NAME @PROJECT_NAME@ //用cmake中的名称变量来定义宏</span><br></pre></td></tr></table></figure><p>注释较为详细，下面选择性讲解一些需要补充说明的内容。先来分析外层 txt ：</p><ul><li><p><strong>外层 txt 的任务是生成可执行文件并链接库，库的生成则交给内层 txt</strong> 。</p></li><li><p>第 3 行， <code>project</code> 函数指定了项目名称和版本，有什么用呢？首先，指定项目名称后，内置变量 <code>PROJECT_NAME</code> 会被自动赋值为该名称，后续就可以直接使用该变量。<strong><font color='orange'>使用变量的语法为 <code>$&#123;变量名&#125;</code></font></strong> 。其次，指定版本后，内置变量 <code>PROJECT_VERSION_MAJOR</code> （主版本号）和 <code>PROJECT_VERSION_MINOR</code> （副版本号）也会被自动赋值。我们在 <a href="http://configure.h.in">configure.h.in</a> 中使用了它们，该文件作用见下文。</p></li><li><p>第 5 行，定义了 USE_MYMATH 选项，默认为 ON ，即使用 myMath 库。其实 option 函数完全可以使用 set 函数来替代：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(USE_MYMATH <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>只不过采用 set 则无法被 ccmake 检测为选项。<strong><font color='orange'>ccmake 是 cmake 的扩展，能够在构建时提供简单的可视化界面来配置编译选项</font></strong> ：<br><img src="/2022/img/image-20230514102921312.png" alt=""><br>可见，使用 option 命令则会在 ccmake 中看到 USE_MYMATH 选项。</p><blockquote><p><strong><font color='orange'>图中的 <code>CMAKE_BUILD_TYPE</code> 也是 cmake 内置的选项，你可以将其定义为 Debug 以开启调试模式（默认是 Release 模式）</font></strong> 。除了这种方式，还可以通过其他cmake变量开启调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定CMAKE_CFLAGS参数</span><br><span class="line">cmake -DCMAKE_C_FLAGS=&quot;-g -O0&quot; ..</span><br></pre></td></tr></table></figure></blockquote></li><li><p>第 8 行，生成配置文件。<strong><code>configure.h</code> 是 <code>configure.h.in</code> 的输出文件，后者由我们手动编写</strong> 。configure.h 会被输出到构建目录（build）中。<strong><font color='orange'><a href="http://configure.h.in">configure.h.in</a> 能够使用 CMakeLists.txt 中的变量</font></strong> ，使用方法见上文 <a href="http://configure.h.in">configure.h.in</a> 。</p></li><li><p><strong><font color='orange'>生成 configure.h 时，需要注意顺序——<a href="http://configure.h.in">configure.h.in</a> 中使用的变量应该在调用 configure_file 函数前定义</font></strong> 。如果你不信，可以将第 5 行的 option 放到 configure_file 函数之后，编译并运行程序后你会发现奇怪的现象。</p><blockquote><p>所以为了保险起见，可以总是将 configure_file 放在最后。</p></blockquote></li><li><p>第 15 行，<code>set (LIB $&#123;LIB&#125; myMath)</code> 的含义是：如果 LIB 不存在，则为其赋值 myMath；如果存在，则添加值，而不会覆盖原有值。<strong>可以使用可读性更强的 <code>list(APPEND LIB myMath)</code> 来代替</strong> 。</p></li><li><p>第 19 行，添加库文件的搜索目录，这里添加的是第三方库的目录。<strong>注意，对于我们自己生成的库（内层 txt 的第 14 行）则无需手动添加搜索目录，cmake 会自动将库的输出目录（内层第 4 行）添加进去</strong> 。</p></li><li><p><strong>第 32 行，bin 目录是相对路径，其前缀随平台而变化：对于 Linux，前缀为 <code>/usr/local</code> ；对 Windows 而言，前缀为 <code>C:\Program Files (x86)\项目名</code></strong> 。你可以在执行 cmake 时通过 -D 选项来指定安装目录的位置：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=\xxx\yyy</span><br></pre></td></tr></table></figure><p><code>CMAKE_INSTALL_PREFIX</code> 是 cmake 内置变量，指定安装目录的前缀。<strong>注意，cmake 的 -D 选项只能定义 CMakeLists.txt 中的变量，不能定义 C/C++ 中的宏</strong> 。</p></li></ul><p>下面来看内层 txt，很简单：</p><ul><li><p>第 8 行，<code>WIN32</code> 也是 cmake 的内置变量，当在 Windows 下构建项目时，该变量就会被定义。</p></li><li><p>第 9 行，<code>add_definition</code> 函数用来添加 C/C++ 的宏定义。</p></li><li><p>第 8~12 行的含义是：如果为 Windows，则将所有库安装到 bin 目录下，即与可执行文件放在一起；如果为 Linux，则将库放在 lib 中，可执行文件放在 bin 中。</p><blockquote><p>为什么要这样安排呢？因为 Linux 通常将可执行文件放在 usr\bin 下，库文件则放在 usr\lib 中，程序运行时会自动在 usr\lib 中搜寻所需的库文件。而 Windows 的习惯则是将所有库文件（尤其是 dll）和 exe 文件存放在同一个目录，当 exe 运行时，优先从当前目录搜寻库文件，例如 QQ ：<br><img src="/2022/img/image-20230514131005841.png" alt="exe与dll一起存放"></p></blockquote></li></ul><h2 id="font-color-red-Linux下构建-font"><font color='red'>Linux下构建</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>默认使用 myMath 库，输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">./bin/ctest</span> </span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use myMath.h //myMath库</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!  //play库</span><br><span class="line">Let&#x27;s dance! //play库</span><br><span class="line">Let&#x27;s work!  //work库</span><br></pre></td></tr></table></figure><p>也可以不使用 myMath 库，方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/CLionProjects/cmakeLearn/build$ </span><span class="language-bash">cmake -DUSE_MYMATH=OFF ..</span></span><br><span class="line"><span class="meta prompt_">~/CLionProjects/cmakeLearn/build$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/cmakeLearn/build$ </span><span class="language-bash">./bin/ctest</span> </span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use 3rdMath.h</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!</span><br><span class="line">Let&#x27;s dance!</span><br><span class="line">Let&#x27;s work!</span><br></pre></td></tr></table></figure><p>接着进行安装，输入 <strong><code>sudo make install</code></strong> （一定要 sudo），安装成功：<br><img src="/2022/img/image-20230514133434317.png" alt=""></p><p><strong><font color='orange'>注意，现在直接在命令行中运行 ctest 可能会提示找不到库文件，这是因为库的默认搜索路径没有包含 /usr/local/lib，所以我们需要将这 lib 目录添加到系统变量</font></strong> ，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/lib</span><br></pre></td></tr></table></figure><blockquote><p>这种做法仅临时有效，如果要长期有效，则需要修改 .bashrc 文件。</p></blockquote><p>然后就可以运行成功啦：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/$ </span><span class="language-bash">ctest</span></span><br><span class="line">PROJECT cmake</span><br><span class="line">VERSION 3.0</span><br><span class="line">use 3rdMath.h</span><br><span class="line">The older age is 20.</span><br><span class="line">Let&#x27;s sing!</span><br><span class="line">Let&#x27;s dance!</span><br><span class="line">Let&#x27;s work!</span><br></pre></td></tr></table></figure><h2 id="font-color-red-Windows下构建-font"><font color='red'>Windows下构建</font></h2><p>首先需要安装 cmake，直接去官网下载安装即可。</p><p>同样步骤：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;mkdir build</span><br><span class="line">&gt;<span class="built_in">cd</span> build</span><br><span class="line">&gt;cmake ..</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230514135550812.png" alt=""></p><blockquote><p>目录中的 <code>.sln</code> 、<code>.vcxproj</code> 等文件 VS 的解决方案文件和项目管理文件。不了解 Visual Studio 的工程管理方式的朋友请先移步 <strong><a href="https://jyx-fyh.github.io/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/">如何使用 VS 编译调试一个大型项目？</a></strong></p></blockquote><p>打开 cmake.sln 文件：<br><img src="/2022/img/image-20230514140109505.png" alt=""></p><p>可见，cmake 很智能地将我们的工程分为了 6 个项目，主要是 ctest，myMath 和 work 项目，剩余的 ALL_BUILD、INSTALL、ZERO_CHECK 则是 cmake 自动构建的，作用如下：</p><ul><li>ALL_BUILD ：相当于 makefile 的默认目标 make all，用于构建整个解决方案，但不包括 INSTALL 。</li><li>INSTALL ：执行安装任务，相当于 make install 。</li><li>ZERO_CHECK ：检查 CMakeLists.txt 文件是否发生了变化，如果有变化则重新生成构建系统，以确保构建系统始终与 CMakeLists.txt 文件保持同步。通常情况下，不需要手动运行 ZERO_CHECK 项目，因为它会在构建过程中自动运行。</li></ul><p>编译整个解决方案，然后构建 INSTALL，报错如下：<br><img src="/2022/img/image-20230514162003916.png" alt=""></p><p>提示权限不够，这是因为 <code>C:\Program Files (x86)</code> 目录需要管理员权限才能进行更改。我们使用管理员权限启动 VS 并打开此 sln，重新编译并 INSTALL，成功：<br><img src="/2022/img/image-20230514162319358.png" alt=""></p><p>运行 ctest.exe 后只会闪现，你可以在源代码中添加 sleep 函数来仔细看看输出结果。</p><hr><h2 id="font-color-red-常见变量与函数-font"><font color='red'>常见变量与函数</font></h2><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CMAKE_BINARY_DIR<br />PROJECT_BINARY_DIR</td><td style="text-align:left">执行编译时所位于的目录，对于外部构建，则一般为 build 目录。</td></tr><tr><td style="text-align:left">CMAKE_SOURCE_DIR<br />PROJECT_SOURCE_DIR</td><td style="text-align:left">工程顶层目录，即最外层 CMakeLists.txt 所在目录。</td></tr><tr><td style="text-align:left">CMAKE_CURRENT_SOURCE_DIR</td><td style="text-align:left">当前 CMakeLists.txt 所在的路径。</td></tr><tr><td style="text-align:left">EXECUTABLE_OUTPUT_PATH<br />LIBRARY_OUTPUT_PATH</td><td style="text-align:left">最终目标文件存放的路径。</td></tr><tr><td style="text-align:left">PROJECT_NAME</td><td style="text-align:left">通过 PROJECT 指令定义的项目名称。</td></tr><tr><td style="text-align:left">CMAKE_INSTALL_PREFIX</td><td style="text-align:left">安装目录的前缀</td></tr><tr><td style="text-align:left">CMAKE_BUILD_TYPE</td><td style="text-align:left">构建类型，如 Debug 或 Release</td></tr><tr><td style="text-align:left">CMAKE_C_COMPILER</td><td style="text-align:left">C 编译器的路径</td></tr><tr><td style="text-align:left">CMAKE_CXX_COMPILER</td><td style="text-align:left">C++ 编译器的路径</td></tr><tr><td style="text-align:left">CMAKE_C_FLAGS</td><td style="text-align:left">C编译器的编译选项</td></tr><tr><td style="text-align:left">WIN32</td><td style="text-align:left">如果是在 Windows 下编译，则会定义该宏。</td></tr></tbody></table><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">set</td><td style="text-align:center">设置变量（覆盖原有值）</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">为变量添加值</td></tr><tr><td style="text-align:center">add_subdirectory</td><td style="text-align:center">添加子目录</td></tr><tr><td style="text-align:center">add_definitions</td><td style="text-align:center">添加编译器定义</td></tr><tr><td style="text-align:center">configure_file</td><td style="text-align:center">用于生成配置文件</td></tr><tr><td style="text-align:center">message</td><td style="text-align:center">输出消息到控制台</td></tr><tr><td style="text-align:center">add_executable</td><td style="text-align:center">添加可执行文件</td></tr><tr><td style="text-align:center">add_library</td><td style="text-align:center">添加库文件</td></tr><tr><td style="text-align:center">aux_source_directory</td><td style="text-align:center">自动包含指定目录下的所有文件</td></tr><tr><td style="text-align:center">link_directories</td><td style="text-align:center">为整个cmake项目设置库文件搜索目录</td></tr><tr><td style="text-align:center">include_directories</td><td style="text-align:center">为整个cmake项目设置头文件搜索目录</td></tr><tr><td style="text-align:center">target_include_directories</td><td style="text-align:center">为目标（可执行文件或库）设置头文件搜索路径</td></tr><tr><td style="text-align:center">target_link_directories</td><td style="text-align:center">为目标设置库文件搜索路径</td></tr><tr><td style="text-align:center">target_link_libraries</td><td style="text-align:center">将指定库链接进目标</td></tr><tr><td style="text-align:center">install</td><td style="text-align:center">安装目标文件</td></tr></tbody></table><hr><h2 id="font-color-red-其他-font"><font color='red'>其他</font></h2><ul><li><p>相比 Linux 下的 ccmake，Windows 下的 cmake 具有更人性化的图形界面，你可以很方便地设置构建目录、安装目录以及编译选项：<br><img src="/2022/img/image-20230514170003470.png" alt=""></p></li><li><p>Windows 下执行 cmake 后会生成 sln 文件，此时你可以用 VS 打开该解决方案然后进行编译（正如我们上面所做）；另外，你也可以直接在命令行中编译：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;mkdir build</span><br><span class="line">&gt;<span class="built_in">cd</span> build</span><br><span class="line">&gt;cmake  .. </span><br><span class="line">&gt;cmake <span class="literal">--build</span> . <span class="literal">--config</span> Release //以Release模式编译工程</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><code>cmake ..</code> 会生成系统默认的构建文件，你能够指定构建文件，可以是 Unix Makefiles、Ninja、Visual Studio 等等</font></strong> ：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;cmake <span class="literal">-G</span> <span class="string">&quot;Visual Studio 17&quot;</span> ..</span><br><span class="line">&gt;cmake <span class="literal">--build</span> . <span class="literal">--config</span> Release</span><br></pre></td></tr></table></figure><p>这里指定的是 Visual Studio 17 。<strong>执行 <code>cmake --build . --config Release</code> 命令时会使用在 CMake 配置时指定的编译器来构建项目，如果没有指定编译器，则会使用默认的编译器</strong> 。在 Unix/Linux 系统上，通常是 gcc/g++；在 Windows 系统上，通常是 CL.exe 编译器。</p></li><li><p>笔者起初有一个疑惑：我们常说的 Linux 下的编译三部曲：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure><p>这个 ./configure 是什么？它和 <code>cmake ..</code> 有什么区别？具体来说，configure 是 Autoconf 的配置文件，Autoconf 通过 configure 文件来生成构建系统，而 cmake 根据 CMakeLists.txt 来生成构建系统。Autoconf 和 cmake 都是跨平台的构建工具，用于自动化配置软件包的编译和安装过程。Autoconf 使用 M4 宏语言和 shell 脚本来编写配置文件，而 CMake 使用自己的 CMake 语言来编写配置文件；M4 宏语言比较复杂，而 CMake 语言简单易懂。选择哪个工具取决于个人的喜好和项目的需求。</p></li><li><p>最后，虽然 cmake 是跨平台构建工具，但如果你想要你的项目能够跨平台运行，首先需要保证你的代码能够兼容多个平台，比如 I/O 复用模块 epoll 只存在于 Linux 下，Windows 对应的为 IOCP，那么你就需要编写不同的代码来适应多个平台。本项目中碰到的跨平台问题是动态链接库的编写，因为 Linux 和 Windows 对动态链接库的处理有所不同，所以也要做一些配置，参见<a href="">静态链接与动态链接</a>。</p></li></ul><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 编译、链接与调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译、链接与调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VS编译调试一个大型项目?</title>
      <link href="/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/05/02/%E7%BC%96%E8%AF%91%E8%B0%83%E5%BC%8F%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中 <code>.cpp</code> ，文件位于 <strong>“源文件”</strong> 节点下。 <code>.h</code>文件位于“**头文件”<strong>节点下，<code>.ico</code>文件<code>.rc</code>位于</strong>“资源文件”**下。 此位置由筛选器文件控制。</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/580990312">C/C++网络训练营</a> 、<a href="https://shiyousan.com/post/636441130259624698">.vs的作用</a> 、<code>chatgpt</code> 。</p></blockquote><h2 id="font-color-red-VS-工程概览-font"><font color='red'>VS 工程概览</font></h2><p>你有没有这样一种感受：想学习 github 上的一些优秀项目时不知道怎么开始；拿到源码后不知道如何运行；项目中密密麻麻的文件是怎么被组织起来的…于是，万里长征路，你就被难在了第一步。确实，学习和使用一个大型项目可能会让人感到困难和无从下手。但是，编译和调试大型项目的过程并不是无法掌握的。下面我将为你提供一些有用的建议和技巧，帮助你更好地理解和使用大型项目。</p><p>1）了解项目的结构和依赖关系是非常重要的。在大多数情况下，大型项目都会有一些文档或者说明文件，尤其是 README 文件，它会告诉你项目的基本信息，包括项目的结构、依赖关系、编译和运行方式等等。你可以先仔细阅读这些文件，了解项目的大致框架和组织方式。</p><p>2）了解项目的编译和构建过程也是非常重要的。大多数大型项目都会使用一些构建工具来自动化编译和构建过程，例如 Make、CMake等。你需要了解这些工具的基本使用方法，以及项目中使用的具体配置和参数。同时，你也需要掌握编译与链接的基本原理。</p><p>3）调试大型项目也是需要一些技巧的。一些常见的调试技巧包括使用调试器、打印日志、使用断言等等。你需要了解这些技巧的基本原理和使用方法，以便更好地定位和解决问题。</p><p>4）充分利用 Google 和 chatgpt，尤其是后者，将报错信息发给它，往往会给你极具引导性的答案。</p><p>一个好的 IDE 也是项目分析的关键。这里我们先来了解 Visual Studio 是如何组织项目的。</p><p>Visual Studio 中，最重要的两个概念是 <strong><u><font color='orange'>解决方案</font></u></strong> 和 <strong><u><font color='orange'>项目</font></u></strong>。</p><p>解决方案 (Solution) 是一个包含一个或多个项目的 <strong>容器</strong> 。<strong>它是用来组织、构建和调试项目的一个虚拟项目</strong> 。解决方案可以包含多个项目，这些项目可以是不同类型的，例如 C++ 项目、静态或动态链接库等等。<strong>在解决方案中，可以对不同项目之间的依赖关系进行管理和设置</strong> 。</p><p>项目 (Project) 是一个实际的代码库（lib \ dll）或者可执行文件（.exe）。在 Visual Studio 中，每个项目都有一个独立的项目文件（.vcxproj），其中包含了项目的所有配置信息，包括编译与链接选项。一个项目可以包含多个源文件（source）、头文件（header）、资源文件（resource）等等，它们一起构成了一个可编译的代码库或者可执行文件。</p><p>在 Visual Studio 中，解决方案和项目是紧密结合的。一个解决方案可以包含多个项目，这些项目可以共享同一个解决方案的设置和配置。例如，你可以在解决方案中设置所有项目的编译选项、链接选项、调试选项等等。同时，你也可以在项目级别上进行一些独立的配置和设置，例如项目的特定编译选项、依赖项等等。</p><p>以 teamtalk 这个在线聊天软件为例（），让我们看看它的结构：<br><img src="/2022/img/image-20230502133617307.png" alt=""></p><p>teamtalk 的解决方案下有 11 个项目。直接运行后报错：<br><img src="/2022/img/image-20230502133719222.png" alt=""></p><p>错误提示 <code>DuiLib.dll</code> 不是一个有效的可执行程序。这是因为 DuiLib 项目为默认启动项，但它生成的是动态链接库，而动态链接库是无法直接运行的，因此报错。<strong><font color='orange'>如何知道哪个项目是默认启动项？</font></strong> 看右边窗口，加粗字体的项目即为默认启动项目。<strong>一般将生成 exe 的项目设置为默认启动项</strong> 。右击任何一个项目，然后点击 <code>Set as Startup Project</code> 选项即可把该项目设置为启动项：<br><img src="/2022/img/image-20230502135834519.png" alt=""></p><p><strong><font color='orange'>怎么知道一个项目的目标生成文件是库还是可执行程序？</font></strong> 右击项目，点击最下方的 Property，显示如下窗口：<br><img src="/2022/img/image-20230502140120538.png" alt="image-20230502140120538"></p><p>可见，teamtalk 项目的目标生成文件为 .exe 。<strong><font color='orange'>一般而言，每个项目都有一个目标生成文件，文件名的前缀即为项目名称（图中高亮的上一行，Target Name）。</font></strong> 目标文件的生成路径也可以在图中的 Output Directory 进行修改。既然它的目标文件是 .exe，那就说明可以运行，我们将其设置为启动项，然后运行：<br><img src="/2022/img/image-20230502141050271.png" alt=""></p><p>成功运行！</p><hr><h2 id="font-color-red-区别几种项目文件-font"><font color='red'>区别几种项目文件</font></h2><p>下面看看 teamtalk 项目的项目文件：<br><img src="/2022/img/image-20230502140749981.png" alt=""></p><p>在 Visual Studio 中创建一个新的 C++ 项目时，通常会生成三个文件：.vcxproj、.vcxproj.filters 和 .vcxproj.user。这些文件分别用于存储项目的配置信息、过滤器信息和用户特定的配置信息。</p><p><strong><font color='gree'>1）</font></strong> .vcxproj 文件是 Visual C++ 项目的主要配置文件，它包含了项目的所有配置信息，例如编译选项、链接选项、输出文件、依赖项等等。这个文件是必需的，没有它，你无法编译和构建项目。<strong><font color='orange'>注意，项目中设置的任何相对路径都是以 .vcxproj 所在路径为基准的。</font></strong></p><blockquote><p>有些朋友可能还见过 <code>.vcproj</code> 文件。vcxproj 和 vcproj 都是 Visual Studio 项目文件的扩展名，但它们之间有一些区别：<br>vcproj 是用于 Visual Studio 2002 和 2003 版本的 C++ 项目文件格式，而 vcxproj 是用于 Visual Studio 2005 及更高版本的 C++ 项目文件格式。因此，vcxproj 是 vcproj 的升级版，它使用了更先进的 XML 格式来表示项目文件。</p></blockquote><p><strong><font color='gree'>2）</font></strong> .vcxproj.filters 文件是 Visual C++ 项目的过滤器配置文件，它用于组织和管理项目中的源文件、头文件、资源文件等。这个文件不是必需的，但是它可以帮助你更好地组织和管理项目中的文件，使代码更易于维护和重用。具体而言，它指定哪些文件类型进入解决方案资源管理器中的逻辑文件夹。 在下图中， 某些文件位于 “Main” 文件夹下，某些文件位于 “ProjectFils” 文件夹下。 此位置由筛选器文件控制：<br><img src="/2022/img/image-20230502142944601.png" alt=""></p><p>将 .vcxproj.filters 文件删除后，显示如下：<br><img src="/2022/img/image-20230502143614625.png" alt=""></p><p>结果散乱一团。所以 .vcxproj.filters 最好保留（一并添加到版本控制中）。</p><p>另外值得一提的是，我们将现有的文件添加到项目中的 <strong><u>逻辑</u></strong> 文件夹来一并管理，<strong>但这并不改变实际的目录结构</strong> 。</p><p><strong><font color='gree'>3）</font></strong> .vcxproj.user 文件是用户特定的配置文件，它包含了用户特定的配置信息，比如窗体和鼠标位置等。这个文件是可选的，它可以让不同的用户在同一个项目中使用不同的配置，以适应不同的开发需求。此文件无需保存到版本控制中。</p><p><strong><font color='gree'>4）</font></strong> .vs 文件夹（一般是隐藏状态），通常存放在解决方案的目录下，<strong>用来存储当前用户在解决方案中的工作配置，具体包括 VS 关闭前最后的窗口布局、最后打开的选项卡/操作记录/文件文档、某些自定义配置/开发环境、调试断点等这类设置信息和状态。</strong> 这样每当用户关闭解决方案后再重新打开，就能继续之前的工作状态。因此也无需保存到版本控制中。<br><img src="/2022/img/image-20230502151248516.png" alt=""></p><hr><h2 id="font-color-red-基本操作-font"><font color='red'>基本操作</font></h2><p><strong><font color='gree'>1）编译整个解决方案</font></strong><br>有时候右击 solution 然后点击 build 后，不会编译 solution 下的所有项目，这就很坑，调了半天原来压根没编译。调整方法如下：<br><img src="/2022/img/image-20230502151950947.png" alt=""></p><p><strong><font color='gree'>2）查看构建顺序</font></strong><br>某些库项目可能依赖另外一些库，通过查看构建顺序，我们能够更有针对性地解决库的编译问题，查看方法如下：<br><img src="/2022/img/image-20230502153808196.png" alt=""></p><p>这样，当我们单独编译 network 时出了问题，就可以去检查 network 是否依赖了 GifSmiley 和 httpclient，并针对性地去排查错误。</p><p><strong><font color='gree'>3）头文件搜索目录</font></strong><br>在Visual Studio中，头文件的搜索顺序如下：</p><ol><li>当前项目目录：Visual Studio 首先会在当前项目目录中搜索头文件，如果头文件存在于该目录中，则会直接使用该头文件。</li><li>系统目录：如果头文件不在当前项目目录中，则会在系统目录中搜索。这些系统目录包括 Visual Studio 安装目录、Windows SDK 安装目录、以及其他系统级目录。</li><li>环境变量：如果头文件不在系统目录中，则会在环境变量中指定的目录中搜索。例如，如果你在环境变量中设置了 <code>INCLUDE</code> 变量，则 Visual Studio 会在该目录中搜索头文件。</li><li>项目属性：如果头文件仍然无法找到，则会在项目属性中指定的搜索路径里搜寻。</li></ol><p>在项目属性中指定头文件的搜寻路径是高频使用的方法，必须掌握：<br><img src="/2022/img/image-20230502154638921.png" alt=""></p><p><strong><font color='gree'>5）库搜索目录</font></strong><br>库文件的搜索顺序如下：</p><ol><li>当前项目目录。</li><li>系统目录。</li><li>环境变量。例如，如果你在环境变量中设置了“LIB”变量，则 VS 会在该目录中搜索库文件。</li><li>项目属性。</li><li>引用的项目。<u>如果你的项目引用了其他项目，则 VS 会在这些项目的输出目录中搜索库文件。</u></li></ol><p>在项目属性中设置库的搜索目录，方法如下：<br><img src="/2022/img/image-20230502155314071.png" alt=""></p><p>也可以设置依赖项目，方法如下：<br><img src="/2022/img/image-20230502155518589.png" alt=""></p><p><strong><font color='gree'>6）定义宏</font></strong><br>有时候给你的整个项目定义宏会方便许多，如下：<br><img src="/2022/img/image-20230502155709943.png" alt=""></p><p><strong><font color='gree'>7）库依赖</font></strong><br>这也是最常用的方法之一，我们的项目经常会依赖某些库（lib 或 dll），添加方法如下：<br><img src="../../public/2022/img/image-20230503220941281.png" alt=""></p><p>实际上，上面我们设置的搜索目录、库依赖和宏定义都化作了命令行来指导编译和链接：<br><img src="../../public/2022/img/image-20230503220743624.png" alt=""></p><p><img src="../../public/2022/img/image-20230503220759030.png" alt=""></p><hr><p>OK，暂时先到这里，后面我们将会进行几个编译练习，分别是 teamtalk、Nginx、Libevent、电驴和 uwebsocket。</p>]]></content>
      
      
      <categories>
          
          <category> 编译、链接与调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译、链接与调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练习1-编译调试teamtalk</title>
      <link href="/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/"/>
      <url>/2023/05/01/%E7%BB%83%E4%B9%A01-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95teamtalk/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>TeamTalk 是一款蘑菇街开源的企业内部即时通讯软件，代码质量优秀，具有较高的学习价值。<a href="https://github.com/balloonwj/TeamTalk">源码</a>由张小方老师提供，在此表示感谢。<br>此次的任务仍然是在 Visual Studio 中将源码跑起来，这个过程碰到了许多编译和链接的问题，通过不断调整试错终于跑通了代码，实属不易！学习源码，往往就难在这第一步，只要将源码运行起来，我们就成功了一半。后续的代码细节直接边调试边理解，再爽不过！这个过程大大加深了我对编译与链接的理解，也熟悉了 Visual Studio 的开发环境。</p></blockquote><blockquote><p>勘误：文中图片的路径有时候为 TeamTalk，有时为 TeamTalk_test，前者是笔者为写此博客而重新开的项目，后者是之前的项目，由于本人疏忽不小心混淆了，大家直接将 TeamTalk_test 视作 TeamTalk 即可。</p></blockquote><p>1）从 <a href="https://github.com/balloonwj/TeamTalk">github</a> 上拉取源码，然后打开客户端的 <code>.sln</code> 解决方案文件：<br><img src="/2022/img/image-20230501211233465.png" alt=""></p><p>2）VS可能提示我们更新项目的编译工具集，默认即可：<br><img src="/2022/img/image-20230502103951134.png" alt=""></p><p>3）配置 configuration manager，指定 Build Solution 时是将该方案下的所有项目进行编译。</p><p><img src="/2022/img/image-20230501212233009.png" alt=""></p><p>4）点击 Build Solution，编译完成后报错如下：<br><img src="/2022/img/image-20230501212537341.png" alt="">我们一个一个来解决错误。</p><hr><p>先看 &lt;hash_map&gt; 的报错。该错误出现在 <code>network</code> 项目中，提示 &lt;hashmap&gt; 已经被废弃，如果要使用它，请先定义指定的宏。 右击 侧边栏的 <code>network</code> 项目，点击最下方的 property 选项；然后在 C/C++ 栏目中找到 Preprocessor 预处理栏，然后打开 Preprocessor Definitions ，向其中添加提示的宏 <code>_SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS</code> 即可。Modules 和 teamtalk 项目也有此错误，相同操作。<br><img src="/2022/img/image-20230501213353573.png" alt=""></p><hr><p>之前的报错中还提示 ‘function’: is not a member of ‘std’ ，这个简单，直接在对应文件中添加头文件 &lt;functional&gt; 即可。</p><hr><p>再次编译，报错如下：<br><img src="/2022/img/image-20230501214331967.png" alt=""><br><code>mbstate_t</code> 是结构体，无法直接赋值，应该使用初始化列表，将 <code>0</code> 改为 <code>&#123;0&#125;</code> 即可。</p><hr><p>再次编译，报错如下：<br><img src="/2022/img/image-20230501214805977.png" alt=""><br>先看后三个错误。在 utility 项目中无法打开 <code>mfcs120ud.lib</code> 文件，而在 Modules 和 teamtalk 项目中无法打开 <code>utility.lib</code> 。<strong>显然，是因为 <code>mfcs120ud.lib</code> 无法被打开导致 utility 项目无法生成 <code>utility.lib</code> ，继而使得 Modules 和 teamtalk 项目无法使用 <code>utility.lib</code> 。</strong> 所以我们必须先解决 <code>mfcs120ud.lib</code> 的问题。从这个静态链接库的名字我们可以知道，它不由任何项目生成，所以它应该是一个第三方库。打开文件夹，在整个 teamtalk 中搜索该文件，没有找到相关内容：<br><img src="/2022/img/image-20230501220032627.png" alt=""></p><p>所以我们可以大胆猜测这个库应该是系统库或编译器自带库。让 chatgpt 来告诉我们：<br><img src="/2022/img/image-20230501220445545.png" alt="image-20230501220445545"></p><p>ok，我们现在知道它是 MFC 的库，而且对应的版本是 Visual Studio 2013 。而当前我们的 VS 版本为 2022，所以极有可能是版本不匹配的原因。还是不确定，那让我们在 VS 的 VC 目录下搜索 mfcs 的相关内容：<br><img src="/2022/img/image-20230501220913135.png" alt=""></p><p>因此可以推断，2022 版本的对应库为 <code>mfcs140u.lib</code> 而不是 <code>mfcs120ud.lib</code> 。所以我们修改 utility 项目的依赖库，如下：<br><img src="/2022/img/image-20230501221137089.png" alt=""></p><p>然后再次编译：<br><img src="/2022/img/image-20230501221225358.png" alt=""></p><p>果然，utility 的 <code>mfcs120ud.lib</code> 错误解决。Modules 也有相同问题，步骤如法炮制。</p><hr><p>再次编译：<br><img src="/2022/img/image-20230501221431394.png" alt=""></p><p>尼玛！问题又多了，头大！现在提示在 Modules 项目中的 <code>libprotobuf-lite.lib</code> 文件中有<code>_MSC_VER</code> 相关的错误。 <code>_MSC_VER</code> 是什么？chatgpt 告诉你：<br><img src="/2022/img/image-20230501221808184.png" alt=""></p><p>真清晰！OK，现在我们大概知道报错是因为 <code>libprotobuf-lite.lib</code> 的编译版本较低造成的。同样，<code>libprotobuf-lite.lib</code> 依然不是我们的项目生成的库文件，让我们看看它在哪：<br><img src="/2022/img/image-20230501222531477.png" alt=""></p><p>嗯，从路径中的 3rdParty（第三方）也可以看出这是第三方库，而不是我们自己编译的库。那么问题来了，我们应该如何将 <code>libprotobuf-lite.lib</code> 转换为高编译器版本呢？大多数第三方库都是知名库，可以直接从官方下载最新版本，比如这个库就可以在<a href="https://github.com/protocolbuffers/protobuf/tree/main">github</a>下载。不过仔细搜寻后发现第三方库下有相关的压缩包（最下方的 protobuf）：<br><img src="/2022/img/image-20230501233642275.png" alt=""></p><p>解压后进入 vsprojects 目录，使用 VS 打开其中的 <code>libprotobuf-lite.vcxproj</code> ，这是工程文件：<br><img src="/2022/img/image-20230501233840160.png" alt=""></p><p>打开后 Build 这个解决方案，编译成功，最新编译版本的 <code>libprotobuf-lite.lib</code> 的输出位置见图：</p><p><img src="/2022/img/image-20230501233437643.png" alt=""></p><p>由于 Modules 项目的 linker 输入目录（Additional Library Directories）为 <code>D:\VSProjects\TeamTalk\win-client\3rdParty\lib\debug</code> ：<img src="/2022/img/image-20230501235111560.png" alt=""></p><p>所以我们用新的 lib 将久版本的 lib 替换掉：<br><img src="/2022/img/image-20230501235420326.png" alt=""></p><p>然后再次编译，该错误已经消失。teamwork 也有相同错误，同样加上前缀即可：<br><img src="/2022/img/image-20230502002924115.png" alt=""></p><p>啊哦，出现了关于 <code>security.lib</code> 的新错误…还是关于编译版本的问题。不过这次和之前的 <code>libprotobuf-lite.lib</code> 不同，第三方库目录下没有相关的压缩包。不过我们在 <code>3rdParty\src</code> 下发现了 <code>security.cpp</code> 源文件，所以为什么不直接编译呢？将这个源文件作为一个项目引入到 solution 下：<br><img src="/2022/img/image-20230502093523653.png" alt=""></p><p>发现有多个源文件找不到路径，搜索后发现它们位于 <code>\TeamTalk\server\src\libsecurity\src</code> 下，所以将此目录包含进项目的头文件搜寻范围：<br><img src="/2022/img/image-20230502093758527.png" alt=""></p><p>现在头文件已经能够检测到，不过还有些类型报错：<br><img src="/2022/img/image-20230502093855723.png" alt=""></p><p>小问题，<code>typedef unsigned char uchar_t</code> 即可。然后单独编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502094149718.png" alt=""></p><p>预编译头文件？这是什么？还是问问 chatgpt 吧：<br><img src="/2022/img/image-20230502094505883.png" alt=""></p><p>我们无需使用预编译头文件，这里报错是因为项目默认开启了预编译头文件的功能，关闭即可：<br><img src="/2022/img/image-20230502094705556.png" alt=""></p><p>再次编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502094754249.png" alt=""></p><p>好，我们在项目中添加 <code>SECURITY_WIN32</code> 宏：<br><img src="/2022/img/image-20230502094917057.png" alt=""></p><p>于是 security 项目编译成功：<br><img src="/2022/img/image-20230502095015199.png" alt=""></p><p>好，同样，我们用新生成的 <code>security.lib</code> 把之前的替换掉：<br><img src="/2022/img/image-20230502095155732.png" alt=""></p><p>然后编译整个 solution，报错：<br><img src="/2022/img/image-20230502095844929.png" alt=""></p><p>提示在 <code>security.lib</code> 中调用了一些没有定义的函数。回想一下，刚才我们是不是只为 security 项目引入了头文件目录以确保头文件能够找到，却没有把这些头文件对应的源文件包含进来，这样的话，<strong><u>如果 <code>security.cpp</code> 中调用了这些头文件声明的函数，只有声明而没有定义，就一定会导致上图所示的链接错误</u></strong> 。因此我们需要把头文件对应的源文件包含进 security 项目，它们仍位于 <code>\TeamTalk\server\src\libsecurity\src</code> 中：<br><img src="/2022/img/image-20230502100837276.png" alt=""></p><p>ok，编译 security 项目，报错如下：<br><img src="/2022/img/image-20230502101048441.png" alt=""></p><p>问题不大，定义该宏就行。然后再次编译，成功！然后把新的 <code>security.lib</code> 替换掉之前的即可。然后编译整个 solution，报错如下：<br><img src="/2022/img/image-20230502102713327.png" alt=""></p><p><code>Please verify that you have sufficient right to run this command</code> ，权限不够？那我们关闭 VS，以管理员身份重新运行：<br><img src="/2022/img/image-20230502102907161.png" alt=""></p><p>哟呼！跑起来啦！！！！大功告成。</p><p>接下来我们就可以随意打断点，单步调试 teamtalk 了，这样来学习源码真是不要太爽！</p>]]></content>
      
      
      <categories>
          
          <category> 编译、链接与调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译、链接与调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言宏的几处陷阱</title>
      <link href="/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/"/>
      <url>/2023/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%87%A0%E5%A4%84%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《C与指针》</p></blockquote><ol><li><p><strong>为宏定义中的变量以及宏定义体加上括号：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) ((x)*(y))</span></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x,y) (x*y)</span></span><br></pre></td></tr></table></figure><p>否则按错误方式书写则可能出现如下错误：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL(a+b, c+d);</span><br><span class="line"><span class="comment">//被编译为 a + b * c + d , 显然是错误的</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义多语句宏代码时，请使用 do{…}while() 语句：</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) &#123;error_code=x;return false;&#125;</span></span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_RET(x) do&#123;error_code=x;return false;&#125;while(0);</span></span><br></pre></td></tr></table></figure><p>是否感觉到很莫名其妙，为什么不能使用 <code>&#123;&#125;</code> ？看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)</span><br><span class="line">    ERROR_RET(x);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这段代码被编译成：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition == <span class="literal">true</span>)&#123;</span><br><span class="line">    error_code=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>显然，第 4 行花括号后面的 <code>;</code> 是一个语法错误。关于 <code>do&#123;&#125;while()</code> 的详细说明，参见<a href="https://jyx-fyh.github.io/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/">do{}while()有什么用？</a> 。</p></li><li><p><strong>如果你不了解所使用的宏，则尽量不要在宏调用中发生动作：</strong><br>什么是 <code>发生动作</code> ？简单解释，就是操作变量或者调用函数，看下面的例子：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">7</span>;</span><br><span class="line">z = MAX(x++, y++);</span><br><span class="line"><span class="comment">//较小的x自增了一次,结果较大的y却自增了两次</span></span><br></pre></td></tr></table></figure><p>这种错误就比较隐蔽。<strong><u>对于宏定义中同一个变量出现多次的情况，更要预防这种错误</u></strong> 。函数调用也可能产生问题：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_lower(ch)  (((ch) &gt; <span class="string">&#x27;a&#x27;</span> &amp;&amp; (ch) &lt; <span class="string">&#x27;z&#x27;</span>) ? 1 : 0)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">is_lower(getchar());</span><br></pre></td></tr></table></figure><p>宏展开后，getchar() 将会被调用两次，也就是说，缓冲区将消耗两个字符，这对后续的文本分析工作可能造成毁灭性影响。</p></li></ol><p>其他注意事项待补充。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转载&gt;do{}while()有什么用?</title>
      <link href="/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
      <url>/2023/04/26/do-while-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一直以来我都认为 do{}while() 语句十分鸡肋，直到最近才发现它的一些妙用，下面这篇文章总结了 do{}while() 的一些使用场景，希望对各位有所帮助。<br>原文：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3535674.html">do{}while()有什么用?</a></p></blockquote><p>在一些Linux内核和其它的开源代码中，我们经常看到像下面这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;while(0)</span><br></pre></td></tr></table></figure><p>该代码片段并非循环，这样想想似乎使用do…while没有任何意义，那么为什么还要使用它呢？</p><p>实际上，do{…}while(0)的用途并不仅仅是优化你的代码。经过一系列的调研和探索，我们总结出它的一些用途如下。</p><h2 id="font-color-red-帮助定义多语句宏以避免错误-font"><font color='red'>帮助定义多语句宏以避免错误</font></h2><p>如果你是一名 C 程序员，你肯定很熟悉宏，它们非常强大，如果正确使用可以让你的工作事半功倍。然而，如果你在定义宏时很随意没有认真检查，那么它们可能使你发狂，浪费N多时间。在很多的C程序中，你可能会看到许多看起来不是那么直接的较特殊的宏定义。下面就是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __set_task_state(tsk, state_value)      \</span><br><span class="line">    do &#123; (tsk)-&gt;state = (state_value); &#125; while (0)</span><br></pre></td></tr></table></figure><blockquote><p>在Linux内核和其它一些著名的C库中有许多使用do{…}while(0)的宏定义。这种宏的用途是什么？有什么好处？Google 的 Robert Love（先前从事Linux内核开发）给我们解答如下：<br><strong><font color='orange'>do{…}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</font></strong></p></blockquote><p><strong>这句话听起来可能有些拗口，其实用一句话概括就是：<font color='orange'>使用 do{…}while(0) 构造后的宏定义不会受到大括号、分号等的影响，并总是会按你期望的方式调用运行。</font></strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure><p>然后你可能这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(wolf);</span><br></pre></td></tr></table></figure><p>这将被宏扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar(wolf); baz(wolf);</span><br></pre></td></tr></table></figure><p>这的确是我们期望的正确输出。下面看看如果我们这样调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br></pre></td></tr></table></figure><p>那么扩展后可能就不是你所期望的结果。上面语句将扩展为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    bar(wolf);</span><br><span class="line">baz(wolf);</span><br></pre></td></tr></table></figure><p>显而易见，这是错误的。这里你可能感到迷惑不解了，<strong>为什么不用大括号直接把宏包围起来呢？</strong> 而非得使用 <strong>do/while(0)</strong> 逻辑呢？例如，我们用大括号来定义宏如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure><p>这对于上面举的if语句的确能被正确扩展，但是如果我们有下面的语句调用呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral)</span><br><span class="line">    foo(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>宏扩展后将变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!feral) &#123;</span><br><span class="line">    bar(wolf);</span><br><span class="line">    baz(wolf);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    bin(wolf);</span><br></pre></td></tr></table></figure><p>大家可以看出，这就有语法错误了。</p><p><strong><font color='orange'>几乎在所有的情况下，期望写<u>多语句宏</u>来保证正确的结果是不可能的，你不能让宏像函数一样行为——除非使用 do/while(0) 语句。</font></strong></p><h2 id="font-color-red-避免使用goto控制程序流-font"><font color='red'>避免使用goto控制程序流</font></h2><p>在一些函数中，我们在return语句之前可能需要做一些工作，比如释放在函数一开始由malloc函数申请的内存空间，使用goto总是一种简单的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething...;</span></span><br><span class="line">END:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于 goto 关键字可能会使代码不易读，因此许多人都不推荐使用它，那么我们可以使用 do{…}while(0) 来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dosomething...;</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用 do{…}while(0) 来包含函数的主要部分，同时使用 break 替换 goto，代码的可读性增强了。</p><blockquote><p>禁止使用 goto 已经成为程序员的教条，但它并非魔鬼，少量使用是有益而无害的——尤其在跳出多重循环时很方便。</p></blockquote><h2 id="font-color-red-避免由宏引起的警告-font"><font color='red'>避免由宏引起的警告</font></h2><p>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用do{…}while(0) 来定义空宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define EMPTYMICRO do&#123;&#125;while(0) </span><br></pre></td></tr></table></figure><p>这样在编译的时候就不会产生警告。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EPOLLHUP/EPOLLRDHUP与read返回0的区别</title>
      <link href="/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/04/24/EPOLLHUP-EPOLLRDHUP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：<a href="https://blog.csdn.net/halfclear/article/details/78061771">epoll触发事件的分析</a> 、<a href="https://stackoverflow.com/questions/51833215/why-do-we-need-epollrdhup-when-epollhup-seems-enough">EPOLLHUP&amp;EPOLLRDHUP</a> 、<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">man_page</a></p></blockquote><p>相信很多时候，大家都是通过检测 read/recv 返回 0 来判断对端是否关闭了连接，如果返回 0，我们通常也会 close 该连接。这没有问题，但在很多场景下有个缺陷：FIN 报文和普通数据报文一样，也是需要在缓冲区中排队的，只有当 read 读取到 FIN 以后才会返回 0，而且 FIN 报文无法和数据同时被读取，也就是说，必须将数据 read 完毕后，再调用一次 read 才能读取到 FIN 并返回 0 。这也是为什么在网络读取时需要将 read 放在循环中的原因之一，不仅是为了将数据读取完整，也是为了能够读到 FIN 报文。</p><blockquote><p><strong>注意，FIN 报文虽然会排队，但当本端收到 FIN 后，内核网络栈会立刻回复 ACK，而不会管你是否 read 到这个 FIN 报文。</strong></p></blockquote><p>那么这个缺陷会引发什么问题呢？由于笔者现在也是网络编程初学者，没有太多实战经验，所以这里只提供本人猜想的两个情景：</p><ul><li>在一个高并发网络场景下，服务器收到了对端发来的 FIN 报文（对端 close），但没有立即读取（正忙于处理已接收的数据），所以现在此连接处于半关状态，因为服务器的 read 还没有返回 0。直到服务器处理完其他事情后 read 并返回 0 才会 close 此连接。问题在于，这段时间内该连接被白白占用了，浪费了服务器的端口，这对高并发处理是不利的。服务器完全可以先关闭该连接，再去处理数据。</li><li>客户端向服务器发送文件，而文件的末端是 EOF，所以当服务器 read 到文件末端的 EOF 后返回 0，进而关闭连接。问题来了，万一客户还想继续发送文件呢？也就是说，<strong><font color='orange'>此时 read 返回 0 并不代表客户端想关闭连接</font></strong> 。</li></ul><p>因此，我们应该尽量避免使用 read/recv 返回 0 来判断对端的关闭状态。那还有什么方法？答案是 epoll 的 EPOLLRDHUP 和 EPOLLHUP 事件。这两者很容易混淆，下面略作区分。</p><p>EPOLLRDHUP 最为常用，<strong>当对方关闭（close）连接或者关闭写（shutdown(SHUT_WR)）时，本事件就会被触发</strong> 。所以 EPOLLRDHUP 被用来监听对方的连接状态。与前面 read 不同，<strong><font color='orange'>只要 FIN 报文进入了缓冲区，不管是否读取，都会引发 EPOLLRDHUP 事件</font></strong> 。</p><blockquote><p>那么当 EPOLLRDHUP 发生时，我们该做什么呢？<strong>因为我不知道对方是 close 还是 shutdown(SHUT_WR)，如果是后者，我就还能够将处理好的数据发给对方，如果是前者，则发送数据后则会收到对方发来的 RST 报文，从而直接结束连接。</strong> 该做什么应该取决于应用场景，如果是 http 服务，那就不应该直接关闭连接，因为对端可能是 shutdown，且还需要接收数据（比如请求图片）；如果是上传文件到服务器，那么就可以直接关闭连接，因为服务器不需要再向对端回复数据。</p></blockquote><p>EPOLLHUP 则令人困惑，官方文档的解释是：当套接字挂起时，本事件被激发。然而什么是“挂起”却没有解释，网络讨论也说法不一。笔者给出两种已经被实验证实的情况：</p><ul><li><p><strong>收到对端发来的 RST 报文</strong></p><blockquote><p>RST 报文用来重置连接，当一方发送RST报文后，对端会立即关闭连接，并释放相关资源。所以收到 RST 后，套接字相当于残废，被“挂起”。</p></blockquote></li><li><p><strong>将一个不可能触发该事件发生的套接字加入 EPOLL</strong></p><blockquote><p>比如，使用 socket() 返回了一个套接字，既不 listen 也不 connect，这个套接字将没有任何事情发生（这也许就是“挂起”的含义），此时如果将其加入到 EPOLL 中，则会产生 EPOLLHUP 事件。</p><p><strong><font color='orange'>值得一提的是，对端 close 连接时，不会触发本端的 EPOLLHUP；但对端同时 shutdown 读和写时（即 shutdown(SHUT_RDWR) ），则会触发本端的 EPOLLHUP</font></strong> 。<strong>因为调用 shutdown(SHUT_RDWR) 只会关闭连接的读端和写端，不会释放文件描述符和其他相关资源，但此时该套接字已经处于“聋哑”状态，没有作用了，所以相当与被“挂起”；</strong><font color='orange'><strong>而当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</strong></font> ，如果应用程序需要释放文件描述符和相关资源，还需要调用 close 函数。</p></blockquote></li></ul><p><strong>注意，EPOLLHUP 不能用来监听对方的关闭状态！</strong></p><p>补充说明：</p><ul><li><strong><font color='orange'>对于 EPOLLERR 和 EPOLLHUP，不需要在 epoll_event 时针对 fd 作设置，一样也会触发</font></strong></li><li><strong>对端发来 RST 信号，触发本端的 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件</strong></li><li>如前文，对端不管是 close 套接字，还是 shutdown 写，本端触发的都是 EPOLLIN + EPOLLRDHUP 事件，<strong>因此，本端无从区分对端是 close 了套接字，还是 shutdown 了写</strong> 。但有一点可以区分，如果对端是 close 了套接字，则本端在套接字上发送数据时，本端会收到对端发来的 RST 报文从而本端会触发 EPOLLIN + EPOLLRDHUP + EPOLLHUP + EPOLLERR 事件；而如果对端只是 shutdown 了写，则本端可以正常发送数据不会触发任何信号。</li><li><strong><font color='orange'>当关闭（close）套接字时，内核会自动将套接字描述符从 epoll 中删除，因此本端不会再触发任何事件</font></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互斥锁、条件变量与信号量的区别及其用法</title>
      <link href="/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2023/04/23/%E7%BB%86%E8%AF%B4%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《操作系统导论》《操作系统之哲学原理》《Linux高性能服务器编程》</p></blockquote><p>由于没有具体的应用场景，笔者之前一直对锁、条件变量和信号量感觉迷迷糊糊，总觉得它们很相似但又有所区别。这两天在写线程池时需要用到任务队列，主线程生产任务，工作线程则竞争地从队列中取出任务——也就是我们常说的“生产者/消费者问题”，接触到这个具体的场景后，笔者突然就明白了它们的区别。</p><p><strong><font color='orange'>互斥锁用来保证多线程/进程之间对共享资源的互斥访问，也就是保证同一时刻只有一个执行流在临界区中。</font></strong></p><p>POSIX 的互斥锁操作主要有如下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化锁,将锁的各个字段都初始化为0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> pthread_mutexattr* attr)</span>;</span><br><span class="line"><span class="comment">//销毁锁,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">//非阻塞上锁,如果锁已经被持有,则返回错误EBUSY</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>除了使用 <code>pthread_mutex_init</code> 初始化锁，也可以采用 <code>PTHREAD_MUTEX_INITIALIZER</code> 如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>注意，这种方式必须在初始化锁使用，不能在声明后赋值。</p></li><li><p><code>attr</code> 是锁的属性，常用的有两种——pshared 和 type，前者指定锁是否跨进程共享，后者指定锁的类型。互斥锁的类型有普通所、检错锁、递归锁，这里笔者没有深入研究，读者可自行了解。正常情况下，attr 设置为 NULL 即可。</p></li><li><p>需要注意，同一个执行流重复持有一个锁会导致死锁，此时需要使用递归锁。两个线程按照不同的顺序来申请两个互斥锁也可能导致死锁，具体情境参见《Linux高性能服务器编程》P278 。</p></li></ul><p><strong><font color='orange'>条件变量则提供了一种线程之间的通知机制，当某个条件满足时再唤醒沉睡在这个条件上的线程。</font></strong> 就笔者遇到的场景来说，只有当任务队列中存在任务时，线程才能获取任务并继续它的工作，否则只能睡眠。相关函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* attr)</span>; <span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>; <span class="comment">// 销毁条件变量,释放系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex)</span>; <span class="comment">//在条件变量上睡眠</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒一个线程,具体唤醒哪个则取决于优先级和调度策略</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒所有线程</span></span><br></pre></td></tr></table></figure><blockquote><p>以上函数成功时都返回 0，否则返回 errno 错误码。</p></blockquote><ul><li><p>同样可以使用如下方式初始化条件变量：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>我们看到 <code>pthread_cond_wait()</code> 函数的第二个参数是互斥锁，那么为什么在条件变量上等待时还需要上锁呢？</font></strong> 假设等待条件变量时不需要加锁，考虑这样的情形：线程 A 中某个时刻，条件变量 cond 还未成立，于是调用 <code>pthread_cond_wait()</code> 准备睡眠，而在**<u>睡眠前一刻</u>** ，执行流切换到线程 B，B 使条件变量 cond 成立，然后调用 <code>pthread_cond_signal()</code> 唤醒在 cond 上睡眠的线程，但线程 A 还没有完全睡眠，所以等待队列中没有可以唤醒的线程（这也就是所谓的 <strong><u>虚假唤醒</u></strong> ）。问题来了，现在执行流切换到 A，接着 A 完全睡眠。于是，线程 A 错过了 B 发送的唤醒信号，继而引发死锁。<strong>上面的问题在于，从 <code>pthread_cond_signal()</code> 函数被执行到调用线程被放入等待队列的这段时间内条件变量发生了改变。</strong> 所以我们必须保证这段空窗期内条件变量不会被修改，这也就是 <code>pthread_cond_wait()</code> 中锁参数的作用。因此 <strong><font color='red'>调用 <code>pthread_cond_wait()</code> 前必须保证 mutex 已经上锁</font></strong> 。</p><blockquote><p>调用 <code>pthread_cond_wait()</code> 时加锁是强制要求（该函数的第二个参数），但 <code>pthread_cond_signal()</code> 则不一定需要在加锁时调用。<strong><font color='red'>但是作为一般化的规则，在 wait 和 signal 时都持有锁总是正确的</font></strong> 。</p></blockquote></li><li><p><strong><code>pthread_cond_wait()</code> 在睡眠前一刻会释放锁，以使其他线程能够进入临界区；被唤醒后执行流从该函数返回，锁又会被该线程持有，以保证互斥访问临界区。</strong></p></li><li><p><code>pthread_cond_broadcast()</code> 函数有什么应用场景？参见《操作系统导论》 P261</p></li></ul><p>下面我们来看条件变量的局限性。先引入具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    add_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在只有两个线程时能够准确无误的运行，但当线程数多于两个时，就会发生问题：消费者 A 发现没有 food，于是沉睡在条件变量 food 上，然后执行流转移到生产者，生产者 add_food 后唤醒消费者 A，于是消费者 A 进入就绪队列（只是就绪，但没有运行）。问题来了，<u>此时消费者 B 抢先执行</u> ，发现 food 不为空，于是 eat_food 。紧接着切换到消费者 A ，从 17 行返回，由于 food 已经被消费者 B 吃掉，所以执行第 18 行 eat_food() 时将引发错误（只有 food 不为空时才能 eat）。</p><p>我们很容易知道解决上面问题的办法：<strong>不让消费者 B 抢先执行。也就是说，唤醒消费者 A 后立刻调度。</strong> 实际上，这种方式被称为 <code>Hoare</code> 语义，而前面的只唤醒，不保证立刻调度的方式称为 <code>Mesa</code> 语义。然而，由于 <code>Hoare</code> 语义的实现难度较大，几乎所有的操作系统都采用 <code>Mesa</code> 语义。</p><p>那么该如何解决这个问题呢？也很简单，将第 7、16 行的 <code>if</code> 改成 <code>while</code> 即可。消费者被唤醒后，总是再次检查共享变量 food，如果不满足，则再次睡眠。因此，<strong><font color='red'>谨记使用条件变量的通用规则：总是使用 while() 判断条件是否成立</font></strong> 。</p><p>上面的方案依旧存在问题：当消费者 A 发出 signal 时，会唤醒哪个线程呢？按道理来说应该是唤醒生产者，但线程调度不保证这一点。设想，当消费者 A 发出 signal 后唤醒的是消费者 B，而 B 发现 food 仍然为空，于是陷入睡眠；而生产者根本没有被唤醒，于是一直相互等待。<strong>这个问题的原因在于信号没有指向性</strong> ，显然消费者不应该唤醒消费者，而应该唤醒生产者。<strong><font color='orange'>解决办法也很简单——使用两个条件变量：</font></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> food;</span><br><span class="line"><span class="type">pthread_cond_t</span> empty;</span><br><span class="line"><span class="type">pthread_cond_t</span> filled;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> <span class="comment">//如果还有food,就不生产,等待没有food时再生产</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">true</span>)</span><br><span class="line">        pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">//如果还有food,就等待被消耗完再添加</span></span><br><span class="line">    add_food(&amp;food); </span><br><span class="line">    pthread_cond_signal(&amp;full);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> <span class="comment">//如果没有food,就等待,直到producer发送信号</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(food == <span class="literal">false</span>)</span><br><span class="line">        pthread_cond_wait(&amp;filled, &amp;mutex);</span><br><span class="line">    eat_food(&amp;food);</span><br><span class="line">    pthread_cond_signal(&amp;empty);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们提出下一个问题：为什么还要引入信号量？<strong><u>实际上，信号量不是必须的，它是对互斥锁和条件变量的封装</u></strong> ，看看源码便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE &amp;&amp; sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">while</span> (sem-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;sem-&gt;cond, &amp;sem-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        sem-&gt;value--;</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;pshared == PTHREAD_PROCESS_PRIVATE) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;sem-&gt;lock);</span><br><span class="line">        sem-&gt;value++;</span><br><span class="line">        pthread_cond_signal(&amp;sem-&gt;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = ENOSYS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> pshared;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>以上源码由 chatgpt 生成。</p></blockquote><p>可以很清楚地看到，信号量内部使用了互斥锁和条件变量。信号量和条件变量的区别在于：</p><ol><li><p>信号量内部使用了 value ，而条件变量是在外部使用 value （也就是上面的 food）来计数。</p><blockquote><p>之前代码中的 food 是二元变量（true\false），实际上你完全可以直接将它改为多值变量。</p></blockquote></li><li><p>由于条件变量是在外部维护的 value，所以操作 value 时必须由程序员负责先持有锁。而信号量也会持有锁，只不过对程序员屏蔽了细节。</p></li><li><p>信号量只能一次唤醒一个特定的线程/进程，而条件变量可以广播。</p></li></ol><p><strong><font color='orange'>二元信号量可以充当互斥锁，也能够充当条件变量。当信号量的 value 初始化为 1 时即为互斥锁。</font></strong></p><p>信号量的 POSIX 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面函数成功时返回 0，失败时返回 -1，并设置 errno。</p></blockquote><ul><li>pshared 表示信号量的类型，可以是 PTHREAD_PROCESS_PRIVATE 或 PTHREAD_PROCESS_SHARED，分别表示进程内私有和进程间共享。value 表示信号量的初始值。</li><li><code>sem_wait()</code> 将信号量的值减 1 。如果信号量的值为 0，则 sem_wait 陷入阻塞，直到信号量大于 0 。参见上面的源码。<br><code>sem_post()</code> 将信号量的值加 1，并唤醒一个线程。</li></ul><p>为了更好地理解信号量，下面使用信号量改写之前的生产者/消费者代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> food; <span class="comment">//food为一个队列,没有食物时队列为空</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> sem; <span class="comment">//信号量的值即为队列中的食物量</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pushback(); <span class="comment">//向队列中添加food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    sem_post(&amp;sem);  <span class="comment">//信号量+1,即食物量+1,并唤醒一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem); <span class="comment">//将信号量-1,如果为0就等待</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    food.pop(); <span class="comment">//从队列中取出food</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为当条件可累积时，信号量比条件变量更方便。从上面的代码也能够看出，<strong><u><font color='orange'>即使使用了信号量，在操作共享资源时仍然必须锁来保证互斥访问</font></u></strong> 。</p><blockquote><p><strong><font color='red'>注意，为了避免死锁，请将互斥锁的获取和释放紧贴着临界区，务必不要将 sem_wait 和 sem_post 放入锁范围内</font></strong> ！详细参见《操作系统导论》P271</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络字节序及其注意事项</title>
      <link href="/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/04/16/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网页上有许多关于字节序的讨论，这里就不多说了，只强调笔者认为最重要的两点：</p><ul><li><strong><font color='orange'>字节序与 CPU 相关，或者说与计算机体系架构相关，而与操作系统无关。</font></strong></li><li><strong><font color='orange'>字节序只针对多字节数据（如 int ）才有意义，单字节数据（如 char）不用考虑字节序的问题。</font></strong></li></ul><p>笔者是这样理解上面两点的：<br><strong><font color='red'>字节序就是指 CPU 中的寄存器对数据的解释方式</font></strong> 。32 位 CPU ，其寄存器大小为 4 字节，如果被设计为小端序，那么低地址的字节会被解释为低位数据，高地址的字节会被解释为高位数据：<br><img src="/2022/img/endian-1681633780948-2.png" alt=""></p><p>从上图也能看出，当单字节数据不会被解释方式（大小端）影响，比如 0x11 仍然被解释为 0x11：<br><img src="/2022/img/endian1.png" alt=""><br>那么，如何知道自己主机的大小端呢？很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span>* p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输出 0x44，那么就是小端。有种常见的错误做法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> j;</span><br><span class="line">    i = <span class="number">0x1234</span>;</span><br><span class="line">    j = (<span class="type">char</span>)i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序不论大小端，都会输出 0x34，<strong><font color='orange'>因为数据截断时，总会保留最低有效字节，而不是保留地址处于最低位的字节</font></strong> 。最低有效字节中的“最低”是指的数据的低位，而不是内存地址的低位，比如 4 字节整型 0x11223344 截断为 1 字节的 char 时，就只会保留最低有效字节 0x44。<strong>截断的行为不会被大小端影响</strong> 。</p><hr><p>下面来讨论网络字节序。</p><p>为了保证在不同字节序机器之间传输网络数据时数据能够被正确解释，<strong><font color='orange'>规定网络数据传输的格式一律为大端序</font></strong> 。使用以下函数转换字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line">    net to host,将网络字节序转为主机字节序</span><br><span class="line">    </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line">    host to net,将主机字节序转为网络字节序</span><br></pre></td></tr></table></figure><p>SOCKET 网络编程初学者可能会疑惑，除了为端口和 IP 地址赋值时会用到上面的函数，其他时候我们发送网络数据都没有用到这些函数呀！<strong><font color='orange'>这是因为大多数情况下我们都是发送的字符串数据，而字符都是 char，即单字节数据，因此根本不会被字节序影响</font></strong> 。那么我们来传输一个 int 整型试试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机是小端序，使用 wireshark 抓取网络报文，可见数据仍是以小端序传输的。如果对端机器是大端序，那么字节序列 <code>78 56 34 12</code> 则会被解释为 <code>0x78563412</code> ，从而造成数据错乱。<br><img src="/2022/img/image-20230416181222470.png" alt=""></p><p>所以我们必须先将整型转为大端序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line">    <span class="type">int</span> a = htonl(<span class="number">0x12345678</span>);</span><br><span class="line">    write(sock, &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230416181831813.png" alt=""></p><hr><p>从上面我们能得到：跨网络传输字符串或其他单字节数据时，不会受大小端影响；而传输多字节的二进制数据时，如果不提前转为大端序，那么就会发生错误。即使手动将二进制数据（如结构体）转为大端序，也存在以下几个问题：</p><ul><li>两端机器对 C 数据类型的实现不同，比如本端机器的 int 为 4 字节，而对端的机器可能为 2 字节。</li><li>不同实现的结构体对齐方式存在差异。</li></ul><p>可以使用以下两种方法解决以上问题：</p><ul><li>将所有数值类型作为字符串来传递，显然效率很低。</li><li>自己定义一个二进制数据结构（协议）。</li></ul><p>最后补充一点，大小端问题不仅出现在主机之间，在同一主机的不同进程之间也可能出现，比如在Java虚拟机中采用的是网络字节序（即大端字节序），因此在与其他进程进行数据交换时，需要进行字节序转换。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三握四挥异常分析</title>
      <link href="/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">全连接与半连接队列</a> 、<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;optval, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    Listen(sock_listen, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    bzero(&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    Connect(sock, (<span class="keyword">struct</span> sockaddr *) &amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包裹函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(fd, backlog))</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == accept(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-第一次握手异常-font"><font color='red'>第一次握手异常</font></h2><p>第一次握手异常一般有三种情况：<br><strong>1） 目标主机不可达，响应一个 “destination unreachable” 的 ICMP 报文。</strong></p><blockquote><p>这个情况很好模拟，在客户端 connect 一个任意 IP 的地址结构即可。</p></blockquote><p><strong>2）目标主机的指定端口上没有套接字处于监听状态，connect 返回 “Connection refused” 。</strong></p><p><strong>3）接收方丢弃 SYN 报文。</strong></p><p>下面重点说说第三种情况。</p><p><strong><mark class="hl-label blue">什么情况下会丢弃SYN报文？</mark> </strong></p><p>有两种情况是可以确定的：</p><ol><li><strong>半连接队列已满，且没有开启 SYN-Cookie</strong></li><li><strong>全连接队列已满</strong></li></ol><p><strong><font color='orange'>情况一验证：</font></strong></p><blockquote><p><strong>在笔者环境下（Ubuntu 16.04），半连接队列的长度等于全连接长度，即为 <code>min(somaxconn,backlog)</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>); <span class="comment">//backlog为5,则全连接队列容量为6,半连接队列为5</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将 SYN-Cookie 设置为 0（默认为 1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//须在管理员身份下运行</span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/tcp_syncookies </span><br></pre></td></tr></table></figure><blockquote><p>0 值，表示关闭该功能；<br>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；<br>2 值，表示无条件开启功能；</p></blockquote></li><li><p>运行 server 端。</p></li><li><p>运行 hping3，发起 SYN 洪水攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机,即伪造</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><p>发送了 1000 个<u>虚假</u> SYN 报文，而半连接队列中只有 5 个连接（满），说明其他 SYN 确实是被服务端丢弃了。那么如果开启了 SYN-Cookie 会怎么样呢？继续实验：</p><ol><li><p>将 SYN-Cookie 设置为 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>运行 server 端和 hping3</p></li><li><p>查看 SYN_RECV 状态的个数，仍然为 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>查看 ESTABLISHED 状态的个数，为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | wc -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>运行客户端，并查看 ESTABLISHED 状态的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><blockquote><p>这里显示为 12，实际上为 6，这是因为服务器端和客户端都在一个主机上，netstat 命令分别以服务器和客户端的角度进行了输出，所以算重复了一次。<br>已连接状态数为 6 的原因请参见前置文章，这里不再赘述。</p></blockquote></li></ol><p><strong><font color='gree'>所以，若半连接队列已满，且没有开启 SYN-Cookie ，则丢弃 SYN 报文。开启 SYN Cookies 后，就可以在不经过半连接队列的情况下成功建立连接：</font></strong><br><img src="/2022/img/39-1679303729834-1-1679373170821-1.jpg" alt=""></p><p><strong><font color='orange'>情况二验证</font></strong></p><ol><li><p>先后运行服务器端和客户端</p></li><li><p>分别查看 ESTABLISH 和 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">12</span><br><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>可见，当全连接队列满了后，半连接队列也不再接受 SYN</strong> 。</p></li></ol><p>追问：如果全连接队列仅还有一个空位，那么半连接队列也只会接收一个 SYN 吗？继续实验：</p><ol><li><p>修改 client 的第 23 行代码，将 10 改为 5，即发起 5 次连接（全队列容量为 6，这样就能余下一个空位）</p></li><li><p>先后运行 server 和 client</p></li><li><p>查看 ESTABLISHED 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep ESTABLISH  | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>即，有 5 个连接已经完成建立，全队列余下一个空位。</p></li><li><p>运行 hping3，并查看 SYN_RECV 个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>发现半连接队列也已经满员。</p></li></ol><p>综合以上两种情况，得到下面的流程图：<br><img src="/2022/img/aha.png" alt=""></p><p><strong><mark class="hl-label blue">SYN报文丢失了会怎样？</mark> </strong><br>很简单，重传即可。值得一提的是，<strong><font color='orange'>SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制</font></strong> 。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后，即，<strong>每次超时的时间是上一次的 2 倍</strong> 。在笔者环境下，重传次数为 6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries </span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>为了更清晰地看到这个过程，我们先关闭 SYN-Cookie，然后发起泛洪，使半连接队列满员，进而只能丢弃新到的 SYN 报文；接着开启一个客户端，此时使用 wireshark 进行抓包，结果如下：<br><img src="/2022/img/image-20230407213529813.png" alt="image-20230407213529813"><br>一共发送 7 次 SYN 报文，其中重传 6 次。看左边的数字小数点的前两位：50 -&gt; 51 -&gt; 53 -&gt; 57 -&gt; 65 -&gt; 81 ，间隔时间分别为 1、2、4、8、16，和我们前面的结论相同。只是最后差了 34s，接近 32s，可能是误差吧，不太清楚这里是怎么回事。</p><hr><h2 id="font-color-red-第二次握手异常-font"><font color='red'>第二次握手异常</font></h2><p>有了第一次异常的分析，第二次握手异常就很容易分析出来了。首先能够确定的是，第一次握手的 SYN 报文仍然会重传，因为 client 压根没有收到 server 的 SYN+ACK 报文。那么 server 会怎么样呢？也容易猜到，由于迟迟没有收到第三次握手的 ACK 报文，server 也一定会重传，<strong><font color='orange'>且重传次数由 <code>tcp_synack_retries</code> 决定</font></strong>（ 在笔者环境下，该值为 5）。实验如下：<br>1）使用 <code>iptables</code> 屏蔽第二次握手：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT -p tcp  --tcp-flags SYN,ACK SYN,ACK -j DROP</span><br></pre></td></tr></table></figure><p>2）运行 server 和 client，使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230415194126268.png" alt=""></p><p>可见，第一次和第二次握手都在重传。</p><h2 id="font-color-red-第三次握手异常-font"><font color='red'>第三次握手异常</font></h2><p>第三次握手就有意思了。看下面的三次握手的过程图：<br><img src="/2022/img/image-20230408101018084.png" alt=""></p><p>可见当第三次握手的 ACK 发出后，客户端已经处于建立连接的状态，而服务器此时还没收到客户端的 ACK 报文，仍处于 SYN_RECV 状态。那么问题来了，如果 client 给 server 发送数据报文，会出现什么情况呢？</p><p>为了模拟server 无法接收 ACK 报文的情况，我们使用 iptables 在防火墙阻截这个 ACK 报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --tcp-flag ACK,SYN  ACK -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>只需知道上述命令的作用为：屏蔽含有 ACK 标记 <strong>且</strong> 不包含 SYN 标记的报文，显然三次握手中只有第三次符合要求，因此会被屏蔽。关于 iptables，请移步本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">iptables</a><br>另外，实验完成后记得把屏蔽去掉，将 -I 改为 -D 重新执行上述命令即可。</p></blockquote><p>结果如下：<br><img src="/2022/img/image-20230408151310936.png" alt=""></p><p>可见，如果第三次握手的 ACK 报文丢失，则会引起第二次握手 ACK+SYN 重传，且重传 5 次，如 <code>tcp_synack_retries</code> 示，然后 clinet 重发 ACK，仍然丢失。再来看看 server 和 client 的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep 12345</span><br><span class="line">tcp        0      0 192.168.248.128:59999   192.168.248.128:12345   ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.248.128:12345   192.168.248.128:59999   SYN_RECV   </span><br></pre></td></tr></table></figure><p>表明 client 已处于已连接状态，server 还未连接。而且重传 5 次完毕后不久，SYN_RECV 状态消失，说明 server 已经主动断开连接。如果此时 client 发送数据，这些报文当然也无法得到回复。<strong><font color='orange'>建立连接后（是指在 ESTABLISHED 状态下）发送的报文丢失，则会重传，次数由 <code>tcp_retries2</code> 决定（本机为 15 次，等待大概 15min）</font></strong> ，没有回应则直接关闭连接。</p><blockquote><p><code>tcp_retries1</code> 变量是控制在系统向下级发出信号以尝试验证网络是否可用之前的重试次数，可忽略。</p></blockquote><p>那么如果 client 不发送数据呢？它岂不是会一直保持 ESTABLISHED 状态。并不会，TCP 有保活机制，当一条连接上连续 <strong>两小时</strong> 没有任何动静时，本端就会发送探测报文，若连续几次探测报文都没有得到回应，则直接断开连接。保活时间，探测报文的次数、时间间隔分别由以下三个参数决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75 </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>即，最少需要经过 2 小时 11 分 15 秒才能断开一个死亡连接</font></strong> 。</p><blockquote><p>关于心跳包和保活机制，可参见<a href="https://jyx-fyh.github.io/2023/04/08/%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BF%83%E8%B7%B3%E5%8C%85%E8%AE%BE%E8%AE%A1/">保活机制与心跳包设计</a> 。</p></blockquote><hr><h2 id="font-color-red-第一次挥手异常-font"><font color='red'>第一次挥手异常</font></h2><p><strong><font color='gree'>FIN 报文丢失的原因之一是因为对方接收缓冲区满导致 FIN 无法被接收。</font></strong></p><p>重传 FIN 报文，次数由 <code>tcp_orphan_retries</code> 控制，超过指定次数则直接关闭。这里有个细节： <code>tcp_orphan_retries</code> 默认为 0，但实际上重传次数为 8，源码向我们解释了原因：<br><img src="/2022/img/28-1680942414542-4.jpg" alt=""></p><p><strong><font color='orange'>为了避免 <code>FIN_WAIT1</code> 状态的连接过多，我们可以调小 <code>tcp_orphan_retries</code> 的值，也可以通过 <code>tcp_max_orphans</code> 限制其数量，</font></strong>  <strong><font color='orange'>如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，<u>而是直接发送 RST 复位报文强制关闭</u>。</font></strong></p><hr><h2 id="font-color-red-第二次挥手异常-font"><font color='red'>第二次挥手异常</font></h2><p>即 ACK 报文丢失，这种情况下会重复第一次挥手。<strong><font color='orange'>注意，pure ACK 报文都不会主动重传！只能被第一次挥手驱动而重传</font></strong></p><h2 id="font-color-red-第三次挥手异常-font"><font color='red'>第三次挥手异常</font></h2><p>则重传 FIN 报文，次数仍由 <code>tcp_orphan_retries</code> 控制，超出指定次数则直接关闭连接。注意，此时 client（主动关闭方） 已经处于 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果 client 是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果 client 是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></p><blockquote><p>关于 close 和 shutdown，参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a></p></blockquote><h2 id="font-color-red-第四次挥手异常-font"><font color='red'>第四次挥手异常</font></h2><p>则重传第三次挥手的 FIN 报文，超过指定次数则直接关闭。第三次挥手成功后，主动关闭方进入了 TIME_WAIT 状态，这在期间如果收到重传的第三次挥手报文则回复 ACK：<br><img src="/2022/img/image-20230416215104213.png" alt=""></p><hr><h2 id="font-color-red-区分连接断开的几种常见情况-font"><font color='red'>区分连接断开的几种常见情况</font></h2><p><strong><mark class="hl-label blue">进程崩溃</mark> </strong><br>进程崩溃可以指是使用 kill 命令杀死进程，此时进程会进行关闭套接字等一系列动作，并向对方发出 FIN 报文，和正常四次挥手无差别。</p><p><strong><mark class="hl-label blue">服务器主机崩溃</mark> </strong><br>服务器主机崩溃可以是断电，这种情况下进程来不及关闭套接字，因此服务器主机直接从网络中消失，那么客户向服务器重传数次后将返回 “destination unreachable” 错误。</p><p><strong><mark class="hl-label blue">服务器主机关机</mark> </strong><br>Unix 系统关机时，init 进程会先给所有进程发送 SIGTERM 信号，等待一小段时间（以给进程清除和终止的时间）后发送 SIGKILL 信号强制终止所有进程。进程终止时会关闭所有描述符，于是进行正常挥手。</p><p><strong><mark class="hl-label blue">服务器主机崩溃后重启</mark> </strong><br>服务器崩溃后重启，之前的 TCP 连接状态信息已经丢失，因此服务器对之前连接上发来的消息都将回复 RST。</p><blockquote><p>参考：《UNP》、<a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">小林网络</a> 、<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptable用法详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络学习利器—hping3</title>
      <link href="/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/"/>
      <url>/2023/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%88%A9%E5%99%A8%E2%80%94hping3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络学习利器—hping3</p><blockquote><p>参考：<a href="https://techyrick.com/hping3-full-tutorial-for-dummies-to-pro/">hping3-tutorial</a> 、<a href="https://www.anquanke.com/post/id/239641#h2-10">端口扫描浅析</a>、<a href="https://linux.die.net/man/8/hping3">hping3-man</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">  -c  --count     packet count</span><br><span class="line">  -i  --interval  wait (uX for X microseconds, for example -i u1000)</span><br><span class="line">      --fast      alias for -i u10000 (10 packets for second)</span><br><span class="line">      --faster    alias for -i u1000 (100 packets for second)</span><br><span class="line">      --flood   sent packets as fast as possible. Don&#x27;t show replies.</span><br><span class="line">  -n  --numeric   numeric output</span><br><span class="line">  -q  --quiet     quiet</span><br><span class="line">  -I  --interface interface name (otherwise default routing interface)</span><br><span class="line">  -V  --verbose   verbose mode</span><br><span class="line">  -D  --debug     debugging info</span><br><span class="line">  -z  --bind      bind ctrl+z to ttl           (default to dst port)</span><br><span class="line">  -Z  --unbind    unbind ctrl+z</span><br><span class="line">      --beep      beep for every matching packet received</span><br><span class="line">Mode</span><br><span class="line">  default mode     TCP</span><br><span class="line">  -0  --rawip      RAW IP mode</span><br><span class="line">  -1  --icmp       ICMP mode</span><br><span class="line">  -2  --udp        UDP mode</span><br><span class="line">  -8  --scan       SCAN mode.</span><br><span class="line">                   Example: hping --scan 1-30,70-90 -S www.target.host</span><br><span class="line">  -9  --listen     listen mode</span><br><span class="line">IP</span><br><span class="line">  -a  --f      spoof source address</span><br><span class="line">  --rand-dest      random destionation address mode. see the man.</span><br><span class="line">  --rand-source    random source address mode. see the man.</span><br><span class="line">  -t  --ttl        ttl (default 64)</span><br><span class="line">  -N  --id         id (default random)</span><br><span class="line">  -W  --winid      use win* id byte ordering</span><br><span class="line">  -r  --rel        relativize id field          (to estimate host traffic)</span><br><span class="line">  -f  --frag       split packets in more frag.  (may pass weak acl)</span><br><span class="line">  -x  --morefrag   set more fragments flag</span><br><span class="line">  -y  --dontfrag   set don&#x27;t fragment flag</span><br><span class="line">  -g  --fragoff    set the fragment offset</span><br><span class="line">  -m  --mtu        set virtual mtu, implies --frag if packet size &gt; mtu</span><br><span class="line">  -o  --tos        type of service (default 0x00), try --tos help</span><br><span class="line">  -G  --rroute     includes RECORD_ROUTE option and display the route buffer</span><br><span class="line">  --lsrr           loose source routing and record route</span><br><span class="line">  --ssrr           strict source routing and record route</span><br><span class="line">  -H  --ipproto    set the IP protocol field, only in RAW IP mode</span><br><span class="line">ICMP</span><br><span class="line">  -C  --icmptype   icmp type (default echo request)</span><br><span class="line">  -K  --icmpcode   icmp code (default 0)</span><br><span class="line">      --force-icmp send all icmp types (default send only supported types)</span><br><span class="line">      --icmp-gw    set gateway address for ICMP redirect (default 0.0.0.0)</span><br><span class="line">      --icmp-ts    Alias for --icmp --icmptype 13 (ICMP timestamp)</span><br><span class="line">      --icmp-addr  Alias for --icmp --icmptype 17 (ICMP address subnet mask)</span><br><span class="line">      --icmp-help  display help for others icmp options</span><br><span class="line">UDP/TCP</span><br><span class="line">  -s  --baseport   base source port             (default random)</span><br><span class="line">  -p  --destport   [+][+]&lt;port&gt; destination port(default 0) ctrl+z inc/dec</span><br><span class="line">  -k  --keep       keep still source port</span><br><span class="line">  -w  --win        winsize (default 64)</span><br><span class="line">  -O  --tcpoff     set fake tcp data offset     (instead of tcphdrlen / 4)</span><br><span class="line">  -Q  --seqnum     shows only tcp sequence number</span><br><span class="line">  -b  --badcksum   (try to) send packets with a bad IP checksum</span><br><span class="line">                   many systems will fix the IP checksum sending the packet</span><br><span class="line">                   so you&#x27;ll get bad UDP/TCP checksum instead.</span><br><span class="line">  -M  --setseq     set TCP sequence number</span><br><span class="line">  -L  --setack     set TCP ack</span><br><span class="line">  -F  --fin        set FIN flag</span><br><span class="line">  -S  --syn        set SYN flag</span><br><span class="line">  -R  --rst        set RST flag</span><br><span class="line">  -P  --push       set PUSH flag</span><br><span class="line">  -A  --ack        set ACK flag</span><br><span class="line">  -U  --urg        set URG flag</span><br><span class="line">  -X  --xmas       set X unused flag (0x40)</span><br><span class="line">  -Y  --ymas       set Y unused flag (0x80)</span><br><span class="line">  --tcpexitcode    use last tcp-&gt;th_flags as exit code</span><br><span class="line">  --tcp-mss        enable the TCP MSS option with the given value</span><br><span class="line">  --tcp-timestamp  enable the TCP timestamp option to guess the HZ/uptime</span><br><span class="line">Common</span><br><span class="line">  -d  --data       data size                    (default is 0)</span><br><span class="line">  -E  --file       data from file</span><br><span class="line">  -e  --sign       add &#x27;signature&#x27;</span><br><span class="line">  -j  --dump       dump packets in hex</span><br><span class="line">  -J  --print      dump printable characters</span><br><span class="line">  -B  --safe       enable &#x27;safe&#x27; protocol</span><br><span class="line">  -u  --end        tell you when --file reached EOF and prevent rewind</span><br><span class="line">  -T  --traceroute traceroute mode              (implies --bind and --ttl 1)</span><br><span class="line">  --tr-stop        Exit when receive the first not ICMP in traceroute mode</span><br><span class="line">  --tr-keep-ttl    Keep the source TTL fixed, useful to monitor just one hop</span><br><span class="line">  --tr-no-rtt    Don&#x27;t calculate/show RTT information in traceroute mode</span><br><span class="line">ARS packet description (new, unstable)</span><br><span class="line">  --apd-send       Send the packet described with APD (see docs/APD.txt)</span><br></pre></td></tr></table></figure><hr><p>先运行服务器端，在 12345 端口上监听。</p><p><strong>1）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 SYN 报文</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S 192.168.248.128 -p 12345 -c 5</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410122835239.png" alt=""></p><p><strong>2）向 <code>192.168.248.128</code> （本机 ens33 网卡的 IP 地址）的 12345 端口发送 5 个 ACK 报文，且窗口大小为 100</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -A  192.168.248.128 -p 12345 -c 5 -w 100</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230410123028629.png" alt="image-20230410123028629"></p><blockquote><p><strong><font color='red'>注意：</font></strong><br>我们向开放的 12345 端口发送 SYN 报文，得到的回复是 SYN+ACK 报文，即第二次握手；而发送 ACK 报文，则得到的回复是 RST 。这两种情况能够反应出端口的开放和过滤状态：<br><strong>发送 SYN 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>数次重发未响应</td><td>filtered</td></tr><tr><td>收到ICMP不可达错误</td><td>filtered</td></tr><tr><td>SYN/ACK</td><td>open</td></tr><tr><td>RST</td><td>closed</td></tr></tbody></table><p><strong>发送 ACK 报文：</strong></p><table><thead><tr><th>行为</th><th>状态</th></tr></thead><tbody><tr><td>收到RST报文</td><td>unfiltered(open/closed)</td></tr><tr><td>未响应</td><td>filtered</td></tr><tr><td>ICMP不可达</td><td>filtered</td></tr></tbody></table><p><strong>也就是说，我们可以通过向指定端口发送 SYN 或 ACK 报文来检测该端口的状态，这称为<font color='red'><u>端口扫描</u></font></strong> 。</p><p>另外，关于报文过滤，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/">包过滤工具iptables</a></p></blockquote><p><strong>3）端口扫描模式</strong><br>扫描 <a href="http://baidu.com">baidu.com</a> 的 75~85 和 12345 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 --scan  75-85,12345 -S baidu.com</span></span><br><span class="line">Scanning baidu.com (39.156.66.10), port 75-85,12345</span><br><span class="line">12 ports to scan, use -V to see all the replies</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">|port| serv name |  flags  |ttl| id  | win | len |</span><br><span class="line">+----+-----------+---------+---+-----+-----+-----+</span><br><span class="line">   80 http       : .S..A... 128 27907 64240    46</span><br><span class="line">All replies received. Done.</span><br><span class="line">Not responding ports: (75 ) (76 ) (77 rje) (78 ) (79 finger) (81 ) (82 ) (83 ) (84 ) (85 ) (12345 ) </span><br></pre></td></tr></table></figure><p><strong>4）flood 泛洪攻击</strong><br>向 <code>127.0.0.1:12345</code> 发起泛洪攻击，源 IP 随机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 -S -p 12345 --flood --rand-source </span><br></pre></td></tr></table></figure><p><strong>5）指定源端口为 12345，源 IP 为 1.1.1.1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S baidu.com -a 1.1.1.1 -s 12345</span><br><span class="line">或</span><br><span class="line">hping3 -S baidu.com --spoof 1.1.1.1 --baseport 12345</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下源 IP 为主机地址，源端口随机</p></blockquote><p><strong>6）传输文件</strong><br>Hping3 支持通过 TCP/UDP/ICMP 等包来进行文件传输。相当于借助 TCP/UDP/ICMP 包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为 <code>--listen</code> 后面输入的字符串）的内容进行相应的解析。在接收端开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hping3 127.0.0.1  --listen signature --safe  --icmp</span> </span><br></pre></td></tr></table></figure><p>监听 ICMP 包中的签名，根据签名解析出文件内容。在发送端使用签名打包的 ICMP 包发送文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 127.0.0.1 --icmp -d 100 --sign signature --file ./data</span><br></pre></td></tr></table></figure><p>注意两点：1）必须指定数据长度 <code>-d</code> ；2）签名字符串必须和接收端相同，这里是字符串 <code>signature</code> 。<br><img src="/2022/img/image-20230410195315834.png" alt="接收端收到文件,并输出文件内容"></p><p>不过没人会使用这种方式来传送文件，因为它是明文发送的：<br><img src="/2022/img/image-20230410201345056.png" alt=""><br><code>--safe</code> 保证的是丢失重传，而不是安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“包过滤工具—iptables”</title>
      <link href="/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/"/>
      <url>/2023/04/08/%E2%80%9C%E5%8C%85%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7%E2%80%94iptables%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>防火墙是保护服务器和基础设施安全的重要工具。在 Linux 生态系统中，<code>iptables</code> 是使用很广泛的防火墙工具之一，它能够用来完成封包过滤、封包重定向和网络地址转换(NAT)等功能。 <strong><code>iptables</code> 基于内核的包过滤框架 <code>netfilter</code></strong> 。如果管理员或用户不了解这些系统的架构，那可能就无法创建出可靠的防火墙策略。</p><p><strong><u>这里我们只简单地使用 iptables 的包过滤功能（后面讨论的命令也仅限于此）</u></strong> ，因为它能够很方便地模拟各种网络状况（<a href="https://jyx-fyh.github.io/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/">TCP 三握四挥的异常处理</a>、报文丢失等），非常有助于我们对网络理论知识的学习。其他功能的详细介绍可以参见<a href="https://www.cnblogs.com/kevingrace/p/6265113.html">iptables用法规则小结</a> 。</p><hr><p>命令格式：<br><img src="/2022/img/FUCKAHA.png" alt=""></p><blockquote><p><code>ACCEPT</code> 允许数据包通过<br><code>DROP</code>  直接丢弃数据包，不给任何回应信息<br><code>REJECT</code> 拒绝数据包通过，必要时会给数据发送端一个响应的信息</p></blockquote><blockquote><p><strong><font color='red'>注意：</font></strong> 即使我们在输入链 INPUT 上 DROP 了指定报文，tcpdump/wireshark 仍然可以抓到该报文，因为报文的进入顺序是：<code>Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables</code> ；而出站顺序为：<code>iptables -&gt; tcpdump -&gt; NIC -&gt; Wire</code> ，此时 tcpdump/wireshark 才无法抓到指定报文。</p><p>注意，在 INPUT 中丢弃报文后，虽然可以被 tcpdump 捕获，但指定的端口或程序仍然无法收到该报文。</p></blockquote><p>示例：</p><p>1）在 lo 接口上丢弃目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -i lo -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j DROP</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定端口必须放在指定协议之后</strong> 。<br>另外，如果是做实验，那么添加之后记得删除，将 -I 改为 -D 再执行一次即可。</p></blockquote><p>2）拒绝目标 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> 的 TCP 报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -d 192.168.248.128 -p tcp --dport 12345 -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝报文后，一般会给发送端发送 IMCP 报文以报告错误：<img src="/2022/img/image-20230409110416756.png" alt=""></p><p>3）拒绝源 IP 为 <code>192.168.248.128</code> ，目标端口为 <code>12345</code> ，且报文含有 SYN 标志的报文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN SYN -j DROP</span><br></pre></td></tr></table></figure><p>这样我们就屏蔽了源 IP 为 <code>192.168.248.128</code> 发向 <code>12345</code> 端口的第一次握手。</p><blockquote><p>这条命令使用了 tcp 扩展模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tcp-flags mask comp</span><br></pre></td></tr></table></figure><p>第一个参数 mask 是我们应该检查的标志，写成由逗号分隔的列表。<br>第二个参数 comp 是必须匹配的标志的列表，列表以逗号分隔。<br>没有被匹配上的标志则要求不能被设置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><p>这条命令只会匹配到设置了 ACK 而没有设置 SYN 的报文。<br>Flags ： SYN ，ACK ，FIN ，RST ，URG ，PSH ，ALL ，NONE</p><p>另外，有时会使用 <code>-m</code> 显式指定模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 12345 -m tcp --tcp-flags SYN,ACK ACK -j DROP</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP</span><br></pre></td></tr></table></figure></blockquote><p>4）列出 filter 表的所有规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN,ACK/ACK</span><br><span class="line">DROP       tcp  --  192.168.248.128      anywhere             tcp dpt:12345 flags:SYN/SYN</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='orange'>注意，如果不使用 <code>-t</code> 指定表，则默认都为 filter</font></strong></p></blockquote><p>5）删除指定规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables  -D INPUT 1  删除第一条规则</span><br></pre></td></tr></table></figure><p>6）<code>!</code> 取反：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT ! -s 192.168.248.128 -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>丢弃除了源 IP 为 <code>192.168.248.128</code> 的其他所有 TCP 报文。</p><p>7）操作网段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.20.30.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>8）端口范围：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.248.128 -p tcp --dport 1000:2000 -j DROP</span><br></pre></td></tr></table></figure><p>9）拒绝 DDOS 攻击：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p>-m limit: 启用limit扩展，限制速度。<br>–limit 25/minute: 允许最多每分钟25个连接<br>–limit-burst 100: 当达到100个连接后，才启用上述25/minute限制</p><p>这种方式似乎不能有效解决 DDOS 攻击。</p></blockquote><p>10）包含指定字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 12345 -m string --algo bm --string &#x27;admin&#x27; -j REJECT</span><br></pre></td></tr></table></figure><p>拒绝目标端口为 12345 且数据中包含 “admin” 字符串的报文。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用socket选项</title>
      <link href="/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/"/>
      <url>/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-获取和设置socket选项-font"><font color='red'>获取和设置socket选项</font></h2><p>使用 <code>getsockopt()</code> 和 <code>setsockopt</code> 来获取和设置 socket 的各种选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(bufsize);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;optlen);</span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span> <span class="params">(<span class="type">int</span> socket,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">void</span> *option_val,</span></span><br><span class="line"><span class="params">                <span class="type">socklen_t</span> option_len)</span>;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line">    <span class="type">int</span> bufsize = <span class="number">10000</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, <span class="keyword">sizeof</span>(bufsize));</span><br></pre></td></tr></table></figure><ul><li><strong>以上两个函数，成功时均返回 0，出错则返回 -1</strong> 。</li><li>关于第二个和第三个参数，参见《UPN》第 151 页。</li></ul><p>注意，细心的朋友可能已经注意到：上面的例子中，作用的套接字是 sock_listen，即监听套接字。那么，能不能作用于已连接套接字呢？好问题！是这样的，<strong><font color='orange'>以下几个选项是由已连接套接字从监听套接字继承而来：</font></strong> <strong><font color='red'>SO_KEEPALIVE、SO_LINGER、SO_RECVBUF、SO_SNDBUF、SO_RCVLOWAT、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY</font></strong> 、SO_DEBUF、SO_DONTROUTE、SO_OBBINLINE （红色标记为重点选项）。所以，在这几个选项上设置监听套接字，将影响后面的所有已连接套接字。<u>作为对比，getpeername() 函数就必须要作用于已连接套接字</u>。</p><h2 id="font-color-red-SO-RCVBUF-和-SO-SNDBUF-font"><font color='red'>SO_RCVBUF 和 SO_SNDBUF</font></h2><p>这是两个重要的选项。要弄清楚这两个选项，就必须先搞明白 Socket 的缓冲区机制。下面总结了 Socket 缓冲区的关键特性：<br><img src="/2022/img/IMG_0579(20230406-190556).PNG" alt=""></p><ul><li><strong><font color='gree'>每个套接字都有独立的输入/输出缓冲区。</font></strong></li><li><strong><font color='gree'>创建套接字时，自动生成缓冲区。</font></strong></li><li><strong><font color='gree'>如果要写（write）的数据大于发送（输出）缓冲区的最大长度，那么将分批写入。</font></strong></li><li><strong><font color='gree'>如果发送缓冲区全满（分批写入也不能进行），则进程被阻塞（假设套接字是阻塞模式）。</font></strong></li><li><strong><font color='gree'>发送缓冲区的数据将一直保存（以便重发），直到接收到相应 ACK。</font></strong></li><li><strong><font color='gree'>接收（输入）缓冲区的数据将一直保存，直到应用层读取（read）。</font></strong></li><li><strong><font color='gree'>接收缓冲区若满，则直接抛弃新数据（不发送其他任何信息，等待对面重传）。</font></strong></li><li><strong><font color='gree'>TCP 接收窗口大小 &lt;= 接收缓冲区大小。</font></strong></li></ul><blockquote><p>以上几个特性的实验，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">网络数据读取的常见问题</a> ，建议浏览，加深理解。</p></blockquote><p><strong><font color='red'>SO_RCVBUF 直接限制本端 TCP 接收窗口的大小</font></strong> 。下面进行实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(recv_size);</span><br><span class="line">    setsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;recv_size, optlen);</span><br><span class="line">    getsockopt(sock_listen, SOL_SOCKET, SO_RCVBUF,(<span class="type">void</span>*)&amp;recv_size,&amp;optlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server recv buffer size: %d\n&quot;</span>,recv_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_listen</span>;</span></span><br><span class="line">    bzero(&amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    addr_listen.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_listen.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_listen.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_listen, (<span class="keyword">struct</span> sockaddr *) &amp;addr_listen, <span class="keyword">sizeof</span>(addr_listen));</span><br><span class="line">    Listen(sock_listen, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = Accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不read,不close</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    sock_clnt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    writen(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别运行运行 server 和 client 后，server 的接收缓冲区的大小为 6000：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server recv buffer size: <span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将 recv_size 设置的为 3000，而实际反馈为 6000，<strong>说明 recv_size 只是一个建议值，操作系统会根据一定条件进行修改（×2）</strong> 。在笔者操作系统上，接收缓冲区最小为 2304 。</p></blockquote><p>然后我们使用 wireshark 抓包，结果如下：<br><img src="/2022/img/image-20230403111812767.png" alt=""></p><p>看第二项，server 发送的 SYN 报文中，<strong>win 为 3000，和我们设置的 SO_RECVBUF 大小相同</strong> ，但这并不意味着窗口大小就一定等于 SO_RECVBUF。<strong><u><font color='gree'>接收窗口会随着网络状况而不断调整，但肯定不会超过缓冲区的大小</font></u></strong> 。</p><blockquote><p>在本机上实验多次发现，<strong>接收窗口始终不会超过接收缓冲区的一半大小</strong> 。</p></blockquote><p>还有以下几点需要注意：</p><ol><li>上面说过，这两个选项是由监听套接字继承而来，<strong><u><font color='orange'>所以对于 server，必须在 listen 前设置选项；对于 client，必须在 connect 前设置选项</font></u></strong> 。对已连接套接字（在 accept 返回之后）设置选项没有任何作用，因为 accept 只是从已连接队列中取出一个连接而已（参见<a href="https://jyx-fyh.github.io/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">深入理解socket基本函数</a>）。</li><li>为了避免潜在的缓冲区空间浪费，接收缓冲区大小应该为 MSS 的整数倍，且至少为 MSS 的 4 倍，参见《UNP》P163。</li><li><strong><font color='orange'>为了最大化性能，缓冲区大小应该约等于带宽-延迟积</font></strong> ，参见《UNP》P164 。</li></ol><h2 id="font-color-red-SO-RCVLOWAT-和-SO-SNDLOWAT-font"><font color='red'>SO_RCVLOWAT 和 SO_SNDLOWAT</font></h2><p>这两个选项作用于 select/poll/epoll，目的在于减少网络 I/O 的次数。<code>SO_RCVLOWAT</code> 指定接收缓冲区中的数据量必须达到多少时，才会唤醒 select/poll/epoll 去读取数据，其默认值为 1 。<code>SO_SNDLOWAT</code> 指定当发送缓冲区的<u>空闲空间</u>大于等于低水平位标记时，将唤醒 select/poll/epoll 写数据到socket ，其默认值为 2048（然而本机实测仍为 1） 。</p><h2 id="font-color-red-SO-REUSEADDR-font"><font color='red'>SO_REUSEADDR</font></h2><p>这是服务器最常用的选项之一。该选项有以下几个作用：</p><ol><li><p><strong>可以在 TIME_WAIT 期间重新绑定该端口，这对服务器崩溃重启并快速恢复有至关重要的作用，避免了几十秒甚至几分钟的等待。</strong></p><blockquote><p>需要注意的是，如果没有开启时间戳选项（默认开启），则 TIME_WAIT 期间重新绑定<u>可能</u>失败，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT探究</a>。</p></blockquote></li><li><p><strong>允许在已连接的状态下重新绑定该端口</strong> ，常见情景如下：<br>a）启动监听进程<br>b）连接请求到达，派生一个子进程处理该连接<br>c）监听进程崩溃，子进程仍在运行<br>d）重启监听进程，并绑定之前的端口</p></li><li><p><strong>允许在同一个端口启动多个服务器，前提是每个服务器绑定的本地 IP 不同（IP 别名）</strong></p><blockquote><p>笔者在本机上实验，分别绑定环回地址 <code>127.0.0.1</code> 和本机 IP 地址，两者可以同时绑定同一个端口。如果未开启 SO_REUSEADDR，则无法同时绑定。<br><strong><u>注意，如果某个服务器程序绑定的是通配地址（INADDR_ANY），那么后续在同一端口上启动的服务器程序则无法完成绑定。</u></strong></p></blockquote></li><li><p>其他作用不常见，详见《UNP》P166</p></li></ol><p><strong><font color='orange'>另外注意，不论是否开启该选项，不同传输层协议是可以同时绑定到同一端口的，比如 TCP 和 UDP 程序就能够同时绑定到一个端口。</font></strong></p><p><strong><font color='red'>对于所有 TCP 服务器，都应该在 bind 前开启 SO_REUSEADDR ！</font></strong></p><blockquote><p>另外，还有一个 <code>SO_REUSEPORT</code> 选项，不常用，参见《UNP》P165</p></blockquote><h2 id="font-color-red-SO-LINGER-font"><font color='red'>SO_LINGER</font></h2><p><code>SO_LINGER</code> 用来控制 close 的行为：<br><img src="/2022/img/image-20230407141037746.png" alt=""><br><img src="/2022/img/image-20230407141059416.png" alt=""><img src="/2022/img/IMG_0580(20230407-134909).PNG" alt=""></p><p><strong><u>注意缓冲区的各种情况！</u></strong> 其中第四种关闭方式就是我们常说的“优雅关闭”。</p><p>书中提供了一种有效办法，使发送端能够确认接收端的<u>应用层</u>已收到数据，详见《UPN》P161。</p><p><strong>另外有个细节，上图中 SHUT_RD 后，接收到的任何数据都会被丢弃，这里的丢弃是先确认再丢弃，也就是说，这不会引发对方的重传。</strong></p><h2 id="font-color-red-TCP-NODELAY-font"><font color='red'>TCP_NODELAY</font></h2><p>此选项用来禁止 Nagle 算法。关于 Nagle 算法，参见本博客另一篇文章——<a href="https://jyx-fyh.github.io/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">TCP流量控制</a> 。 有时候我们必须要关闭 Nagle 算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark入门笔记</title>
      <link href="/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/02/wireshark%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>学习 wireshark 前需要先了解 tcpdump，<strong>许多情况下我们使用 tcpdump 抓包（更快速、更方便），然后使用 wireshark 进行分析</strong> 。可参见 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump实操</a><br>环境：Ubuntu 16.04 LTS</p></blockquote><hr><h2 id="font-color-red-安装-wireshark-font"><font color='red'>安装 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install wireshark-qt</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-启动-wireshark-font"><font color='red'>启动 wireshark</font></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wireshark</span></span><br></pre></td></tr></table></figure><p>启动后显示如下界面：<br><img src="/2022/img/image-20230402115238469.png" alt=""></p><p>发现没有我们想要的网卡。如何知道哪块网卡是我们想要的？打开命令行终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4331 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3064 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2400943 (2.4 MB)  TX bytes:462038 (462.0 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1249 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1249 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:121848 (121.8 KB)  TX bytes:121848 (121.8 KB)</span><br></pre></td></tr></table></figure><p><code>ens33</code> 就是可用网卡（<code>lo</code> 是环回接口，不用管）。</p><p>没有显示 <code>ens33</code> 是因为操作权限问题。重新以管理员身份运行 wireshark：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo wireshark</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20230402115430627.png" alt=""></p><p>成功显示 <code>ens33</code> ，<strong><u>双击该选项</u></strong> ，进入 wireshark 抓包页面。</p><hr><h2 id="font-color-red-捕获过滤器-font"><font color='red'>捕获过滤器</font></h2><p>捕获过滤和显示过滤器是 wireshark 的两种主要过滤方式，但二者机制完全不同。前者是指示 wireshark 只捕获满足一定要求的报文，而后者则是在已经捕获到的报文中筛选出满足进一步要求的报文。捕获过滤器在打开 wireshark 时设置：</p><p><img src="/2022/img/image-20230402151407256.png" alt=""></p><p>或者打开 wireshark 后，在设置页面操作：<br><img src="/2022/img/image-20230402151634036.png" alt="注意，需要先停止捕获才可设置"></p><p>配置捕获规则的语法和 <a href="https://jyx-fyh.github.io/2023/03/21/tcpdump/">tcpdump</a> 相同，这里不再赘述。</p><blockquote><p>建议：某些时候无需设置太过具体的条件，以免不利于网络错误排查。比如你要求只接收 TCP 报文，但 TCP 连接出错时可能会产生 ICMP 报文来传达错误信息，而这却被你给屏蔽了…</p></blockquote><hr><h2 id="font-color-red-显示过滤器-font"><font color='red'>显示过滤器</font></h2><p>显示过滤在捕获网络报文后进行：<br><img src="/2022/img/image-20230402152619594.png" alt=""></p><p>显示过滤的语法和 tcpdump 完全不同。详细语法参见<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html">wireshark manual</a></p><hr><h2 id="font-color-red-名称解析-font"><font color='red'>名称解析</font></h2><p><img src="/2022/img/image-20230402163513811.png" alt=""><br><img src="/2022/img/image-20230402163636148.png" alt=""></p><ul><li>选项 1：将 MAC 地址解析为名称。</li><li>选项 2：将著名端口号解析为协议名，如，将端口号 80 解析为 http 。</li><li>选项 3：将 IP 解析为域名。</li><li>选项 4：如果将 IP 解析为域名，则只利用已经抓到的包来解析，不另外专门进行 DNS 查询。</li><li>选项 5：如果无法从已抓到的报文解析 IP，则另外进行 DNS 查询。这会影响速度，一般不开。</li></ul><p>已经解析的名字可以通过以下方式找到：<br><img src="/2022/img/image-20230402165754095.png" alt=""></p><p>另外，你也可以自己命名一些 IP 地址：<br><img src="/2022/img/image-20230402165953271.png" alt=""><br>自己命名的 IP 也会被加入到上面的 Resolved Address 栏目中。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump实操</title>
      <link href="/2023/03/21/tcpdump/"/>
      <url>/2023/03/21/tcpdump/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-tcpdump-font"><font color='red'>tcpdump</font></h2><blockquote><p><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump man</a></p></blockquote><p>tcpdump 须在管理员权限下运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump</span></span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><ul><li>输出结果表明 tcpdump 的监听网卡为 <code>ens33</code> 。</li><li>默认截断大小为 262144 字节（随版本而改变），超过该数字报文会被截断。</li></ul><p>使用 <code>ifconfig</code> 查看其他网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:48:09:a9  </span><br><span class="line">          inet addr:192.168.248.128  Bcast:192.168.248.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::555a:9e00:3f14:e7f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12058 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4911 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:9115911 (9.1 MB)  TX bytes:577567 (577.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1110 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1110 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:1022006 (1.0 MB)  TX bytes:1022006 (1.0 MB)</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-i 指定网卡</mark> </strong></p><p>上面默认监听网卡是 <code>ens33</code> ，我们也可以指定为 <code>lo</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump -i lo</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br></pre></td></tr></table></figure><p><code>-i any</code> 可以监听所有网卡。</p><hr><p><strong><mark class="hl-label blue">-nn 直接显示IP和端口号</mark> </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcpdump -i lo</span></span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">01:12:54.640796 IP localhost.44438 &gt; localhost.12345: Flags [S], <span class="built_in">seq</span> 1028792545, win 65495, options [mss 65495,sackOK,TS val 1381449987 ecr 0,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640834 IP localhost.12345 &gt; localhost.44438: Flags [S.], <span class="built_in">seq</span> 3925511357, ack 1028792546, win 65483, options [mss 65495,sackOK,TS val 1381449987 ecr 1381449987,nop,wscale 7], length 0</span><br><span class="line">01:12:54.640870 IP localhost.44438 &gt; localhost.12345: Flags [.], ack 1, win 512, options [nop,nop,TS val 1381449987 ecr 1381449987], length 0</span><br></pre></td></tr></table></figure><p>监听环回网卡时，我们运行自己编写的简易 TCP 服务器端和客户端的回射程序，结果输出以上三次握手内容。其中主机地址为 <code>localhost</code> ，由于 server 和 client 都在一台主机，所以都为 <code>localhost</code> 。如果服务器的端口为著名端口（如 ssh 为 22 号端口），那么 22 也会显示为 ssh。若想直接显示 IP 和端口号，则使用 <code>-nn</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn</span></span><br><span class="line">01:14:54.615811 IP 127.0.0.1.44438 &gt; 127.0.0.1.12345: Flags [P.], seq 1028792546:1028792548, ack 3925511358, win 512, options [nop,nop,TS val 1381569983 ecr 1381449987], length 2</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-n 不将IP转换为域名</mark> </strong></p><p>不讲 IP 转为域名，则可以省去 DNS 查询，输出速度会快很多。</p><hr><p><strong><mark class="hl-label blue">过滤主机</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源地址是 192.168.1.1 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定源地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>指定目的地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst host 192.168.1.1</span></span><br></pre></td></tr></table></figure><ul><li>也可直接指定域名：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dest host <span class="string">&quot;baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">过滤端口</mark> </strong></p><ul><li>抓取所有经过 eth1，目的或源端口是 25 的网络数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定源端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src port 25</span></span><br></pre></td></tr></table></figure><ul><li>指定目的端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure><ul><li><p>指定端口范围：portrange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo portrange 10000-20000</span></span><br></pre></td></tr></table></figure></li><li><p>对于著名端口，可直接用应用层协议替代，相当于宏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump port http</span> </span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">网段过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 src net 192.168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 dst net 192.168.0.0/16</span>  </span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">协议过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump arp</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump ip</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump tcp</span>  </span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不能直接过滤协议,如下</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump http</span>  </span><br></pre></td></tr></table></figure><p>而应该</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump port http</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">常用表达式</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非 : ! 或 not </span><br><span class="line">且 : &amp;&amp; 或 and  </span><br><span class="line">或 : || 或 or</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp &amp;&amp; dst port 12345 &amp;&amp; src host 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i lo -nn tcp and dst port 12345 and src host 127.0.0.1</span></span><br></pre></td></tr></table></figure><p>有时条件比较复杂的需要用括号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -i eth1 <span class="string">&#x27;((tcp) and (! port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))&#x27;</span></span></span><br><span class="line">抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200,并且端口不是80的TCP数据</span><br></pre></td></tr></table></figure><p><strong>如果使用括号，则整个表达式需要用 <code>''</code> 或 <code>&quot;&quot;</code> 包住。</strong></p><hr><p><strong><mark class="hl-label blue">包头过滤</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（从第0字节开始）</span><br><span class="line">proto[x:y] &amp; z = 0  : proto[x:y]和z的与操作为0</span><br><span class="line">proto[x:y] &amp; z !=0  : proto[x:y]和z的与操作不为0</span><br></pre></td></tr></table></figure><p><strong>IP报头格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    0                   1                   2                   3</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1   \bit</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0   |Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4   |         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">12  |  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16  |                       Source Address                          |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20  |                    Destination Address                        |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24  |                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">28  |                            DATA ...                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><p><strong>TCP报头格式：</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   0                   1                   2                   3</span><br><span class="line">   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \bit</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">0  |          Source Port          |       Destination Port        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">4  |                        Sequence Number                        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">8  |                    Acknowledgment Number                      |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">12 | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">   |       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16 |           Checksum            |         Urgent Pointer        |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">20 |                    Options                    |    Padding    |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">24 |                             data                              |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">\byte</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;tcp[2:2]=12345&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的报文</span><br></pre></td></tr></table></figure><p><strong>TCP标记定义在TCP头的第 13 个字节：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;src port 12345 &amp;&amp; tcp[13]&amp;1 = 1&quot;</span></span></span><br><span class="line">只显示目的端口号为12345的FIN报文</span><br></pre></td></tr></table></figure><p>TCP标记宏可以替代数值：</p><p><code>tcpflags</code> , <code>tcp-fin</code> , <code>tcp-syn</code> , <code>tcp-rst</code> , <code>tcp-push</code> , <code>tcp-push</code> , <code>tcp-ack</code> , <code>tcp-urg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i lo <span class="string">&quot;dst port 12345 &amp;&amp; tcp[tcpflags]&amp;tcp-fin=tcp-fin&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-w 输出到文件、-r 读取文件</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -w test.cap</span></span><br></pre></td></tr></table></figure><p>把信息输出到 test.cap 文件。将文件保存为 <code>cap</code> 或 <code>pcap</code> 类型就能方便地使用 wireshark 打开并分析：<br><img src="/2022/img/image-20230401192959234.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap</span></span><br></pre></td></tr></table></figure><p>读取 <code>test.cap</code> 文件并打印在终端，同时也可以使用过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp -r test.cap port 12345</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">输出时间</mark> </strong></p><ul><li><code>-t</code>：在每行的输出中不输出时间</li><li><code>-tt</code>：在每行的输出中会输出时间戳</li><li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li><li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -t dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1650, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">1680352032.093467 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1662, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -ttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line"> 00:00:00.000000 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1672, length 64</span><br><span class="line"> 00:00:01.002438 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1673, length 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -tttt dst  <span class="string">&quot;baidu.com&quot;</span></span></span><br><span class="line">2023-04-01 05:27:30.131073 IP 192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 11930, seq 1680, length 64</span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-v 展示详细信息</mark> </strong></p><p><code>-v</code>：产生详细的输出。比如包的TTL，id标识，数据包长度，以及IP包的一些选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/butcher/Documents# tcpdump -v dst  &quot;baidu.com&quot;</span><br><span class="line">tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">05:36:46.543701 IP (tos 0x0, ttl 64, id 44013, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    192.168.248.128 &gt; 39.156.66.10: ICMP echo request, id 12115, seq 7, length 64</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-c 指定接收报文个数</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -v -c 3</span> </span><br><span class="line">05:46:32.275269 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.248.2 tell 192.168.248.1, length 46</span><br><span class="line">05:46:32.276545 IP (tos 0x0, ttl 64, id 50690, offset 0, flags [DF], proto UDP (17), length 72)</span><br><span class="line">    192.168.248.128.34566 &gt; 192.168.248.2.domain: 39118+ PTR? 2.248.168.192.in-addr.arpa. (44)</span><br><span class="line">05:46:32.280758 IP (tos 0x0, ttl 128, id 35219, offset 0, flags [none], proto UDP (17), length 127)</span><br><span class="line">    192.168.248.2.domain &gt; 192.168.248.128.34566: 39118 NXDomain 0/1/0 (99)</span><br><span class="line">3 packets captured</span><br></pre></td></tr></table></figure><p>抓满指定数量的报文后自动停止。</p><p><strong><mark class="hl-label blue">-C -W 分文件写入</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -C 1 -W 4 -w <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>-C 和 -w 配套使用，后者将抓包情况写入文件，前者指定每个文件的最大大小，单位为 1MB（小文件利于分析）。</p><ul><li><code>-C 1</code> ：指定单个文件最大为 1MB</li><li><code>-W</code> ：指定最多写 4 个文件</li><li><code>-w</code> ：写入文件</li></ul><p>每个文件会依次添加后缀：test1、test2、test3、test4 。<strong><u>注意，如果写满这 4 个文件后，数据还在持续，那么会重新覆盖这 4 个文件并继续写入，而不会新建文件。</u></strong></p><hr><p><strong><mark class="hl-label blue">-Q 指定方向</mark> </strong></p><ul><li>-Q in ：只显示收到的数据</li><li>-Q out ：只显示发出的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -Q <span class="keyword">in</span></span></span><br><span class="line">06:04:34.157713 IP 192.168.248.1.50277  &gt; 239.255.255.250.1900: UDP, length 175</span><br><span class="line">06:04:34.163603 IP 192.168.248.2.domain &gt; 192.168.248.128.34566: 27092 NXDomain 0/1/0 (103)</span><br><span class="line">06:04:35.003369 IP 180.101.49.186.https &gt; 192.168.248.128.33644: Flags [.], ack 769671203, win 64240, length 0</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-s 指定截取大小</mark> </strong></p><p><code>-s</code> 指定每个包捕获的长度、单位是 byte，而不是默认的 262144 字节；如果超过了设定的大小限制，包就会被截断，并在打印行出现[|proto]这种标识，这个proto就是被截断的报文的协议名字。但是抓取越长，包的处理时间越长，并且会减少 tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好，<strong><u>一般只抓报头</u></strong> ，抓 80 个字节一般就能包含 TCP 层、IP 层、链路层。</p><p><code>-s 0</code> 使用默认长度 262144。</p><p><strong><mark class="hl-label blue">-e 显示链路层信息</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump  -e</span> </span><br><span class="line">06:49:36.315000 00:0c:29:48:09:a9 (oui Unknown) &gt; 00:50:56:fb:6d:e0 (oui Unknown), ethertype IPv4 (0x0800), length 54: 192.168.248.128.33644 &gt; 180.101.49.186.https: Flags [.], ack 565954419, win 65535, length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">-F 指定过滤过滤表达式文件</mark> </strong></p><p>有些过滤表达式经常用，但又很冗长，每次输入都很麻烦。所以可以保存为文件，每次 tcpdump 时指定该文件为过滤规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump -F filter_file</span></span><br></pre></td></tr></table></figure><p>该命令行中的其他命令会被忽略。</p><hr><p><strong><mark class="hl-label blue">less，greater 指定大小</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tcpdump less 100</span></span><br></pre></td></tr></table></figure><hr><p><strong><mark class="hl-label blue">-X 打印数据内容</mark> </strong><br><code>-X</code> 除了打印每个数据包的头之外，还可以用十六进制和ASCII打印每个数据包的数据（不包括链路级头，<code>-XX</code> 可包含）：<br><img src="/2022/img/image-20230402084531352.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级I/O函数&amp;网络数据读取的常见问题</title>
      <link href="/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/21/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：《UNIX网络编程》《UNIX环境高级编程》《TCP/IP编程》、<a href="http://c.biancheng.net/view/2349.html">socket阻塞模式</a></p></blockquote><h2 id="font-color-red-read-font"><font color='red'>read</font></h2><p><img src="/2022/img/IMG_0576(20230325-120322).PNG" alt=""></p><blockquote><p><code>ssize_t</code> 是有符号整型 long；<code>size_t</code> 是无符号整型 unsigned long</p></blockquote><p>对于 read 和 write 这类 <strong>低速系统调用（即可能使进程永远阻塞下去的系统调用）</strong> ，当执行期间捕捉到信号，则该系统调用就会被中断不再执行，且返回 -1，并将 errno 设置为 -1。为什么呢？有这样一个常见的场景：网络中，由于不知道对端网络具体会发来多大的包，所以我们会让 read 尽可能多地接收数据，即把其第三个参数设置大些。那么问题来了，对端只发送了 1000 字节的数据，而你却指定本端的 read 读取 10000 字节，那怎么办？总不能一直阻塞下去吧？所以此时就需要用到信号，来中断 read 使其结束。</p><blockquote><p>至于 read 在读取数据时是被什么信号中断的，笔者也没有查到相关资料，知晓的读者还请在评论区指点一二。</p></blockquote><p><strong><font color='orange'>需要注意的是，TCP 套接字上的 IO 表现的行为不同于通常的磁盘 IO。</font></strong> <strong><u>磁盘 IO 一般不会被信号打断而终止，因为磁盘 IO 与网络 IO 的区别在于：前者的 IO 量是可以确定的，虽然可能会暂时阻塞调用者，但只要把指定量的数据处理掉就 OK，任务很明确；而网络 IO 一般不知道具体的 IO 量，就像上面的场景一样，所以必须在某个时刻终止 IO（终端 IO 也是如此，计算机不知道用户可能会输入多少数据）。除非发生硬件错误，否则磁盘 IO 总会很快返回</u></strong> 。</p><p>对于被中断的 read，<u>早期实现</u>是：如果 read 已接收部分数据到应用缓冲区，但还未接收到应用程序请求的所有数据（即 read 的第三个参数），则操作系统会认为本次 read 调用失败，返回 -1，errno 被设置为 EINTR 。<strong><font color='orange'>目前的 POSIX 标准采用的方式是：如果 read 只接收了部分数据就被信号中断，那么也算成功，且返回已接收的字节数，errno 不修改</font></strong> 。</p><blockquote><p><strong><font color='gree'>这就是为什么在 Socket 编程中，往往将 read 函数放在循环中的原因！</font></strong> 大多数书籍将其归咎于 Socket 的缓冲机制，实际上这只是原因之一。也有许多人认为 read 只将接收缓冲区读一次就返回，当请求的数据量大于接收缓冲区时，read 返回值就当然会小于请求的字节数，这种说法更不准确。做个实验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> rcv_buf=<span class="number">1000</span>; <span class="comment">//系统会调整接收缓冲区大小,本例中被调整为2304</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(rcv_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,<span class="keyword">sizeof</span>(rcv_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;rcv_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server rcv_buf : %d\n&quot;</span>,rcv_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">int</span> snd_buf =<span class="number">100000</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(snd_buf);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,<span class="keyword">sizeof</span>(snd_buf));</span><br><span class="line">    getsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;snd_buf,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client snd_buf : %d\n&quot;</span>,snd_buf);</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后 server 的结果如下：<br><img src="/2022/img/image-20230324152945053.png" alt=""></p><p>你看，server 的接收缓冲区大小被修改为 2304 字节，但却 read 了 65482 字节，大于 2304，说明不止读取一次缓冲区；小于请求值 100000，说明 read 还没有读完对面发送的 10000 字节就被信号中断。</p></blockquote><p>所以得出一个重要结论：如果 read 返回值小于请求值，说明有两种情况：</p><ol><li><strong>提前收到了 EOF。</strong></li><li><strong>被信号中断。</strong></li></ol><p>第一种情况说明数据已经接收完，第二种情况则还需要重新调用 read 才能将数据接收完毕。我们可以使用自己的包裹函数 readn 一次性将数据读完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* tmp = buf;</span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, tmp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nread == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">//被信号打断,则继续循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        tmp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>不过需要注意，readn 可能会一直阻塞</font>，因为正常情况下它只会在接收到 EOF 或者读满 n 字节才会返回；而 read 不同，read 收到 EOF 、读满 n 字节或者被信号中断（没读满）时就能返回</strong> 。所以当发送的字节数小于请求的字节数时，readn 就会被阻塞，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    writen(sock_clnt,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//while停住,以免关闭套接字发送EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上程序时，服务器不会显示客户端发来的消息，因为 readn 要求读满 1000 或者读到 EOF。当把 readn 改成 read，就能成功显示消息了。解决这个问题的办法之一是设计应用层协议，比如在包头说明本包的大小，这方面内容后续补充。</p><p><strong>recv 的第四个参数可以选 MSG_WAITALL 标志来阻止这种行为，当 flags 为 MSG_WAITALL 时，recv 会阻塞直到所指定的长度 nbytes 字节的数据全部返回，recv 才会返回。</strong></p><h2 id="font-color-red-write-font"><font color='red'>write</font></h2><p><strong>不同于 read，作用于字节流套接字时，输出字节比请求的字节少这种情况仅在非阻塞前提下才会发生</strong> 。</p><p>调用 write 时，如果套接字的发送缓冲区容不下请求量，那么 write 被阻塞，直到缓冲区中的数据被发送到对端，腾出足够的空间，才唤醒 write 函数继续写入数据。有以下几个要点需要注意：</p><ol><li><strong>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</strong></li><li><strong>发送缓冲区中的数据必须保留，直到对端回复相应的 ACK（这是由内核自动完成的）。</strong></li><li><strong>接收缓冲区的数据将一直保留，直到应用层读取（read）。</strong></li><li><strong>write 函数的返回只说明应用层的数据已经全部转移到输出缓冲区，这不代表对方已经收到所有数据。</strong></li></ol><p>让我们做几个实验来验证上面的结论。</p><p><strong><mark class="hl-label blue">实验一</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">100000</span>; <span class="comment">//设置接收缓冲区,系统会调节该值,可能为200000</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>];</span><br><span class="line">    <span class="type">ssize_t</span> size = readn(sock_clnt, buf, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received %lu bytes\n&quot;</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf_size = <span class="number">1000</span>; <span class="comment">//系统会调节该值,可能为3000左右</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">    setsockopt(sock_clnt,SOL_SOCKET,SO_SNDBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> size = write(sock_clnt,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,size);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，<strong>立刻</strong> 输出结果，client 发送 100000 字节，server 接收 100000 字节。这说明即使我们将 client 的发送缓冲区设置为 1000，数据也会分批发送。结论一得证。</p><p><strong><mark class="hl-label blue">实验二</mark> </strong></p><p>将上面代码 server 的接收缓冲区改为 1000，运行程序，<strong>等待几秒后</strong> 输出结果，两方仍是 100000 字节。这说明接收缓存区虽小，但由于应用层一直在读取数据（readn），所以接收缓冲区可以不断地丢弃旧数据、接收新数据，直到收到所有数据。</p><p>继续，修改 14~22 行代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf_size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(buf_size);</span><br><span class="line">setsockopt(sock_clnt,SOL_SOCKET,SO_RCVBUF,(<span class="type">void</span>*)&amp;buf_size,len);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//循环,不close套接字</span></span><br></pre></td></tr></table></figure><p>即，不从接收缓冲区读取数据，同时不 close 套接字。close 套接字可能导致缓冲区的一系列动作，不利于我们进行实验。</p><p>运行程序，<strong>两端都陷入阻塞</strong> 。这说明由于接收缓冲区没有被 read，数据一直积压，因此无法接收 client 发来的数据，也就不能回复 ACK；而 client 因为没有收到 server 回复的 ACK ，所以发送缓冲区不能接收应用层的新数据，以至于在 write 中阻塞。结论 2、3 得证。</p><p><strong><mark class="hl-label blue">实验三</mark> </strong></p><p>在实验二的基础上，把 client 的发送缓冲区改为 100000 字节，运行程序。client 立刻输出 <code>100000</code> 。表明 client 成功向发送缓冲区写入 100000 字节，并立刻从 write 返回。但 server 的接收缓冲区只有 1000 字节的大小，不可能接收完这 100000 字节。因此，结论 4 得证。</p><hr><hr><h2 id="font-color-red-sendfile-font"><font color='red'>sendfile</font></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半连接与全连接队列</title>
      <link href="/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考：《UNIX网络编程》、<a href="https://blog.csdn.net/qq_42877870/article/details/105027743">hping3命令使用</a>、<a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA">小林网络</a>、<a href="https://www.51cto.com/article/687595.html">51CTO</a></p></blockquote><p><strong>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</strong> 。前者又称半连接队列、SYN队列，后者又称全连接队列、accept 队列。</p><p>半连接队列：服务器收到客户端发来的 SYN 报文后，将该连接存入此队列中。这些连接处于 SYN_RCVD 状态。<br>全连接队列：服务端收到第三次握手的 ACK 后，该连接被内核从半连接队列转移到全连接队列，此时已经完成三次握手，处于  ESTABLISHED 状态。当调用 accept 函数时，该连接将从全连接队列中移除。</p><hr><p><strong><mark class="hl-label blue">backlog</mark> </strong></p><p><strong>“backlog的含义从未有过正式的定义”，不同的 UNIX 操作系统对其有不同的实现</strong> 。这里只以笔者的环境 Ubuntu 16.04 进行说明。</p><blockquote><p>其他版本的相关说明请参见《UNP》第 3 版 84 页。</p></blockquote><p><strong>先说结论：</strong></p><p><strong><font color='orange'>在 Linux 内核 2.2 之后，<code>backlog</code> 参数影响全连接队列的长度， <code>tcp_max_syn_backlog</code> 作为系统变量则影响半连接队列的长度</font></strong> 。</p><blockquote><p>为什么说“影响”而不是“决定”？因为两个队列长度的具体定义是采用的如下方式：</p><ul><li><strong><code>全连接队列长度 = min(somaxconn, backlog)+1</code></strong></li><li>半连接队列的长度计算较为复杂，且不同版本的操作系统实现不一样，故没有必要掌握其计算方法。<strong><font color='orange'>只需要知道，半连接队列长度可能同时取决于 <code>backlog</code> 、<code>somaxconn</code> 和 <code>tcp_max_syn_backlog</code> ，这三者越大，则半连接队列容量越大</font></strong> 。</li></ul><p><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值。</p></blockquote><p><strong>下面就全连接队列进行 <code>backlog</code> 的实验。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_lsn.sin_family = AF_INET;</span><br><span class="line">    Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line">    Listen(sock_lsn, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//注意,没有accept和close</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">    addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addr_clnt.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个客户进程并发送连接请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">            sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">            close(sock_clnt);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行以上代码，结果如下：<br><img src="/2022/img/image-20230319223902516.png" alt=""></p><p><strong><code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可</strong> 。可以看到，10 条连接中，只有 6 条是 ESTABLISHED 状态，剩下 4 条是 SYN_SENT 。很奇怪，我们指定的 <code>backlog</code> 是 5，所以不应该只有 5 条是 ESTABLISHED 状态吗？嗯，这里挺坑的，<u><strong>这是因为大多数操作系统的实现都为 <code>backlog</code> 引入了 <font color='orange'>模糊因子</font></strong></u> ，我们这里的模糊因子就是 +1，也就是说，<code>实际全连接队列容量 = backlog + 1</code> 。其他操作系统的模糊因子参考：<br><img src="/2022/img/IMG_0575(20230319-224643).PNG" alt=""></p><blockquote><p>关于更多模糊因子的描述，参见《UNP》85~87 页。</p></blockquote><p>接着我们查看 <code>somaxconn</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /prog/sys/net/core/somaxconn</span><br><span class="line">128</span><br></pre></td></tr></table></figure><p>将其修改为 3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//必须在管理员权限下才能修改</span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /prog/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p>然后再运行服务器和客户端，得到以下结果：<br><img src="/2022/img/image-20230321093637098.png" alt=""><br>可见，有 4 条连接处于已建立状态，比我们指定的 <code>somaxconn</code> 还要多 1 。</p><p><strong><font color='orange'>综上，我们得出结论：全连接队列长度 = min(somaxconn, backlog) + 1</font></strong></p><p><strong><mark class="hl-label blue">当全连接队列满了怎么办</mark> </strong><br>默认行为是直接丢弃，我们也可通过指定 <code>tcp_abort_on_overflow</code> 参数来调整其行为：</p><ul><li>0 ：直接忽略客户端发过来的 ACK ；</li><li>1 ：回复 RST 给客户端，表示终止本次连接；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /prog/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>一般情况下默认为 0 即可，这是更合理的方式，因为全连接队列已满的状态只是暂时的，客户端会因迟迟未收到 ACK 重发报文，期待不久就能等到全连接队列腾出可用空间。</p><hr><p><strong>半连接队列的长度受多方面影响，且不同操作系统版本的实现方式各不相同</strong> ，所以无需掌握具体计算方式。这里笔者简单演示如何间接查看半连接队列的长度。</p><p>半连接队列中的状态为 SYN_RCV ，所以我们可以发起 SYN 泛洪，向端口发送大量虚假的 SYN 报文，然后查看该端口上最多时有多少个连接处于 SYN_RCV 状态，此时就是半连接队列的最大长度。</p><ol><li><p>下载 hping3 ，用来发起 SYN-flood 攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install hping3</span><br></pre></td></tr></table></figure></li><li><p>修改系统配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_max_syn_backlog = 128</span><br><span class="line">somaxconn = 150</span><br></pre></td></tr></table></figure><p>笔者将 backlog 设置为 9（那么全连接队列的容量就为 10），读者随意。</p></li><li><p>运行服务器端</p></li><li><p>发起攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 1000 -d 120 -S -w 64 -p 12345 --flood --rand-source 127.0.0.1</span><br><span class="line">//-c 1000  = 发送的数据包的数量</span><br><span class="line">//-d 120   = 发送到目标机器的每个数据包的大小,单位是字节</span><br><span class="line">//-S       = 只发送 SYN 数据包</span><br><span class="line">//-w 64    = TCP 窗口大小</span><br><span class="line">//-p 12345 = 目的地端口为12345</span><br><span class="line">//–flood   = flood攻击模式</span><br><span class="line">//--rand-source 源IP随机</span><br><span class="line">//目标IP为主机127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>查看 SYN_RECV 的个数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>可见，半连接队列长度等于 backlog</strong></p></li><li><p>再将 backlog 设置为 200，重复以上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep :12345 | grep SYN_RECV  | <span class="built_in">wc</span> -l </span><br><span class="line">150</span><br></pre></td></tr></table></figure><p><strong>可见，在笔者环境下（Ubuntu 16.04） ，<font color='orange'>如果 backlog 小于 <code>somaxconn</code> ，则半连接队列容量为 backlog，反之则为 <code>somaxconn</code> ，与 <code>tcp_max_syn_backlog</code> 无关。</font></strong></p></li></ol><p>综上， <strong><font color='orange'>半连接队列容量<u>可能</u>同时受 <code>tcp_max_syn_backlog</code> 、<code>somaxconn</code> 和 <code>backlog</code> 的影响，想要增大半连接队列的长度，就需要同时增大这三个参数，仅增大 <code>tcp_max_syn_backlog</code>  是无效的</font></strong> 。</p><p>对于半连接队列，更多的是需要掌握它与 SYN 泛洪的关系。关于 SYN 泛洪，详细可参见博主另一篇文章-<a href="https://jyx-fyh.github.io/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">SYN泛洪攻击</a></p><hr><p>另外，还可以从 <code>ss</code> 命令直接观察全连接队列的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*       </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59492              </span><br><span class="line">ESTAB       100     0             127.0.0.1:12345       127.0.0.1:59496              </span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>-n 不解析服务名称<br>-t 只显示 tcp sockets<br>-l 显示正在监听(LISTEN)的 sockets</p></blockquote><p><strong>对于 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：当前全连接队列的中的连接个数，即已完成三次握手等待应用程序 accept 的 TCP 连接</strong></li><li><strong>Send-Q：全连接队列的容量</strong></li></ul><p><strong>对于非 LISTEN 状态的 socket</strong></p><ul><li><strong>Recv-Q：已收到 <u><font color='gree'>但未被应用程序读取</font></u> 的字节数</strong></li><li><strong>Send-Q：已发送 <u><font color='gree'>但未收到确认</font></u> 的字节数</strong></li></ul><p>注意上面的输出，LISTEN 状态下的 Recv-Q ，即全连接队列中的连接个数为 11；但 Send-Q，即全连接的最大长度才为 10，这是怎么回事？这可能是因为 Send-Q 没有包含模糊因子，直接等同于 backlog 。</p><p><strong><font color='orange'>另外注意，<code>ss</code> 命令和 <code>netstat</code> 命令对 LISTEN 状态输出的 Recv-Q 和 Send-Q 的含义不相同</font></strong> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -at</span><br><span class="line">Proto    Recv-Q     Send-Q   Local Address           Foreign Address         State </span><br><span class="line">tcp      0          0        *:12345                 *:*                     LISTEN</span><br><span class="line">$ ss -nlt</span><br><span class="line">State       Recv-Q  Send-Q        Local Address:Port    Peer Address:Port</span><br><span class="line">LISTEN      11      10            *:12345               *:*  </span><br></pre></td></tr></table></figure><p>这两条命令是在同一次网络请求下进行的，但两者的 Recv-Q 和 Send-Q 却不相同。个人猜测 <code>netstat</code> 下的 Recv-Q 和 Send-Q 就是单纯的收发字节数，不再表示连接个数或队列长度。</p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误处理与包裹函数</title>
      <link href="/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/"/>
      <url>/2023/03/18/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E5%8C%85%E8%A3%B9%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考书籍：《UNIX网络编程》《UNIX环境高级编程》</p></blockquote><h2 id="font-color-red-errno-font"><font color='red'>errno</font></h2><p>只要在一个 <strong><u>系统调用</u></strong> 中有错误发生，<strong>全局变量 errno</strong> 就会被自动设置为一个特定的正值，用来反馈具体错误，而函数本身则会返回 -1，以说明函数发生了错误；如果函数返回正值，即没有错误发生，则 errno 没有定义。errno 包含在 <code>errno.h</code> 中。</p><ul><li><p>如果函数没有出错，则之前的 errno 可能不会被清除（未定义）；只有发生错误时，才会覆盖之前的错误。</p></li><li><p>errno 不会为 0，这与多线程的 errno 处理有关。</p><blockquote><p><strong>这是因为：线程函数（以 pthread_ 开头的函数）遇到错误时不会设置标准 Unix 的 errno 变量，而是将 errno 的值以函数返回值的形式交给调用者。也就是说，返回值大于 0 则说明发生了错误，那没有发生错误呢？自然也就是返回 0 了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(&amp;ndoen_mutex))!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这意味着我们每次调用 pthread_ 函数时，都要事先分配一个整形来保存错误值，这很麻烦，所以我们可以把错误处理和 pthread_ 函数包裹起来以简化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n=pthread_mutex_lock(mptr))!=<span class="number">0</span>)</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error:%s&quot;</span>,strerror(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong><font color='red'>虽然 errno 是一个全局变量，但是在多线程环境中，每个线程都会有自己独立的 errno 副本，这是通过线程本地存储（Thread-Local Storage，TLS）实现的，因此一般不用担心多线程会相互竞争 errno，可参见《APUE》P358</font></strong><br><img src="../../public/2022/img/image-20230410230004254.png" alt=""></p></li><li><p><strong>虽然在多线程下不用担心 errno 的竞争问题，不过单线程下 errno 仍可能出现问题，比如在信号处理函数中被修改</strong> 。当发生信号时，执行流会跳转到信号处理函数，这感觉就像是多线程，但实际上它和之前的执行流位于同一个上下文，也就是说信号处理函数并不是新开的线程。因此，如果之前的执行流在系统调用出错后修改 errno，接着被信号中断，进入了信号处理函数，而信号处理函数中也调用了某些系统函数如 write，如果此时这个系统调用出错，那么 errno 就会被修改，<strong>这就使得之前的 errno 被覆盖！</strong> 因此，<strong><font color='orange'>作为一个通用的规则：</font></strong> 在信号处理函数中，应首先保存 errno，退出时再恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alarm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> errno_cpy = errno;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">    write(....);</span><br><span class="line">    errno = errno_cpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="font-color-red-perror、strerror-font"><font color='red'>perror、strerror</font></h2><p>C 库函数 <strong>void perror(const char *str)</strong> 把一个描述性错误消息输出到标准错误 stderr，其中 str 是自定义内容。该函数先输出 str，再输出错误描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"><span class="comment">//连接错误则输出以下结果：</span></span><br><span class="line">connect: Connection refused</span><br></pre></td></tr></table></figure><p>C 库函数 <strong>char *strerror(int errnum)</strong> 从内部数组中搜索错误号 <strong>errnum</strong>，并返回一个指向错误消息字符串的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == connect(fd, addr, len))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str = strerror(errno);</span><br><span class="line">    <span class="built_in">fputs</span>(str, <span class="built_in">stderr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-包裹函数-font"><font color='red'>包裹函数</font></h2><p>网络编程很多时候都会遇到一些网络问题，并通过函数返回值或 errno 反馈错误，因此绝不能忽略对错误的处理。包裹函数一般用来处理致命性错误，此时能干的也就只有打印错误然后退出，对于非致命性错误，比如 EINTR 错误，就需要我们自己来处理失败情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sock_conn=accept(sock_listen,<span class="literal">NULL</span>,<span class="literal">NULL</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要自己重启被中断的系统调用。关于中断的系统调用，参见《APUE》第 260 页。</p><p>一些包裹函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bind(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (connect(fd, sa, salen) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他包裹函数可参考<a href="https://github.com/jyx-fyh/unp-source-code/blob/master/lib/wrapsock.c">UNP-sockwarp.c</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TIME_WAIT与SO_REUSEADDR</title>
      <link href="/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>运行环境：Ubuntu 16.0.4</p></blockquote><ul><li><p>无论是否开启 SO_REUSEADDR ，客户端主动断开连接后，无需等待 TIME_WAIT 即可重连，因为客户端每次 bind 的端口都不一样。由此可见， <strong>TIME_WAIT 是对端口而言</strong> 。</p><blockquote><p>不管是服务器还是客户端，只要是主动断开连接的，都会有 TIME_WAIT 。</p></blockquote></li><li><p>如不开启 SO_REUSEADDR，服务器端主动断开连接，则必须等待 TIME_WAIT 后才可重新 bind 该端口，原因见下文。</p></li><li><p><strong><font color='red'>注意，必须是要在 accept 或 connect 成功返回后（即连接成功后）断连或终止程序，才会有 TIME_WAIT ；仅仅 bind 但未连接成功，终止程序后是不会 TIME_WAIT 的</font></strong> 。</p></li><li><p><strong><font color='red'>注意，如果 bind 指定端口不成功，则会自动 bind 其他任意端口；</font></strong></p></li><li><p><code>SO_REUSEADDR</code> 生效的前提条件是开启时间戳，即令 <code>/proc/sys/net/ipv4/tcp_timestamps</code> 为 1（默认也为1）。</p><blockquote><p>实操发现即使关闭时间戳，服务器也能立刻重新绑定端口，原因尚不明确。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>; <span class="comment">//SO_REUSEADDR默认也是0</span></span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR, &amp;opt, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server failed to bind\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> != (sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>)))&#123;</span><br><span class="line">        <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">        size = write(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server sent %ld bytes\n=====================&quot;</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(3);  //stop 3s so that client could send FIN first</span></span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> in_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">99</span>;i++)</span><br><span class="line">        out_buf[i]=<span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="keyword">sizeof</span>(out_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    size = read(sock_clnt, in_buf, <span class="keyword">sizeof</span>(in_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">//stop 3s so that server could send FIN first</span></span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编译上述代码，先运行 server 端，再运行 client 端（注意，最好运行可执行文件，不要直接在编译器中运行），结果如下：<br><img src="/2022/img/image-20230316190258629.png" alt="server"><br><img src="/2022/img/image-20230316190325197.png" alt="client"><br>由于客户端 close 前调用了 sleep，所以可以判断一定是 server 主动断开连接，如下图：<br><img src="/2022/img/image-20230316190534357.png" alt=""><br><code>localhost:12345</code> 是本端地址信息，<code>localhost:53188</code> 是对端地址信息，后面的状态是描述本端状态的，因此可知 server 主动发送 FIN 并断开连接后，进入了 TIME_WAIT 状态。此时我们马上重启服务器，则输出以下内容：<br><img src="/2022/img/image-20230316191622035.png" alt=""><br>在 TIME_WAIT 内重启服务器，则报错绑定失败。注意，绑定指定端口失败后，会随机绑定其他端口，如下：<br><img src="/2022/img/image-20230316191842098.png" alt=""><br>第三行的 <code>46937</code> 便是服务器端随机绑定的端口。不过这已经失去意义，因为服务器是通过知名端口来被客户端认识的，客户端根本不认识这些随机端口，所以 server 会一直处于监听状态，不会有 client 来连接。因此，对于服务端，如果 bind 失败，应该直接终止程序或等待 TIME_WAIT 后重新 bind。</p><p>下面我们让 client 主动关闭连接——加上 server 的 sleep ，去掉 client 的 sleep 即可。结果如下：<br><img src="/2022/img/image-20230316193318143.png" alt="server"><br><img src="/2022/img/image-20230316193335972.png" alt="client"><br><img src="/2022/img/image-20230316193425965.png" alt=""><br>本端为 <code>localhost:53200</code> ，可见确实是 client 发起的 FIN 。因为 client 无需 bind 特定端口，即 client 每次运行绑定的端口都不同，所以不用担心会因为 TIME_WAIT 而连接失败。</p><p>接下来我们使用 SO_REUSEADDR 选项来修改 TIME_WAIT 的限制——将 server 代码第 7 行的 opt 赋值为 1 即可，这样就可以无视 TIME_WAIT 直接复用端口。下面是连续两次运行 server 和 client 的结果：<br><img src="/2022/img/image-20230316204302114.png" alt=""><br><img src="/2022/img/image-20230316204349584.png" alt="">你看，即使服务器处于处于 TIME_WAIT 状态，还是可以直接绑定端口并进行通信。</p><p><strong><font color='red'>注意，即使将 SO_REUSEADDR 置 1，TIME_WAIT 状态也依旧存在，只是可以无视该状态直接 bind 而已。</font></strong></p><p>待补充</p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1-time-wait-%E7%8A%B6%E6%80%81">https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html#为什么要设计-time-wait-状态</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#先说结论</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket网络编程重点</title>
      <link href="/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li><li>本文只记录重点内容和个人理解，系统学习请移步《UNIX网络编程》</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>监听</font>套接字</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='red'>监听套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong><font color='red'>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</font></strong> 。<strong>监听套接字和已连接套接字有本质区别。</strong></p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><h3 id="font-color-red-socket-font"><font color='red'>socket</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>该函数返回主动套接字，经过 listen 函数转换后才会成为监听套接字。</li><li><strong>protocol 敲定最终协议</strong> 。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；</li></ul><h3 id="font-color-red-bind-font"><font color='red'>bind</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png" alt=""></p><ul><li><p>该函数将 addr 地址结构所包含的信息绑定到 sockfd 套接字上，相当于为套接字办理身份证。</p></li><li><p><strong>bind 可以手动指定 IP 地址或端口，可以两者都指定，也能两者都不指定，如果不手动指定，则按以下方式处理：</strong></p>  <img src="/2022/img/image-20230308162549530.png" style="zoom:80%;" /><p><strong><font color='red'>对于 IPv4，通配地址为宏 INADDR_ANY；对于 IPv6，为 in6addr_any</font></strong> ：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servSock.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//INADDR_ANY一般为0,可以不用htonl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果绑定 INADDR_ANY，此时服务器在自己的所有 IP 上（如果是多宿）监听，等到客户发来的 SYN 报文时，再绑定到该报文指定的对端 IP</strong> 。</p></li><li><p><strong><u>注意，对于 TCP 而言，如果不手动指定端口，<font color='orange'>则在调用 listen (server) 或 connect (client) 时</font>，内核会选择一个临时端口</u></strong> 。对于客户端，我们一般让内核来绑定套接字的端口（除非需要预留端口）；<strong><u><font color='orange'>对于服务器端，很少让内核自行决定端口，因为服务器是通过它们的总所周知端口而被外界认识的</font></u></strong> 。</p></li><li><p><strong><u>对于 TCP 客户端，由内核绑定 IP 地址；对于 TCP 服务器端，如果没有手动绑定，则内核就把客户发送的 SYN 报文中的目的IP地址作为绑定的 IP 地址。</u></strong></p></li><li><p><strong><font color='red'>不论是服务器还是客户端，如果绑定指定端口失败，则随机分配一个端口</font></strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p><strong>如果服务器的某个端口刚断开连接，处于 TIME_WAIT 状态，则默认情况下不能立即再次绑定该端口，否则返回 EADDRINUSE 错误</strong> ，参见<a href="https://jyx-fyh.github.io/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/">TIME_WAIT 与 SO_REUSEADDR</a> 。</p></li><li><p>注意 bind 与 accept 中后两个参数类型的差异，前者是值类型，后者是值-结果类型（调用函数后，参数会被改变，即作为返回值）。</p></li></ul><h3 id="font-color-red-listen-font"><font color='red'>listen</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li><strong>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</strong></li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同；<strong><u>内核为<font color='orange'>每个监听套接字</font>维护两个队列：未完成连接队列和已完成连接队列</u></strong> 。关于这两点，详见<a href="https://jyx-fyh.github.io/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/">socket等待队列</a> 。</li></ul><h3 id="font-color-red-accept-font"><font color='red'>accept</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li><p>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度 addrLen；注意，addrLen 是输入-输出参数，传参前需要将 clntAddr 的大小赋给 addrLen。<strong><font color='orange'>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</font></strong> 。</p><blockquote><p>严格来说，对端套接字可能是 IPv4，也可能是 IPv6，为了能够容纳这两者，clntAddr 最好为通用套接字结构体 <code>sockaddr_storage</code>  。</p></blockquote></li><li><p><strong><font color='red'>accept 从已完成队列中取出一个连接；仅仅只是取出一个完成了三次握手的连接，并返回绑定此连接的套接字</font></strong> 。</p></li><li><p><strong><font color='orange'>上面这句话说明了一个很重要的事实：accept 与三次握手无关！三次握手是底层网络协议栈自动完成的（当然，第一次握手是 connect 发起的）！换句话说，即使没有 accept 也能完成三次握手！</font></strong></p><blockquote><p>做个实验便知：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//======!!!代码中的Bind、Listen等函数是博主自己包装的,读者可以直接改成小写的形式!!!=======</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> sock_lsn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_lsn</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_lsn, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> addr_lsn.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> addr_lsn.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_lsn.sin_family = AF_INET;</span><br><span class="line"> Bind(sock_lsn, (<span class="keyword">struct</span> sockaddr*)&amp;addr_lsn, <span class="keyword">sizeof</span>(addr_lsn));</span><br><span class="line"> Listen(sock_lsn, <span class="number">20</span>);</span><br><span class="line"> <span class="comment">//注意,没有accept和close</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_clnt</span>;</span></span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr_clnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line"> addr_clnt.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"> addr_clnt.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"> addr_clnt.sin_family = AF_INET;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//创建10个进程并发送连接</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == fork())</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">         Connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;addr_clnt, <span class="keyword">sizeof</span>(addr_clnt));</span><br><span class="line">         sleep(<span class="number">10</span>);<span class="comment">//暂停10s,以便我们观察连接状态</span></span><br><span class="line">         close(sock_clnt);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行，结果如下：</p><p><img src="/2022/img/image-20230319221140308.png" alt=""><br>因为是在同一主机上运行 server 和 client，<code>netstat</code> 分别以客户端和用户端为角度输出了结果，所以有 20 个条目，实际上是 10 条连接，我们只需要看一个纵列的红色条目即可。显然，即使服务器端没有调用 accept，两端仍然建立了连接。<strong><font color='orange'>这再次说明，accept 只是从全连接队列中取出一个四元组，并绑定到一个新的套接字描述符而已</font></strong> 。<br>——<strong>四元组：即本端 IP、本端端口、对端 IP、对端端口，用来唯一确定一个 TCP 连接</strong> 。</p></blockquote></li></ul><h3 id="font-color-red-connect-font"><font color='red'>connect</font></h3><ul><li><p>connect 函数仅在客户端使用，调用此函数时，内核会为客户端绑定套接字，端口随机，这个过程相当于 bind。</p></li><li><p>connect 会激发三次握手，只在连接成功或出错时返回。出错有以下三种情况：</p><ol><li><p>客户端迟迟未收到对 SYN 报文的 ACK，此时返回 ETIMEDOUT 错误。</p><blockquote><p>“迟迟”是多久？SYN 重传次数由 <code>tcp_syn_retries</code> 控制。<u><strong>通常</strong></u> ，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后。即，每次超时的时间是上一次的 2 倍。</p></blockquote></li><li><p>对 SYN 报文的回复是 RST，表明服务端在我们指定的端口上没有套接字处于监听状态，返回 ECONNREFUSED 错误。</p></li><li><p>SYN 报文在某个中间路由器上引发了“目的地不可达”的 ICMP 错误，重复发送几次 SYN 后，如果在规定时间内仍无响应，则返回错误。</p></li></ol></li><li><p><strong><font color='red'>如果 connect 失败，则该套接字不能再重新调用 connect，只能生成新的套接字再 connect 。</font></strong></p><blockquote><p>为什么不能对其重调用 connect 呢？其实如果联想到上文中的 TIME_WAIT ，那么这个问题就有思路了。考虑这样一种情况：当发送 SYN 后，由于网络拥堵，在 MSL(报文最大生存时间) 的前一刻到达了服务器，然后服务器发送 ACK 报文，然后 ACK 也在 MSL 前到达客户端；但是，将近 2MSL 已经挺久了，客户端没有等到这么久就返回 connect 错误，同时重新在该套接字上发起 connect 并发送新的 SYN；问题来了，此时上一个 ACK 刚好到达客户端！换句话说，第二次发送的 SYN 得到的回复是第一次的 ACK，这可能导致某些错误。<br>以上只是本人的猜想，仅作为一种思路。</p></blockquote></li></ul><h3 id="font-color-red-close-font"><font color='red'>close</font></h3><ul><li>调用 close 后，<strong><font color='orange'>该套接字（文件描述符）的引用计数减 1</font></strong> ，<strong>如果引用计数仍大于 0，则不会给对端发送 FIN 报文，等于 0 才会引发挥手</strong> 。这一点在多进程网络编程中有重要作用。</li><li><strong>close 函数的默认操作是立刻关闭套接字并返回，但如果发送缓冲区中还有数据残留，则内核会将这些数据继续发送给对端。close 的行为可以由 <code>SO_LINGER</code> 控制。</strong> 关于 <code>SO_LINGER</code> ，参见<a href="https://jyx-fyh.github.io/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/">SOCKET常见选项</a></li><li>对于主动关闭端而言，发送 FIN 并收到对方回复的 ACK 报文后进入 <code>FIN_WAIT2</code> 状态，<strong><font color='orange'>如果主动关闭端是通过 close() 函数关闭连接的，则 <code>FIN_WAIT2</code> 状态只会持续 <code>tcp_fin_timeout</code> 指定的秒数（默认 60s）；如果是通过 shutdown() 关闭连接的，则 <code>FIN_WAIT2</code>  可以一直保持。</font></strong></li></ul><h3 id="font-color-red-shutdown-font"><font color='red'>shutdown</font></h3><ul><li>close 同时终止读与写两个方向的数据传送，而 shutdown 用来指定关闭一个方向的数据传送。</li><li><strong><font color='orange'>使用 shutdown 关闭读后，缓冲区的所有数据都被丢弃，而且后续收到的数据会<u>先被确认</u>然后悄然丢弃，不会返回 RST。</font></strong></li><li><strong><font color='orange'>shutdown 的 SHUT_WR 不管套接字的引用计数是否为 0，直接发起挥手。</font></strong></li></ul><p><img src="/2022/img/IMG_0580(20230407-134909)-1681295358001-1.png" alt=""></p><h3 id="font-color-red-地址转换函数-font"><font color='red'>地址转换函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">    若字符串有效,则返回二进制值,无效则返回<span class="title function_">INADDR_NONE</span><span class="params">(其值为<span class="number">-1</span>)</span></span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值。32 位说明它只能用于 IPv4 地址转换。该函数不能处理 <code>255.255.255.255</code> ，详细原因参见《UNP》P67；另外，此函数已经被废弃，最好不再使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="keyword">struct</span> in_addr *addr)</span></span><br><span class="line">    若字符串有效,则返回1,否则返回0</span><br></pre></td></tr></table></figure><p>本函数将字符串 str 转换为 32 位的网络字节序二进制值并保存在 addr 结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span> <span class="params">(<span class="keyword">struct</span> in_addr addr)</span></span><br></pre></td></tr></table></figure><p>将 32 位的网络字节序二进制值转换为点分十进制字符串。<strong><font color='orange'>注意，<u>inet_ntoa() 是不可重入的</u>，该函数返回的字符串是储存在静态内存中的，第二次调用该函数时将覆盖之前的结果。因此，当我们通过该函数的返回值取得字符串后必须马上转移到其他地方储存。</font></strong><br><img src="/2022/img/image-20230415204033411.png" alt=""></p><blockquote><p>关于重入问题，参见<a href="https://jyx-fyh.github.io/2023/04/15/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5/">什么是不可重入</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> * str, <span class="type">void</span> * addr)</span></span><br><span class="line">    成功则返回1,若str不是有效表达式则返回0,失败则-1</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，因此第三个参数为 void*，因为实参既可以为 in_addr 也可以为 in6_addr 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntop</span> <span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> * addr, <span class="type">char</span> * str, <span class="type">socklen_t</span> len)</span></span><br><span class="line">    成功则返回字符串指针,否则返回<span class="literal">NULL</span>,并置errno为ENOSPC</span><br></pre></td></tr></table></figure><p>该函数同时适用于 IPv4 和 IPv6，将网络字节序二进制值转换为点分十进制字符串。其中 str 不能为 NULL，其必须为 str 分配空间并指定大小。这个大小可使用 <code>&lt;netinet/in.h&gt;</code> 中的宏指定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure><p><strong>第二个参数 addr 的结构体类型为 <code>in_addr</code> 或 <code>in6_addr</code></strong> ，后面有例子。</p><blockquote><p>另外，<code>inet_pton</code> 和 <code>inet_ntop</code> 总是可重入的，应尽量使用 <code>inet_ntop</code> 来代替 <code>inet_ntoa</code></p></blockquote><h3 id="font-color-red-getsockname与getpeername-font"><font color='red'>getsockname与getpeername</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *local_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *peer_addr, <span class="type">socklen_t</span> *len)</span></span><br><span class="line">    成功返回0,否则-1</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>参数 len 是值-参数类型（既做参数，也储存返回值），作为返回值时，传递实际地址结构体的大小</font></strong> 。什么是实际地址结构体？是这样的：当你 getpeername 时，你不知道对面是 IPv4 还是 IPv6，如果此时你将 <code>sockaddr_in</code> 类型（IPv4）的结构体作为第二个参数，len 为 <code>sockaddr_in</code> 的长度，那么问题来了——万一对方是 IPv6 ，那这个 <code>sockaddr_in</code> 就无法完全存储 <code>sockaddr_in6</code> ，一部分会被截断。同时，len 被修改为 <code>sockaddr_in6</code> 的大小。如何解决这个问题呢？很简单，<strong><font color='orange'>使用通用结构 <code>sockaddr_storage</code> 来储存实际地址结构体，它能够承载任何套接字地址结构，因此不会被截断</font></strong> 。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">saddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>* <span class="title">pinaddr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span>* <span class="title">pin6addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"><span class="type">int</span> ret = getpeername(sock, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;getpeername err\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET)</span><br><span class="line">&#123;</span><br><span class="line">    pinaddr = (<span class="keyword">struct</span> sockaddr_in*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv4:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pinaddr-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%u\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(saddr.ss_family == AF_INET6)</span><br><span class="line">&#123;</span><br><span class="line">    pin6addr = (<span class="keyword">struct</span> sockaddr_in6*)&amp;saddr;</span><br><span class="line">    <span class="type">char</span> str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv6:%s\n&quot;</span>, inet_ntop(AF_INET,&amp;pin6addr-&gt;sin6_addr, str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%ud\n&quot;</span>, ntohs(pinaddr-&gt;sin_port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下理由需要这两个函数：</p><ul><li>客户端一般不调用 bind，端口和地址都在 connect 时由内核分配，所以需要通过 getsockname 获得本端信息。</li><li>服务器端经常绑定通配地址 <code>INADDR_ANY</code> ，所以需要使用 getsockname 来确定本端绑定的地址。<strong><font color='orange'>注意，上文说过，当绑定通配地址时，监听套接字的最终绑定结果是在收到对端发来 SYN 报文后才确定的，所以此时 getsockname 的作用对象只能是已连接套接字，而不能是监听套接字。</font></strong></li><li><strong><font color='orange'>如果一个服务器程序是由执行过 accept 的某个进程调用 exec 而得到，那么这个服务器程序只能通过 getpeername 来获取对端信息</font></strong> 。inetd 派生 Telnet 服务器就是这样的情况：<br><img src="/2022/img/IMG_0585(20230415-212627).PNG" alt=""></li></ul><h3 id="font-color-red-字节序转换函数-font"><font color='red'>字节序转换函数</font></h3><p>为了避免在不同字节序主机之间传送数据时发生数据解释错乱，网络传输统一使用大端字节序，即高位数据在低字节，低位数据在高字节。因此，传送数据前我们必须使用以下函数对数据转换字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span> <span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line">    net to host,将网络字节序转为主机字节序</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span> <span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line">    host to net,将主机字节序转为网络字节序</span><br></pre></td></tr></table></figure><p>应该有初学者会疑惑，似乎这几个函数只在绑定端口和 IP 时才使用，其他时候几乎没有用，这是为什么？难道传输数据时，网络栈会自动将我们的数据转换为网络序？这个问题也困惑了我好些时候，详细请移步<a href="">网络字节序及其注意事项</a>。</p><h3 id="font-color-red-其他问题-font"><font color='red'>其他问题</font></h3><p><strong><mark class="hl-label blue">bind为什么将 sockaddr_in* 转换为 sockaddr*</mark> </strong></p><p><strong><font color='orange'>为了实现“多态”，即，使用 bind 函数处理多种协议类型。</font></strong></p><p><code>sockaddr_in</code> 是 IPv4 套接字地址结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族，一般为AF_INET</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">// 端口号，网络字节序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4地址，网络字节序</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];        <span class="comment">// 未使用，填充0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大小为16字节</span></span><br></pre></td></tr></table></figure><p><code>sockaddr</code> 是通用套接字地址结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;    <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];         <span class="comment">// 具体地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大小为16字节</span></span><br></pre></td></tr></table></figure><p>实现多态的关键在于 <code>sa_family</code> 成员。所有类型的套接字结构体都保证 <code>sa_family</code> 成员在最前面，这样即使转换后也能正确地获取地址族类型。同时，bind 的第三个参数 len 也很重要，<strong><u>系统调用将第二个参数 sockaddr* 指针指向的 len 大小的数据传入内核空间</u></strong> 。这样，内核有了正确的地址族类型和完整的地址信息，就可以针对各种不同协议类型进行套接字绑定。</p><p>你可能和我一样，认为 len 参数有些鸡肋，因为内核完全可以根据 sa_family 确定地址族，而地址族一确定，相应的套接字地址结构体大小就能确定，比如 sa_family 若为 AF_INET，那么就能判断传入的结构体一定是 sockaddr_in 。那为什么还有专门传入 len 呢？实际上，我们设想的前提就有错，<strong><font color='orange'>地址族确定并不代表套接字地址结构体就能确定，比如 UNIX 域结构和数据链路结构就是可变长度的（如下图）</font></strong> 。因此，为了向内核传入正确、完整的结构体信息，就必须手动传入 len 。<br><img src="/2022/img/AF42B09F2B4C386B42D377D97AB95965.png" alt=""></p><p>另外，我们在前文中也提到了图中的 <code>sockaddr_storage</code> 结构体，<strong>它能够承载任意大小的地址结构体，并满足某些地址结构体的对齐需要</strong> ，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> ss_family;      <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __ss_align;   <span class="comment">// 对齐要求</span></span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span> - <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)];  <span class="comment">// 填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 ss_family 成员，其他两个成员对用户透明。</p><p>最后笔者仍有一个问题：为什么 <code>sockaddr_in</code> 有一个 8 字节的填充？历史原因？效率问题？目前没有找到一套“自圆其说”的说法。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于CHATGPT的一些想法</title>
      <link href="/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
      <url>/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近一个月以来，国内乃至全世界的焦点都汇聚到了chatgpt之上。被chatgpt刷屏后，我个人也不禁产生了一些思考。</p><p><strong><mark class="hl-label blue">chatgpt对我们的生活将造成哪些影响？</mark> </strong><br>很难说。《未来世界的幸存者》中有这样一个观点：未来几十年内，人工智能将使许多传统岗位消失，如客服、信用评估员、市场分析师等；但有些职业是人工智能暂时很难取代的，如画家或律师等艺术性或人文性较强的工作，原因很容易知道，一言以蔽之，机器始终无法替代人类的灵光一闪。之前我也对此观点深信不疑，直到看见了下面这些新闻：<br><img src="/2022/img/b&bo=NwQzBjcEMwYWECA!&rf=viewer_311.jpeg" alt="AI画作：太空歌剧院" style="zoom:80%;" /><br><img src="/2022/img/b&ek=1&kp=1&pt=0&bo=OARgCTgEYAkWECA!&tl=1&vuin=1572676601&tm=1676037600&dis_t=1676037625&dis_k=f9474985ff1e09ce64e0efcb968d67df&sce=50-1-1&rf=viewer_311.jpeg" alt="AI律师" style="zoom:67%;" /></p><p>要知道，该书出版于2018年，至今仅过了短短五年…所以，你很难想象科技的发展速度，谁知道下一个五年将会是什么样呢？就chatgpt而言，虽然目前它的回答尚有较大的瑕疵，但风口已经打开，如周鸿伟所说——“搭不上ChatGPT的企业可能将被淘汰”，大量资本的注入势必会大大增强其性能，所以它的潜力仍然无法预估。不过，有一点我们必须清楚：如果想要避免未来被人工智能取代，就必须从事技术含量高、重复性低、可量化性低的工作。当然，公务员也许不错。</p><p>话说回来，也许不用对未来AI是否会造成失业潮而过度担心呢：<br><img src="/2022/img/image-20230210223238238.png" alt=""><br>本人浅薄地认为，AI过度地取代人工，将生成大量无业游民，进而引发社会动荡，这无疑是政府所不愿看到的。因此，政府可能会进行宏观上的调控。但，即使在调控下AI只会代替少部分人，你又如何保证你不是那倒霉的小部分呢？</p><p><strong><mark class="hl-label blue">由此看到的中外差距</mark> </strong><br>在<a href="https://www.huxiu.com/article/787988.html">《万字拆解：ChatGPT为什么这么强？》</a>论文中，作者向国内同胞们发出了真切的呼吁，此诚危急存亡之秋！包括但不限于人工智能领域，国内外的差距正在不断拉大，而极多数国人却在某些公知不怀好意的误导下，认为我国已经全方位赶英超美，天朝上国无所不能…如此下去，未来中国只有两个方面能够战胜国外——浓香型科技和酱香型科技。</p><p>再来看看我们的企业在干什么：<br><img src="/2022/img/image-20230210231638974.png" style="zoom:50%;" /><br><img src="/2022/img/image-20230210231800724.png" style="zoom:50%;" /><br>国外科技巨头在马不停蹄地创新，国内巨头却在你追我赶地和菜市场的小商贩抢生意。chatgpt爆火后，国内巨头们也争先恐后地计划推出类gpt产品：<br><img src="/2022/img/image-20230210232254477.png" style="zoom:67%;" /><br>个人不认为国内的这场chatgpt争夺战能够分出胜负，反而可能是全军覆没。原因很简单：2022年，OpenAI的算力支出约为4亿美元，人工支出约为9千万美元，光是这两样就达到了惊人的35亿人民币！中国有哪家企业能够下这样的血本？更不要说它的时间成本与技术成本了。在国内浮躁的学术环境和企业环境下，我们很难持续地取得技术创新。下一个5G还有多久？</p><p><strong><mark class="hl-label default">AI可能取代人类吗？</mark> </strong><br><img src="/2022/img/image-20230210222435996.png" alt=""><br>想起了流浪地球2的开头旁白——“起初，没人认为这是一场灾难，直到它和每一个人都息息相关。”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度思维-读书总结</title>
      <link href="/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几日，我父亲醉酒后拉着我谈心，不知道是酒后起兴还是愁绪积压太久，向我倾诉了他对前半生的无尽悔恨，悔恨学生时代没有自制力（初中名列前茅，中考前被朋友带着打牌，三个月不眠，因此失利；高中仍名列前茅，又被朋友拉着打乒乓，没下课就跑去占台，耗费大量时间）；悔恨早年赚到钱时，没能听朋友劝告进入房地产；悔恨后来发家时，没能及时在深圳买房…父亲微仰着头，泪光不停地闪烁着，“在那个疯狂的、满地是钱的年代，无数个机会从我们面前闪过，然而我一个也没曾抓住。”</p><p>父亲的这些话，令我感触颇多。那个撒钱的年代，为什么机会遍地，却不曾抓住过？当然，任何一件事都有其时代的局限性，马后炮总是容易的。但话说回来，不依旧有很多人脱颖而出，改变了自己的命运吗？有人说他们靠的是胆量，或说凭的是运气。不可否认，这两者差一个都不行，但笔者认为，更重要的是——认知。与认知同义的，还有我们常说的眼界、格局等。最近有句话在网上传得很火——凭运气赚到的钱，总会凭实力亏掉，这句话的背后也许就体现了认知的重要性。如著名畅销书籍《穷爸爸富爸爸》中提到的，为什么一些运动员、演员等红极一时，短时间内赚到了普通人几辈子都赚不到的钱，而十几年甚至几年后就传出破产消息（拳王泰森、影帝尼古拉斯·凯奇都是例证）？个人认为，其背后深层次的原因都是认知（眼界）的不足。打一场拳或拍一部戏就能拿到一笔难以想象的巨款，相信绝大部分人此时都难以压抑自己的消费欲望，对于出身普通的人而言，更是会出现报复性消费，于是买豪车、置豪宅…不出多久，现金流就为负数了。而对于极少数的另一部分人，他们有更高的认知、更远的眼界，则可能用这些巨款继续创造正现金流（买房买车多数时候都属于负债，即负现金流），进而持有更多的资产。</p><p>那么，作为普通人的我们，怎样才能提升自己的眼界呢？又怎么才能把握时代的机遇呢？《深度思维》这本书也许就给出了答案。这本书给出了几种思维技术和思维格局，配以普通人的事例，让我深刻体会到了思维能力的重要性。下面简单谈谈我读完本书的感受。</p><p><strong>文章首先提到了思维链</strong> 。思维链的形式很简单，就是通过对一个问题进行连续追问，从而推测事物的未来走向（5so思考法），或探究问题的本质根源（5why思考法）。别看其思想和步骤极其简单，但结果往往令人吃惊！比如书中的例子，<strong>如何解决墙被腐蚀的问题——只需关上博物馆的窗帘！</strong> 这便是 5why思考法的威力，而普通的思考往往很难达到如此大的跨度。5so思考法同样令我震惊，书中有个精彩的真实案例：上海自贸区要成立了，so？——上海本地的贸易公司业务会繁荣，相应公司的股票一定上涨，so？——物流业务肯定也会被带动，物流公司的股票也值得购买，so？——物流繁荣，港口也一定繁荣，so？——集装箱租赁业务也肯定火爆…最后事实证明这一逻辑链完全正确，少量窥探先机的人则赚得盆满钵满。<br>既然这种简单到人人都会的思想方法能展现出如此巨大的威力，那为什么实际中，受益的人少之又少呢？个人认为，是因为没有刻意训练。方法再厉害也没有用，<strong>只有形成本能，当任何问题发生时，第一时间用这些方法思考问题，才能发挥作用</strong> 。而想要形成本能，就需要我们刻意训练，每当遇到问题，都先问自己，可以用什么样的方法或角度来解决，久而久之就可形成本能。</p><p><strong>接着提到了换位思维</strong> 。额，这还需要说？俺小学就学会了换位思考！小时候，一个小姐姐护士给我扎针，扎错了好几次，紧张得从脖子红到了耳朵，但我没怪她，因为我换位思考，如果我作为一个实习生护士，连续扎错了针，心里该多么紧张和难受啊！所以需要体谅和理解，想到这，我还安慰了这位护士，果然，一下就扎对了…呵呵，首先，这篇读后感不是小学课文；第二，换位思考不仅用于感受和体谅他人，在营销或其他领域也常有应用。还是书中的例子，一旅行社针对高压力的白领群体推出了一款旅游路线，广告语有以下两个：</p><ol><li><strong>风光无限，畅想人生</strong></li><li><strong>你是愿意待在沉闷的办公室里勉强安慰自己小点压力，还是愿意躺在大理洱海边畅快地呼吸新鲜空气？</strong></li></ol><p>高下立判。显然，第一个广告语是从你自己的角度来描述的，这并不能和白领们产生共鸣。而第二个广告语则是站在白领的角度来考虑的。想想，将自己放置于沉闷、阴暗的办公司，耳边嘈杂声不绝，满屋缭绕着对面男同事呼出的二手烟，桌面上堆满了待处理的文件…此时，你不经意抬头，看见了电脑上的第二则广告语，一幅蓝天白云，海边沙滩的画面立刻出现在你的眼前——OMG！去他妈的工作，这洱海我去定了！</p><p><strong>当我们面向的对象是人时，换位思考几乎是不能避免的</strong> 。<strong>记住，谁能引起共鸣，谁就能赢得了客户的心</strong> 。任何时候，问自己一句：如果我是他，我会想什么？我会做什么？每一份直击人心的文案策划，每一次打开局面的商业谈判，每一个引爆用户的产品设计，背后都对应着成功的换位思维。<br>另外，换位思考的一个精彩应用是爱德华·德·博诺博士提出的六顶思考帽，有专门的一本书——《六顶思考帽》详细介绍了该思想。六顶思考帽是利用换位思考，站在六种极端的角度来分析问题，最终得到一份最优的答案。后面有时间再阅读此书并另写读后感，这里就不多说了。</p><p><strong>在可视化思维一章中，文章提到了一种重要的时间管理原则——容易的事先做，重要的事先做</strong> ，经过大量实践，该原则被认为是解决拖延症的不二良方。嗯？就这么个小原则就能解决我多年的拖延症？这也太小看我了吧！再容易的事我也能拖…当然，这并不能解决你的拖延症，因为作者犀利地指出，<strong>这种时间管理原则最大的问题，在于如何评价事情的容易或重要程度</strong> ，就这点，我深有同感！很多时候，我在评价一件事情的重要性或可能性时，总会直接脱口而出：这件事有 80%~70% 的重要（可能）性！喔？70%~80% ，这些确切的数字是怎么得到的？计算得到的？还是调研得到的？又或者是随口一说？很显然，只是随口说说。通过这种模糊不定的评价标准来决策事情的先后，自己本身也会对其产生怀疑，所以当然就不会严格遵守。因此，作者就提出了一套评价标准：<br><img src="/2022/img/未命名绘图37.png" style="zoom:150%;" /><br>有了这样的确切的评价体系，我们就能够更客观地估计事件的优先级。你甚至可以对以上某一角度加权。注意，一旦决定实施这一评价体系，就必须时刻遵守它的结果。比如，算出 A 事件的优先级大于 B 事件，但你自己更喜欢 B 事件，所以你就违背了这一结果，直接先做 B 事件。长期这样违背只会降低这一方式的权威性，直到最后形同虚设。当然，你完全可以将喜爱程度也加入到这一体系中，并对喜爱度加权。</p><p><strong>令我同样印象深刻的还有秘籍型思维</strong> 。秘籍型思维是指，当我们探寻一个人是怎么成功的，或怎么才能做成一件事，最终会将原因归结到某种秘籍——职场能力、个人背景、贵人相助、思维方式…实际上，这种秘籍型思维已经深入我们的骨髓，我们将原因归结为一点，却忽视了别人在其他方面所作的努力。拿我自己举例，高中时，我一直对数学的奇技淫巧很感兴趣，花费大量时间去追求所谓的秒杀方法，基础却没能重视，最后的结果显而易见——基础不牢，地动山摇，高考数学成绩给了我一记耳光。更重要的是，直到大学，我都没有再提起过对数学的兴趣，甚至对其反感和厌恶，我想，这可能会成为我的一生之痛。<br><strong>秘籍型思维将复杂的东西过于简单化，企图用一个相对简单的秘籍去代替复杂的成功规律，而对其他方面的因素视而不见。</strong> 所有成功都是多方面因素促成的结果，单一考虑某一个方面，则有可能使得我们将鸡蛋全部放入一个篮子，增大了事件的风险性。</p><p>与秘籍型思维相反的是思维方法是全流程优化。全流程优化的最诱人的地方在于它的复利性。爱因斯坦曾说，复利是世界的第八大奇迹。全流程优化是指，将一件事情拆分为多个步骤，如果你每个步骤都做得比别人好那么一点，则成效则可能是别人的几倍！这是真正的在平凡中创造伟大！还是拿书中广告软文的例子来说明：<br>文章标题 --&gt; 正文内容 --&gt; 商品软文 --&gt; 链接跳转 --&gt; 店铺页面 --&gt; 支付界面 --&gt; 收获评价<br>富有吸引力的标题能够带来更多流量，这是第一步；正文内容不会直接谈到商品，而是做一些铺垫，这里必须保证足够吸引读者，或者和读者引发共鸣，这是第二步；接着是商品软文，这里需要承上启下，展现商品用途，需要足够打动读者；然后，读者可能成功被你的软文打动！ta尝试点入链接…<br>在以上步骤中，其他几个步骤你可以很容易地优化，比如将店铺页面装饰得漂亮些、评价反馈服务再做得到位一些…那么，链接跳转和支付页面该怎么优化呢？实际上，这两点是最容易被忽略的点，也是很容易丢失客户的点！拿我自己的感受来说，当我点击跳转链接后，经常会提示：“请复制该链接，并在浏览器中打开”，而这会极大地消耗我的耐心和冲动。本来这些软文广告就是在消费我们读者的冲动，而这些冲动都被繁琐的跳转链接给消耗了，还谈什么购买呢？对于支付页面，我也常有体会，很多时候下定决心要购买商品了，却发现没有微信支付，而只有支付宝支付，这每每令我相当恼火。<br>话转回来，如果我们将每个流程都优化 20%，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>4.29</mn></mrow><annotation encoding="application/x-tex">1.2^7=4.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4.29</span></span></span></span> ，你收获的成果将是别人的 4.29 倍！而你多做的努力只有 20% ！这就是复利的威力。因此，重视每一个细节，是我们成功的关键！</p><p>接着书中讲到了生态思维，生态思维侧重于发现事物之间的关系。《浪潮之巅》一书中介绍了计算机行业的一个著名生态链——以微软为首的软件公司吃掉硬件带来的全部好处（比如你内存越大，那我软件也刻意占用越大的内存），迫使用户更新机器让惠普和戴尔等公司收益，而这些计算机制造商再向英特尔这样的半导体厂商订货。在这条链上，相应公司的股票先后都会上涨，因此华尔街的投资者们都知道，如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔的股票。这些投资者们就深谙生态思维和逻辑链的威力。曾经在知乎上还看见一句令我印象很深刻的话：如果大家都知道某个产业赚钱，那就一定不能再挤进去，那怎么办呢——进入这个产业的上游产业。这也是一种生态思维的体现。生态思维下还有几个著名的模型：<strong>淘金模型、森林模型和平台模型</strong> 。<br>淘金模型的底层考虑是共生——如果恶龙太强，那就当恶龙的马仔！额…说错了——如果对手强大如河马，那我们可以成为牙签鸟！淘金模型来源于全球著名牛仔裤制造商李维斯。在疯狂的淘金热下，想要继续挖到大金矿已经几乎不可能，但大量的挖矿工人需要结实耐磨的裤子，聪明的李维斯便开始在金矿附近买起了牛仔裤，从而发展成了后来的著名牛仔裤品牌。相似的例子还有很多，比如为大量捡贝壳以求珍珠的人们提供坚实的橡胶手套。<br>森林模型强调的是错位竞争；平台模型则是为大量竞争者提供平台，而自己则成为平台的收益者。这些方法和事例看似简单，实践起来仍有很大难度。</p><p>文章最后提到的是大势思维。文章有一段很漂亮的话：</p><blockquote><p>古代诗人罗隐说：“时来天地皆同力，远去英雄不自由。”<br>荀子说：“君子生非异也，善假于物也。”<br>小米创始人雷军说：“站在风口上，猪都能飞起来。”</p></blockquote><p>这几句话都是对大势思维的例证。20年前，中国的富豪大多数是搞矿产的；10年前，中国富豪大多数是搞房地产的；现在，中国富豪则大多数是搞互联网的；那么可以预测，未来几十年，中国的富豪可能是发展人工智能或自动驾驶的。身为普通人的我们，又该如何发现并利用趋势呢？其实，趋势下往往隐藏着深刻的经济学规律，而文章中则给出了三条强大的规律——马太效应、科技进步和人口变化。这三条规律能够压制其他任何心理学或经济学规律，值得我们重视。</p><p>书中还有许多精彩的内容，限于笔者精力有限，就不再总结了，详细还请各位细品此书，定能有所收获。</p><p>在这个充满机遇和挑战的时代，共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更安全的用户进程?</title>
      <link href="/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>data_limit_3gb</code></p></blockquote><p>在<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程</a>一文的文尾，笔者留下了一个思考题：既然要求用户不能直接访问内核，那为什么不将用户代码段的界限设置为 3GB 呢？正如之前所演示的那样，如果用户代码段的界限为 4GB，则用户就可以随意修改内核，包括直接访问显存：<br><img src="/2022/img/image-20230112155046604-1673594986128-1.png" alt=""><br>其实笔者也不知道准确的答案，我粗略参考了 Linux 0.11 的代码，发现 Linux 0.11 <u>似乎</u>也是直接将段界限设置为 4GB 。至于规范的防止用户修改内核的方式，咋们以后遇上了再说，现在我们来看看到底能不能通过将数据段界限改为 3GB 来防止用户直接修改内核数据。</p><p>首先将用户数据段的段界限改为 <code>0xbfffffff</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:tss.c</span></span><br><span class="line"><span class="comment">//函数说明:tss_init()</span></span><br><span class="line">*((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xbffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br></pre></td></tr></table></figure><p>还要修改 syscall：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span></span><br><span class="line">    <span class="params">(<span class="string">&quot;int 0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (retval)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a&quot;</span> (no), <span class="string">&quot;b&quot;</span> (_arg1)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.....其他syscall也需要改为内联汇编</span></span><br></pre></td></tr></table></figure><p>为什么要将之前的静态变量方式改成扩展内联汇编呢？说到这，笔者不禁流下了悔恨的泪水…当初我也是为了少学这点看起来复杂的扩展汇编，所以使用了全局静态变量这样的“巧计”来代替这种复杂的汇编。没办法，未来某些场景必须使用到它，所以，该来的早晚会来。话说回来，目前而言，由于我们还没有真正的加载用户进程（真正的用户进程是从文件中读取，进而载入内存的，而当前我们使用函数代替用户进程的），所以一切代码和数据（的标号，即地址），不论用户进程还是内核，都被链接成了 3GB 以上，这都是下面这行 makefile 指令造成的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><p>这条指令将目前的所有文件全部链接成 kernel.bin，并指定入口的虚拟地址为 <code>0xc0001500</code> ，因此，所有的函数和全局、静态变量的地址实际上都在 <code>0xc0000000</code> 以上！所以，我们将用户段的界限限制在 3GB 以下时，在用户态中就不能再使用任何全局变量和静态变量！所以这里的 _syscallX 就不能使用静态变量来中转啦！于是乎，只有改成扩展内联汇编喽。<br>最后，还得修改系统调用入口函数，因为进入中断并不会自动切换 ds、es、fs（只会切换cs），所以咋们必须手动将这几个寄存器修改为内核态的数据段选择子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;.....</span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   push eax</span><br><span class="line">   mov  ax,0x10   ;内核的数据段选择子</span><br><span class="line">   mov  ds,ax</span><br><span class="line">   mov  es,ax</span><br><span class="line">   mov  fs,ax</span><br><span class="line">   pop  eax</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;.....</span><br></pre></td></tr></table></figure><p>ok，来试试看这下能不能直接在用户态访问显存：</p><p><img src="/2022/img/image-20230114134607206.png" alt="image-20230114134607206"></p><p>显然，发生了 GP 异常，禁止访问。说明这样是能够起到一定的保护作用的。来看看正常运行的效果：<br><img src="/2022/img/image-20230114150332216.png" alt=""></p><p>上图中用户只打印了一次，我就使用 Bochs 断点指令将其打断了，因为后面任务切换时引发了程序崩溃，原因就不细说了。这说明通过限制用户数据段的界限来禁止访问内核的这种方式是不可行的。<strong><font color='orange'>实际上，现代操作系统的内存保护机制并非在段上，而是在页上</font></strong> ，关于这点，以后再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统调用</title>
      <link href="/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/"/>
      <url>/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>printk</code></p></blockquote><h3 id="font-color-red-系统调用与API-font"><font color='red'>系统调用与API</font></h3><p>之前很长一段时间，笔者都将系统调用和 API 函数混为一谈，实际上两者有较大区别。</p><p><strong>API (Application Programming Interface，应用程序接口)</strong> ，其主要功能是提供<u>通用功能集</u>，程序员通过调用 API 对应用程序进行开发，可以减轻编程任务。</p><blockquote><p>API 可以简单的理解为一个通道或者桥梁，是一个程序和其他程序进行沟通的媒介，本质上一个函数。比如我们想往屏幕上打印字符，显然，如果自己从头实现，则需要了解显卡、汇编等知识，无疑相当麻烦。而且 C 库中早就为我们准备了打印函数，即 printf，你只需要按它的要求传入参数就行，无需了解 printf 内部实现。所以 printf 也可以称为 API 。说白了，<strong>接口，就是指两个不同程序之间交互的地方</strong> ，就这么简单。</p></blockquote><p>而系统调用是一种特殊的接口，通过这个接口，用户可以访问内核空间，进而实现一些只有内核才能完成的操作，比如屏幕打印、内存申请（malloc）等。<br>那么这两者有什么区别呢？严格来说，两者没有直接关系，但一般而言，系统调用一般封装在 API 中，但不是所有 API 内部都会进行系统调用。<strong>API 的提供者是运行库，运行库则使用操作系统提供的系统调用接口</strong> ，如果再往下，内核则调用驱动程序，由驱动程序来和硬件打交道。</p><h3 id="font-color-red-系统调用实现原理-font"><font color='red'>系统调用实现原理</font></h3><p>系统调用的直接目的是进入 ring0，以便进行一些只有 ring0 才能完成的工作。我们之前说过，想要从低特权级进入高特权级，则只能通过门完成。由于调用门开销较大，Linux 选择通过中断门进入高特权级，并进行系统调用。<strong><font color='orange'>Linux 系统调用的中断号为 0x80，子功能号存入 eax，而 ebx、ecx、edx、esi 和 edi 则依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中</font></strong> 。</p><blockquote><p>如果要传入五个以上的参数，则需要使用栈传递参数，后文将演示这一过程。</p></blockquote><p>如果细分，Linux 系统调用可以分为三种方式：<br><strong><mark class="hl-label blue">通过 glibc 提供的库函数</mark> </strong><br>glibc 是 Linux 下使用的开源的标准 C 库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了系统调用。比如通过 glibc 提供的 <code>chmod</code> 函数来改变文件 <code>etc/passwd</code> 的属性为 444：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        rc = chmod(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="number">0444</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;chmod failed, errno = %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;chmod success!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用syscall</mark> &quot;</strong><br>syscall 也由库函数提供，但相比于其他调用方式， syscall 则更加灵活，比如你通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，所以你可以利用 glibc 提供的 <code>syscall</code> 函数直接调用，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">syscall</span> <span class="params">(<span class="type">long</span> <span class="type">int</span> sysno, ...)</span></span><br></pre></td></tr></table></figure><p>其中 sysno 是系统调用号（子功能号），每个系统调用都有唯一的系统调用号来标识；<code>...</code> 则是可变参数列表，根据系统调用的不同，可带0~5个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。<br><strong><mark class="hl-label blue">通过int指令调用</mark> </strong><br>直接通过内联汇编进行系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rc;</span><br><span class="line">    <span class="type">char</span> *file_name = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode = <span class="number">0444</span>;</span><br><span class="line">    <span class="keyword">asm</span></span><br><span class="line">    (</span><br><span class="line">     <span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">    :<span class="string">&quot;=a&quot;</span> (rc)</span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (SYS_chmod), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)file_name), <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)mode)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容易知道，这三种方式最终都会使用 <code>int</code> 指令进行系统调用</strong> 。</p><h3 id="font-color-red-实现系统调用-font"><font color='red'>实现系统调用</font></h3><p><strong><mark class="hl-label blue">添加_syscallX</mark> </strong><br>实际上，库函数也是通过操作系统提供的 _syscallX 宏来进行系统调用，其中 X 是参数个数，以 _syscall3 举例，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c)              \</span></span><br><span class="line"><span class="meta">type name(atype a,btype b,ctype c)&#123;                                      \</span></span><br><span class="line"><span class="meta">long __res;                                                              \</span></span><br><span class="line"><span class="meta">asm volatile                                                             \</span></span><br><span class="line"><span class="meta">    (<span class="string">&quot;int $0x80&quot;</span>                                                         \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res)                                                       \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a)),<span class="string">&quot;c&quot;</span> ((long)(b)),<span class="string">&quot;d&quot;</span> ((long)(c))) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res&gt;=0)                                                            \</span></span><br><span class="line"><span class="meta">return (type) __res;                                                 \</span></span><br><span class="line"><span class="meta">errno=-__res;                                                            \</span></span><br><span class="line"><span class="meta">return -1;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>各位无需了解以上代码的含义，咋们会契合自己的操作系统，使用更简单的方式实现。另外，此 _syscallX 已经被 Linux 废弃，但为了简单，我们仍模仿 _syscallX 进行系统调用。</p><p>由于我们的操作系统最多只会使用三个参数的系统调用，所以这里咋们只实现 0~3 个参数的系统调用，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> callno_ret;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg1;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg2;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg3;</span><br><span class="line"><span class="type">uint32_t</span> _syscall0(<span class="type">uint32_t</span> no)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall2(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall3(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2, <span class="type">uint32_t</span> _arg3)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    arg3 = _arg3;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov edx,arg3&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于为什么要使用静态变量，这已在之前的文章多次提及，不再说明。</li></ul><p>啊哈，很简单吧！这里只解释 <code>mov callno_ret,eax</code> ：因为系统调用也遵循 ABI 规范，即，将返回值存入 eax 中，所以我们还要将 eax 转移到静态变量 callno_ret 中，并将其返回（callno_ret 即说明它既用来存放调用号，也用来作为返回值）。</p><p><strong><mark class="hl-label blue">编写中断入口函数</mark> </strong><br>进入 0x80 中断例程后，代码会根据传入的调用号跳转到相应的函数，函数执行完毕后回到中断，再通过 iret 返回到用户态。0x80 中断例程代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;文件说明:interrupt.s</span><br><span class="line">;......上文忽略.......</span><br><span class="line">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;</span><br><span class="line">[bits 32]</span><br><span class="line">extern syscall_table</span><br><span class="line">section .text</span><br><span class="line">global syscall_handler</span><br><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EID</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 为系统调用子功能传入参数</span><br><span class="line">   push edx            ; 系统调用中第3个参数</span><br><span class="line">   push ecx            ; 系统调用中第2个参数</span><br><span class="line">   push ebx            ; 系统调用中第1个参数</span><br><span class="line"></span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;4 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><ul><li>以上代码的格式和之前中断处理的格式完全相同，不再赘述。</li><li><code>syscall_handler</code> 为系统调用的入口，所有系统调用都会通过该入口函数进入到指定的子功能处理函数。</li><li>第 25 行， <code>syscall_table</code> 是在 <code>syscall_init.c</code> 中定义的指针数组，该数组中存放的是各个系统调用的指针。</li><li>第 28 行，将存放返回值的 eax 存入内核栈的相应位置。为什么要这样呢？因为从用户态进入中断时，保存现场，存放调用号的 eax 被存入中断栈；所以从中断返回，恢复现场时，调用号重新被放入 eax；但 eax 必须用来存放返回值，所以必须将返回值提前放入中断栈的相应位置处，这样才能在返回用户态后从 eax 取得返回值。</li></ul><p><strong><mark class="hl-label blue">为 0x80 中断例程建立中断描述符</mark> </strong></p><p>想要通过 0x80 正确进入到相应例程，就必须建立相应的中断描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:idt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_CNT 0x81  <span class="comment">//修改为0x81</span></span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    make_idt_desc(&amp;idt[<span class="number">0x80</span>],IDT_DESC_DPL3,syscall_handler); <span class="comment">//为0x80建立中断描述符</span></span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//........</span></span><br></pre></td></tr></table></figure><p>现在完事具备，就差一个具体的系统调用啦！为了让用户进程能够说话，咋们先实现 write 系统调用，该调用可以在屏幕上打印文字。</p><h3 id="font-color-red-加入write系统调用-font"><font color='red'>加入write系统调用</font></h3><p>write系统调用相当简单，不过是对 console_put_str 的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(str,DEFUALT);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这是实际的子功能函数，是通过 <code>syscall_handler</code> 中断入口函数调用的，而不是被用户直接调用。用户调用的 write 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_WRITE,(<span class="type">uint32_t</span>)str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>SYS_WRITE</code> 为调用号，定义在 syscall.h 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SYSCALL_NR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SYS_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><u>如此一来，整个系统调用的流程就清晰的呈现在我们眼前：</u></font></strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRB(write)--&gt;L(_syscall1)--&gt;G(int 0x80)--&gt;K(syscall_handler)--&gt;A(sys_write)  </pre></div><p>最后，别忘了初始化系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    syscall_table[SYS_WRITE] = sys_write;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;init_all\n&quot;</span>,DEFUALT);</span><br><span class="line">    idt_init();    <span class="comment">// 初始化中断</span></span><br><span class="line">    timer_init();  <span class="comment">// 初始化PIT</span></span><br><span class="line">    thread_init(); <span class="comment">// 初始化线程相关结构</span></span><br><span class="line">    mem_init();   <span class="comment">// 初始化内存管理系统</span></span><br><span class="line">    console_init();<span class="comment">// 初始化终端输出</span></span><br><span class="line">    tss_init();    <span class="comment">// 初始化tss</span></span><br><span class="line">    syscall_init();<span class="comment">// 初始化系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前用户进程无法直接调用 print 系列函数进行打印（否则发生 0xd 号异常），现在实现了 write 系统调用，就可以让它说话啦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line">    process_execute(u_prog_a,<span class="string">&quot;proa&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hi,man\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/protalk.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h3 id="font-color-red-栈传递参数-font"><font color='red'>栈传递参数</font></h3><p>前文说到，如果参数超过五个，那么寄存器就不够用了，此时只能通过栈来传递。其实通过栈传递参数是调用门的原生做法，这点在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中有提到过。对于中断门而言，使用栈传递需要手动实现，但也很简单：进入中断时，处理器自动压入旧栈的 ss 和 esp，由于段基址都为 0，所以我们就能直接根据该 esp 定位到旧栈中的参数（因为旧栈压入参数后，调用中断，旧栈的 ss 和 esp 紧接着就被自动压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断剖析</a>），图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE36-1673590654821-2.png" alt=""><br>根据上图，就很容易知道如何从旧栈获取参数啦，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 获取当前栈中esp的值</span><br><span class="line">   mov ebx,[esp+4+48+4+12]</span><br><span class="line">;3 再将参数压入当前栈中</span><br><span class="line">   push dword [ebx+12]  ; 系统调用中第3个参数</span><br><span class="line">   push dword [ebx+8]   ; 系统调用中第2个参数</span><br><span class="line">   push dword [ebx+4]   ; 系统调用中第1个参数</span><br><span class="line">   mov eax,[ebx]        ; 子功能号</span><br><span class="line">;4 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;5 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><h3 id="font-color-red-思考-font"><font color='red'>思考</font></h3><p>你可能会问，为什么不直接在 API 中进行系统调用呢，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = SYS_WRITE</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式不是更直接吗？为啥还要通过 syscallX 来进行系统调用？答案是代码复用。系统调用有上百上千个，而它们的调用代码都像上面这样相似，如果每个函数都采用这种方式，无疑是相当冗余的。若参数个数相同的系统调用都使用同一种 syscall，如 syscall3，这样不就大大减少了代码量吗？</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf加强-支持short与long long</title>
      <link href="/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
      <url>/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">printf 底层剖析及可变参数探究</a><br>本文参考文章：<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a> ，<a href="https://blog.csdn.net/kjlist2017/article/details/104113265">使用位运算代替取模</a><br>本节对应分支：<code>printk-enhanced</code></p></blockquote><p>上节说到 Linux 0.11 的 printk 不支持输出 short （不是不支持，而是表现得和 int 相同）和 long long，本节修改代码来支持 <code>%hd</code> 和 <code>%lld</code> 。<br>本以为很简单，只需像之前那样对 short 或 long long 数值不断除以基数并取模，依次得到数字字符，然后组成字符串即可。没想到的是，Bochs 的 <strong>32 位 x86 环境不支持 64 位除法和取模运算</strong> ，也就是说无法支持以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = a / b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = a % c;</span><br></pre></td></tr></table></figure><p>否则会报错，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `__divdi3&#x27;</span><br><span class="line">undefined reference to `__moddi3&#x27;</span><br></pre></td></tr></table></figure><p><strong><code>__divdi3</code> 和 <code>__moddi3</code> 是 gcc 为我们准备的 64 位除法和取模函数，当发生以上情况时，就用这两个函数来模拟除法和取模</strong> 。但由于咋们是自己实现操作系统，所以不能引入外部库函数（就算能，俺也不愿意，俺可不想让复杂的库函数来破坏我们操作系统的简洁性，而且链接了一个库，往往会连着其他许多库）。所以，我们要自己实现 64 位除法和取模函数。</p><p>坏消息是，笔者找了一天的相关资料，发现要么实现过于复杂，要么函数有 bug 。绞尽脑汁时，突然在知乎大佬的<a href="https://zhuanlan.zhihu.com/p/112361959">一篇文章</a>中看见了这样一个等式：</p><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x=2^{32}×H+L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></strong></p><p>其中 H 为 64 位整型 x 的高 32 位，L 为低 32 位。笔者狂喜，接着在草稿纸上写下了如下等式：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x/y=(2^{32}×H+L)/y=2^{32}×H/y+L/y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>其中 y 为 32 位整型，因为 y 就是基数 base，范围在 2~32 之间。<br>这样一来，不就将 64 位除法转换为了 32 位除法吗？哇哈哈哈哈，原来不过如此嘛！等着，别急，突然觉得哪有问题…计算机的除法是向下取整的，这也能使用分配律吗？当然不行，反例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">29</span>+<span class="number">32</span>)/<span class="number">8</span>=<span class="number">29</span>/<span class="number">8</span>+<span class="number">32</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span>  <span class="comment">//该等式成立,但换个方式拆分就不行了:</span></span><br><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">31</span>+<span class="number">31</span>)/<span class="number">8</span>=<span class="number">31</span>/<span class="number">8</span>+<span class="number">31</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span>  <span class="comment">//哦豁</span></span><br></pre></td></tr></table></figure><p>所以此方法无效喽，那怎么办？别急，考虑到我们的除法有一定特殊性，除数只为 8、10、16（printf只支持这三种格式打印），这个特性也许能用上。先想想，为什么取整除法不能像上面那样分配？因为拆分方式会影响两方的精度丢失情况，随着双方的精度丢失情况变化，就会影响最终结果。那么，使另一方被整除，从而将精度丢失只划给一方，这样不就能保证结果不受拆分方式而改变了吗？具体做法如下：</p><p>对于八进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>3</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><msup><mn>2</mn><mn>29</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">x/8=(2^{32}×H+L)/2^{3}=2^{32-3}×H+L/8=2^{29}×H+L/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span></span></span></span></font><br>对于十六进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>4</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>28</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">x/16=(2^{32}×H+L)/2^4=2^{32-4}×H+L/16=2^{28}×H+L/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span></span></span></span></font><br>可以发现，精度丢失只发生在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">L/base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span></span></span></span> 上，所以结果一定正确。</p><p>上面解决了 64 位除法的问题，那取模怎么解决呢？使用位运算的一个特性就可以完美解决这个问题：<br><u><strong><font color='orange'>取模运算 (a%b) 在当 b 为 2^n 时可简化为 a &amp; (b - 1)</font></strong></u></p><blockquote><p>简单证明：当 b 为 2^n 时,a/b的意义就是 a 右移 n 位，而右移的 n 位的值，就是 a%b 的值。</p></blockquote><p>以上除法和取模的方法只能用于 2 的幂，而 10 不是 2 的幂，所以只有另找办法了。所幸，那位知乎大佬的代码恰好能解决这个问题，详细参见<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a>。最终代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG    128     <span class="comment">//if long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_10</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = *n % <span class="number">10</span>;</span><br><span class="line">    *n = *n / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_16_8</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *n, <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = base==<span class="number">16</span>?<span class="number">28</span>:<span class="number">29</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> low = *n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hign= (*n)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mod = ((*n)&amp;(base==<span class="number">16</span>?<span class="number">15</span>:<span class="number">7</span>)); <span class="comment">//a &amp; (base - 1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(<span class="number">1</span>&lt;&lt;t) * hign + low / base;</span><br><span class="line">    *n = tmp;</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">long</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;LEFT) type &amp;= ~ZEROPAD;</span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) size--;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">16</span>) size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">16</span> || base==<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> *p = &amp;num;</span><br><span class="line">            *(++p) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div_16_8(&amp;num,base)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">                tmp[i++] = digits[do_div_10(&amp;num)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> low = num;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hign= num&gt;&gt;<span class="number">32</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i++] = ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                low = <span class="number">429496729</span> * (hign % <span class="number">10</span>) + low / <span class="number">10</span> + ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">                hign = hign / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;precision) </span><br><span class="line">        precision=i;</span><br><span class="line">    size -= precision;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line">    <span class="type">int</span> flags;<span class="comment">/* flags to number() */</span></span><br><span class="line">    <span class="type">int</span> field_width;<span class="comment">/* width of output field */</span></span><br><span class="line">    <span class="type">int</span> precision;<span class="comment">/* min. # of digits for integers; max number of chars for from string */</span></span><br><span class="line">    <span class="type">int</span> qualifier;<span class="comment">/* &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields */</span></span><br><span class="line">    <span class="keyword">for</span> (str=buf ; *fmt ; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process flags */</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">        repeat:</span><br><span class="line">        ++fmt;<span class="comment">/* this also skips first &#x27;%&#x27; */</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get field width */</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* get the precision */</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++fmt;</span><br><span class="line">                <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the conversion qualifier */</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            fmt++;</span><br><span class="line">            <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qualifier = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                flags |= LONG;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">                len = <span class="built_in">strlen</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                    precision = len;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                    len = precision;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                    *str++ = *s++;</span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    field_width = <span class="number">8</span>;</span><br><span class="line">                    flags |= ZEROPAD;</span><br><span class="line">                &#125;</span><br><span class="line">                str = number(str,(<span class="type">unsigned</span> <span class="type">long</span>) va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                flags |= SMALL;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)<span class="comment">// %llx</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                flags |= SIGN;</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">                *ip = (str - buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (*fmt)</span><br><span class="line">                    *str++ = *fmt;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --fmt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>do_div_16_8 函数就是处理 16 进制和 8 进制的例程，逻辑和前文所述相同，不再赘述。</p></li><li><p>此版本用 do_div_10 来代替了之前版本的 do_div 函数，没什么原因，只是不喜欢内联。do_div_10 只用来处理 32 位除法。</p></li><li><p>86~88 行用来处理 64 位 10 进制除法。</p></li><li><p>第 198 行，当类型为 long long 时，将 qualifier 赋值为 ‘m’，以便在 switch 中识别并处理</p></li><li><p>第 199 行，当类型为 long long 时，将 LONG 标记加入 flag 。打印 8 进制和 16 进制时，如果不为 long long，第 67~68 行则将 num 的高 4 位置零，只计算低 4 位。为什么要这样做呢？因为打印负的 16 进制和 8 进制的 32 位整型时，由于负数（补码）的首位为 1，传入 number 函数时，该数会发生符号扩展（因为 number 的参数 num 是 long long，而实参是 32 位），比如 32 整型数 -1 的二进制是 <code>0XFFFFFFFF</code> ，符号扩展后就成为 <code>0xFFFFFFFFFFFFFFFF</code> ，因此造成的结果就是：<code>printf(&quot;%x&quot;,-1)</code> 也会打印 <code>0xFFFFFFFFFFFFFFFF</code> ，而正确的结果应该是 8 个 F 。所以要对于 32 位负整型，需要将高 32 位清零。</p><blockquote><p>关于补码，详见[CSAPP][<a href="https://jyx-fyh.github.io/2022/07/08/CSAPP/">https://jyx-fyh.github.io/2022/07/08/CSAPP/</a>]。再次强调， <strong>打印八进制和十六进制的负数时，是直接打印其补码！</strong></p></blockquote></li></ul><p>最终效果如下：<br><img src="/2022/img/image-20230111102501588.png" alt=""><br>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf底层剖析及可变参数探究</title>
      <link href="/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/">可变参数列表</a>，<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本文参考文章：<a href="https://book.douban.com/subject/3422332/">《你必须知道的495个C语言问题》</a><a href="https://book.douban.com/subject/1231236/">《Linux内核完全注释》</a>《操作系统真相还原》<a href="https://www.runoob.com/cprogramming/c-function-printf.html">printf-菜鸟教程</a><br>本节对应分支：<code>printk</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>相信每一位 C 选手写下的第一句代码都是下面这句经典的 Hello World 吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理所应当的，其中的 <code>printf</code> 函数也成为了咋们认识的第一个函数。对笔者个人而言， <code>printf</code> 是一个熟悉而陌生的函数，说熟悉是因为它伴随了我整个 C 语言的学习生涯；说陌生是因为学习过程中一直对它存疑，模模糊糊，始终没能一探究竟，不知道各位读者是否也是像笔者一样呢？记得 C 语言萌新阶段时，我时常吐槽 <code>printf</code> 中的那些格式符，如 <code>%d</code>、<code>%s</code>、<code>%c</code>、<code>%x</code> 等，乱七八糟的，实在是太难记啦！入门阶段时，我赞叹 <code>printf</code> 强大的格式处理能力，比如左右对齐、输出宽度、输出精度等；进阶阶段时，我又开始疑惑 <code>printf</code> 是如何做到参数可变的，但因为基础不足，就暂时搁浅。现在，天时地利人和，让我们对 <code>printf</code> 一网打尽吧！</p><p>本文将从以下几个方向逐个击破 <code>printf</code> ：</p><ul><li><strong><font color='gree'>默认参数提升</font></strong></li><li><strong><font color='gree'>可变参数的类型检查</font></strong></li><li><strong><font color='gree'>可变参函数实现原理</font></strong></li><li><strong><font color='gree'>其他注意事项</font></strong></li><li><strong><font color='gree'>printf源码详解</font></strong></li></ul><h3 id="font-color-red-默认参数提升-font"><font color='red'>默认参数提升</font></h3><p><strong><font color='orange'>注意，默认参数提升仅对可变参数列表有效</font></strong> ，其规则是：<strong><font color='orange'>char 和 short 自动提升为 int，float 自动提升为 double</font></strong> 。<br>比如我们一定知道，<code>%f</code> 用来输出 float，<code>%lf</code> 则用来输出 double；但实际上 <code>%f</code> 可以同时表示 float 和 double 类型，而无需专门指定 <code>%lf</code> 来表示 double（因为 printf 只能看到双精度），如下图：<br><img src="/2022/img/image-20230108145958396.png" alt=""></p><blockquote><p>本操作系统未支持浮点（难度较大，非常麻烦），且笔者对浮点的硬件支持不太了解，所以下面不讨论浮点。</p></blockquote><p>将 char/short 提升为 int 的原因是：<strong><u>可变参函数的原型无法提供参数个数以及参数类型，所以编译器无法针对各个参数生成相应代码，因此只好统一为 int 类型</u></strong> 。</p><blockquote><p>比如 <code>printf</code> 的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span></span><br></pre></td></tr></table></figure><p>显然，<code>...</code> （即可变参数列表）无法提供参数的个数和类型。值得一提的是，<code>printf</code> 中的 <code>f</code> 就是指的 <code>format</code> 。</p></blockquote><p>这么说原因大家可能还不太明白什么意思，下面笔者用代码进行解释，先来看普通函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">    test(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件生成的反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line">   4:   83 e4 f0                and    esp,0xfffffff0</span><br><span class="line">   7:   ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line">   a:   55                      push   ebp</span><br><span class="line">   b:   89 e5                   mov    ebp,esp</span><br><span class="line">   d:   51                      push   ecx</span><br><span class="line">   e:   83 ec 14                sub    esp,0x14</span><br><span class="line">  11:   c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">  18:   66 c7 45 f2 02 00       mov    WORD PTR [ebp-0xe],0x2</span><br><span class="line">  1e:   c6 45 f1 03             mov    BYTE PTR [ebp-0xf],0x3</span><br><span class="line">  22:   0f be 55 f1             movsx  edx,BYTE PTR [ebp-0xf]</span><br><span class="line">  26:   0f bf 45 f2             movsx  eax,WORD PTR [ebp-0xe]</span><br><span class="line">  2a:   83 ec 04                sub    esp,0x4</span><br><span class="line">  2d:   52                      push   edx</span><br><span class="line">  2e:   50                      push   eax</span><br><span class="line">  2f:   ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line">  32:   e8 fc ff ff ff          call   33 &lt;main+0x33&gt;</span><br><span class="line">  37:   83 c4 10                add    esp,0x10</span><br><span class="line">  3a:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3f:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">  42:   c9                      leave  </span><br><span class="line">  43:   8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line">  46:   c3                      ret    </span><br><span class="line"></span><br><span class="line">00000047 &lt;test&gt;:</span><br><span class="line">  47:   55                      push   ebp</span><br><span class="line">  48:   89 e5                   mov    ebp,esp</span><br><span class="line">  4a:   83 ec 08                sub    esp,0x8</span><br><span class="line">  4d:   8b 55 0c                mov    edx,DWORD PTR [ebp+0xc]</span><br><span class="line">  50:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">  53:   66 89 55 fc             mov    WORD PTR [ebp-0x4],dx</span><br><span class="line">  57:   88 45 f8                mov    BYTE PTR [ebp-0x8],al</span><br><span class="line">  5a:   c7 45 08 0a 00 00 00    mov    DWORD PTR [ebp+0x8],0xa</span><br><span class="line">  61:   66 c7 45 fc 0b 00       mov    WORD PTR [ebp-0x4],0xb</span><br><span class="line">  67:   c6 45 f8 0c             mov    BYTE PTR [ebp-0x8],0xc</span><br><span class="line">  6b:   90                      nop</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   c3                      ret  </span><br></pre></td></tr></table></figure><p>从第 34~36 行就可以看出参数类型的区别：int、short、char 对应的反汇编分别为 DWORD、WORD、BYTE ，也就是说，编译器为不同的类型生成了不同的代码。</p><blockquote><p>笔者以前想当然地认为函数参数类型影响的是压栈的字节数，比如将 char 压入栈，对应的反汇编就应该为 <code>push BYTE PTR [xxx]</code> ；实际上并非如此，<strong><font color='orange'>不论是 char、short、int 或是 long、long long，编译器都会压入 4 字节（对于 long long 8 字节，分两次压入）</font></strong> ，这点从 15~17 行就能体现。所以参数类型影响的不是压栈，而影响的是从栈中取值或赋值。</p></blockquote><p>那么对于可变参数列表，默认参数提升是如何体现的呢？待会讲解 <code>printf</code> 源码时再回过头来说这点。</p><h3 id="font-color-red-可变参数的类型检查-font"><font color='red'>可变参数的类型检查</font></h3><p>还是由于可变参数列表无法提供参数类型，所以编译器无法对参数进行类型检查，换句话说，<strong>编译器不能执行默认的类型转换，通常也不会报错</strong> 。对于普通函数而言，如果实参和形参类型不匹配，编译器会将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153040201.png" alt=""></p><p>而对于可变参数函数，编译器则无法将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153229945.png" alt=""><br>所以程序员必须自己确保参数类型的匹配或手动强制转换。</p><h3 id="font-color-red-可变参数函数实现原理-font"><font color='red'>可变参数函数实现原理</font></h3><p>想要实现可变参数，最重要的是明白其函数的调用方式，如果没有特定的<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>，可变参数将无从谈起。<strong><u>可变参数函数的调用方式必须满足以下两个条件：</u></strong></p><ol><li><p><strong><font color='orange'>从右向左压栈</font></strong></p><blockquote><p>为什么要从右往左入栈？ 因为如果从左向右，编译器就不知道用户传入了多少实参。参数的信息是由第一个参数 <code>fmt...</code> 确定的（如 <code>printf (“% s % s”,str1 ,str2)</code> 的参数信息是通过检测两个 <code>%s</code> 来获取的）。若从左向右压栈，<code>fmt...</code> 就被放入了栈底，而 esp 由于不清楚参数个数和类型，就无法跨过这些参数来指向 <code>fmt...</code> ，因此无法获取各个参数的信息。相反，若从右向左压栈，<code>fmt...</code> 就存放在栈顶，这样就可以直接通过它得知参数的个数和类型，进而准确从栈中取得各个参数。</p></blockquote></li><li><p><strong><font color='orange'>外平栈（调用者平栈）</font></strong></p><blockquote><p>必须由调用者平栈的原因是：只有调用者才知道压入了几个参数，所以也只能由调用者进行平栈。读者可能感到疑惑，为什么只有调用者才知道压入了几个参数？仍然拿 <code>printf</code> 举例，是这样的：<code>printf</code> 作为库函数，是提前被编译好了的（一般作为动态链接库），最后直接与我们自己编写生成的可重定位文件链接在一起，从而生成可执行文件；所以 <code>printf</code> 完全不知道实际压入了多少个参数（因为压参是由我们的编译器进行的）！因此也就无法由 <code>printf</code> 自己来完成平栈。相反，如果是调用方本身来调用的 <code>printf</code> ，理所应当地，调用方就知道自己向栈中压入了多少个参数，所以调用方就可以承担平栈任务，如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d  %c&quot;, 1, 2);</span><br><span class="line">&#125;</span><br><span class="line">//对应汇编：</span><br><span class="line">//......省略</span><br><span class="line">00BF17E1  push        2  </span><br><span class="line">00BF17E3  push        1  </span><br><span class="line">00BF17E5  push        offset string &quot;%d\n&quot; (0BF7BD8h)  </span><br><span class="line">00BF17EA  call        _printf  </span><br><span class="line">00BF17EF  add         esp,0Ch  </span><br><span class="line">//......省略</span><br></pre></td></tr></table></figure><p>call 之前，编译器 push 了三次，所以它当然知道平栈需要 add esp,0xC ！而 printf 是已经编好的库，它就不知道 push 了几次。</p></blockquote></li></ol><p>而 __cdel 调用约定就符合以上两个规则，所以可变参函数必须使用此方式。值得一提的是，__cdel 是 C/C++ 默认方式。<br>有了以上两种条件的支持，现在无非就是处理 <code>fmt...</code> 获取参数信息，然后从栈中取得参数即可。这就是咋们接下来要干的事。</p><h3 id="font-color-red-其他注意事项-font"><font color='red'>其他注意事项</font></h3><p><strong><mark class="hl-label blue">需要打印%咋办？</mark> </strong><br>这点相信大部分读者都清楚，打印百分号需要再加个百分号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是百分号%%&quot;</span>);</span><br></pre></td></tr></table></figure><p>很多小白会在 <code>%</code> 前加 <code>\</code> ，即 <code>printf(&quot;\%&quot;)</code> 来输出百分号。出现这种想法是因为没有理解转义字符的意义，要知道，<code>\n</code> 是一个 ASCII 码（10），由编译器负责将 <code>\n</code> 转为 10 。而 <code>\%</code> 可不是转义字符，对 <code>%</code> 的处理是由我们的代码负责，而不是由编译器负责！</p><p><strong><mark class="hl-label blue">printf实参问题</mark> </strong><br>很多读者应该都像下面这种方式调用过 printf 吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>这种方式有什么不对吗？结果正确，但这种调用方式十分危险。这是因为，<code>110</code> 没有指明类型，所以根据前面的默认参数提升，<code>110</code> 被视为 int，这符合 <code>%d</code> ，所以能够正确输出。但是碰到下面这种情况呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>结果就变得诡异，输出如下：<br><img src="/2022/img/image-20230110115919374.png" alt=""><br>这是因为 <code>110</code> 被编译器视为 int（4字节)，但 printf 内部代码根据 <code>%lld</code> 将 <code>110</code> 视为 long long（8字节)，在定位参数时，将 long long* 指针指向 <code>110</code> 所在的位置，那么用该指针解释数据的时候，将会把 <code>110</code> 后面的四字节包含进去，而这四字节中的数据是未定义的，所以造成以上错误。再来看下面的调用：<br><img src="/2022/img/image-20230110130458876.png" alt=""><br>怎么这种情况又能够正确显示呢？这是因为编译器判定 <code>0xfffffffff</code> 无法用 int 装下，所以该值的类型就变为了 long long，因此能够正确输出。正确的调用方式需要加上强制转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>看完 printf 源码后，你会对上述行为有深刻理解。</p><h3 id="font-color-red-printf源码剖析-font"><font color='red'>printf源码剖析</font></h3><blockquote><p><strong>说明：</strong></p><ul><li>以下源码来自 Linux 0.11 ，也就是 Linus Torvalds 编写的初代 Linux ，所以其功能肯定不如现在的 printf 强大，这点读者需要清楚。</li><li>printk（print kernel）和 printf 的功能完全相同，只不过前者是在内核中使用的打印函数，而后者是在用户态中使用的打印函数。</li><li>为了契合咋们的操作系统，笔者会将 printk 作轻微修改，使其能够在用户态下使用（此时也就变成了 printf ），这不会影响对 printf 的理解。</li></ul></blockquote><p>以下是原版的 <code>printk</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">va_start(args, fmt);</span><br><span class="line">i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">va_end(args);</span><br><span class="line">__asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $_buf\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;call _tty_write\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>提供原版的 printk 只是为了与下面咋们改进后的 printf 形成对比，大家无需纠结上面的代码</u>。以下是我们操作系统的 <code>printf</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> </span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="type">int</span> i = write(buf);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可见，除了第 9 行外，其他完全相同。实际上，第 9 行将最终的字符串传给我们之前实现的系统调用 write，由 write 进行打印。另外，<strong><font color='orange'>正因为 write 是系统调用，所以该 printf 既可以供内核使用，也可以供用户使用</font></strong> 。</li><li><code>printf</code> 返回字符个数。</li></ul><p>接下来重点说明处理可变参数的四个宏： <code>va_list</code> 、<code>va_start</code> 、<code>va_end</code> 和 <code>va_arg</code> 。</p><p><strong><mark class="hl-label blue">可变参数宏</mark> </strong><br>首先要破除大家的先入为主，别以为这四个宏是用来处理可变参数的，就觉得它们高大上，有什么特异功能，实际上这四个家伙的本质就普普通通：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(p, fmt) (p = (char*)&amp;fmt + sizeof(char*))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(p)        (p = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(p, type)  (p += __va_rounded_size(type), *((type*)(p - __va_rounded_size (type))))</span></span><br></pre></td></tr></table></figure><ul><li><p><em><em><code>va_list</code> <u>就是 char</em> 指针类型，该指针（args）用来在栈中依次遍历各个参数</u></em>* 。</p></li><li><p><strong><code>va_start</code> <u>的作用是将 args 指针指向参数列表（即 <code>...</code> ）中的第一个参数</u></strong> 。</p><blockquote><p><code>p = (char*)&amp;fmt + sizeof(char*)</code> 就是令 p 跳过栈中的 fmt ，指向栈中的下一个参数，即参数列表中的第一个参数。注意必须对 fmt 取地址，得到该指针的地址，也就是该指针在栈中的位置，<code>&amp;fmt</code> 为二级指针，还需要强制转换为一级指针 char* 。</p></blockquote></li><li><p><strong><code>va_end</code> <u>的作用是将 args 指针置 NULL</u></strong> 。</p></li><li><p><code>va_arg</code> 出现在下面的 <code>vsprintf</code> 函数中，<strong><u><code>va_arg</code> 的作用是返回当前 args 指向的参数的值，然后 args 向后移动，指向下一个参数</u></strong> 。</p><blockquote><p><code>__va_rounded_size(type)</code> 也是一个宏，<strong><u>用来得到取整后的 type 类型的大小，是 int 的整数倍</u></strong> ，比如 type 为 char，则返回 4；type 为 long long，则返回 8 ，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __va_rounded_size(type)  \</span></span><br><span class="line"><span class="meta">  (((sizeof (type) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span></span><br></pre></td></tr></table></figure><p>注意，va_arg 宏定义是一个逗号表达式，第一个表达式<u>根据目前所指参数 A 的大小</u>，将指针 p 移向了下一个参数 B（+=，p的值已经被改变）；接着将 A 的值返回（逗号表达式中的最后一个式子作为返回值）。顺便提一下，如果按照《操作系统真相还原》中的代码，将无法应对 long long 的情况。</p></blockquote></li></ul><p>接着来看 vsprintf 。</p><p><strong><mark class="hl-label blue">vsprintf</mark> </strong><br><strong>vsprintf 的作用是格式化字符串，也就是将参数列表中的所有参数值填入到 fmt 中的对应位置，并将最终的字符串存入 buf</strong> 。<code>fmt</code> 中的格式符，如 <code>%d</code> 、<code>%s</code> 等都在此函数中进行处理。在讲解该函数代码前，有必要先复习 printf 的用法，否则看代码时将一头雾水。</p><p>我们将 <code>%s</code> 这样的格式称之为一个 format 标签，format 标签的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure><p>比如下面这样的 printf 调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10ld&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中的 <code>-</code> 为 flags，即指明左对齐；<code>10</code> 为 width，即指明输出宽度；<code>l</code> 为长度，对于 <code>d</code> 而言，即输出长整型 long；<code>d</code> 为 specifier，指明输出整型。<br>具体规则如下：</p><table><thead><tr><th><strong>flags</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>-</strong></td><td>在给定的字段宽度内左对齐，默认是右对齐</td></tr><tr><td><strong>+</strong></td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td><strong>空格</strong></td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td><strong>#</strong></td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。由于本操作系统暂不支持小数，所以不说明 # 对 f、e、g 等说明符的影响。</td></tr><tr><td><strong>0</strong></td><td>在左边填充零，而不是空格</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>width</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>number</strong></td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充；如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定宽度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>.number</strong></td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 <br />对于 s：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 <br />对于 c：没有任何影响。 当未指定任何精度时，默认为 1。</td></tr><tr><td style="text-align:left"><strong>.</strong>*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定精度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>length</strong></th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>h</strong></td><td style="text-align:left">参数被解释为短整型或无符号短整型 short（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left"><strong>l</strong></td><td style="text-align:left">参数被解释为长整型或无符号长整型 long，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left"><strong>L</strong></td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。本操作系统不支持。</td></tr><tr><td style="text-align:left"><strong>ll</strong></td><td style="text-align:left">本操作系统中，ll 仅被解释为 <strong>无符号 long long</strong>，适用于整数说明符。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">和 d 完全相同</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">到目前为止成功写入缓冲区的字符数，此值存储在指定的整数中，其地址作为参数给出。</td></tr></tbody></table><p>下面做几个示范：<br><img src="/2022/img/image-20230109092042387.png" alt=""><br><img src="/2022/img/image-20230109092442698.png" alt=""><br><img src="/2022/img/image-20230109094520482.png" alt="由于安全原因，VS默认禁止使用%n，所以此处用 Bochs 代替"></p><p>了解以上格式后，再来看 vsprintf 就十分轻松啦，总的来说，该函数就是在依次处理 flags --&gt; width --&gt; .precision --&gt; length --&gt; specifier 。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成2的倍数,是因为我们将flag变量视为位图,将属性保存到各个二进制位上</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">int</span> flags;          <span class="comment">// flags to number() </span></span><br><span class="line"><span class="type">int</span> field_width;    <span class="comment">// width of output field </span></span><br><span class="line"><span class="type">int</span> precision;      <span class="comment">// min of digits for integers; max number of chars for from string </span></span><br><span class="line"><span class="type">int</span> qualifier;      <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (str=buf ; *fmt ; ++fmt) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//如果不是format标签,则直接复制到str</span></span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//处理flags</span></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">repeat:</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理输出宽度</span></span><br><span class="line">field_width = <span class="number">-1</span>; <span class="comment">//默认为-1,即未指示宽度,因为 flag | -1 = flag</span></span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">field_width = skip_atoi(&amp;fmt); <span class="comment">//skip_atoi将字符转为数字,后文给出</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则width由下一个参数给出 </span></span><br><span class="line"><span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)  <span class="comment">//若宽度参数小于0,则左靠齐,和&#x27;-&#x27;号效果相同</span></span><br><span class="line">&#123;</span><br><span class="line">field_width = -field_width;</span><br><span class="line">flags |= LEFT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理精度</span></span><br><span class="line">precision = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">precision = skip_atoi(&amp;fmt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">precision = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则precision由下一个参数给出 </span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理长度描述符符</span></span><br><span class="line">qualifier = <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">qualifier = *fmt;  <span class="comment">//实际上,后面就没有用到qualifier了,显得鸡肋</span></span><br><span class="line">++fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理格式字符</span></span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT)) <span class="comment">//如果不是左靠齐,则左边补field_width-1个空格</span></span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">*str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) <span class="comment">//否则后方补空格</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) <span class="comment">//如果字符串长度大于精度,则丢弃超过精度的部分</span></span><br><span class="line">len = precision;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">*str++ = *s++;</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)<span class="comment">//如果执行了上面的while,此处就不会再执行</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:  <span class="comment">//number函数用来将数字转换为字符串</span></span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="comment">//按十六进制输出指针,宽度为8,宽度不足则补前导0</span></span><br><span class="line"><span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">field_width = <span class="number">8</span>;</span><br><span class="line">flags |= ZEROPAD;</span><br><span class="line">&#125;</span><br><span class="line">str = number(str,(<span class="type">unsigned</span> <span class="type">int</span>)va_arg(args,<span class="type">void</span>*), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">flags |= SMALL;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">flags |= SIGN;  <span class="comment">//%d和%i都是有符号数</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">*ip = (str - buf); <span class="comment">//返回目前字符串的宽度</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若格式转换符不是&#x27;%,则表示格式字符串有错,直接将一个%写入输出串中;如果格式转换符的位置处还有字符,则也直接将该字符写入输</span></span><br><span class="line">        <span class="comment">//出串中,并返回到107行继续处理格式字符串;否则表示已经处理到格式字符串的结尾处,则退出循环。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt)</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">--fmt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释得比较清楚，对照之前的规则来看代码就很容易理清其中的逻辑，不再详细说明。提一点，看第 90 行，<code>va_arg(args, int)</code> ，这说明从栈中取字符时，是以 int 大小来取的（ <strong><u><font color='orange'>这里就体现了默认参数提升</font></u></strong> ），然后再被强制转换为 char 。为什么不能 <code>va_arg(args,char)</code> 呢？实际上这样完全能够准确获取栈中字符的值，但如果这样的话，下一次使用 va_arg 宏取参数时，args 指针就指向了该字符的下一字节，但下一个参数应该是在该字符的四字节后，这无疑将引发错误，图示如下：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE35.png" alt=""></p><p>代码中还用到了 skip_atoi() 和 number() 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//判断是否为数字字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \    <span class="comment">// n=n/base,并返回n%base</span></span></span><br><span class="line"><span class="type">int</span> __res; \                   <span class="comment">//宏定义采用大括号的方式,最后一条语句作为返回值</span></span><br><span class="line">__asm__(<span class="string">&quot;div %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (n),<span class="string">&quot;=d&quot;</span> (__res):<span class="string">&quot;0&quot;</span> (n),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),<span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">__res; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span><span class="comment">//pointer to fmt,即fmt的指针,所以该指针为二级指针</span></span><br><span class="line">&#123;                                      <span class="comment">//为什么要用二级指针?因为咋们要在函数中修改fmt的值(不仅是修改形参,实参也要修改)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;                           <span class="comment">//由于fmt是指针,所以要修改指针的值,就需要用二级指针</span></span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//(*fmtp)++,就是fmt++</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SMALL) </span><br><span class="line">digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;LEFT) </span><br><span class="line">type &amp;= ~ZEROPAD; <span class="comment">//如果为左对齐,则无需0填充</span></span><br><span class="line"><span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>) <span class="comment">//仅支持2~36进制,否则返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">num = -num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);<span class="comment">//要么+,要么空1格</span></span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">size--; <span class="comment">//如果有符号或空格,则占一位</span></span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">size -= <span class="number">2</span>; <span class="comment">//0x占两位</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">size--;    <span class="comment">//0占一位</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 以下开始处理数字</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">tmp[i++]=digits[ do_div(num,base) ]; <span class="comment">//依次取得num的最低位数字,并填入tmp,</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;precision)                     <span class="comment">//此时顺序是反的,第72行会调整顺序</span></span><br><span class="line">precision=i; <span class="comment">//如果数字个数大于精度,不会截断,精度成鸡肋</span></span><br><span class="line">size -= precision;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">*str++ = sign;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">&#123;</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">*str++ = digits[<span class="number">33</span>]; <span class="comment">//&#x27;X&#x27;或&#x27;x&#x27;,取决于digit的指向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>) <span class="comment">//如果是右靠齐,则补前导0或前导空格</span></span><br><span class="line">*str++ = c;</span><br><span class="line"><span class="keyword">while</span>(i&lt;precision--)<span class="comment">//精度大于数字个数,则补前导0</span></span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = tmp[i];<span class="comment">//i--,str++,调整数字顺序</span></span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果67行已经执行,此处就不会再执行</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释详尽，不再说明。<br>值得一提的是，该版 printf 有许多不足，例如不支持 <code>%hd</code> (short)，<code>%lld</code> (long long) ，下节<a href="https://jyx-fyh.github.io/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/">printf加强版</a>中我们会增加这两个功能。<br><img src="/2022/img/image-20230110134655302.png" alt=""></p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现用户进程-代码详解</title>
      <link href="/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程-进入用户态</a><br>本节对应分支：<code>userprog</code></p></blockquote><h3 id="font-color-red-初始化TSS、C语言接管GDT-font"><font color='red'>初始化TSS、C语言接管GDT</font></h3><p>下面是 <code>global.h</code> 中添加的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="comment">//=============用户进程的段选择子================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_CODE   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span></span><br><span class="line"><span class="comment">// ===============GDT描述符属性=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_G_4K    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_D_32    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_L     0<span class="comment">// 64位代码标记，此处标记为0便可。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_AVL     0<span class="comment">// cpu不用此位，暂置为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_P     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_1   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_2   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_3   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_CODE1       <span class="comment">// s为1时表示存储段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_DATADESC_S_CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_SYS0       <span class="comment">// s为0时表示系统段.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_CODE8<span class="comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_DATA  2<span class="comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_TSS   9<span class="comment">// B位为0,不忙</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ATTR_HIGH     ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_CODE_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_DATA_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span></span><br><span class="line"><span class="comment">//================ TSS描述符属性===================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_DESC_D  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_LOW ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_TSS ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2 ) + RPL0)</span></span><br><span class="line"><span class="comment">//================ GDT描述符 =====================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit_low_word;</span><br><span class="line">    <span class="type">uint16_t</span> base_low_word;</span><br><span class="line">    <span class="type">uint8_t</span>  base_mid_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  attr_low_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  limit_high_attr_high;</span><br><span class="line">    <span class="type">uint8_t</span>  base_high_byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第 3~5 行定义了用户进程的段选择子，其中代码段选择子索引为 5，即用户代码段的描述符位于 GDT 的第 5 号描述符的位置处；数据段和栈段共享一个描述符，选择子索引为 6 。你可能会疑惑，为什么只定义了一套用户的选择子，万一将来有多个用户进程同时运行，这几个选择子岂不是不够用？实际上只需要一套用户选择子就可以了，<strong><font color='orange'>因为所有用户进程都共享这一套选择子</font></strong> 。为什么可以共享呢？这便体现出虚拟空间下平坦模型的优越性了。<strong><font color='orange'><u>因为每个进程都有自己独立的虚拟地址空间，平坦模型下数据段和代码段描述符的基址直接设为 0，所以执行流只取决于 EIP 而依赖 CS。反观分段模型，由于没有虚拟地址空间，各个用户进程被分配到不同区域的物理内存中，所以为了隔离它们，每个用户进程的段基址都不相同，因此需要为每个用户进程都分配一套段选择子和段描述符</u></font></strong> ，不仅管理繁琐，而且效率低下。<br>另外，当初咋们在 <code>loader.s</code> 中设计 GDT 表时，并没有为用户和 TSS 预留段描述符，所以现在必须在 <code>loader.s</code> 中加上一行代码以预留空间：<br><img src="/2022/img/image-20230103153548106.png" style="zoom:100%;" /></li><li>之前是在 <code>loader.s</code> 中直接书写 GDT ，为了方便，现在我们使用 C 语言接管 GDT，以方便在 GDT 中添加和修改段描述符。所以在头文件中定义了段描述符和 TSS 描述符的各个属性以及段描述符的结构体 <code>gdt_struct</code> 。关于各个位的解释，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">GDT</a> 。</li></ul><p>下面是 <code>tss.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">gdt_operand</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> tss_slt;</span><br><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> backlink;</span><br><span class="line">    <span class="type">uint32_t</span>* esp0;</span><br><span class="line">    <span class="type">uint32_t</span> ss0;</span><br><span class="line">    <span class="type">uint32_t</span>* esp1;</span><br><span class="line">    <span class="type">uint32_t</span> ss1;</span><br><span class="line">    <span class="type">uint32_t</span>* esp2;</span><br><span class="line">    <span class="type">uint32_t</span> ss2;</span><br><span class="line">    <span class="type">uint32_t</span> cr3;</span><br><span class="line">    <span class="type">uint32_t</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> ldt;</span><br><span class="line">    <span class="type">uint32_t</span> trace;</span><br><span class="line">    <span class="type">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新tss中esp0字段的值为pthread的0级线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tss_esp</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    tss.esp0 = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建gdt描述符 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gdt_desc <span class="title function_">make_gdt_desc</span><span class="params">(<span class="type">uint32_t</span>* desc_addr, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> attr_low, <span class="type">uint8_t</span> attr_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> desc_base = (<span class="type">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="type">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="type">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在gdt中创建tss并重新加载gdt */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tss_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"><span class="comment">/* gdt基址为0x910,把tss放到第4个位置,也就是0x910+0x20的位置 */</span></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">   *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000930</span>)  = make_gdt_desc((<span class="type">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000940</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    load_xdt(&amp;gdt_operand,<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>,<span class="number">0xc0000910</span>);</span><br><span class="line">    tss_slt = SELECTOR_TSS;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lgdt gdt_operand&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ltr tss_slt&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init and ltr done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4~33 行定义了 TSS 结构，这没有太多要说的，有个小问题是，结构体定义不应该放在头文件中吗，这里为什么要放在 C 文件中呢？是不是不太规范？这也是笔者之前的误解，原以为只要是宏定义或者结构体定义一类的都应该放在头文件，而 C 文件中只放函数定义，这样才显得规范。实际上并不是如此，原则应该是：<strong><font color='orange'>如果其可见性超出一个 .c 文件，那么应当放入 .h 中，如果只是某一个 .c 里需要这么一个结构作为辅助，直接放入这个.c中更好一些</font></strong> 。放在 .c 还是 .h 取决于该结构是否要暴露给其他 .c，能放 .c 绝不放 .h 。而 TSS 结构只会在此文件中使用，所以就定义在此 .c 文件中。</li><li>第 37 行，update_tss_esp() 用来将 TSS 中 esp0 字段的值更新为 pthread 的内核线。如上节内容所说，所有任务共享一个 TSS，只是在任务切换时更新 ESP0 的值。</li><li>第 61 行，将 TSS 的 io_base 字段设置为 TSS 的大小，这表示此 TSS 中没有 IO 位图。</li><li>第 62 行，GDT 的基址为 0x910，这是如何确定的？见下面 <code>loader.s</code> 的片段即可知道。<br><img src="/2022/img/image-20230105121240944.png" style="zoom:67%;" /></li><li>第 69 行的 load_xdt 函数，咋们之前用它设置过 IDTR，定义在 global.h 中。gdt_operand 是加载 GDT 时用的操作数，设置好 gdt_operand 的基址和界限后，第 71 行便使用内联汇编 <code>lgdt</code> 指令加载 GDTR。至于为什么要将 gdt_operand 和 tss_slt 定义为全局静态变量，这在之前的文章中反复提及过，不再赘述。同理，第 72 行使用 <code>ltr</code> 指令将 TSS 的选择子 tss_slt 加载进 TR 寄存器，由于 TSS 只有一个，所以只会加载这一次，以后就不会再修改 TR 了。</li></ul><h3 id="font-color-red-用户进程的虚拟地址空间-font"><font color='red'>用户进程的虚拟地址空间</font></h3><p>在<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础篇</a>中，我们划出了三个内存池：内核物理内存池、内核虚拟内存池、用户物理内存池。为了实现用户进程的虚拟地址空间，我们还需要给每个进程设置私有的用户虚拟内存池。见以下步骤。</p><p><strong><mark class="hl-label blue">在task_struct中添加虚拟内存池</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       <span class="comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> <span class="comment">// general_tag的作用是用于线程在一般队列中的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span><span class="comment">// all_list_tag的作用是用于线程队列thread_all_list中的结点</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              <span class="comment">// 进程页表</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span>   <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 14 行即为用户进程的虚拟内存池。</p><p><strong><mark class="hl-label blue">用户虚拟内存管理</mark> </strong><br>在 <a href="">内存管理-进阶</a>中，我们留下了部分内容等到实现用户进程时补充，如下：<br><img src="/2022/img/image-20230105154723658.png" style="zoom:67%;" /><br>第 33 行的作用和其上内核部分的代码相似，都是在申请虚拟内存。以下代码补齐这部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct* cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">        <span class="comment">/*0xc0000000-PAGE_SIZE作为3级用户栈已经在start_process中被分配*/</span></span><br><span class="line">        assert((<span class="type">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>逻辑清晰，不再解释。另外还添加了几个必要的内存管理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_user_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="type">void</span>* vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将地址vaddr与pf池中的物理地址关联,仅支持一页空间分配 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_a_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="type">int32_t</span> bit_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;pgdir != <span class="literal">NULL</span> &amp;&amp; pf == PF_USER)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;pgdir == <span class="literal">NULL</span> &amp;&amp; pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span></span><br><span class="line">        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        panic(<span class="string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">    <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">    lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址映射到的物理地址 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">addr_v2p</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"><span class="comment">/* (*pte)的值是页表所在的物理页框地址,</span></span><br><span class="line"><span class="comment"> * 去掉其低12位的页表项属性+虚拟地址vaddr的低12位 */</span></span><br><span class="line">    <span class="keyword">return</span> ((*pte &amp; <span class="number">0xfffff000</span>) + (vaddr &amp; <span class="number">0x00000fff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>get_user_pages 和 get_kernel_page 的逻辑完全相同，不再赘述。提一下，笔者在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶</a>中提到过如下内容：</p><blockquote><p>扫描和设置位图必须连续，中间不能切换线程 。这里和线程切换有关，简单解释：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题 。因此扫描和设置位图必须保证原子操作。需要注意的是，此处代码并没有保证原子性，未来我们会用锁来实现 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></blockquote><p>现在咋们已经实现了锁机制，所以这里申请内存时用锁来保证原子性。锁加在 pool 结构体中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span>                      //管理物理内存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 本内存池字节容量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>            <span class="comment">// 保证内存申请时的原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第 13 行定义 get_a_page 函数，该函数与 get_kernel_page 或 get_user_page 的差别在于前者能够申请指定位置的虚拟内存，而后者则无法指定位置。该函数待会用来指定在 0xc0000000 处申请一页虚拟内存作用户栈。</p></li><li><p>addr_v2p 函数，其中 2 和 to 同音，即 addr_v_to_p，功能是将虚拟地址 vaddr 转换为对应的物理地址。下面咋们马上就会用到此函数。</p></li></ul><p><strong><mark class="hl-label blue">创建用户进程</mark> </strong><br>这部分内容很多，打起精神啦！</p><p>在中断栈中构建用户进程的上下文时，需要设置 eflags 寄存器，所以在 global 中定义好 eflags 的属性位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:global.h</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_MBS(1 &lt;&lt; 1)        <span class="comment">// 该位保留,总是为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_1(1 &lt;&lt; 9)        <span class="comment">// if为1,开中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_00               <span class="comment">// if为0,关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_3(3 &lt;&lt; 12)   <span class="comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_0(0 &lt;&lt; 12)   <span class="comment">// IOPL0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_ROUND_UP(X, STEP) ((X + STEP - 1) / (STEP)) <span class="comment">//用于除法的向上取整,如2/3=1</span></span></span><br></pre></td></tr></table></figure><p>下面则开始创建用户进程，<strong><font color='orange'>注意上节中的进程创建流程图对比</font></strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:process.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">proc_stack</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pagedir_phy_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">intr_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_process</span><span class="params">(<span class="type">void</span>* filename_)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* function = filename_;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);   <span class="comment">//跨过thread_stack,指向intr_stack</span></span><br><span class="line">    proc_stack = (<span class="keyword">struct</span> intr_stack*)cur-&gt;self_kstack; <span class="comment">//可以不用定义成结构体指针</span></span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>;          <span class="comment">// 不允许用户态直接访问显存资源,用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function; <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="type">void</span>*)((<span class="type">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,proc_stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;jmp intr_exit&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 击活页表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_dir_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">     * 执行此函数时,当前任务可能是线程。</span></span><br><span class="line"><span class="comment">     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,</span></span><br><span class="line"><span class="comment">     * 否则不恢复页表的话,线程就会使用进程的页表了。</span></span><br><span class="line"><span class="comment">     ********************************************************/</span></span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    pagedir_phy_addr = <span class="number">0x100000</span>;  <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)  <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov eax,pagedir_phy_addr&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov cr3,eax&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 激活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0特权级,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0*/</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建页目录表,将当前页表的表示内核空间的pde复制,</span></span><br><span class="line"><span class="comment"> * 成功则返回页目录的虚拟地址,否则返回-1 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">create_page_dir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页目录表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">&quot;create_page_dir: get_kernel_page failed!&quot;</span>,FT_RED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span>*<span class="number">4</span>), (<span class="type">uint32_t</span>*)(<span class="number">0xfffff000</span>+<span class="number">0x300</span>*<span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_user_vaddr_bitmap</span><span class="params">(<span class="keyword">struct</span> task_struct* user_prog)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_execute</span><span class="params">(<span class="type">void</span>* filename, <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 **/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, DEFUALT_PRIO);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);<span class="comment">//start_process(filename)</span></span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>start_process 中，proc_stack 结构体指向中断栈，并初始化进程上下文。</p></li><li><p>第 9 行，需要说明的是，用户进程一般是硬盘中的一段程序，需要加载到内存，然后再运行，所以进程的定义就是“运行中的程序”。<strong>但目前我们还没有实现硬盘驱动程序和文件系统，所以用户进程只能由一个函数代替</strong> ，实际上，这两者也没有本质区别。</p></li><li><p>第 15 行，由于 <strong><font color='orange'>用户不能直接使用显存</font></strong>，所以将 gs 直接初始化为 0，则用户使用该选择子时，会索引到 GDT 的第 0 号描述符而引发异常。</p></li><li><p>第 20 行，调用 get_a_page() 在指定位置，即用户空间 3GB 顶端处申请一页内存用来作用户栈，这在之前有所提及。</p><blockquote><p>用户栈只有一页吗？笔者暂不清楚当栈使用超过一页会发生什么，后续补充。</p></blockquote></li><li><p>第 23 行，intr_exit 是从 <code>interrupt.s</code> 引入的函数，专门处理中断返回。这没有什么好说的，只是为了复用代码，也可以直接在 23 行处使用内联汇编连续弹栈并 <code>iret</code> 。<code>iret</code> 后执行流就转移到用户进程啦！</p></li><li><p>第 27 行，page_dir_active，页表激活函数。从流程图中可以看见，该函数在 schedule() 中被调用，如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.c</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    process_activate(next);</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong><u>每当任务切换(swtich_to)前，都会重新激活页表</u></strong> ，这不禁引发我们的疑惑：不是进程才有独立的地址空间吗？怎么连线程都要激活页表了呢？其实这可以在上节<a href="">进程的实现方式</a>找到答案。在 Linux 中，<strong><u>多个地址空间相同的线程组成了一个进程</u></strong> ，所以线程也需要记录页表。需要注意的是，<strong><font color='gree'>目前我们只实现了内核线程(thread_start) 和用户进程 (process_execute)，还未实现用户线程</font></strong>  (未来看情况按需添加)，所以 task_struct 中的 pgdir 只分为两种情况：NULL 和其他值；如果为 NULL，则说明该任务为内核线程；如果为非 NULL，则说明该任务为用户进程。<br>另外，<strong>第 40 行加载 cr3 有大坑！</strong> 还记得吗，在<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>一文中，笔者将内核的起始虚拟地址设置为了 0x1500，并提醒读者未来这个 0x1500 会留下问题。这个问题就在此处浮现：首次切换页表之前，执行流一直位于内核进程中，而内核进程虚拟空间的低 1MB 和高 3GB 处都是内核（这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中早有说明，忘记的读者请回头复习）。又因为之前将内核的起始虚拟地址设置为了 0x1500，所以一直以来内核始终运行在低端 1MB 处，而非高 3GB 处。关键来了，当内核执行流运行到第 40 行切换页表时，切换前执行流位于 1MB 下，切换后当然也仍位于 1MB 下（因为代码中的地址都是提前编译好的），但是，切换到用户进程的页表后，低端 1MB 就不再是内核啦（对于用户进程而言，内核只位于高 3GB 处）之前说过，用户进程的低端 128MB 为保留，没有任何东西，所以执行流运行在用户进程虚拟空间的低端 1MB 下将必定出错！因此，为了保证切换页表前后执行流能够统一，我们必须将内核的起始虚拟地址设置为 0xc0001500，这样对于内核进程和用户进程来说，内核都运行在高 3GB 上，切换页表前后执行流就不会改变。修改如下：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><blockquote><p>这里也是卡了笔者很久，如果当初不作死修改 Ttext，也不会引发这些问题，但实际上，不就是这些找 Bug 的过程加深了我们对程序的理解吗？</p></blockquote></li><li><p>第 51 行，只有用户进程才会更新 TSS 中的 ESP0，因为从内核进入中断不涉及特权级转移，从用户进程进入中断才会切换到对应的内核栈。</p></li><li><p>第 58 行是笔者期待已久的页表创建函数 create_page_dir()，该函数为用户进程创建对应的页目录表，其任务很简单：1）<strong>申请一页内存用来存放页目录表 <strong>；2）</strong><u>将内核页目录的第 768~1022 项复制到用户页目录表的相同位置，从而实现所有用户进程共享内核</u></strong> （这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中重点提到过）；3）将用户进程页目录表的物理地址写入第 1023 号页目录项，这是为了访问页目录表和页表本身，详细原因仍请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。注意，<strong><u>用户进程的页目录表和页表不能安装在用户空间中，而是安装在内核空间里</u></strong> ，否则用户就可能自己修改页表，映射任意的内存地址，访问任何内存，进程间、内核的隔离保护就失去了意义。</p><blockquote><p>另外，不知道读者是否和我一样有这样的疑惑：为什么没有为用户程序本身开辟页表？也就是说，现在只映射了 3~4GB 的内核，而没有映射 0~3GB 的用户空间，那用户程序本身运行在哪？笔者从两个方面来解释此问题：<br>1）由于现在还没有完成硬盘驱动和文件系统，所以只能使用函数（如下面的u_prog_a、u_prog_b）来代替用户程序。而这些函数也是同样定义在 main.c 中，所以它们都会被链接进 kernel.bin，然后载入内核。换句话说，这些函数虽然是用户进程，但也位于 3~4GB 空间中（即使位于内核空间，特权级仍然为 3）。<strong>这只是目前为了演示用户进程而作的妥协</strong> 。<br><img src="/2022/img/image-20230106150001512.png" style="zoom:67%;" /></p><p>2）真正的用户进程加载是从硬盘读取程序并载入内存，进而运行，大致流程是这样的：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  &gt; graph LR&gt; A{创建独立的虚拟空间}--&gt;B{读取可执行文件头}--&gt;C{建立虚拟空间和可执行文件的映射关系}--&gt;D{将EIP设置为可执行文件的入口地址，开始运行}&gt;   </pre></div><p>啊啥？这不是还没将程序加载进内存吗？怎么就开始运行啦？是这样的，比如入口地址为 <code>0x08048000</code> ，<strong><font color='orange'>当执行流运行到该地址时，发现页面 <code>0x08048000~0x08049000</code> 是空页面，于是陷入缺页异常，异常处理程序通过第三步建立的映射关系找到可执行文件中缺失页面对应的部分代码，然后再将该部分载入内存，最后重新运行</font></strong> 。相关详细内容可参考《链接、装载与库》。<br>综上两点考虑，当前无需建立其他部分的映射。</p></blockquote></li><li><p>第 78 行，create_user_vaddr_bitmap() 函数用来为用户进程创建虚拟内存池，以便管理内存空间。其中 USER_VADDR_START 的值即为 <code>0x08048000</code> 。该函数逻辑清晰，不做说明。</p></li><li><p>第 88 行便是 process_execute() 函数。需要说明的是，该函数是在内核中被调用来创建用户进程的，而 fork 函数则是在用户程序中来创建子进程的，两者有巨大区别，将来实现 fork 时还会提到这一点。</p></li></ul><p>大功告成，了解了具体实现后，再来回顾进程创建的整个过程，思路也许会变得更清晰：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><h3 id="font-color-red-运行用户进程-font"><font color='red'>运行用户进程</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> test_var_a = <span class="number">0</span>, test_var_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;argA &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_b&quot;</span>, <span class="number">31</span>, k_thread_b, <span class="string">&quot;argB &quot;</span>);</span><br><span class="line">    process_execute(u_prog_a, <span class="string">&quot;user_prog_a&quot;</span>);</span><br><span class="line">    process_execute(u_prog_b, <span class="string">&quot;user_prog_b&quot;</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_int(test_var_a,FT_RED,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        console_put_int(test_var_b,FT_YELLOW,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而运行结果不尽人意：<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br>可见，运行一段时间后任务就停止了切换。这个 Bug 目前还没有找到，只知道这是锁引起的问题，没办法，只能将锁改为开关中断了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:console.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//console_acquire();</span></span><br><span class="line">    CLI;</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    STI;</span><br><span class="line">    <span class="comment">//console_release();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>再次运行：</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro1.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>现在好多了。关于这个锁的问题，笔者调试了两天还是不知道原因，请知道原因的读者朋友们在评论区留言，感谢！<br>需要说明的是，print 和 console 系列打印函数只能在内核，即 ring0 下使用，在用户进程中调用则会引发 0xd 号异常：<br><img src="/2022/img/image-20230112092402708.png" alt=""><br>所以这里使用两个变量 test_var_b、test_var_a 来间接反映进程的调度情况。</p><p>最后留下一个问题：既然禁止用户直接访问内核，那为什么还要将用户代码段描述符的界限设置为 4GB 呢？这样用户不就能轻松访问高地址的内核了吗？就像下面这样直接在用户态访问显存：<br><img src="/2022/img/image-20230112155046604.png" alt=""><br>既然这样，为什么不将用户代码段的界限设置为 3GB 呢？留给读者思考，笔者将在后续文章给出答案。</p><p>本文结束，下节实现系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现用户进程—进入用户态</title>
      <link href="/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>本文前置内容(必看)：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> ，<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a></strong> ，<a href="https://markrepo.github.io/kernel/2018/08/22/memory/">进程的虚拟内存布局</a>、《装载、链接与库》<br>本节对应代码讲解：<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程-代码详解</a></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong><font color='gree'>操作系统有三大核心功能：内存管理、进程管理、文件管理</font></strong> 。截至目前，我们已经完成了内存管理和进程管理的部分内容，对于内存管理，咋们还差内存回收机制；对于进程管理，由于线程是进程的基础，之前咋们实现了线程，所以进程也就完成了一半；文件管理将在不久后实现文件系统后再进行。</p><h3 id="font-color-red-任务切换的原生方式-font"><font color='red'>任务切换的原生方式</font></h3><p>在 <a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 一文中，我们简单了解过 TSS 与 LDT 的作用，明白了 TSS 和 LDT 只是理想中的任务管理和切换的工具： <strong><font color='orange'>Intel 建议用 TSS 来保存并恢复任务的状态，用 LDT 来保存任务的实体资源</font></strong> 。而考虑到效率问题，现代操作系统并未（完全）使用 TSS 和 LDT 来进行任务切换。至于为什么效率低下，看看其任务切换的具体过程便能体会到：<br>CPU <strong>原生支持</strong> 的任务切换方式有两种：1）中断 + 任务门；2）call / jmp + 任务门；下面分别介绍这两种方式。</p><p><strong><mark class="hl-label blue">中断+任务门</mark> </strong><br>既然是通过中断调用，那么调用方式只能通过中断信号或 int 指令进行，此时任务门也当然是在 IDT 中注册。<br><strong>调用过程如下：</strong></p><ol><li><p>时钟中断发生，处理器自动从该任务门描述符中取出新任务的 TSS 选择子。</p><blockquote><p>之前咋们的时钟中断的向量号对应的是中断门描述符，对应时钟中断处理程序（schedule），而现在我们要使用任务门来切换任务，所以时钟中断向量号就应该指向任务门描述符：<br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>这里笔者有个问题，时钟中断号为 0x20，如果 0x20 指向任务门描述符，那岂不是每次发生时钟中断时，都会切换到同一个任务？那还如何实现任务调度呢？由于我们的操作系统不会使用任务门来进行任务切换（Linux也不会)，所以这里就不深究了，直到答案的读者还请麻烦在评论区指点一二。</p></blockquote></li><li><p>用 TSS 选择子在 GDT 中索引 TSS 描述符。</p></li><li><p>判断该 TSS 描述符的 P 位是否为 1，为 0 则表示对应的 TSS 不在内存中，这将引发异常。</p></li><li><p>从 TR 寄存器中获取旧任务（当前任务）的 TSS 位置，将当前寄存器状态保存到该 TSS 中。</p></li><li><p>将新任务 TSS 中的值加载进相应寄存器。</p></li><li><p>将新任务的 TSS 段选择子加载进 TR 寄存器，这由 CPU 自动完成。</p></li><li><p>将当前任务的 B 位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 。</p></li><li><p>将新任务标志寄存器的 NT  位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>将旧任务的 TSS 选择子写入到新任务 TSS 的 <code>上一个任务的TSS指针</code> 字段中。</p></li><li><p>开始执行新任务。</p></li></ol><p><strong>返回过程如下：</strong></p><ol><li>调用 <code>iret</code> ，检查 NT 位，如果为 1，则应该返回旧任务而非中断返回。</li><li>将当前任务的 NT 位置 0 。</li><li>将当前任务的 TSS 描述符中的 B 位置 0 。</li><li>将寄存器现场保存到当前 TSS 中。</li><li>获取当前 TSS 中 <code>上一任务的TSS指针</code> 字段，将选择子加载进 TR 。</li><li>根据 TR 指向的 TSS 恢复寄存器现场。</li></ol><p><strong><mark class="hl-label blue">call、jmp切换任务</mark> </strong><br>任务门除了可以在 IDT 中注册，还能在 GDT 和 LDT 中注册，当在后两者中注册时，就可以通过 call、jmp 指令来切换任务。call 和 jmp 有所不同，前者有去有回，<strong>所以通过 call 调用的新任务可以认为是旧任务的分支，本质上它们算是同一个任务</strong> ；而 jmp 则是有去无回，新旧任务之间没有关系。<strong><font color='orange'>此二者的区别体现在是否将旧任务的 B 位置 0</font></strong> ，先以指令 <code>call 0x0018:0x1234</code> 来看 call 的任务调用过程：</p><ol><li><code>0x0018</code> 表示在 GDT 中索引第 3 号描述符，即任务门描述符。不同于普通段描述符，任务门描述符中记录的是 TSS 选择子，所以处理器自动忽略 <code>0x1234</code> 。</li><li>检查 P 位，为 0 则表示该描述符不在内存中，抛出异常。</li><li>检测 S 和 TYPE 位，判断描述符类型，如果是任务门描述符，则检查 B 位，若为 1 则抛出异常。</li><li>特权级检查，数值上 CPL 和 TSS 选择子中的 RPL 都要小于或等于 TSS 描述符的 DPL，关于特权级检查与 RPL、CPL、DPL 的区别，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a> 。</li><li>将当前任务的现场保存到 TR 寄存器所指向的 TSS 中。</li><li>将新任务的 TSS 选择子加载到 TR 寄存器中。</li><li>将新任务 TSS 中的寄存器载入到相应寄存器中，并进行特权级检查。</li><li>将新任务的 NT 位置 1，表示为任务嵌套，以便 iret 时从新任务返回到旧任务，而非从中断返回。</li><li>将旧任务的 TSS 选择子写入到新任务 TSS 中 <code>上一任务的TSS指针</code> 字段中，以便能够返回。</li><li>将新任务的 B 位置 1 以表示当前任务忙，<strong><u>但旧任务的 B 位仍然为 1，不会置零</u></strong> ；</li><li>切换完成，新任务开始。</li></ol><p>任务返回则同上文中断调用相同。</p><p>jmp 的任务调度过程和 call 几乎相同，只是第 10 步 B 位置零有所不同：<strong><u>由于 jmp 有去无回，所以新旧任务不构成链式关系，因此会将旧任务的 B 位置 0</u></strong> 。<br>从以上过程便能看出，CPU 原生的任务调度方式很是繁杂，这降低了任务切换的效率和灵活性，因此现代操作系统都没有采用这种方式。</p><h3 id="font-color-red-任务切换的现代方式-font"><font color='red'>任务切换的现代方式</font></h3><p>虽然咋们没有用 Intel 建议的方式来进行任务调度，但这也不是说 TSS 就一无是处了（LDT 是真的完全成孤儿了），Linux 在以下两个地方还是会用到 TSS：</p><ul><li><p><strong><font color='gree'>I/O 特权级控制</font></strong><br>我们一直认为用户进程无法直接访问硬件，必须通过操作系统才行；但是，为了在某些场景下快速反应，TSS 中的 I/O 位图为用户程序直接控制硬件提供了途径。</p><blockquote><p>提示：我们的操作系统并不会使用 IO 位图。</p></blockquote></li><li><p><strong><font color='gree'>将进程的内核栈记录在 TSS 中的 SS0 和 ESP0 位置处</font></strong><br>我们通过时钟中断来进行任务调度，在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>一文中提到，<strong><u><font color='orange'>当发生中断并引用中断门描述符时，会检查是否发生特权级转移，如果特权级改变，则会自动转移到新栈，这个新栈就从 TSS 中获取</font></u></strong> 。换句话说，一个任务分为用户部分和内核部分，从用户转移到内核时，CPU 就会 <u><strong>自动</strong></u> 切换到内核自己的栈。</p></li></ul><p>同时注意，<strong><u>Linux 只使用一个 TSS ，任务切换时并不会随之切换 TSS，而是只修改 TSS 中的 ESP0</u></strong> ，这样也会大大提高任务切换的效率。后文解析代码时，读者朋友就能清楚地看到这一过程。</p><h3 id="font-color-red-进程的实现方式-font"><font color='red'>进程的实现方式</font></h3><p><strong>Windows 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。<font color='orange'>而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务（这点对于理解进程和线程的关系至关重要）</font>，这在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程基础</a>中有代码说明</strong> 。<strong><font color='red'>每个任务都类似于单线程，具有内存空间、执行实体（寄存器）、文件资源等，<u>但不同的任务可以选择共享同一虚拟内存空间，因此，共享了同一个内存空间的任务集合构成了一个进程</u></font></strong> 。</p><p>我们的操作系统是仿 Linux 系统，所以咋们实现用户进程就能够以线程为基础，具体方式如下：<br>先回顾线程创建的大概流程：</p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，调用 get_kernel_page() 向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息（task_struct），包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>要以线程为基础实现进程，<strong>就只需要将执行普通任务的线程函数替换成创建进程的新函数（即start_progress）即可</strong> 。那么，具体创建进程的流程是怎么样的呢？见下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><p>以上函数具体的实现待会再说，先来看看程序是如何进入到用户进程的。我们已经知道如下几点：</p><ol><li>用户进程运行在 3 特权级（ring3），而内核则运行在 ring0；</li><li>在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中我们了解到，除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上。<br><img src="/2022/img/image-20230103141410952.png" style="zoom:67%;" /></li><li>一直以来我们都在内核中运行，即执行流一直停留在 ring0 。</li></ol><p>那么现在，要在内核中，即 ring0 下创建用户进程，并进入到 ring3 用户态，该怎么做呢？显然，只能通过中断返回，即 <code>iret</code> 进入用户态。<u>所以我们采用的具体办法是：利用之前的方式创建线程，将线程里运行的函数设置为 start_progress() ；然后在 start_progress 中初始化该线程的中断栈（也就是将用户进程的寄存器现场提前写入中断栈）；最后 <code>iret</code> 中断返回，即可 ring0 -&gt; ring3，进入用户态</u>。</p><p>其实这种方式可以说是瞒天过海，妥妥地欺骗了 CPU。我们用 <code>iret</code> 指令使 CPU 以为咋们处于中断处理环境中，于是便假装从中断返回，顺利通过特权级检查并进入用户态。</p><h3 id="font-color-red-用户进程的虚拟内存分布-font"><font color='red'>用户进程的虚拟内存分布</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE34-1672909464756-2.png" alt="未命名绘图34"><br><strong>上图是经典的 Linux 用户进程内存布局(内核2.4版本)</strong> ，下面依次对各个部分作简单阐述：</p><ul><li><p>3GB~4GB 虚拟内存映射为内核空间，由所有进程共享。</p></li><li><p>用户内存的顶部是用户栈。一般而言，用户栈的最大空间为 8MB，详见<a href="https://www.tiehichi.site/2020/10/22/Linux%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/#%E5%86%85%E6%A0%B8%E6%A0%88">Linux进程栈空间大小 - Tiehichi’s Blog</a>。另外，用户栈的最高处会用来保存命令行参数和环境变量，这些数据是由 C 运行库压入的，后续从文件系统加载进程时会再提及此处。</p></li><li><p>用户栈下面是共享库的内存映射区域。共享库就是动态链接库，一个共享对象（即.so文件）由所有用户进程共享。举个例子，A 进程用到了 math 库，B进程也用到了 math 库，则 math 库会被加载到物理内存中，进而被映射到各个进程的虚拟内存空间中，由此实现共享，大大节省了内存，这便是动态链接库相对于静态链接库的优势。</p></li><li><p>接着是运行时堆，用于满足程序运行时的动态内存需求。</p></li><li><p>.bss 用于保存未初始化的数据，如未初始化的静态变量和全局变量。</p></li><li><p>.data 段用来保存已初始化且可读写的数据。实际上还有 .rodata 用来存放只读数据，此段并未体现在图中。</p></li><li><p>.text 则是代码区。IA-32 体系结构中，进程空间的代码段都从 <code>0x08048000</code> 开始，这与最低可用地址 <code>0x00000000</code> 有 128M 的间距。</p><blockquote><p>关于 <code>0x08048000</code> 这个值有许多解释，<a href="">Linker And Loader</a>一书给出的解释如下：<br>在 386 系统上，代码的起始虚拟地址是 <code>0x08048000</code> ，这允许在代码下方有一个相当大的堆栈；同时保持在地址0x08000000上方，允许大多数程序使用单个二级页表（回想一下，在 386 上，每个页目录项映射 0x00400000 大小的空间）。其他原因可参见<a href="https://www.cnblogs.com/l2017/p/11879310.html">0x08048000由来</a></p></blockquote></li></ul><p>关于进程的虚拟内存分布，这将在《 <strong>链接、装载与库</strong> 》系列笔记中详细阐述，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁机制—代码实现</title>
      <link href="/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/">浅谈锁机制</a><br>本节对应分支：<code>lock</code></p></blockquote><p>在上节内容中我们提到，当线程申请锁时，如果该锁已经被其他线程拥有，则此线程必须在该锁上陷入睡眠，直到锁的拥有者将其叫醒。所以我们先实现进程的睡眠与觉醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_block</span><span class="params">(<span class="keyword">enum</span> task_status stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line">    cur_thread-&gt;status = stat;</span><br><span class="line">    schedule();                  <span class="comment">//将当前线程换下处理器</span></span><br><span class="line">    intr_set_status(old_status); <span class="comment">//待当前线程被解除阻塞后才继续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_unblock</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));</span><br><span class="line">    <span class="keyword">if</span> (pthread-&gt;status != TASK_READY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag))</span><br><span class="line">            panic(<span class="string">&quot;thread_unblock: blocked thread in ready_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4 行，只有为 TASK_BLOCKED、TASK_WAITING、TASK_HANGING 三种状态才会进行睡眠。</li><li>第 20 行，为了使觉醒的线程尽快得到调度，使用 list_push 而非 list_append 。</li><li>注意，thread_block() 是由当前线程主动执行来进入睡眠的，如果要觉醒，则只能等待其他线程来唤醒，此时是被动的。</li></ul><p>再来看锁的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>  //信号量</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  value;       <span class="comment">//锁的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">waiters</span>;</span>  <span class="comment">//在此信号量上等待的线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span>       //锁结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">task_struct</span>* <span class="title">holder</span>;</span>    <span class="comment">// 锁的持有者</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span>    <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">    <span class="type">uint32_t</span> holder_repeat_nr;    <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>holder_repeat_nr</code> 是同一线程对锁的申请次数。这是为了 1）防止重复申请锁导致陷入死锁；2）防止多次释放锁而出错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    psema-&gt;value = value;       <span class="comment">// 为信号量赋初值</span></span><br><span class="line">    list_init(&amp;psema-&gt;waiters); <span class="comment">//初始化信号量的等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;</span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_init(&amp;plock-&gt;semaphore, <span class="number">1</span>);  <span class="comment">// 信号量初值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="keyword">while</span>(psema-&gt;value == <span class="number">0</span>)<span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag))</span><br><span class="line">        &#123;</span><br><span class="line">            panic(<span class="string">&quot;sema_down: thread blocked has been in waiters_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">        list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);</span><br><span class="line">        thread_block(TASK_BLOCKED);    <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">    psema-&gt;value--;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread_blocked</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));</span><br><span class="line">        thread_unblock(thread_blocked);</span><br><span class="line">    &#125;</span><br><span class="line">    psema-&gt;value++;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line"><span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder != running_thread()) &#123;</span><br><span class="line">        sema_down(&amp;plock-&gt;semaphore);    <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">        plock-&gt;holder = running_thread();</span><br><span class="line">        plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;   <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_up(&amp;plock-&gt;semaphore);   <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第 60 行，如果自己已经持有该锁，则仅将 holder_repeat_nr 加 1，不做其他操作，否则重复进行 sema_down 会导致死锁！</p><blockquote><p><strong>为什么重复申请同一把锁会产生死锁？</strong><br>在已经持有锁的情况下继续申请该锁，若仍 sema_down ，则线程会陷入睡眠，等待锁的持有者将自己叫醒。而锁的持有者又是其本身，自己可不能叫醒自己，因此系统陷入死锁。</p></blockquote><p>所以这里为了应对重复申请锁的情况，当第二次申请时（内层），仅 holder_repeat_nr++ ；当释放锁时，肯定是先从内层释放，所以仅 holder_repeat_nr-- ；外层释放时，再 sema_up 。</p></li><li><p>第 70 行，<strong>必须将置空操作放在 sema_up 之前</strong> 。如果顺序放反，则可能出现这样的情况：线程 A 刚执行完 sema_up 还没来得及置空 holder 就被换下了处理器，轮到线程 B 执行。线程 B 申请该锁，因为线程 A 已经释放，所以 B 申请成功，成为该锁的持有人。当线程 B 还没来得及释放锁时，线程 A 重新被换上 CPU，执行的第一条语句就是置空 holder，然而此锁现在依然属于线程 B ，这就引发了错误。</p></li><li><p>第 19 行为什么使用 while 而非 if，这是因为锁也是通过抢占来获得的，一次抢占可能无法获得锁，举个例子：线程 A 执行 down 操作时发现锁已经被 B 占用，于是陷入睡眠；线程 B 解锁，叫醒 A ；而线程 C 却排在 A 之前，优先被调度，所以锁又被 C 占用，A 继续陷入睡眠。<br>但这里也可以用 if 呢？见上面 thread.c 第 20 行，我们把叫醒的线程放在了首位，不存在线程 C 排在 A 之前的情况，所以可以用 if 。</p><blockquote><p>再次强调，叫醒并不是立刻调度，而是将其放入 thread_ready_list 中。</p></blockquote></li></ul><p>本文件代码在源代码基础上删除了许多 assert 断言，因为笔者发现即使没有触发这些断言，程序最终总会停留在某个任务中，不再调度其他任务，这令笔者非常疑惑，怎么 assert 还会影响程序结果？即使其没有被触发？这里折磨了我很久，最终也是胡乱改，把这些 assert 删除之后才得到了满意的结果。有明白其原理的朋友麻烦在评论区指点一二，感谢！</p><h3 id="font-color-red-实现终端输出-font"><font color='red'>实现终端输出</font></h3><p>emm，终端输出，这玩意儿听起来高端，实际就是给打印函数添了个锁，来看实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">// 控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_init(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str, <span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_str(str,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_int(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_uint</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_uint(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这么简单。直接看结果吧：</p><div id="dplayer10" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer10"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/lock.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈锁机制</title>
      <link href="/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-前言-font"><font color='red'>前言</font></h3><p>在上节<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程 - 进阶 - 任务调度</a>的末尾，笔者演示了当删去 <code>put_str()</code> 上下的 <code>STI</code> 和 <code>CLI</code> 后发生的错误情况（打印不规律，且发生 GP 异常）这是为什么呢？这里就不卖关子了，直接原因是 <strong>线程不同步</strong> 。这样说了也当白说，让我们仔细还原现场：</p><ol><li>k_thread_a 在 put_char 中读取了字符打印的光标位置 p 。</li><li>当 k_thread_a 准备更新光标位置时，中断发生，切换到 k_thread_b 。</li><li>k_thread_b 读取光标位置，由于 k_thread_a 还未更新光标，所以此时光标值仍为 p 。</li><li>于是，k_thread_b 在相同地方打印字符，覆盖了 k_thread_a 的字符。</li></ol><p>因此才出现少字符的情况。对于其他错误，比如一大串空格以及 GP 异常，就不详细说明原因了，只需明白，它们的罪魁祸首都是线程不同步造成的。为了进一步解释什么叫线程不同步，先来看看下面几个概念：</p><ul><li><p><strong><font color='gree'>临界区</font>：</strong> 是指包含有共享数据的一段 <strong><u>代码</u></strong> ，这些代码可能被多个线程访问或修改。临界区的存在就是为了保证当有一个线程在临界区内执行的时候，不能有其他任何线程被允许在临界区执行。</p><blockquote><p><strong>注意，临界区是代码，不是受访的静态公共资源。</strong></p></blockquote></li><li><p><strong><font color='gree'>互斥</font>：</strong> 某一时刻公共资源只能被一个任务访问，即，不允许多个任务同时出现在临界区中。</p></li><li><p><strong><font color='gree'>竞争条件</font>：</strong> 多个任务以竞争的方式（非互斥）进入临界区，其最终的的结果依赖于多个进程的指令执行顺序。<br>举例：假设两个进程 P1 和 P2 共享了变量 a。在某一执行时刻，P1 更新 a 为 1，在另一时刻，P2 更新 a 为 2。因此两个任务竞争地写变量 a。在这个例子中，竞争的失败者（最后更新的进程）决定了变量 a 的最终值。多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p></li></ul><p>显然，我们代码中的临界区就应该为 put_char（准确来说，是 put_char 中操作光标的代码部分），而 k_thread_a 和 k_thread_b 两个线程以竞争的方式访问临界区，从而产生竞争条件，最终引发不同步导致错误。那么，如何才能实现互斥访问呢？<strong><u>最简单的方式就是像视频演示中的那样开关中断，但现实的方式是采用锁</u></strong> 。关于这两种方式的比较，请见文末。</p><p>下面我们来看看锁的进化历程，以此加深读者对锁的理解。</p><h3 id="font-color-red-锁的进化-font"><font color='red'>锁的进化</font></h3><p>情景：金鱼有个很奇怪的特点，就是没有饱的感觉，如果你不停地给它喂食，它就会一直进食直到把自己撑死。现在线程 A 和线程 B 共同喂养一条金鱼，要求只能由其中一个线程进行喂食，即，若 A 线程已经投喂，那么 B 就不能再继续投喂；如果 B 线程已经投喂，则 A 线程也不能再投喂，否则金鱼被撑死。除了不能多次投喂外，也不能不进行投喂，即 A 和 B 线程中总有一者必须投喂金鱼，否则金鱼被饿死。</p><p><strong><mark class="hl-label blue">第一阶段</mark> </strong></p><p>使用全局变量 if_feed 标记喂食情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能防止多次投喂了吗？<br><img src="/2022/img/未命名绘图29.png" style="zoom:67%;" /><br>哦豁，依旧投喂了两次，金鱼被撑死。这里的原因在于，A、B 两线程同时进入了临界区。</p><p><strong><mark class="hl-label blue">第二阶段</mark> </strong></p><p>经过第一阶段的失败，我们吸取了教训：要防止金鱼胀死，就必须避免多个线程同时进入临界区，即需要做到互斥。下面通过留字条的方式来互斥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>以上代码无论按什么顺序穿插执行 A、B 线程，都不会再造成金鱼胀死了，但却可能饿死！如下：</p><img src="/2022/img/未命名绘图30.png" style="zoom:80%;" />哈哈，即使饿死，也比撑死好。这是因为几个线程同时获得一个资源，最终出现崩溃几乎是必然的事；如果谁都获取不了资源，则可能只是停止推进，而不一定产生错误结果。让我们继续改进。<p><strong><mark class="hl-label blue">第三阶段</mark> </strong></p><p>为了保证投喂，我们让某个线程一直等着，直到确认对方投喂之后再离开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(noteB == <span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这样一来就能够保证金鱼能够被投喂了。但即使如此，以上方式仍存在较大问题：</p><ol><li>程序不对称。功能完全相同，程序却不一样，这加大了代码的难度。</li><li>浪费 CPU 资源。线程 A 的 while 完全是白占着 CPU 资源。</li><li>可能造成优先级倒挂。</li></ol><p><strong><mark class="hl-label blue">第四阶段</mark> </strong><br>那么现在，我们又该怎么办呢？仔细思考后其实可以发现，第 2、3 个阶段的重心都落在字条上，即留字条是为了防止两个线程同时投喂或都不投喂金鱼。既然留字条不能完美地解决办法，那有没有其他方法来进行互斥呢？有，当要投喂时，进入房间，把门锁上，投喂金鱼，打好标记，解锁并离开房间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><p>这种为房间上锁的方式实际上是对第一种方案的改善，即，将检查标记和打标记合并为一个原子操作（投喂金鱼也被合并了）。如此一来，似乎就完美了。但再仔细观察后仍可以发现一个问题：如果线程 A 喂鱼的动作很慢，那么线程 B 将会被锁很长一段时间，这种等待不仅浪费 CPU 资源，也会降低系统效率。而且，喂鱼这个动作并非临界区，对标记的操作才是，所以完全可以将喂鱼的动作移出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">    noteA = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteA = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">    noteB = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteB = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>谨记，临界区的动作越少越好！</font></strong> 另外，当其他线程被锁在临界区外时，只能苦等锁被打开，除此之外无法进行任何动作，<strong><font color='orange'>所以这些线程就不应该再占用 CPU 资源，即，在锁被打开前，CPU 不再调度这些任务，直到锁被打开后再恢复调度</font></strong> 。这就涉及到线程的 <strong><font color='orange'>睡眠</font></strong> 与 <strong><font color='orange'>觉醒</font></strong> 。</p><h3 id="font-color-red-睡眠与觉醒：生产者和消费者问题-font"><font color='red'>睡眠与觉醒：生产者和消费者问题</font></h3><p><strong>线程的睡眠和觉醒是指：当对方持有锁，将你锁在外面时，你无需一直敲门，而是可以在门口睡觉，等到对方解锁之后再来叫醒你</strong> 。下面用线程中经典的生产者和消费者问题来演示睡眠与觉醒。我们知道，一般来说，生产者（厂家）会将商品批发给超市，然后消费者在超市进行购买。如果没有超市这个中转站，生产者就无法独立操作，必须拿到消费者的订单才能生产；消费者也必须在每次订货后且等待商品完工后才能拿到货。显然，超市扮演着重要的缓冲区角色。现在抛出两个问题：1）当超市没货了怎么办？2）当超市货太多装不下怎么办？</p><p>现实的实际做法一般是：<strong>当超市没货了，如果有顾客上门购买商品，则告知顾客缺货并让顾客回家等候通知；当超市货满了，则通知厂商暂时不要再生产</strong> 。用代码表示即如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100  <span class="comment">//超市最多能存下的商品数</span></span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//超市中现存的商品数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            sleep();         <span class="comment">//不再生产</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            wakeup(consumer);<span class="comment">//通知客户取货</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            sleep();         <span class="comment">//回家等通知</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)     <span class="comment">//如果count==N-1,说明厂家一定处于睡眠状态</span></span><br><span class="line">            wakeup(producer);<span class="comment">//通知厂家生产</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，wakeup() 只是叫醒对方线程，即让其重新在 thread_ready_list 中，而不是立刻调度！</strong></p></blockquote><p>以上代码看上去正确无误，实际上存在着巨大问题：<strong><font color='red'>可能造成死锁！</font></strong></p><blockquote><p>死锁，即生产者和消费者均无法向前推进。</p></blockquote><p>例如，若消费者先来，此时 count=0，则去睡觉，但在<u>睡下的前一刻</u>，CPU 任务调度，执行流转移到生产者。生产者开始运行，生产一件商品后发现 count=1，于是叫醒消费者。但此时消费者并没有睡觉（还在 thread_ready_list 中），所以这个叫醒信号无用。缓冲区满后，生产者转入睡眠，执行流转移到消费者。而消费者执行的第一个操作就是 sleep()，于是消费者也转入睡眠。最后两者都陷入睡眠状态并等待彼此叫醒自己，显然，它们都无法再醒来，系统死锁发生。</p><p>解决上述问题的方法也很简单。很容易发现，造成死锁的原因是因为叫醒信号的丢失。那我们想个办法将信号收集起来不就OK了嘛！消费者换上 CPU 执行 sleep 后，生产者发送的叫醒信号依然保留，因此消费者检测到该信号而觉醒。<strong><font color='gree'>这种能够累积的信号就叫做信号量</font></strong> 。</p><h3 id="font-color-red-信号量-font"><font color='red'>信号量</font></h3><p>实际上，信号量是操作系统中一个极其重要，威力巨大的概念，它不仅可以用来线程同步，还能用于进程间通信。我们现在仅讨论其作为锁的用途。<strong>当信号量的取值限制在 0 和 1 时，则获得了一把锁，也称二元信号量</strong> 。对信号量有 up、down 两种操作：</p><p><strong><font color='orange'>up：</font></strong> 1）将信号量加 1；2）唤醒在此信号量上等待的线程。<br><strong><font color='orange'>down：</font></strong> 1）判断信号量是否大于 0；2）若信号量大于 0，则将信号量减 1；3）若信号量等于 0，则在此信号量上睡眠。</p><blockquote><p>因为信号量是荷兰科学家 Dijkstra 发明的一种程序设计规范，所以 up 和 down 也被称为 PV 操作，即荷兰语中的 Proberen 和 Verhogen 。</p></blockquote><p><strong><u><font color='orange'>down 即获得锁，up 即解锁</font></u></strong> 。<strong>初始状态下信号量值为 1，某线程获得锁后，其值减为 0，当其他线程申请锁时，则只能在此锁上陷入睡眠，直到该线程解锁。</strong></p><p>值得一说的是，信号量也不是完美的解决方案，当二元信号量多起来后，死锁也有极大的概率会发生，但由于我们的操作系统非常简单，不会发生如此复杂的情况，所以不考虑这些情况，详细内容请参考《操作系统之哲学原理》。</p><h3 id="font-color-red-死锁-font"><font color='red'>死锁</font></h3><p>有大概如下几种情况会产生死锁：</p><ul><li><strong>忘记释放锁</strong></li><li><strong>单线程重复申请锁</strong></li><li><strong>多线程多锁申请</strong></li></ul><h3 id="font-color-red-锁比开关中断好在哪？-font"><font color='red'>锁比开关中断好在哪？</font></h3><p>前文提到，关中断是避免资源竞争最简单的方式，那为什么还需要锁呢？<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE31.png" alt=""><br>从上图可见，当红色箭头进入临界区时，关闭中断，虽然这避免了资源竞争，但却令红色箭头在整个临界区内独占 CPU，其他任务得不到调度，从而导致系统效率下降。这是关中断的方式，下面来看看用锁是什么情况：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE32.png" alt=""><br>锁就不一样了，当红色箭头获得锁进入临界区后，绿色箭头仍然能够得到 CPU 调度，直到到达临界区才会被锁住而进入睡眠。因此，<strong>相比于开关中断，锁机制在任务调度上的效率更高</strong> 。</p><blockquote><p>以上是笔者的个人想法，若读者还有其他想法，不妨在评论区提出。</p></blockquote><p>本文就到这里，下节我们将实现锁机制。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-进阶-任务调度</title>
      <link href="/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a><br>本节分支：<code>thread-schedule</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>任务链表</font></strong><br>通常使用链表来维护任务队列。链表本身不是本节的重点，所以笔者将其放在文末。</li><li><strong><font color='gree'>任务调度基础</font></strong><br>基于上节内容对 <code>thread.c</code> 和 <code>thread.h</code> 进行改进。</li><li><strong><font color='gree'>任务切换</font></strong><br>改进时钟中断，添加任务调度器，开始任务切换。</li></ul><h3 id="font-color-red-任务调度基础-font"><font color='red'>任务调度基础</font></h3><p><strong><mark class="hl-label blue">thread.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              </span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              </span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>thread.h 中只对 <code>task_struct</code>  添加了一些成员：</p><ul><li><strong>ticks：</strong> 时间片，任务刚被调度时，时间片被初始化为 priority，随后每发生一次时钟中断 ticks 就减 1，减到 0 后被换下 CPU 。</li><li><strong>elapsed_ticks：</strong> 记录该任务一共被运行了多少 CPU 滴答数。它和 ticks 的区别是：ticks 减到 0 时任务被换下 CPU，但此时任务可能还未执行完毕，所以重新加入到任务队列等待下一次被调度。所以，elapsed_ticks 记录的是从任务初次被调度到任务执行结束所经过的总滴答数，而 ticks 只是任务的一次倒计时。</li><li><strong>general_tag：</strong> <font color='orange'>当任务处于<u>就绪或其他等待状态</u>时，需要把该 tag 添加到 thread_ready_list 或其他相应等待队列中</font>。将 tag 加入到队列就相当于将 task_struct 加入到队列吗？是的，可以通过 tag 来定位 task_struct，原因很简单，因为这些 tag 本来就位于 task_struct 内存中，只需要根据成员的偏移量就能反向推断出 task_struct 的地址。文末会演示这一过程。<br><img src="/2022/img/image-20221217171337120.png" alt="通过tag将各个PCB连接成队列" style="zoom:67%;" /></li><li><strong>all_list_tag：</strong> thread_all_list 用来管理所有任务，所有任务的 all_list_tag 都需要加入到 thread_all_list 中。</li><li><strong>pgdir：</strong> 上节提到过，对于进程，pgdir 指向自己的页目录表；对于线程，pgdir 被初始化为 NULL 。注意，pgdir 中装的是虚拟地址，经过手动转换变成物理地址后才会加载进 CR2 ，这是后话。</li></ul><p><strong><mark class="hl-label blue">thread.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">main_thread</span>;</span>    <span class="comment">// 主线程PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span>    <span class="comment">// 就绪队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span>    <span class="comment">// 所有任务队列</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">thread_tag</span>;</span><span class="comment">// 用于保存队列中的线程结点</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> tmp_esp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前线程pcb指针 */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">running_thread</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov tmp_esp,esp&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">/* 取esp整数部分即pcb起始地址 */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> task_struct*)(tmp_esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由kernel_thread去执行function(func_arg) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">    intr_enable();</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程栈thread_stack,将待执行的函数和参数放到thread_stack中相应的位置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再留出线程栈空间,可见thread.h中定义 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread)</span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    </span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">/* 加入就绪线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">/* 加入全部线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将kernel中的main函数完善为主线程 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_main_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 因为main线程早已运行,咱们在guide.S中进入内核时mov esp,0xc009f000,</span></span><br><span class="line"><span class="comment">已经为其预留了pcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/</span></span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">&quot;main&quot;</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数就是当前线程,当前线程不在thread_ready_list中,</span></span><br><span class="line"><span class="comment"> * 所以只将其加在thread_all_list中. */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务调度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING)    <span class="comment">// 若当前线程只是时间片到了,将其加入到就绪队列尾,等待重新被调度</span></span><br><span class="line">    &#123;  </span><br><span class="line">        assert(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">        cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">        cur-&gt;status = TASK_READY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前线程是被阻塞了,则不需要将其加入到就绪队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!list_empty(&amp;thread_ready_list));</span><br><span class="line">    thread_tag = <span class="literal">NULL</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu.</span></span><br><span class="line">    thread_tag = list_pop(&amp;thread_ready_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;thread_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    list_init(&amp;thread_ready_list);</span><br><span class="line">    list_init(&amp;thread_all_list);</span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">    make_main_thread();</span><br><span class="line">    put_str(<span class="string">&quot;thread_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老规矩，讲解以上代码前先理理脉络：</p><ol><li><strong>开启线程机制前需要调用 <code>thread_init()</code> 来初始化线程环境，内容包括初始化就绪任务链表和所有任务链表、创建 main 线程。</strong></li><li><strong>初始化线程环境后即可调用 <code>thread_start()</code> 创建线程。在此函数中进入如下动作：</strong><br><strong>1）调用 <code>init_thread()</code> 初始化线程信息，</strong><br><strong>2）调用 <code>thread_create()</code> 将线程函数及其参数写入到线程栈中。</strong><br><strong>3）将该线程加入到 thread_ready_list 和 thread_all_list 中。</strong></li><li><strong>随后等待调度。</strong></li></ol><p>下面进行代码讲解：</p><ul><li><p>第 12 行，使用内联汇编取得当前 esp 的值。和之前一样，内联汇编中用到的 C 变量必须是全局或者全局静态变量，因此使用全局静态变量 tmp_esp 中转。</p></li><li><p>第 14 行，因为栈位于 PCB 中，而 PCB 大小为一页，所以将 esp 向下取页框，即得 PCB 起始地址。</p></li><li><p>第 21 行，进入线程函数 <code>function()</code> 前需要先打开中断，这里需要重点说明其原因：任务切换是由时钟中断驱动的，也就是说，<code>schedule()</code> 是在时钟中断里被调用的，任务调度后直接进入 <code>function()</code> 执行任务 ，<strong><u>并不会返回中断（iret）</u></strong> ，这样一来，就相当于任务的调度和执行都发生在中断里。咋们之前说过，进入中断后 <code>IF</code> 位自动置 0，也就是屏蔽外部中断，如此一来，进入该任务后就无法发生时钟中断来调度其他任务啦，于是，该任务独占了 CPU 控制权！为了防止这种情况发生，<strong><font color='orange'>我们需要在进入任务前手动开启中断</font></strong> ！！！</p></li><li><p>第 68 行，<strong>只有将该任务加入到 thread_ready_list 队列中，才会被 CPU 调度</strong> ；目前还没有体现到 thread_all_list 的作用，后续才会用到该队列。</p></li><li><p>第 77 行，从 CPU 被启动的那一刻，执行流就一直在按我们的代码运行。现在，<strong>我们要将该执行流也包装成线程（即kernel_main线程）并加入到队列中，否则调度其他任务后就没法回到主线程了</strong> 。注意 <code>guide.s</code> ：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[BITS 32]</span><br><span class="line">extern kernel_main</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov esp, 0xc009f000</span><br><span class="line">    jmp kernel_main</span><br></pre></td></tr></table></figure><p>第 6 行，<strong>进入内核前必须将 esp 指向主线程 PCB 的顶端，即 0xc009f00 处，否则无法根据 esp 定位到 PCB</strong> 。</p></li><li><p>第 92 行，<code>schedule()</code> 函数可能在时钟中断里被调用，也可能被后续将要说到的 <code>thread_block()</code> 函数调用。<strong><font color='orange'>因此，在 <code>schedule()</code> 中需要考虑当前线程是出于什么原因才被换下 CPU 的，是因为时间片到期？还是说被阻塞了？所以必须针对不同的状态做出相应的应对措施</font></strong> 。另外，最下方调用的 <code>switch_to</code> 是汇编函数，下文会重点讲解。</p></li><li><p>第 109 行，由于我们还未实现 idle 线程，所以就绪队列可能为空，为了避免无线程可调度的情况，暂用 assert 来保障。</p></li><li><p>第 114 行，<code>elem2entry()</code> 是宏函数，用来将 general_tag 或 all_list_tag 转换为对应的 task_strcut 指针。此函数在文末介绍链表时会谈到。</p></li></ul><p>其他就没什么好说的了，下面进入正题。</p><h3 id="font-color-red-任务切换-font"><font color='red'>任务切换</font></h3><p>我们采用的调度方式是 <strong><font color='red'>轮询（Round-Robin，RR）</font></strong> ，这是一种基础的调度方式。轮询，说白了就是按先进先出（FIFO）的顺序一个一个调度。切换任务时，从 thread_ready_list 弹出队首，并将其调度上 CPU 。注意，正在执行的任务的状态是 RUNNING，该任务不在 thread_ready_list 中，而在 thread_all_list 中。</p><p><strong>完整的任务调度分为三个大步：</strong></p><ol><li><strong>进入时钟中断</strong></li><li><strong>时钟中断调用 <code>schedule()</code></strong></li><li><strong><code>schedule()</code> 调用 <code>switch_to()</code></strong></li></ol><p><strong><mark class="hl-label blue">1.进入时钟中断</mark> </strong><br>还记得吗？在<a href="https://jyx-fyh.github.io/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加入中断</a>一文中，我们将每个中断处理函数都统一初始化为 <code>general_intr_handler()</code> ，这是一般化函数，只是用来告诉我们发生了什么中断，以便于排错。现在咋们就需要将时钟中断专门化了，见以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idt.c</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_handler</span><span class="params">(<span class="type">uint8_t</span> vector_no, intr_handler function)</span></span><br><span class="line">&#123;</span><br><span class="line">    interrupt_handler_table[vector_no] = function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> ticks;          <span class="comment">// ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"><span class="comment">/* 时钟的中断处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intr_timer_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line"></span><br><span class="line">    assert(cur_thread-&gt;stack_magic == <span class="number">0x19870916</span>);  <span class="comment">// 检查栈是否溢出</span></span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;elapsed_ticks++;                    <span class="comment">// 记录此线程占用的cpu时间嘀</span></span><br><span class="line">    ticks++;  <span class="comment">//从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_thread-&gt;ticks == <span class="number">0</span>)                     <span class="comment">// 若进程时间片用完就开始调度新的进程上cpu</span></span><br><span class="line">        schedule();</span><br><span class="line">    <span class="keyword">else</span>                                            <span class="comment">// 将当前进程的时间片-1</span></span><br><span class="line">        cur_thread-&gt;ticks--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;timer_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);</span><br><span class="line">    register_handler(<span class="number">0x20</span>, intr_timer_handler);  </span><br><span class="line">    put_str(<span class="string">&quot;timer_init done: Clock interrupt frequency increased to 100Hz\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局变量 ticks 用来记录自中断开启后经历的总滴答数，类似于系统运行时长的概念。该变量当前保留，未来可能会用到。</li><li>第 14 行，<strong>cur_thread-&gt;ticks == 0 意味着<u>该任务还未结束，但时间片已经到期</u></strong> ，所以进入 <code>schedule()</code> ，将该任务重新放入队尾等待下一次调度。</li><li>第 25 行，注册专门的时钟中断。</li></ul><p><strong><mark class="hl-label blue">进入schedule()</mark> </strong></p><p>上文已作讲解，不再说明。</p><p><strong><mark class="hl-label blue">进入switch_to</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">section .text</span><br><span class="line">global switch_to</span><br><span class="line">switch_to:</span><br><span class="line">   ;栈中此处是返回地址</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ebx</span><br><span class="line">   push ebp</span><br><span class="line"></span><br><span class="line">   mov eax, [esp + 20]     ; 得到栈中的参数cur, cur = [esp+20]</span><br><span class="line">   mov [eax], esp          ; 保存栈顶指针esp</span><br><span class="line">                           </span><br><span class="line">                           </span><br><span class="line">;------------------  以上是保存当前线程的栈，下面是恢复下一个线程的栈  ----------------</span><br><span class="line">   mov eax, [esp + 24]     ; 得到栈中的参数next, next = [esp+24]</span><br><span class="line">   mov esp, [eax]          ; 恢复esp</span><br><span class="line">                           </span><br><span class="line">   pop ebp</span><br><span class="line">   pop ebx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret                     ;第一次执行时会返回到kernel_thread</span><br><span class="line">                           ;后续执行则会返回到schedule函数</span><br></pre></td></tr></table></figure><ul><li>关于 esi、edi、ebx、ebp 的压栈问题已在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a>中阐述。</li><li>参数 cur 和 next 分别是当前任务和下个任务的 task_struct 指针，需要强调的是，<strong>由于 task_struct 的首个成员是 self_kstack，所以可以认为 cur 和 next 指针也是指向 self_kstack</strong> ！这样一来，<strong><font color='orange'>self_kstack 的真正作用便清晰了——记录线程被换下瞬间的 esp 值</font></strong> 。</li></ul><p><strong><code>switch_to</code> 是任务调度的核心，它向我们直接展示了操作系统是如何通过栈切换来完成任务调度的</strong> 。不过，大家可能还是很迷糊，不急，让我们看看实际的调度过程：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE28-1671258856847-2.png" alt="以下解析的步骤和上图的序号相对应"></p><ol><li><p>当前执行流位于 kernel_main() 主线程，esp 当然也位于 kernel_main 的 PCB 顶端。某一时刻，时钟中断发生，<strong>中断压栈保护任务现场</strong> ，接着进入 <code>schedule()</code> ，进而到 <code>switch_to()</code> 。<code>switch_to()</code> 前半段将当前 esp 的值保存到 kernel_main 的 self_kstack 中。</p><blockquote><p>为什么 cur 和 中断栈之间还有个省略号？这只是想告诉大家，实际的线程栈情况和 <code>thread_stack</code> 结构体并不能一一对应，比如，调用 <code>schedule()</code> 函数还需要将返回地址压栈呢，而这个并没有考虑进 <code>thread_stack</code> 或 <code>intr_stack</code> ，所以栈中的数据实际上是错位的！不能通过该结构体取得栈内对应的值。<code>intr_stack</code> 也同样不能对应，比如，在 kernel_main() 中调用了一个函数，执行此函数时发生中断，此时的 esp 就不是从 0xc009f000 开始的啦！</p></blockquote></li><li><p>执行 <code>mov esp,[eax]</code> 后即完成栈切换。<strong><font color='orange'>注意，这个新任务是首次被调度的，它的线程栈已经在 <code>thread_create()</code> 中被我们设计好了</font></strong> 。</p><blockquote><p>为啥没省略号了？因为现在对齐啦！！！要知道，在 <code>thread_create()</code> 中，我们跳过了中断栈和线程栈，将 self_kstack 不偏不倚地指向了线程栈的起点，所以这里是完全对齐了的，也是基于这一点，下面的 pop 和 ret 才能正确执行。</p></blockquote></li><li><p>四次 pop 并 ret，成功进入 eip 对应的 <code>kernel_thread()</code> ，进而 <code>function()</code> ，任务开始执行。</p></li><li><p>某时刻，中断再次发生，中断压栈，再一路来到 <code>switch_to()</code> 上半部分，即保存当前栈。<strong><font color='orange'>注意，由图可见，此时中断压栈是发生在线程栈中而非中断栈中！</font></strong></p><blockquote><p><strong><font color='orange'>注意步骤 3 和步骤 4 的栈中的 eip 差异，这点差异非常重要！步骤 3 中的 eip 是我们设计好的，指向 <code>kernel_thread()</code> ；而步骤 4 中的 eip 是 <code>schedule()</code> 中调用 <code>switch_to()</code> 时留下的返回地址，也就是说将来会通过这个 eip 回到 <code>schedule()</code></font></strong> 。<br>另外再次强调，中断之所以能够再次发生，是因为我们进入 <code>function()</code> 前手动打开了中断，这并不是 <code>iret</code> 的功劳。</p></blockquote></li><li><p>执行 <code>switch_to()</code> 的下半部分，<code>mov esp,[eax]</code> ，切换任务栈。</p></li><li><p>接着 pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复 kernel_main() 的任务。</p></li><li><p>一段时间后，中断发生，保存当前栈。</p></li><li><p>恢复之前的栈。此时的 eip 是 <code>schedule()</code> 留下的返回地址（而非 kernel_thread 的地址）。</p></li><li><p>pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复线程任务。</p><blockquote><p>可见，该线程的线程栈栈底将一直存留这三个参数，这并不重要。问题是，当任务结束后，<code>kernel_thread()</code> 该如何返回呢？这个占位符原本应该是 <code>switch_to</code> 调用 <code>kernel_thread()</code> 留下的返回地址，但现在它仅是一个占位符，<strong><font color='orange'>这意味着任务结束后 kernel_thread() 将无法正常返回！</font></strong> 所以，<strong><u>在我们的操作系统中，线程返回不能通过普通 return 的方式进行</u></strong> ，而要专门调用一个线程退出函数（ <code>thread_exit()</code> ）来结束任务，这是后话，目前我们的策略是强制要求在任务末端放一个 <code>while(1)</code> ，以避免任务结束。关于这点的实验演示见以下视频。</p></blockquote></li></ol><blockquote><p><strong>为什么使用 <code>ret</code> 来调用 kernel_thread() ？</strong><br>从上面的过程你可以发现，<code>switch_to</code> 的最后一句 <code>ret</code> ，在线程首次被调度时，是进入 <code>kernel_thread()</code> ；后续被调度时，则是返回到主调函数 <code>schedule()</code> 中。<strong><font color='orange'>所以此处的 <code>ret</code> 有双重作用！而你可以通过 ret 调用 kernel_thread，也可以使用 ret 来返回 schedule，但你可不能使用 call 来返回 schedule 吧？这也是为什么要使用 <code>ret</code> 而非 <code>call</code> 来调用 <code>kernel_thread()</code> 的原因！</font></strong></p></blockquote><div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_exit.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>可见，一旦任务退出，就引发缺页异常。不知道有没有眼尖的小伙伴看见 while 语句中，打印语句上下的 <code>STI</code> 和 <code>CLI</code> ？为什么要在 <code>put_str()</code> 的上下分别放置这两条语句呢？先让我们看看，如果去掉这两条语句会发生什么：</p><div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>看见了吗？若去掉 <code>STI</code> 和 <code>CLI</code> ，则会发生 0xd 号异常。这涉及到锁相关的内容，将在下节内容详细介绍。</p><p>另外，说说笔者在这里遇见的一个大坑，看下面的 <code>interrupt.s</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的interrupt.s</span></span><br><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>上面是修改后的 <code>interrupt.s</code> ，也就是现在的版本。而之前，笔者是像下面这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>嗯？只是处理 EOI 的代码改变了位置，有什么影响吗？影响可大了！前文已经强调，任务调度在时钟中断处理函数(第11行)中进行的，调度完成后直接开始执行任务，并不会返回到中断内并执行末尾的 <code>iret</code> 指令；而中断发生后 CPU 会自动将 IF 位置零来屏蔽外部中断，因此，为了防止任务独占 CPU，任务（即<code>function()</code>)正式开始前还要手动开中断。问题来了，<strong><font color='orange'>8259A 芯片发送中断信号后，必须要收到 CPU 发来的 EOI 结束命令后才会继续发送中断，否则即使你开了中断也没用！</font></strong> 所以，按上面的写法，进入第 11 行时钟中断处理函数后，压根不会执行后面的 EOI 发送代码，时钟中断无法产生，后续的任务调度也就没法进行了！这里坑了笔者两天之久！</p><h3 id="font-color-red-链表-font"><font color='red'>链表</font></h3><p>双向链表是用来维护任务队列的核心数据结构。数据结构不是本系列博客的重点，所以就不详细展开了，仅强调几个要点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset(struct_type,member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line"><span class="meta">        (struct_type*)((int)elem_ptr - offset(struct_type, struct_member_name))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">prev</span>;</span>  <span class="comment">// 前躯结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">next</span>;</span>  <span class="comment">// 后继结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span>   <span class="comment">//头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span>   <span class="comment">//尾节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数类型function,用于在list_traversal中做回调函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">bool</span> <span class="params">(function)</span><span class="params">(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_iterate</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>offset</code> 宏用来计算结构体内的某成员相对于该结构体起始处的偏移量。这个操作很骚，可以说将指针运用得炉火纯青了：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)(&amp;((struct_type*)<span class="number">0</span>)-&gt;member)</span><br></pre></td></tr></table></figure><p>将 0 强制转换为 struct_type* 指针，换句话说，<strong><u>该指针指向 struct_type 类型的结构体，而该结构体位于地址 0x0000 处</u></strong> 。如此一来，由于是以地址 0x0000 为基准，所以该结构体中成员的地址即为此成员相对于该结构体的偏移量。</p></li><li><p><code>elem2entry</code> 宏就好说了，用 tag 指针减去 tag 偏移量即得结构体的起始地址。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag); <span class="comment">//thread.c第114行</span></span><br></pre></td></tr></table></figure><blockquote><p>那么，为什么这两个操作设计成宏而非函数呢？留给读者自己思考。</p></blockquote></li><li><p>注意，list 中的 head 是头节点，而非首元节点；尾节点同理；节点只会插在 head 与 tail 之间。</p><blockquote><p>头节点是一个不存放任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，<strong>它的作用只是为了方便解决某些实际问题</strong> ；<br>首元节点是链表中第一个存有数据的节点；首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p></blockquote></li><li><p>第 19 行，自定义函数类型，该类型在 <code>list_traversal()</code> 中作为回调函数的类型。如果不使用 typedef，那么第 30 行声明就需改成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="type">bool</span> (func)(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>), <span class="type">int</span> arg)</span>;</span><br></pre></td></tr></table></figure><p>显然，这种方式没有上一种方式好看。<code>list_traversal()</code> 函数当前还未使用，后续用到了再介绍。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="comment">/* 初始化双向链表list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = &amp;<span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.prev = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把链表元素elem插入在元素before之前 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    before-&gt;prev-&gt;next = elem;</span><br><span class="line">    elem-&gt;prev = before-&gt;prev;</span><br><span class="line">    elem-&gt;next = before;</span><br><span class="line">    before-&gt;prev = elem;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加元素到列表队首 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(plist-&gt;head.next, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 追加元素到链表队尾 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(&amp;plist-&gt;tail, elem); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使元素pelem脱离链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    pelem-&gt;prev-&gt;next = pelem-&gt;next;</span><br><span class="line">    pelem-&gt;next-&gt;prev = pelem-&gt;prev;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将链表第一个元素弹出并返回,类似栈的pop操作 */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    list_remove(elem);</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == obj_elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把列表plist中的每个元素elem和arg传给回调函数func,</span></span><br><span class="line"><span class="comment"> * arg给func用来判断elem是否符合条件.</span></span><br><span class="line"><span class="comment"> * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的元素返回元素指针,否则返回NULL. */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(plist))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(elem, arg))   </span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        elem = elem-&gt;next;     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回链表长度 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断链表是否为空,空时返回true,否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (plist-&gt;head.next == &amp;plist-&gt;tail ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数都是常规的链表操作，不再解释。</p><p>本文结束。经过这两节的煎熬，想必读者朋友们也憔悴了吧？哈哈，休息再战！</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理-进阶-分配页内存</title>
      <link href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/"/>
      <url>/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节前置内容：<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础-初始化内存池</a><br>本节对应分支：<code>memory-alloc</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>对笔者而言，内存分配一直是操作系统最神秘的部分之一，从学习编程开始，就一直能在耳边听到这个词，所以这也是本人最期待的部分，不知读者是否也是如此呢？本节我们实现的内存分配是“整页分配”，这与 malloc 函数不同，后者能申请任意大小的内容，而前者的申请单位则是以页为计。不过，malloc 也是基于“整页分配”进行的，所以未来我们也会借助本节内容来实现 malloc 函数。</p><p>本节的函数逻辑也都很简单，只是它们的数量较多，关系稍显复杂，所以贴心的笔者（手动狗头^_^）献上一幅函数关系图以供大家参考：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE22.png" alt=""><br>上图就是内存申请的全过程，大括号中包含的函数即为括号所指函数中调用的函数，且从上到下依次调用。上图只是为了让大家稍微熟悉页分配的过程，具体过程咋们还是来看代码吧。</p><h3 id="font-color-red-代码解析-font"><font color='red'>代码解析</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pool_flags</span> &#123;</span></span><br><span class="line">   PF_KERNEL = <span class="number">1</span>,    <span class="comment">// 内核内存池</span></span><br><span class="line">   PF_USER = <span class="number">2</span>     <span class="comment">// 用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_1  1<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_0  0<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_R  0<span class="comment">// R/W 属性位值, 读/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_W  2<span class="comment">// R/W 属性位值, 读/写/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_S  0<span class="comment">// U/S 属性位值, 系统级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_U  4<span class="comment">// U/S 属性位值, 用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">mem_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">malloc_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br></pre></td></tr></table></figure><ul><li>pool_flags 为枚举，用来指明当前的操作对象是内核内存池还是用户内存池。</li><li>第 18~23 行为页表项/目录项的属性，这将在我们创建页表项和页目录项时用到。读者可能已经忘了页表项/页目录项的格式：<br><img src="/2022/img/IMG_0526(20221115-170651)-1670564791259-2.png" alt="" style="zoom:67%;" /><br>关于这些属性的详细介绍，请回顾<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr对应的页目录表索引,其实直接addr&gt;&gt;22也是可以的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr对应的页表索引</span></span></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START   0xc0100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,</span></span><br><span class="line"><span class="comment"> * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pf == PF_KERNEL) </span><br><span class="line">   &#123;</span><br><span class="line">      bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">      <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span>(cnt &lt; pg_cnt)       <span class="comment">//将申请到的位置1,表示已使用</span></span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">      vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pte指针*/</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pde的指针 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 0xfffff是用来访问到页目录表本身所在的地址 */</span></span><br><span class="line">   <span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在m_pool指向的物理内存池中分配1个物理页,</span></span><br><span class="line"><span class="comment"> * 成功则返回页框的物理地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 扫描和设置位图要保证原子操作 */</span></span><br><span class="line">   <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>); <span class="comment">// 找一个物理页面</span></span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);       <span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">   <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>  vaddr = (<span class="type">uint32_t</span>)_vaddr;</span><br><span class="line">   <span class="type">uint32_t</span>  page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">   <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">   <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,可能会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">   <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">   <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>)           <span class="comment">//页目录项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">   &#123;                            <span class="comment">//如果存在，则添加映射(安装页表项)</span></span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);  <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                             <span class="comment">//如果页目录项对应的页表不存在,则先创建页表再创建页表项. </span></span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="comment">/* 页表所用页框一律从内核空间分配 */</span></span><br><span class="line">      <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool); <span class="comment">//申请页表空间</span></span><br><span class="line">      *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);     <span class="comment">//安装页目录项</span></span><br><span class="line">      <span class="comment">/* 以下将分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">       * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">       * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">       * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">       * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);    <span class="comment">//将申请到的页表清零</span></span><br><span class="line">      assert(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">//注册页表项</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   assert(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);       <span class="comment">//3840页内存=15MB</span></span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line">   <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">   <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">void</span>* page_phyaddr = palloc(mem_pool);      <span class="comment">//palloc每次申请一个物理页</span></span><br><span class="line">      <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)   <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">      &#123;  </span><br><span class="line">          <span class="comment">//回滚,后续补充</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射 </span></span><br><span class="line">      vaddr += PG_SIZE;                          <span class="comment">// 下一个虚拟页</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   <span class="type">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>)  <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">      <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">   <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==========以下是mem_pool_init和mem_init函数,上节已做解析,不再展示。=====================</span></span><br></pre></td></tr></table></figure><p>建议看官阅读代码时，按上面给的函数关系图的顺序进行，这样思路会更加清晰。注释很详细，下面只对几个点做强调：</p><ul><li><p>第 41 行，获取虚拟地址对应的 PTE 地址。如何根据给定的虚拟地址定位相应的页目录和页表？这在<a href="">开启分页-代码详解</a>中提到过，请各位回顾该节，此处不再赘述。</p></li><li><p>第 57 行，“扫描和设置位图要保证原子操作”，这句话的意思是，<strong>扫描和设置位图必须连续，中间不能切换线程</strong> 。这里和线程切换有关，简单作下阐述：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。<strong>由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题</strong> 。因此扫描和设置位图必须保证原子操作。需要注意的是，<strong><font color='orange'>此处代码并没有保证原子性，未来我们会用锁来实现</font></strong> 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></li><li><p>同样是申请页，为什么 vaddr_get() 有申请页数的参数，而 palloc() 没有呢？这个答案在第 100 行 malloc_page() 函数中。这是因为申请的 <strong>虚拟地址必须连续，即必须是一整块虚拟内存；而申请的物理内存则无需连续</strong> （如果要求物理内存连续，则分页机制将彻底变成鸡肋）。所以，申请一大块虚拟内存时，填写你所需的页数参数即可；而申请一大块物理内存时，则需要通过第 115 行的 while() 进行。同时注意，第 58 行的位图扫描，申请个数被指定为 1 。</p></li><li><p><strong><u><font color='gree'>第 79~96 行是需要重点强调的内容</font></u></strong> 。<br>（1）第 79 行判断该 vaddr 对应页目录项是否存在，这句话并不精确，应该是：判断该页目录项对应的页表是否存在。原因是，页目录项一定是存在的（因为页目录表是完整的），不管是现在的内核进程或是将来的用户进程，创建进程时我们都为其开辟一张完整的页目录表内存，<u>只是说可能并不会为所有的页目录项填写信息（安装页目录项）</u>。有人会问，既然并非每个页目录项都记录了信息，那怎么还能通过 79 行的 if 语句判断目录项对应的页表是否存在呢？好问题！<strong>这就是第 133 行将申请到的页内存全部清零的原因</strong> 。将来我们为用户进程开辟页目录表时，会通过 get_kernel_pages() 申请一页内存，并将其作为页目录表。此时页目录表所占字节全为 0（第133行），因此每个页目录项中的 P 位也为 0（表示不对应任何页表），如此一来，就可以通过 P 位来判断该目录项对应的页表是否存在。也就是说，如果不显式安装页目录项，则 P=0，无对应页表。<br>（2）第 85 行注释，<strong><font color='orange'>不论是内核页表还是用户页表，所用页框一律从内核空间分配</font></strong> 。注意，用户进程的页目录表/页表存放在内核空间而非用户空间中，否则恶意用户进程就可以通过某些方式修改内存映射，从而访问内核或其他进程的物理内存。<strong>因此，内存管理都由内核负责！</strong><br>（3）第 93 行，与前类似，须将申请到的页表内存初始化为 0，这样访问某虚拟地址时，如果对应的页表项不存在，即 P=0，则引发缺页异常。注意，笔者最初很疑惑为什么不直接利用 pde_phyadd 清零页表：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pde_phyadd, <span class="number">0</span>, PG_SIZE);</span><br></pre></td></tr></table></figure><p>这是因为：<strong><font color='orange'>由于开启了分页，即使 pde_phyadd 为页表的物理地址，编译器也会将其看作虚拟地址</font></strong> ，所以此方式清零的内存并非物理地址 pde_phyadd！经过第 87 行安装页目录项后，<code>(void*)((int)pte &amp; 0xfffff000)</code> 对应的物理地址才是 pde_phyadd 。这里很绕，请读者反复理解！</p><blockquote><p>内核的页目录被创建时也被初始化为 0，参见<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中 loader.s 的第 122 行代码。</p></blockquote><blockquote><p>在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">分页机制</a>中我们说过，页目录表必须完整，通过以上解析，大家理解了其中的原因吗？由于页目录表已经覆盖所有地址，页表才能够按需创建，这相比于一级页表，大大节省了页表所占用的内存。</p></blockquote><blockquote><p>实际上，只有在用户进程中才会出现页目录项对应的页表不存在的情况。内核代码只运行在 1MB 内，内核堆的约 1GB 空间也已经提前创建好了页表（第769~1022号页表），所以内核不会出现此情况。</p></blockquote></li><li><p>vaddr_get()、palloc()、page_table_add() 均被声明为静态函数，这是因为这三个函数仅供 malloc_page() 函数使用，对外部不可见。</p></li></ul><p><img src="/2022/img/image-20221211151606411.png" alt=""></p><p>OK，本节就到这里，内容少但密度大，注意消化。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解字符串操作函数</title>
      <link href="/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>string</code></p></blockquote><p>下节我们将要实现内存管理，这不可避免地要频繁使用到 memcpy、memset 等函数，有了内存操作函数就很容易实现字符串操作函数 strcpy、strcat 等。所以这节我们来实现内存操作和字符串操作函数。本节内容虽然简单，但有许多代码规范需要注意，还请读者不可掉以轻心。</p><p><strong><mark class="hl-label blue">memset</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst, <span class="type">char</span> var, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((size--) &gt; <span class="number">0</span>)</span><br><span class="line">        *tmp++ = var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，<code>void*</code> 是无法直接作指针运算的，因为编译器无法确定其步长及其解释方式</font></strong> 。因此，需要定义 <code>unsigned char* tmp</code> 来代替 <code>void* dst</code> ，tmp 指针的步长即为 1 字节。以下同理。</p><blockquote><p>什么是指针的步长？就是指 <code>++</code> 或 <code>--</code> 时指针移动的字节数。<br>什么是解释方式？就是指定编译器如何去解释指针所指向的这个数据。</p></blockquote><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">void</span>* src, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    src = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">    dst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(size--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">        dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有以下两点需要注意：</p><ol><li>规范问题：能直接 <code>assert(dst!=NULL &amp;&amp; src!=NULL)</code> 吗？<br>当然可以，但出问题时，你怎么确定是 dst 还是 src 的问题？所以最好细化，便于追踪错误。</li><li>解决了 <strong><font color='orange'>内存重叠</font></strong> 的问题，参考<a href="https://jyx-fyh.github.io/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/">memcpy和memmove</a> 。</li></ol><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* mem1, <span class="type">const</span> <span class="type">void</span>* mem2, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(mem1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(mem2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp1 = mem1;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp2 = mem2;</span><br><span class="line">    <span class="keyword">while</span>((size++) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp1 != *tmp2)</span><br><span class="line">            <span class="keyword">return</span> *tmp1 &gt; *tmp2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        tmp1++;</span><br><span class="line">        tmp2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst,<span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串 src 是不会被改变的，所以要声明为 const 。</li><li>注意第 5 行的检查，这是我们容易忽略的地方。</li><li>第 8 行，赋值运算符也是有返回值的，其返回所赋的值，即 <code>*src</code> 。</li></ul><p>上面代码看上去无懈可击，实际上也存在内存重叠的问题：<br><img src="/2022/img/image-20221205235315941.png" alt="存在内存重叠时，报错"></p><p>因此将代码改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src)+<span class="number">1</span>); <span class="comment">//+1是包括&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20221205235435072.png" alt="修改代码后，正常运行"></p><p><strong><mark class="hl-label blue">strlen</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp++);</span><br><span class="line">    <span class="keyword">return</span> tmp-str<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 -1 可别忘了。</p><blockquote><p>这种方式很容易忽略 1，保险可采用此方式：<code>while(*tmp) tmp++;</code> ；如此就无需减 1 。</p></blockquote><p><strong><mark class="hl-label blue">strcmp</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *dst==*src)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *dst &lt; *src ? <span class="number">-1</span> : *dst &gt; *src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第 10 行，把 0、1、-1三种情况都概括了，很漂亮的方式。</p><p><strong><mark class="hl-label blue">strchr与strrchr</mark> </strong><br>strchr ：参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str &amp;&amp; *str != ch)</span><br><span class="line">        str++;</span><br><span class="line">    <span class="keyword">if</span> (*str == ch)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strrchr ：参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* last_char = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch) </span><br><span class="line">            last_char = str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)last_char;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcat</mark> </strong><br>string-concatenate：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//通过strcpy来实现strcat函数</span></span><br><span class="line">    <span class="built_in">strcpy</span> (dst + <span class="built_in">strlen</span> (dst), src);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strchrs</mark> </strong><br>string-char-reserch：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strchrs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = src;</span><br><span class="line">    <span class="keyword">while</span>(*tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == ch)</span><br><span class="line">            cnt++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础-加载线程</title>
      <link href="/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://blog.csdn.net/qq_26442553/article/details/78729793">并发和并行</a>，<a href="https://cloud.tencent.com/developer/article/1688297">区分进程和线程</a>，《操作系统真相还原》《操作系统哲学原理》<br>本节分支：<code>thread</code></p></blockquote><p>嚯，跨过千山万水，咋们终于要实现线程啦！这是既内存管理后，笔者最期待的部分。正式开干前，先让我们了解一下本节的学习框架。</p><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>并发和并行、同步与异步</font></strong><br>这是常见而又容易混淆的几种关于任务执行的概念，它们与线程、进程息息相关。</li><li><strong><font color='gree'>任务、进程、线程</font></strong><br>任务是 CPU 的最小调度单元；任务既可以是线程，也可以是进程；<strong>线程是在进程基础上进行的第二次并发</strong> 。</li><li><strong><font color='gree'>PCB</font></strong><br>进程/线程的身份证，用于存放进程/线程的管理和控制信息。</li><li><strong><font color='gree'>线程的内核态与用户态实现</font></strong><br>粗略了解这两种方式的优缺点以及现代操作系统对线程的实现模型。</li><li><strong><font color='gree'>线程实现</font></strong><br>初步实现线程，这是下节实现任务调度的基础。</li></ul><h3 id="font-color-red-并发与并行、同步与异步-font"><font color='red'>并发与并行、同步与异步</font></h3><p><strong><mark class="hl-label blue">并发和并行</mark> </strong><br><strong>并发又称“伪并行”</strong> ，<strong>并发的实质是一个物理 CPU 在若干道程序之间来回切换，每一刻都只有一个任务在 CPU 上执行</strong> ，但因为切换任务的速度相当快，所以看上去是多个任务同时执行。</p><blockquote><p>需要注意的是，伪并行降低的是任务的平均响应时间，也就是说，并发让执行时间短的任务可以不必等待那些执行时间长的任务完全结束后再被调度，因此任务的响应速度快了许多；然而，<strong>所有任务的总执行时间实际上不减反增，这是因为任务切换也需要时间</strong> 。但显然，如果能让后面的紧急任务能够及时完成，这点时间成本是微不足道的。</p></blockquote><p><strong>并行则是真正意义上的多个任务同时执行，这必须建立在多核处理器的基础上，每个任务在不同的核上进行</strong> 。<br>另外，还有一个常见的名字是“串行”，并行和串行都指任务的执行方式。<strong>串行是指存在多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个</strong> ，并发的工作方式即为串行。</p><p><strong><mark class="hl-label blue">同步和异步</mark> </strong></p><p>同步和异步，以及阻塞和非阻塞，这两组概览看上去简单，实际上有很多细节需要区分。笔者尚未有讲解该知识点的能力，详细请参考<a href="https://www.zhihu.com/question/19732473/answer/241673170">同步和异步、阻塞与非阻塞</a> 。</p><h3 id="font-color-red-任务、进程、线程-font"><font color='red'>任务、进程、线程</font></h3><p>任务是一个相对而言比较抽象的概念，它是软件发起的某一个活动，其既可以是线程，也可以是进程。<strong><u>任务是独立的执行流，每个任务都具备自己的一套资源（栈、寄存器映像等），这些资源是保证该任务能够被 CPU 单独执行的关键</u></strong> ！什么叫做被 CPU 单独执行呢？举个例子：在 A 任务中调用了 func() 函数，这个 func() 函数是随 A 任务一块被带上处理器的，实际的调度单元是 A 任务而非该函数，换句话说，这个函数是在更大的执行流（A任务）中被“夹杂着、捎带着”执行的，甚至有可能没有等到执行该函数，任务 A 就被换下了 CPU 。在这个例子中，任务 A 为调度单元，即被 CPU 单独执行。如果我们想让 func() 函数成为单独的执行流，就必须为它分配上下文环境，使其成为任务。</p><p><strong><u>线程是任务调度的基本单位</u></strong> ，是独立的执行流，而进程则是多个线程的集合。它们的联系与区别如下：</p><ul><li><p>进程是对运行时程序的封装，是 <strong><font color='gree'>系统进行资源调度和分配的的基本单位</font>，实现了操作系统层面上的并发</strong> ；线程是进程的子任务，<strong><font color='gree'>是 CPU 任务调度和分派的基本单位</font>，是在进程基础上实现的第二次并发</strong> 。</p></li><li><p>一个进程可以有多个线程，<strong><font color='gree'>同一进程的所有线程共享该进程的资源</font></strong> ，如<u>地址空间</u>、代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）；<strong><font color='gree'>但是每个线程拥有自己的栈段，用来存放所有局部变量和临时变量</font></strong> 。</p><blockquote><p>需要强调的是，每个进程都有自己的 4GB 虚拟空间，同一进程内的线程共享该虚拟空间。</p></blockquote></li><li><p>进程可分为单线程进程与多线程进程，在我们平时写的程序中，<u>如果没有显式创建线程，那么该程序就是单线程进程</u>。线程不能独立于进程而存在。</p></li><li><p><strong><font color='gree'>进程=资源+线程</font></strong> 。</p></li></ul><blockquote><p><strong><font color='red'>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务。这个task_struct 数据结构囊括了进程管理生命周期中的各种信息</font></strong> 。</p></blockquote><p>刚才我们提到，在某个任务中调用 func() 函数，则此函数是随该任务一起被放上 CPU 执行的，并非单独的执行流。那么有没有方法能够使某个函数成为单独的执行流呢？有，就是通过线程。<strong>在高级语言中，线程是运行函数的一种方式</strong> ，与普通函数的执行方式不同，线程机制可以为函数创造它所依赖的上下文环境，使函数代码具有独立性，进而能被 CPU 单独调度。下面是 Linux 下 C 语言创建线程的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ThreadFun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg is NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">char</span> * url = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="comment">//定义两个表示线程的变量（标识符）</span></span><br><span class="line">    <span class="type">pthread_t</span> myThread1,myThread2;</span><br><span class="line">    <span class="comment">//创建 myThread1 线程</span></span><br><span class="line">    res = pthread_create(&amp;myThread1, <span class="literal">NULL</span>, ThreadFun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>暂不深究 pthread_create() 函数，有兴趣的同学请自行研究。</p></blockquote><p><strong><mark class="hl-label blue">有了进程为什么还要引入线程？</mark> </strong></p><ul><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，线程之间切换的开销小。所以线程的创建、销毁、调度性能远远优于进程。</li><li>同一进程内的线程共享资源，因此它们之间相互通信无须调用内核，比进程间通信更方便。</li><li>进程采用多个线程（执行流）和其他进程抢占处理器资源，从而节省单个进程的总时间。</li><li>避免某些阻塞使整个进程都被挂起。</li></ul><blockquote><p>那么，在同一个进程下，哪些资源被线程共享，哪些又是线程私享的呢？一般的评判标准是：如果资源独享会导致线程运行错误，则该资源由线程共享。下表给出一般情况下的共享与独享资源划分：</p><table><thead><tr><th>线程共享资源</th><th>线程独享资源</th></tr></thead><tbody><tr><td>地址空间</td><td>栈</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开的文件</td><td>状态字</td></tr><tr><td>子进程</td><td>程序计数器</td></tr><tr><td>堆</td><td>…</td></tr><tr><td>…</td><td></td></tr></tbody></table></blockquote><h3 id="font-color-red-PCB-font"><font color='red'>PCB</font></h3><p>PCB(Process Control Block，程序控制块)，用于唯一地标识一个进程和记录进程的相关信息。<strong><u>PCB 的具体格式并不固定，这取决于操作系统厂商</u></strong> 。PCB 的一些基本信息如下：</p><table><thead><tr><th>内核栈</th><th><strong>内核栈指针</strong></th><th>优先级</th><th>PID</th><th>时间片</th><th>页目录表指针</th><th><strong>进程状态</strong></th><th>…</th></tr></thead></table><p>现代操作系统的 PCB 已经相当复杂，加之笔者也没有深入了解，因此本文不再对其展开，只说我们后面将要用到的东西以及重点内容：</p><ul><li><p>我们的操作系统较小，<strong>PCB 只会占到一页内存</strong> 。<strong><font color='orange'>在 PCB 的顶部是内核栈，内核栈分为中断栈与任务栈；PCB 底端则是 PCB 的相关信息，如栈指针、PID、时间片等</font></strong> 。这点在 <a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理基础</a>中说过，忘记的同学还请回头看看。</p><blockquote><p>既然是内核栈，<strong><font color='gree'>说明此栈是在 ring0 下使用的栈，而非 ring3 下的用户栈</font></strong> 。就因为栈在 PCB 中，所以 PCB 才会占一页的大小。<u>为什么要为每个线程都分配一个内核栈呢</u>？大概有以下原因：</p><ul><li>线程切换就是通过栈切换来实现的（下节内容），如果所有线程共享一个栈，就没法完成任务调度啦。</li><li>将线程相关的所有资源的集中在一起，方便管理。比如线程执行后需要销毁，由于 PCB 中存放着该任务的所有资源，所以直接回收该 PCB 就行了，无需其他多余动作（当然，堆管理另说，这由程序员自己负责 free，否则内存泄漏）。</li></ul></blockquote></li><li><p>不是说同一个进程下的线程共享虚拟空间吗，那为什么 PCB 中还会有页目录表指针呢？是这样的，<strong><font color='gree'>Linux 中不论线程还是进程，都统一由 task_struct 结构体管理，对于线程，页目录表指针被初始化为 NULL；对于进程，页目录表指针指向该进程的页目录表起始地址</font></strong> 。这是线程和进程的最大区别。另外，在进程创建之初，会重新加载 CR2 寄存器（该寄存器中存放的是页目录表的物理地址），这将在后续实现用户进程时提到。</p></li><li><p>优先级并不是说谁先执行，而是指定每次任务执行时所经历的中断次数。初始状态下，时间片等于优先级。之前说过，<strong><u>任务切换是由时钟中断驱动的，也就是说任务调度是在时钟中断处理函数中进行的</u></strong> 。当 A 任务刚被调度上 CPU 时，时间片被初始化为优先级，之后每发生一次中断，时间片就自减 1，当时间片等于 0 时，该任务被换下 CPU 。因此，<strong>优先级越大，占用 CPU 的时间就越长</strong> 。</p></li><li><p>严格来说，<strong><font color='gree'>内核栈指针并不是用来指向内核栈的（内核栈永远位于 PCB 顶端），它是用来指向内核寄存器现场的</font></strong> 。读者看完这句话一定是一头雾水，不急，该指针是任务切换的核心，下节我们会重点剖析该指针的作用，敬请期待。</p></li><li><p><strong>PID就是各进程的身份标识</strong> ，程序一运行系统就会自动分配给进程一个独一无二的 PID 。<strong>PID 只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程</strong> 。PID 将在后续添加，目前暂时不用。</p></li><li><p>一般来说，<strong><font color='gree'>按进程在执行过程中的不同情况至少要定义三种不同的进程状态：运行态(running)、就绪态(ready)、阻塞态(blocked)</font></strong>  。在我们的操作系统中，定义了六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead)。这几态的作用将在后续实现一一体现。</p><blockquote><p>虽然叫做“进程状态”，但这可不意味着只有进程才能使用这个信息，线程同样能使用。</p></blockquote></li></ul><h3 id="font-color-red-线程的内核态与用户态实现-font"><font color='red'>线程的内核态与用户态实现</font></h3><p>由于线程依附于进程而存在，所以其储存方案无需额外设计，而是直接使用进程的储存方案（这就是 Linux 中进程和线程都是用 task_struct 结构体作为任务信息存储结构的原因）。虽然进程与线程采用了相同的储存方案，但两者的调度方式却有所不同。线程产生于进程，理所当然的，其调度就可以由进程负责（用户态）；另一方面，线程调度也可以交给操作系统来管理（内核态）。</p><blockquote><p>进程调度只能由操作系统负责，并不存在用户态一说。</p></blockquote><p><strong><mark class="hl-label blue">内核态实现</mark> </strong><br><strong>优点：</strong></p><ol><li><p>并发性高。采用与进程类似的调度方式，从而使线程实现进程级并发。</p><blockquote><p>什么是进程级并发？由于操作系统直接控制进程，所以当某个进程被阻塞时，操作系统能够立刻检测到这个情况并将其他进程调度上 CPU 。对于内核态实现的线程而言，当某个线程被阻塞，操作系统也可以立即反应过来，并将其他线程调度上 CPU。</p></blockquote></li><li><p>简化用户编程。线程的复杂性由操作系统承担，程序员无需关心线程的调度。</p></li><li><p>提升了进程的速度。当进程内的线程较多时，该进程占据的 CPU 资源就更多，执行时间就越短。</p></li></ol><p><strong>缺点：</strong></p><ol><li>效率较低。每次调度都需要进入内核态，多了些现场保护的栈操作，因此减小了效率。</li><li>占用稀缺的内核资源。线程的数量远多于进程数，因此随着线程的数量增加，内核空间将迅速被耗尽。</li><li>内核态的实现需要修改操作系统。这在提出线程的初期是很难办到的，操作系统厂商可不会轻易将一个未被证明的新概念加入到操作系统中。因此，最初只能由用户自己管理线程。</li></ol><p><strong><mark class="hl-label blue">用户态实现</mark> </strong><br><strong>优点：</strong></p><ol><li>灵活性高。操作系统不知道线程的存在，其仅对用户可见，因此在任何操作系统上都能够实现此方式。</li><li>切换效率高。无需进入内核态，减少了栈操作。</li></ol><p><strong>缺点：</strong></p><ol><li>编程变得复杂。不同于由时钟中断驱动的内核态任务调度，程序员必须时刻考虑什么时候主动让出 CPU ，将控制权交给其他线程。实际上，一旦线程多起来，人为管理将是巨大麻烦。</li><li>无法实现进程级并发。用户态实现下，当进程中的某个线程被阻塞，这将使整个进程都被阻塞！这是致命的缺点。</li></ol><p><strong><mark class="hl-label blue">现代操作系统的线程实现模型</mark> </strong><br>现代操作系统对以上两种实现取其精华、剔其糟粕，将二者有机结合：<strong><u>用户态负责进程内部在非阻塞时的切换；内核态负责线程阻塞时的切换</u></strong> 。同时，每个内核态线程可以负责多个用户态线程，比如，某进程有 5 个线程，操作系统将这 5 个线程划分为两组，一组 2 个，另一组 3 个，每组使用一个内核线程，如下图：</p><img src="/2022/img/IMG_0564(20221216-100357).PNG" style="zoom:67%;" />当某个线程阻塞时，同组的线程皆被阻塞，当另一组仍可继续执行。如此一来，该模型就缓解了以上两种方式的缺点：<ol><li>不必为每个线程都创建对应的内核线程，减小了内核资源的压力。</li><li>不会因为一个线程的阻塞而使整个进程被挂起。</li><li>用户态线程的切换无需经过内核，提高了效率。</li></ol><p><strong>注意，为了简单，本操作系统仅使用内核态实现。</strong></p><h3 id="font-color-red-实现线程-font"><font color='red'>实现线程</font></h3><p>本节是对线程的简单实现，主要让大家理解操作系统是如何 <strong><font color='orange'><u>通过栈切换来完成线程切换的</u></font></strong> 。下面先看 thread.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>*)</span>; <span class="comment">//使用typedef自定义函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TASK_RUNNING,</span><br><span class="line">    TASK_READY,</span><br><span class="line">    TASK_BLOCKED,</span><br><span class="line">    TASK_WAITING,</span><br><span class="line">    TASK_HANGING,</span><br><span class="line">    TASK_DIED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> vec_num;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esp_dummy;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="comment">//------以下为CPU自动压入------------</span></span><br><span class="line">    <span class="type">uint32_t</span> err_code;</span><br><span class="line">    <span class="type">void</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="comment">//------以下为发生特权级转移时自动压入-----</span></span><br><span class="line">    <span class="type">void</span>* esp;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*eip) (thread_func* func, <span class="type">void</span>* func_arg);</span><br><span class="line">    <span class="type">void</span>* unused_retaddr;</span><br><span class="line">    thread_func* function;</span><br><span class="line">    <span class="type">void</span>* func_arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程或线程的pcb,程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;   <span class="comment">//内核栈指针</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span> <span class="comment">//任务状态</span></span><br><span class="line">    <span class="type">uint8_t</span> priority;        <span class="comment">//优先级</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];           <span class="comment">//任务名</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;    <span class="comment">//魔数，用于检测PCB是否被栈破坏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span>;</span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第 4 行 task_status 枚举定义了前文提到的六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead) 。</p></li><li><p>第 14 行定义了中断栈。注意，结构体中靠前的成员位于内存低地址，靠后的成员位于高地址，所以可发现，结构体成员的声明顺序和 <code>interrupt.s</code> 中的压栈顺序是对应的：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE25.png" alt=""><br><strong>必须要说明的是，虽然这两者是一一对应的关系，但我们并不会通过 <code>intr_stack</code> 结构体来取得栈中寄存器的值</strong> ！原因有两点：</p><p>1）没必要取得这些寄存器的值，它们仅用来保护现场。为了安全，也不建议获取它们的值；<br>2）无法保证一定是一一对应的关系。比如，最下方的 SS 和 ESP，此二者仅在发生特权级转移时才会压入，所以是否发生特权级转移将直接影响其对应关系。因此，无法通过该结构体获取栈中的值。那为什么还要声明这个结构体呢？没有其他原因，<strong><u>只是为了得到该中断栈的大小</u></strong> ，以便后续跳过该栈。</p></li><li><p>第 39 行是线程栈，该栈有两个作用：<br>1）保存任务调度的现场，即 ebp、ebx、edi、esi 这四个寄存器。为什么只保存这四个寄存器？这涉及到 ABI，见<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C与汇编混合编程</a>。<br>2）指定线程中要运行的函数及其参数。即最后四个成员。下面重点说说这几个成员：</p><ul><li><p>eip：创建线程时，我们会将 eip 指向 kernel_thread() 函数，通过 kernel_thread 来调用想运行的函数：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span>&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unused_retaddr：这是用来占位的，没有其他作用。为什么要占位？说来话长。进入 kernel_thread() 时，并不是通过 <code>call</code> 指令来调用的，而是 <code>ret</code> 指令。什么不伦不类、莫名其妙的玩意儿？？？干嘛用 <code>ret</code> 来调用函数？读者朋友请别急，笔者初学此处时也是一脸懵逼，现在暂时无法解释，等到下节任务调度时笔者会专门解析这一点，现在只需记住，<u>kernel_thread() 是在 <code>switch.s</code> 中通过 <code>ret</code> 指令进入的</u> 。那么问题来了，<strong>kernel_thread() 是 C 语言写的函数，C 默认这个函数是 call 调用的，所以在寻参时会跳过 call 指令留下的返回地址（call下一条指令的地址）</strong> 。正常调用 kernel_thread() 函数时，其反汇编大致如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push  func_arg</span><br><span class="line">push  function</span><br><span class="line">call  kernel_thread </span><br><span class="line">;------------------进入kernel_thread后</span><br><span class="line">push  [esp-8]</span><br><span class="line">call  function</span><br></pre></td></tr></table></figure><p>其中 <code>[esp-8]</code> 就是寻参，寻的是 func_arg 参数，<strong><u>减 8 则是跳过返回地址和 function 参数</u></strong> 。由于我们用的是 <code>ret</code> 而非 <code>call</code> ，所以必须手动为 kernel_thread() 营造是 call 指令的假象，即，将原本的返回地址用占位符代替，以确保能够正确寻参。</p><blockquote><p>爱思考的读者可能会问，既然我们将返回地址用占位符代替，那这岂不是意味着 kernel_thread() 运行完毕后无法正确地返回？是的，它不能像普通函数那样返回，因为它本身可不普通，它可是运行在线程里的、高贵的函数。哈哈，开个玩笑，这点我们也会在下节中剖析。</p></blockquote></li><li><p>function 和 func_arg 的作用见上一点。值得一提的是，<strong>线程函数(function)的参数必须为 void</strong>* ！<strong>这是为了应对需要向线程函数传递多个参数的情况：<font color='gree'>当需要传递多个参数时，需要将这些参数包装成结构体，并将结构体指针传入即可。如果不使用此方式，想传几个参数就传几个，那么栈操作就无法统一，任务切换也无从谈起。</font></strong></p></li></ul></li><li><p>第 53 行的 task_struct 就是我们的线程控制块啦！前三个成员在前文提到过，这里重点讲解 stack_magic 是如何检测 PCB 是否被破坏的。我们已经知道，内核栈在 PCB 的顶部（高地址处），任务信息在 PCB 的底部（低地址处），由于栈是由高地址向低地址扩展的，所以在某些情况下栈可能会覆盖低地址的 task_struct ：<br><img src="/2022/img/未命名绘图26.png" style="zoom:80%;" /><br>可见，只要 task_struct 被破坏，那么最先被覆盖的一定是 stack_magic（这也是为什么将 stack_magic 声明在最后的原因） ，所以可以通过检测该魔数来判定是否发生破坏。stack_magic 任由你自己决定，应适当复杂。</p></li></ul><p>接着来看 thread.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>* <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line">    pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE); <span class="comment">//将栈指针指向PCB顶端,即栈底</span></span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  name:线程名</span></span><br><span class="line"><span class="comment">*  prio:线程优先级</span></span><br><span class="line"><span class="comment">*  function:执行函数</span></span><br><span class="line"><span class="comment">*  func_arg:函数参数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>); <span class="comment">//pcb都位于内核空间,包括用户进程的pcb也是在内核空间</span></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="built_in">stack</span> = thread-&gt;self_kstack;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebp&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebx&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop edi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop esi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ret&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='gree'>先理理线程创建的整体思路：</font></strong></p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息，包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>代码逻辑比较清晰，下面讲解重点内容：</p><ul><li><p>第 40 行，向内核申请一页内存用来存放 PCB 。之前说过，<strong><u>我们的线程采用内核态实现，由内核管理所有线程，所以必须从内核空间申请</u></strong> 。</p></li><li><p>第 12、13 行减去中断栈和线程栈，使 self_stack 指向线程栈的起点，这是为了让线程栈与 self_stack 结构体一一对应，使相关信息能够准确写入线程栈的正确位置。<strong><font color='orange'>注意，不同于中断栈，我们不会通过 inr_stack 结构体向中断栈赋值或取值；而对于线程栈，我们必须精确赋值，不能将位置搞错，一旦错位，就无法进入线程函数来实行任务啦</font></strong> ！</p></li><li><p>第 18 行，此四个寄存器可初始化为 0，下节你明白为什么。</p></li><li><p>第 44 行就是我们之前常听到的栈切换了，这是任务切换的最关键一步。切换栈很简单，就是通过修改 esp 的指向来完成的。对了，为什么要用静态全局变量 stack 来中转呢？这种用法在<a href="https://jyx-fyh.github.io/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/">assert断言</a>中已经提到过了，由于第 44 行是内联汇编，<strong>汇编只认识全局符号</strong> ，所以我们要使用一个全局变量来中转。经过下面的 4 次 pop 后，esp 便指向了 eip，而 eip 在 <code>thread_create()</code> 中被指向了 <code>kernel_thread()</code> 函数，所以接下来的 <code>ret</code> 指令就会进入到此函数中。之后，<code>kernel_thread()</code> 调用 <code>function()</code> ，开始执行任务。图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE27.png" alt=""></p><blockquote><p>这几句汇编这是我们这节临时使用的方案，下节实现任务切换时会使用正规方法。</p></blockquote></li><li><p>读者朋友可能已经发现，<code>thread_create()</code> 第三个参数是一个 void 指针，用来传递线程函数所需要的参数。问题是，为什么要用 void 指针来传递参数呢？而且万一要传递多个参数，那怎么办？很简单，将多个参数封装成一个结构体，然后将该结构体的指针传入该函数，然后在线程函数中解包就ok了。那么，传指针是唯一的方法吗？能不能学习 printf，使用可变参数列表来进行传参呢，这样可多方便呐！好问题！当你彻底理解任务调度和切换后（本小节和下一小节），你将明白为什么不能使用可变参数列表。</p></li></ul><p><img src="/2022/img/image-20221216210636536.png" alt=""></p><p>本文结束，休息一会，请移步<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程-进阶-任务调度</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理-基础-初始化内存池</title>
      <link href="/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>memory</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong>操作系统内存管理可以说是操作系统中最重要的部分</strong> ，它是未来所有工作的基础。内存管理相当复杂，大约有如下内容：<br><img src="/2022/img/v2-4c9fcddd65b35e84c4c6783aaeee3826_720w.jpg" alt="操作系统—内存管理"></p><p>但本节并不会讨论以上全部内容，而是根据我们自制操作系统的需要来进行。我们当前的任务是完成操作系统的内存划分（本节）以及虚拟内存的申请（下节），即虚拟空间到物理内存的映射，其他内容咋们后续按需补充。本节内容如下：</p><ol><li><strong><font color='orange'>通过 BIOS 中断获取内存容量</font></strong><br>既然要分配内存，就一定需要知道系统的内存容量有多大，这通过 BIOS 中断来获取。</li><li><strong><font color='orange'>通过位图来管理内存</font></strong><br>管理内存时，肯定需要知道哪些内存已经被使用，哪些还没有使用，这些信息通过我们自己维护的位图来获取。</li><li><strong><font color='orange'>规划内存池</font></strong><br>管理内存前，当然还需要对内存做出规划，比如，哪些内存给内核使用，哪些内存又给用户使用。</li><li><strong><font color='orange'>向页表填写映射关系</font></strong><br>我们早就实现了分页机制，就差向其中填入映射关系啦！笔者期待已久，让我们开始吧。</li></ol><h3 id="font-color-red-获取内存容量-font"><font color='red'>获取内存容量</font></h3><p>获取内存容量的例程已经由操作系统厂商写好并存入了 BIOS 中，因此我们只需要调用 BIOS 中断即可。现在问题是，进入保护模式后，BIOS 中断无法再被调用，这怎么办呢？不得已，<strong>我们只能回到 loader.s 中，即进入保护模式之前调用 BIOS 中断</strong> 。</p><blockquote><p><strong>为什么进入保护模式后不能再使用 BIOS 中断</strong> ？</p><ol><li>BIOS 中断例程的地址存放在中断向量表（IVT）中，实模式下使用 <code>int</code> 指令调用中断时，会跳转到 IVT 描述符指向的例程地址；而保护模式下使用 <code>int</code> 指令调用中断时，则是跳转到 IDT 描述符所指向的例程。因此，IVT 不再有效。</li><li>BIOS 中断例程是在实模式，即 16 位模式下运行的代码，这些代码并不能直接运行在 32 位保护模式下。</li></ol></blockquote><p>Linux 采用了三种方式来检测内存容量，如果一种方式失败，就调用下一种，全部失败则挂起。这三种方式都是通过调用 0x15 号 BIOS 中断来进行的，它们的功能号及其特点为：</p><ul><li>EAX = 0xE820 ：遍历主机所有内存。</li><li>AX   = 0xE801 ：最大支持 4GB 。</li><li>AH   = 0x88     ：最大支持 64 MB 内存。</li></ul><blockquote><p>功能号需要装在 EAX 或 AX 中。</p></blockquote><p>由于咋们的操作系统最大不会超过 100 KB，因此我们只使用第三种方式，即 0x88 功能号。因为该部分只需要调用中断，没有其他需要强调或理解的地方，所以此处笔者就不详细记录这三个功能号的中断参数和用途了，详情还请读者朋友移步《操作系统真相还原》第 177 页。下面只贴出我们要用到的 0x88 功能号：<br><img src="/2022/img/IMG_0561(20221206-184055).PNG" alt=""><br><strong>需要注意两点：</strong></p><ul><li><strong>0x88 功能号返回的内存不包括低端 1 MB，因此我们算总内存时还需要加上 1MB 。</strong></li><li>返回后 AX 中的值以 1KB 为单位，所以还需要换算成以 1 字节为单位。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">total_mem_bytes dd 0</span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88:</span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt     ;CF为0则跳转</span><br><span class="line">   and eax,0x0000FFFF;加上1024,即低端的1MB(1024KB)</span><br><span class="line"></span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16       ;把dx移到高16位</span><br><span class="line">   or edx, eax       ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line">   jmp prepare       ;跳转,准备进入保护模式</span><br><span class="line"></span><br><span class="line">.error_hlt:          ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure><p>代码逻辑很简单，注释也足够清晰，不再赘述。需要强调的是，标号 <code>total_mem_bytes</code> 用来存放所得结果，此结果待会会在 memory.c 中使用，因此，我们还得手动算出该标号所代表的地址，以方便在 C 文件中通过指针引用该值。有读者可能会疑惑了，为什么还得手动算地址呢？难道不能像我们之前那样，使用 <code>global</code> 关键字导出 <code>total_mem_bytes</code> ，然后在 C 文件中声明 <code>extern total_mem_bytes</code> 来直接引用这个变量吗？是的，不能。原因在于，我们链接时并没有将 loader.o 包含进来，看下面的 makefile 语句：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KERNEL=build/guide.o  build/print.o  build/main.o build/interrupt.o build/idt.o build/port_io.o \</span><br><span class="line">       build/timer.o  build/intrmgr.o  build/debug.o  build/string.o  build/memory.o  build/bitmap.o \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0x00001500</span><br></pre></td></tr></table></figure><p>其中并没有包含 loader.s 。我猜到你要说什么了：那就包含 loader.s 呗…昂，kernel.bin 可是咋们的内核呀，现在又将 loader 包含进去，可谓不伦不类啦。所以，我们需要手动算出 <code>total_mem_bytes</code> 的地址值，它的位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段</span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06]</span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;检测出的总内存大小,位于0x90c处.前面一共0xc，即12字节</span><br><span class="line">    total_mem_bytes dd 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;BASE_ADDR=0X900</span><br><span class="line">;dd=4bytes, dw=2bytes</span><br><span class="line">BASE_ADDR+4+2+4+2=0x90c</span><br></pre></td></tr></table></figure><p>因此，<code>total_mem_bytes</code> 的地址为 0x90c 。如此，咋们就轻松获取了内存容量的大小，为 32MB，即 0x2000000<br><img src="/2022/img/image-20221207201205263.png" alt=""></p><h3 id="font-color-red-位图-font"><font color='red'>位图</font></h3><p>位图并不止用于内存管理，<strong><u>它是一种映射，用一个位来表示一个对象的状态</u></strong> 。在之前我们也接触过位图，比如 8259A 中的各个寄存器就是关于 IRQ 的位图。现在，我们要使用位图来管理内存，即用一个位来表示某片内存的状态（是否已经使用）。问题是，一个位应该映射成多大的一片内存呢？通过前面内存分页的学习，我们知道内存是按页来分隔的，一页的大小是 4KB，出于这个原因，我们将一个位映射为 4KB 内存，即一个位管理一页内存。<strong><font color='orange'>如果某位为 1，则表示对应的页已经被使用；为 0 则表示该页为空闲状态，可以使用</font></strong> 。<br><img src="/2022/img/IMG_0562(20221206-193514).PNG" style="zoom:67%;" /></p><p>位图结构体的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> btmp_bytes_len;</span><br><span class="line"><span class="comment">/* 在遍历位图时,整体上以字节为单位,细节上是以位为单位,所以此处位图的指针必须是单字节 */</span></span><br><span class="line">    <span class="type">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>btmp_bytes_len</code> 表示位图的长度，包含的总位数为 btmp_bytes_len*32 。该值由位图所管理的内存大小决定。</li><li><code>bits</code> 为位图的指针。<strong>位图也当然是存放在内存中的，所以我们用 <code>bits</code> 指针来记录位图的起始地址</strong> 。</li></ul><p>需要注意，虽然 <code>bits</code> 是 <code>uint8_t*</code> 型的指针，步长为 1 字节，但实际操作时我们会细化为按位处理，即通过掩码来判断相应位是否为 1 。<br>位图的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>bitmap_init</code> ：用来初始化位图，<strong><u>根据传入的 btmp 参数来决定将哪片内存视为位图，并将其初始化为 0</u></strong> 。</li><li><code>bitmap_scan_test</code> ：用来检测位图中第 <code>bit_idx</code> 位是否为 1，该函数只在 <code>bitmap_apply</code> 中调用。</li><li><code>bitmap_set</code> ：用来将位图中的第 <code>bit_idx</code> 位赋值为 0/1 。</li><li><code>bitmap_apply</code> ：在位图中申请<u>连续</u> <code>cnt</code> 个位，若成功则返回起始位的索引(下标)，失败则返回 -1 。</li></ul><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bitmap.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 7</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断bit_idx位是否为1,若为1则返回true，否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line">    <span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &gt;&gt; bit_odd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line"><span class="comment">/* 先逐字节比较,蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> (( <span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len)</span><br><span class="line">    &#123;  <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位，</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对,返回空闲位的索引。*/</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &gt;&gt; idx_bit) &amp; btmp-&gt;bits[idx_byte])</span><br><span class="line">        idx_bit++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;    <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);  <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>;      <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;      <span class="comment">// 先将其置为-1,若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((bit_left--) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit)))  <span class="comment">// 若next_bit为0</span></span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt)     <span class="comment">//若找到连续的cnt个空位</span></span><br><span class="line">        &#123;</span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将位图btmp的bit_idx位设置为value */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(value == <span class="number">1</span>);</span><br><span class="line">    assert(value == <span class="number">0</span>);</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/</span></span><br><span class="line">    <span class="keyword">if</span> (value)    <span class="comment">// 如果value为1</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 若为0</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释较清晰，下面挑重点解释：</p><ul><li><p>第 13 行，重点理解这个按位检测，逻辑也比较简单。需要说明的是，《真相还原》中的原代码是：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));</span><br><span class="line"><span class="comment">//.......</span></span><br></pre></td></tr></table></figure><p>这和我们的代码效果是相同的，笔者之所以作如此改动，是因为改动之后的逻辑更符合我们直觉，即，位是按顺序排列的：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE23.png" alt=""></p><p>而原代码的逻辑是：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE21.png" alt=""></p></li><li><p>第 41 行，为什么要把 cnt==1 的情况单独拿出来呢？因为后面我们申请物理内存时，物理内存池中的页可以不连续，所以传参时 cnt=1；申请虚拟内存时，必须连续，所以 cnt 不必为 1 。由于会大量用到 cnt=1 的情况，所以单独拿出来，避免再做后续处理以提高效率。</p><blockquote><p>没懂上述解释的同学不用慌，下节内存管理进阶我们还会说到这点。</p></blockquote></li><li><p>第 54 行，每当连续的位被断开时，cnt 就需要清零，因为函数要求的是找出连续的 cnt 个位。</p></li></ul><p>位图的介绍就是这些，下面我们用位图来规划内存。</p><blockquote><p>值得一提的是，位图只是内存管理的一种方法，其他常用的方式还有链表，参见<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">空闲内存管理，位图，空闲链表-CSDN</a></p></blockquote><h3 id="font-color-red-规划内存池-font"><font color='red'>规划内存池</font></h3><p><strong><mark class="hl-label blue">什么是内存池？</mark> </strong></p><p>说得高深一点，内存池是内存集合的抽象；说白了，内存池就是上面所说的用来管理内存的位图。所以，内存池的职责就是管理内存，需要内存时，从内存池（位图）中申请；回收内存时，则归还内存池。</p><blockquote><p>可以将位图理解成内存池的物理形式。既然将内存池等同于位图，就说明<strong>内存池的存取粒度和位图一样，都是以 4KB 为单位</strong> 。</p></blockquote><p><strong><mark class="hl-label blue">如何规划内存池</mark> </strong><br>规划内存池，分为两个大的方向：</p><ol><li><strong><font color='orange'>物理内存和虚拟内存的规划</font></strong></li><li><strong><font color='orange'>用户内存和内核内存的规划</font></strong></li></ol><p>这两者必须结合在一起讨论。我们已经知道，虚拟内存这个概念，其本身是针对于进程而言的，每个进程都有 4GB 的虚拟内存，<u>其中一部分</u>虚拟地址会映射到物理内存。那么，我们就不得不考虑如下两点：</p><ul><li><p>这么多进程都有各自的虚拟空间，它们都会争用物理内存，所以<u><strong>操作系统必须知道哪些物理内存被用了，哪些还未被使用</strong></u> ，因此，我们需要建立物理内存池，以管理物理内存的使用情况。</p></li><li><p>虽然每个进程都有自己的虚拟 4GB 空间，但在进程内部，虚拟内存也不能重复使用，即，<strong><u>虚拟地址在进程内是唯一的</u></strong> 。同样，为了管理虚拟地址的使用情况，我们需要建立虚拟内存池。</p><blockquote><p><strong><font color='orange'>注意，虚拟内存在进程是唯一的，但多个进程之间，可以使用相同的虚拟地址，各自的虚拟地址对外是不可见的，相互独立的！</font></strong></p></blockquote></li></ul><p>除此之外，我们还需要将物理内存分为内核内存和用户内存，这是基于以下两点原因：</p><ul><li>操作系统会占用较多内存，毕竟它是其他用户进程的载体，不仅要引导用户程序的运行，还要负责任务调度，内存开辟等诸多重要任务。</li><li>为了内核的正常运行，<u>不能用户申请多少内存就给多少，否则有可能因为物理内存不足而导致内核自己都不能正常运行</u>。</li></ul><p>因此，咋们专门分出内核的专属内存，其他物理内存则划给用户。</p><p>综上所述，我们最后划出三个内存池：<strong><font color='gree'>1）内核物理内存池；2）内核虚拟内存池；3）用户物理内存池</font></strong> 。<br><strong><font color='red'>有了前两者，当内核申请内存时，便会先从内核虚拟地址池中申请发配虚拟地址，接着从内核物理地址池中申请分配物理地址，最后在内核自己的页表中建立虚拟地址到物理地址的映射关系</font></strong> 。这个过程我们很快就会用代码展现出来。接着，你一定会问，为什么只有用户物理内存池，而没有用户虚拟内存池呢？是这样的，用户物理内存池是供所有用户进程使用的，用户共享这一片物理内存池；而 <strong>用户虚拟内存池则是每个用户进程私有的，当创建用户进程时，也会在其内部开辟虚拟池给自己使用</strong> 。用户虚拟内存池将在我们实现用户进程时介绍。</p><p><strong><mark class="hl-label blue">规划细节</mark> </strong><br>话不多说，先放出本操作系统的具体内存安排：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE20.png" alt=""></p><p>下面对以上内存规划进行阐述：</p><ul><li><p>低端 1 MB 完全给内核使用，内核的代码只运行在这 1MB 内，且低端 1MB 物理内存和虚拟内存是一一映射的。这点在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中讲解过。</p></li><li><p>为什么将这三个内存池位图放在低端 1MB 内呢？因为 <strong><font color='orange'>低端 1MB 是不会放入内存池中的</font></strong> ，这 1MB 空间相当于是上帝视角，不受内存管理约束，原因很简单——它自己就是管理者。内存池用于管理其他内存，而不用关心自己所在的内存，否则就是自己管理自己啦，这么说来，将自己所在内存的对应位置 1，岂不是相当于自杀了？哈哈哈哈开个玩笑，原因大概就是如此。</p></li><li><p>PCB (Process Control Block, 进程控制块)，用来管理进程，每个进程的信息（pid、进程状态等）都保存在各自的 PCB 内。关于 PCB 的详细内容会在后面讲线程时提到，现在读者只需记住两点：</p><ul><li><p><strong><u>PCB 需要用一个自然页存放</u></strong> ，即 PCB 的起始地址必须为 0xXXXXX000，结尾必须是 0xXXXXXfff 。</p><blockquote><p>这就是为什么 0x9f000~0x9fbff 未使用的原因——为了凑一个自然页。这么说大家可能还不清楚什么叫做未使用，放一张图各位就知道了：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70-1670387128776-1.png" alt=""><br>原本 0x7E00~0x9FBFF 都是空闲区域，咋们大可以将 PCB 放在 0x9E000~0x9FBFF 处，但无奈 PCB 只能占用一个自然页，所以 0x9F000~0x9FBFF 只能被废弃。</p></blockquote></li><li><p><strong>PCB 的最高处 0xXXXXXfff 以下用于进程/线程在 <u>ring0 下使用的栈</u></strong> 。为什么将栈放置于 PCB 内以及为什么只用于 ring0，这会在后面实现线程时详细阐述。现在读者仍只需知晓，<strong><u>我们的内核代码本身就是一个线程（主线程，或者说单线程进程），所以它也有自己的 PCB</u></strong> ，没错，就是上上图的那个 PCB。因此，在进入内核前（guide.s），我们会将 esp 指向 PCB 的顶端（栈底），即 <code>mov esp,0x9f000</code> 。</p><blockquote><p><strong>先向读者透露一下，PCB 中的栈与线程切换息息相关，可以说，线程切换就是通过栈操作来进行的。</strong></p></blockquote></li></ul></li><li><p>注意，在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>中，我们将页目录表和页表放在了 1MB 地址之上，刚好占用了 1MB~2MB 地址。<u>这里的目录表和页表是供内核进程使用的，已经被占用</u>，<strong><font color='orange'>所以这部分内存也不能划入用户/内核物理内存池</font></strong> 。</p></li><li><p>除开低 2MB 的内存外，<strong><font color='orange'>剩下的 30MB 物理内存<u>平均</u>(各自15MB)分给用户/内核物理内存池</font></strong> 。注意，内核物理内存池位图管理 15MB 物理内存（kernel_pool），所以内核虚拟内存池位图也管理 15MB 虚拟内存；用户物理内存池位图虽然管理 15MB 物理内存（user_pool），用户虚拟内存池位图（位于用户进程中）却管理 4GB 虚拟内存。</p></li><li><p>注意，虽然图示中 0x9a000~0x9e000 用来存放这三个位图，但实际上并没有完全放满。因为我们的操作系统目前就 32MB，压根用不了这么多，这个位图空间我们只用了一小部分（三个位图一共才占 0x5a0 字节），其他剩余空间是预留的，以便于未来扩展此操作系统。</p></li></ul><p><strong><mark class="hl-label blue">内存规划代码剖析</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>virtual_addr</code> 结构体目前仅用于内核<u>虚拟</u>内存池，后期还会用该结构管理用户虚拟内存池。</li><li><code>pool</code> 结构体用于内核与用户<u>物理</u>内存池的管理。为什么 <code>pool</code> 比 <code>virtual_addr</code> 多一个 pool_size 成员呢？这是因为，物理内存是很有限的（本OS为32MB），虽然虚拟地址最大为 4GB，但相对而言却是无限的，因此 virtual_addr 无需记录容量。</li><li>至于为什么还需要指定起始地址，阅读下面的代码后你就会彻底明白。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"><span class="comment">/* 初始化内存池 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_pool_init</span><span class="params">(<span class="type">uint32_t</span> all_mem)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;         <span class="comment">// 为什么乘256,详见下文解析</span></span><br><span class="line">    <span class="type">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;   <span class="comment">// 低端1M内存+页表/目录表都不算入内存池</span></span><br><span class="line">    <span class="type">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="type">uint16_t</span> all_free_pages = free_mem / PG_SIZE;     <span class="comment">// 1页为4k,不管总内存是不是4k的倍数,</span></span><br><span class="line">    <span class="comment">// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。</span></span><br><span class="line">    <span class="type">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;  <span class="comment">// 平均分给内核物理内存池和用户物理内存池</span></span><br><span class="line">    <span class="type">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span></span><br><span class="line">    <span class="type">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;      <span class="comment">// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> ubm_length = user_free_pages   / <span class="number">8</span>;      <span class="comment">// User BitMap的长度.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> kp_start = used_mem;                     <span class="comment">// Kernel Pool start,内核内存池的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;  <span class="comment">// User Pool start,用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start   = up_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = PG_SIZE * kernel_free_pages;</span><br><span class="line">    user_pool.pool_size  = PG_SIZE * user_free_pages  ;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len   = ubm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********    内核内存池和用户内存池位图   ***********</span></span><br><span class="line"><span class="comment">    *   位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    *   全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    *   而我们需要根据总内存大小算出需要多少字节。</span></span><br><span class="line"><span class="comment">    *   所以改为指定一块内存来生成位图.</span></span><br><span class="line"><span class="comment">    *   ************************************************/</span></span><br><span class="line">    <span class="comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span></span><br><span class="line">    <span class="comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="type">void</span>*)MEM_BITMAP_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span></span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line">    <span class="comment">/******************** 输出内存池信息 **********************/</span></span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits + kernel_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_start:      &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_end:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start + kernel_pool.pool_size,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_start:          &quot;</span>,DEFUALT);</span><br><span class="line"></span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_end:            &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits + user_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start + user_pool.pool_size,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将位图置0*/</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span></span><br><span class="line">    <span class="comment">// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.start: &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.end:   &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits + kernel_vaddr.vaddr_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理部分初始化入口 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;mem_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> mem_bytes_total = *((<span class="type">uint32_t</span>*)MEM_SIZE_ADDR);</span><br><span class="line">    put_str(<span class="string">&quot;memory size:&quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(mem_bytes_total,DEFUALT,HEX);</span><br><span class="line">    mem_pool_init(mem_bytes_total);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;<span class="comment">/* 初始化内存池 */</span></span><br></pre></td></tr></table></figure><p>上面的代码配合注释以及之前的讲解，是完全能够看懂的，便不再挨个解释了，只对部分内容进行说明：</p><ul><li><p>第 12 行，<code>MEM_SIZE_ADDR</code> ，即 0x90c ，这就是前文我们存放内存容量的地址；第 98 行，通过对该地址解引用，取得内存大小，随后传参给 <code>mem_pool_init()</code> ，开始初始化内存池。</p></li><li><p>第 19 行，为什么页目录和页表所占内存大小是 <code>PG_SIZE*256</code> ？（1）页目录表，占 1 页；（2）第0、768号页目录项都指向第 0 号页表，此页表占 1 页；（3）第 769~1022 号页目录项一共指向 254 个页表，占 254 页。因此，所占内存大小为 <code>4096*(1+1+254)=PG_SIZE*256</code> 。</p><blockquote><p>有人肯定纳闷了，我们之前不是仅为 769~1022 号页目录项安装了页表的地址吗？并没有创建页表页呀？那为什么还要算入这 254 页的内存大小呢？就是因为我们提前指向了这些页表的地址，每个地址相差 4096 字节，所以才必须为这些页表预留空间哒！笔者起初对这点很疑惑，想了好一会才反应过来，不知道读者会不会有这样的问题。另外，我们在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中也提到过，提前为 769~1022 号页目录项安装页表的地址是为了实现内核的完全共享，忘记的朋友不妨回头看看。</p></blockquote></li><li><p>第 35 行，<strong>物理内存池所管理的物理内存被规定为从 2MB 开始</strong> ，那么为什么要跳过这 2MB 呢？这在前文已经详细说明，0~1MB 是内核空间，1~2MB 是内核进程的页目录和页表，因此这部分物理内存不能再使用，所以不可划入内存池。</p></li><li><p>第 86 行，为什么将内核虚拟起始地址设为 <code>K_HEAP_START</code> ，即 0xc0100000 ？这是因为在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中，<strong>我们已经将虚拟空间高 1GB 处的起始 1MB 直接映射到物理内存的低 1MB 了，所以 0x0~0xc0100000 实际上是运行的内核代码（内核镜像）。因此，内核虚拟池中对应的起始虚拟地址必须跳过这 1MB，即从 0xc0100000 开始分配</strong> 。另外，从 <code>K_HEAP_START</code> 应该也能看出，<strong><font color='gree'><u>内核物理池是用来存放内核开辟的堆</u></font></strong> ，读者应该对堆很熟悉了吧，这就是程序在运行时动态开辟的内存。<strong>内核代码都存放在 0x9a000 内，注意，代码是不会运行在内核物理池中的！</strong></p></li></ul><p><img src="/2022/img/image-20221208113835640.png" alt=""></p><p>好了，本节内容大致就是如此，各位一定还有未能想明白的问题，可在评论区留言。同时也请别着急，进入下一节<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶-分配页内存</a>后，也许你就会恍然大悟。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的#和##</title>
      <link href="/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
      <url>/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-字符串化-font"><font color='red'>字符串化#</font></h3><p>C 语言中，<code>#</code> 号可用于将宏参数转为字符串，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(x)  #x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(STR(age)); <span class="comment">//输出字符串age,而非18</span></span><br><span class="line">    <span class="built_in">printf</span>(STR(<span class="number">18</span>));  <span class="comment">//输出字符串18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法有什么使用场景呢？如下，有时候我们需要取得宏函数参数（表达式/变量）的字面内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">warn(a==<span class="number">0</span>);    <span class="comment">//打印&quot;a==0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在某些情况下很有用，比如 assert 宏，参见<a href="https://jyx-fyh.github.io/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/">assert剖析</a>。</p><p><strong>另外需要注意，当宏参数是另一个宏的时候，宏定义里有用 <code>#</code> 的地方宏参数不会再展开</strong> ，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;Π==3.14&quot;而不是&quot;3.14==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要宏参数展开，则需要使用以下两步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)   _warn(expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;3.14==3.14&quot;而不是&quot;Π==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 warn(expr) 展开时会扩展它的参数，即替换 expr 中的宏变量。</p><h3 id="font-color-red-符号粘贴-font"><font color='red'>符号粘贴##</font></h3><p><code>##</code> 用于拼接两个符号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ponit(x,y) x##.##y </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,point(<span class="number">12</span>,<span class="number">32</span>));  <span class="comment">//输出12.32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，从以上结果可见，转换后的结果不是字符串！</strong> 而是正常的代码或数字。如果想将结果转为字符串，可以采用如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTR(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONT(a,b) TOSTR(a)##TOSTR(b)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(CONT(<span class="number">12</span>,<span class="number">32</span>)); <span class="comment">//输出&quot;1232&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window 下对 <code>##</code> 的一个简单使用是指定字符编码方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) L##x</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) x</span></span><br></pre></td></tr></table></figure><p>当定义了 <code>_UNICODE</code> 时，则 <code>TEXT(&quot;hello&quot;)</code> 为 <code>&quot;hello&quot; </code> ，否则为 <code>L&quot;hellp</code> 。</p><blockquote><p><code>L&quot;str&quot;</code> 是 C/C++ 对宽字节字符的原生支持，表示字符串中的每个字符都是双字节。</p></blockquote><p>另外需要强调的是，<code>#</code> 和 <code>##</code> 都只能用于预处理宏扩展，不能在普通源码中使用。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层剖析assert断言</title>
      <link href="/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/"/>
      <url>/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/20/assert-%E4%B8%8Eif/">assert与if</a> ，<a href="https://jyx-fyh.github.io/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/">C语言中的#和##</a><br>本节对应分支：<code>assert</code></p></blockquote><p>关于 assert 断言函数的意义和用法，请参见<a href="https://jyx-fyh.github.io/2022/06/20/assert-%E4%B8%8Eif/">assert与if</a> ，本文不再赘述。在我们自制的 OS 中，会实现两种 assert 函数，一种为内核服务，另一种为用户进程服务。本节实现内核 assert 函数。</p><p>内核 assert 函数有以下几个要点需要注意：</p><p><strong><font color='gree'>1）</font></strong> 一旦内核 assert 函数被调用，就说明此时发生了严重的错误，系统可能面临崩溃的危险，所以应该立即停止运行。如何让系统停止运行呢？你可能会想到在 assert 函数末尾加上一个 <code>while(1)</code> 。没错，这也是我们的做法，但这还不够！还记得吗，<strong><font color='orange'>操作系统是由中断来驱动并发的，即使当前代码正在 <code>while(1)</code> 中循环，只要发生中断，执行流依旧会转移到中断程序</font></strong> 。如果中断目的是任务调度，那么执行流转移到任务后，因为操作系统已经出现问题，所以任务的执行也是不可靠的。因此，<strong>我们还<font color='orange'>需要关闭中断</font></strong> 。视频演示如下：</p><div id="dplayer6" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/assert.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><blockquote><p>显然，用户进程的 assert 函数无需关闭中断，即使 A 用户程序遇上 assert 而崩溃，B 程序可还要接着运行呢。再者，用户进程也没有关闭中断的权限，因为 <code>cli</code> 指令是 ring0 级别才能使用的指令。</p></blockquote><p><strong><font color='gree'>2）</font></strong> 发生错误后，我们需要快速定位错误源，因此还需要用到几个常见的预定义宏：<code>__FILE__</code> ，<code>__FUNC__</code> ，<code>__LINE__</code> ，分别指示 assert 被触发的所在文件、函数、行号。</p><p>本分支新增了 <code>debug.h</code> 、<code>debug.c</code> 、<code>intrmgr.c</code> 三个文件，以下对此三个文件进行分析。</p><p><strong><mark class="hl-label blue">intrmgr</mark> </strong><br><code>intrmgr</code> 为 <code>interrupt manager</code> 的缩写，意为管理中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/system.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> EFLAGS=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//以下函数的声明放在了interrupt.h</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(INTR_ON==intr_get_status())</span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        STI;</span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_disable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(INTR_OFF==intr_get_status())</span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLI;</span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_get_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pushf; pop EFLAGS&quot;</span>)</span>; <span class="comment">//获取eflags的值</span></span><br><span class="line">    <span class="keyword">return</span> (EFLAGS_IF &amp; EFLAGS) ? INTR_ON:INTR_OFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_set_status</span><span class="params">(<span class="keyword">enum</span> intr_status st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTR_ON &amp; st ? intr_enable() : intr_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>第 29 行，<code>intr_get_status()</code> 函数用于获取中断的开闭状态。第 29 行内联汇编，先使用 <code>pushf</code> 将 EFLAGS 寄存器压栈，再将其弹出到全局变量 EFLAGS 中，这样便获取了标志寄存器的值。注意，如果想要在内联汇编修改 C 语言变量的值，则该变量必须为全局变量！！因为局部变量是不会记录在符号表中的，所以编译器根本不认识局部变量的符号。这涉及到编译原理，详情请参阅《装载，链接与库》。</p><blockquote><p>其实，如果理解了笔者之前的文章<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a>，你也会明白为什么内联汇编不认识局部变量。简单来说，局部变量在函数栈中被创建，其定位是通过 EBP 进行的，而不是通过符号（符号本身代表地址）进行的。</p></blockquote><p>随后第 30 行识别中断开闭状态，并返回该状态。另外，EFLAGS_IF 定义在 interrupt.h 中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF  (1&lt;&lt;9)      <span class="comment">//eflags中的if位</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>intr_enable()</code> 和 <code>intr_disable()</code> 很简单，不再赘述。唯一可能的疑惑是，为什么要返回修改之前的状态？这与以后的任务调度有关，后续还会用到这些函数，我们先提前在这做好准备。</p></li><li><p><code>intr_set_status()</code> 并不多余，它可以提升代码的灵活性，后续我们也会看到这一点。</p></li></ul><p><strong><mark class="hl-label blue">debug.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OSLEARNING_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSLEARNING_DEBUG_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span>* err_msg, <span class="type">char</span>* file_name, <span class="type">int</span> line, <span class="type">char</span>* func)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(expression) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(expr) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(expr)&#123;&#125;       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>&#123;            \</span></span><br><span class="line"><span class="meta">    panic(#expr, __FILE__, __LINE__, __func__);&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//OSLEARNING_DEBUG_H</span></span></span><br></pre></td></tr></table></figure><ul><li><p>再次强调，assert 仅在 Debug 模式下使用，当软件发行（release）后，就需要屏蔽 assert 。因此，在非 Debug 时，定义 NDEBUG 宏，则 assert 成为空值，不参与编译；在 Debug 下，assert 被定义为第 7~10 行代码段。</p><blockquote><p>指定非 Debug 有两种方式：<br>1）使用 GCC 的 <code>-D</code> 参数即可定义 NDEBUG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DNDEBUG</span><br></pre></td></tr></table></figure><p>2）在 debug.h 第 2 行插入 <code>#define NDEBUG</code></p></blockquote></li><li><p>第 10 行使用到了 <code>#</code> 号，用于字符串化，详见<a href="https://jyx-fyh.github.io/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/">C语言中的#与##</a> 。</p></li><li><p>宏定义是以行为单位的，跨多行需要使用 <code>\</code> 进行连接。</p></li><li><p><code>__FILE__</code> ，<code>__FUNC__</code> ，<code>__LINE__</code> 是预定义宏，分别指示该行所在文件、函数、行号，这是在编译阶段就确定了的。</p></li></ul><p><strong><mark class="hl-label blue">debug.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/print.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span>* err_msg, <span class="type">char</span>* file_name, <span class="type">int</span> line, <span class="type">char</span>* func)</span></span><br><span class="line">&#123;</span><br><span class="line">    intr_disable();  <span class="comment">//务必关闭中断</span></span><br><span class="line">    put_str(<span class="string">&quot;\n===============================&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\ndebug error:&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nFileName: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(file_name,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nFunction: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(func,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nLine:     &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_int(line,BG_BLACK+FT_RED,DEC);</span><br><span class="line">    put_str(<span class="string">&quot;\nmessage:  &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(err_msg,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\n===============================&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);       <span class="comment">//将程序停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示如下：</p><div id="dplayer7" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer7"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/assert_debug.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特权级全面剖析(LDT/TSS/GATE)</title>
      <link href="/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/"/>
      <url>/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：《x86汇编：从实模式到保护模式》《操作系统：真相还原》，<a href="https://hackmd.io/@0xff07/HJ5FO4xXc">SegmentationAndPrivilege</a> ，<a href="https://www.scs.stanford.edu/05au-cs240c/lab/i386/s07_02.htm">80386 Programmer’s Reference Manual</a></p></blockquote><h3 id="font-color-red-特权级概述-font"><font color='red'>特权级概述</font></h3><p>我们知道，实模式是单任务系统，对于各个段的隔离，仅依靠分段机制来维护，可以说毫无安全可言。而在保护模式下，通过将内存分为大小不一的段，并用描述符指定各个段的类型与权限，就可以在程序运行时由<u>处理器硬件</u>实施访问保护。但这仍然无法有效保护操作系统，比如，如果恶意程序通过某种方式知道了 GDT 的位置，它就能向段寄存器加载操作系统的数据段描述符，或者在 GDT 中增加一个指向操作系统数据区的描述符，以此来修改操作系统的私有数据。再者，多任务系统对任务之间的隔离与保护，以及任务与操作系统之间的隔离与保护都提出了复杂的要求，基本的段保护机制已经无法胜任。因此，操作系统引入了特权级的概念。</p><p><strong>特权级分为 0、1、2、3 四级，数字越小，权力越大</strong> 。0 级特权级是操作系统拥有的权力；系统程序（如虚拟机, 驱动程序）分别位于 1、2 特权级；用户程序则位于第 3 特权级。<br><img src="/2022/img/IMG_0535(20221127-095601).PNG" alt="特权级环（ring）"></p><blockquote><p>需要注意的是，我们将数值小的级称为高特权级，数值大的称为低特权级，别搞混啦！</p></blockquote><h3 id="font-color-red-LDT-font"><font color='red'>LDT</font></h3><p>LDT，即局部描述符表，大家应该并不陌生了，前文经常提起它的大名。在之前的代码中，我们一直将所有的段描述符放在 GDT 中，而不管它是属于内核还是用户程序（当然，因为我们还没有用户进程，敬请期待）。为了有效地实现任务之间的隔离，处理器建议每个任务都应该有自己专属的描述符表，即 LDT，并且把专属于自己的段放在 LDT 中。</p><blockquote><p>想想看，这是不是很好地呼应了<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>中的内容：<strong>一个完整的程序分为用户代码（私有部分）和操作系统代码（全局部分）</strong> 。</p></blockquote><p>LDT 与 GDT 不同的地方有（笔者目前所知道的）：</p><ol><li><p>每个任务都有自己的 LDT，而一个 CPU 只有一张 GDT ，由所有任务共享。</p></li><li><p>GDT 的第 0 号描述符不可用，LDT 的第 0 号描述符则是可用的。</p><blockquote><p>为什么有这个区别呢？因为在某些情况下（后文会提），CPU 为了控制权限会将选择子初始化为 0，如果后续用户忘记给选择子重新初始化，就会引发异常，<u>这是一种积极的保护措施</u>。而如果指定为 LDT，则选择子的 TI 位为 1，这必然是经过用户显式初始化的结果，完全排除了忘记初始化的可能，因此 LDT 的第 0 个描述符可用。</p></blockquote></li><li><p>GDT 由 <code>lgdt</code> 指令加载进 GDTR 寄存器；LDT 由 <code>lldt</code> 指令加载到 <code>LDTR</code> 寄存器。需要注意的是，与 GDTR 不同，LDTR 是一个 16 位的寄存器，且其中装载的是指向 GDT 的索引，是不是蒙圈啦？别急，接下来我们细说。</p></li></ol><p><strong><font color='orange'>LDTR 中本质上装载的是选择子，这个选择子将其引导到 GDT 中的某一个描述符(LDT描述符)，而这个描述符中装载着 LDT 的信息</font></strong>。换句话说，LDT 的基址和界限等信息都存在 GDT 的描述符当中。让我们看看 LDTR 的结构：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE17.png" alt=""></p><blockquote><p>显然，TI 为必须为 0，即指向 GDT，不然就会指向 LDT 本身。<br>至于为什么不直接将 LDTR 设计为 48 位，然后直接从其中获取 LDT 的基址和界限，而采用这种迂回的方式？这是考虑到特权级检查的问题：用选择子在 GDT 中索引 LDT 描述符，这样就可以套用引用段描述符时的特权级检查（后面我们将会介绍）。</p></blockquote><p>可见，LDTR 和段寄存器有着神之相似。我们在<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">全局描述符表</a>中提到过，32 位 CPU 的段寄存器分为 16 位可见部分(选择子)和不可见部分(高速缓存器,位数根据CPU型号而变)，LDTR 也是如此。<strong><font color='orange'>通过索引在 GDT 中定位到 LDT 描述符所在位置，然后将描述符中的信息加载进不可见部分的高速缓存中</font></strong> 。读者可能忘了，GDT 中可不仅有数据段/代码段，还有系统段，如下：<br><img src="/2022/img/IMG_0502(20221101-114007)-1669466423582-5.png" alt="第三项便是 LDT"></p><blockquote><p>注意，GDT 中不包含中断门和陷阱门。</p></blockquote><p>在多任务系统中，正在执行的任务被称为“当前任务(Current Task)”。<strong><font color='gree'>由于 LDTR 只有一个，所以它仅指向当前任务</font></strong> ，每当发生任务切换，LDTR 中的内容被更新，以指向新的 LDT 。那么问题来了，切换任务时，LDTR 是如何被更新的呢？也就是说 LDTR 中的内容从哪里获取？而且，任务切换时，必须保护旧任务的寄存器现场，这些又保存到哪里呢？这就不得不提到 TSS 了。</p><h3 id="font-color-red-TSS-font"><font color='red'>TSS</font></h3><p>为了保存任务的状态以便在下次切换时恢复，每个任务都需要使用一个额外的区域来保存相关信息，这个区域叫做<strong>任务状态段 (Task State Segment, TSS )</strong> 。TTS 具有固定格式，<u>且最小尺寸为 104 字节</u>，根据需要还可以接上 I/O 位图。TSS 结构如下：<br><img src="/2022/img/2C2361DFB1D1643813669F6D50FF92C5.png" alt=""></p><blockquote><p><strong><font color='pink'>看见 96 字节处的 LDT 段选择子了吗？LDTR 就是从这里获取内容并加载的</font></strong> 。</p></blockquote><p>TSS 是 32 位处理器在<u>硬件上原生支持多任务</u>的一种实现方式，处理器固件能够识别 TSS 中的每个元素，并在任务切换时<u>自动读取</u>其中的信息。既然 TSS 也是内存中的一块区域，且每个任务都有一个 TSS，那 CPU 又如何获取这些 TSS 的位置呢？和 LDT 类似，<strong><font color='orange'>处理器使用 TR(Task Register) 寄存器来指向当前任务的 TSS</font></strong> ，既然是指向当前任务的 TSS，所以 TR 寄存器也只有一个。当发生任务切换时，处理器将当前任务的寄存器现场保存到 TR 指向的 TSS 中；然后再使 TR 指向新任务的 TSS，并根据 TSS 恢复现场。TR 结构如下：<br><img src="/2022/img/fig7-3.gif" alt=""></p><p>可见，TR 寄存器也同段寄存器类似，分为可见的 16 位段选择子与不可见的高速缓冲器。其中 BASE 指向 TSS 所在的起始地址，LIMIT 则为其界限。为什么还有界限呢？因为 TSS 长度是不固定的，会根据 I/O 位图而变化。既然 TR 为选择子，那就肯定有 TSS 描述符，如下：<br><img src="/2022/img/fig7-2.gif" alt=""></p><blockquote><ul><li><strong>TSS 描述符可能只驻留在 GDT 中</strong> ，所以 TR 选择子的 TI 位只能为 1，否则会导致异常。</li><li><strong>LIMIT 字段的值必须等于或大于 103，尝试切换到界限小于 103 的任务会导致异常</strong> 。</li><li>YTPE 字段中的 B 位主要用来判断任务是否重入，即是否为自己调用自己。如果被调用的任务的 B 位为 1，则表明当前任务是在调用自己，这将破坏任务调用链，继而引发严重错误。另外，也并不是只有当前任务的 B 位才为 1，当使用 call 指令进入新任务（成为当前任务）时，不仅新任务的 B 位被置 1，旧任务的 B 位仍保持为 1，这是因为 call 指令是“有去有回”的指令，这说明新任务只是旧任务的分支，待新任务完成后还会回到旧任务，所以本质上它们属于同一个任务。同时，任务的嵌套调用还会影响 eflags 的 NT 位，详见 <a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断超详解</a> 文末。</li></ul></blockquote><p>另外，注意到一个细节没？TSS 中起始位置存放着前一个任务的指针，而这个指针只有 16 字节！奇了怪了，16 位地址怎么定位？细心的读者可能已经观察到了，上一张系统段类型图中，还包含了 TTS 类型，这说明什么？这说明此处 16 位的 <strong><font color='orange'>TTS 指针也是一个选择子</font></strong> ！<strong><font color='orange'>可见，不仅是 LDT，连 TSS 的信息也是作为段描述符存放在 GDT 当中的(即 TSS 也需要在 GDT 中注册)</font></strong> 。</p><blockquote><p><strong>插一句，由于效率问题，Linux 并没有为每个任务都创建一个 TSS，而是所有任务共享一个 TSS，我们的 OS 也会模仿 Linux 的做法，</strong> 详见<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程</a> 。</p></blockquote><p>加载初始任务时，使用 <code>ltr</code> 指令将 TSS 选择子加载进 TR 寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltr 16位寄存器/16位内存单元</span><br></pre></td></tr></table></figure><p>后续任务切换时，由 CPU 自动加载 TR 寄存器。</p><p>关于最上方的 I/O 映射基地址，其内容较多，我们将在另一篇文章中详细阐述。另外一个疑惑是，为什么一个 TSS 中有三个栈呢？这涉及到特权级转移的相关内容，请见下文。</p><h3 id="font-color-red-特权级转移-font"><font color='red'>特权级转移</font></h3><p>代码段发生段间跳转时，其特权级检查是很严格的。<u>一般而言，跳转只允许发生在两个同级的代码段之间</u>。显然，这不能满足我们对操作系统的要求（这意味着不能进行系统调用，用户将什么也做不了）。<strong>因此，为了让低特权级能够调用高特权级的例程，处理器提供了两个办法</strong> ：</p><ol><li><strong><font color='gree'>将高特权级的代码段设为依从</font></strong> 。</li><li><strong><font color='gree'>使用门（ GATE ）</font></strong> 。</li></ol><p>下面我们来详细说明这两点。</p><p><strong><mark class="hl-label blue">依从代码段</mark> </strong><br>还记得段描述符中的 type 字段吗？不用说，肯定忘了，再把图搬过来：<br><img src="/2022/img/image-20221101105041738-1669515483779-2.png" alt=""><br>其中，代码段的 C 位表示代码段的依从属性。<strong><font color='orange'>依从表示可以从特权级比它低的代码段中进入该段</font></strong> 。注意，<strong><font color='orange'>将控制转移到依从的代码段时，要求当前特权级(CPL)必须低于或等于目标(依从)代码段的DPL</font></strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上，因为操作系统无法相信用户程序的可靠性</font></strong> 。</p></blockquote><p>同时，<strong><font color='orange'>转移到目标(依从)代码段后，也并不是以它自己的 DPL 运行，而是在调用程序的特权级上运行。换句话说，当控制转移到依从的代码段上执行时，不会改变当前特权级(CPL)！</font></strong> 举个例子，从特权级为 3 的用户程序切换到特权级为 0 的依从代码段时，当前特权级(CPL)依然是 3，而非 0 。</p><blockquote><p>注意，仅代码段有依从属性，数据段只允许比自己更高或同级的代码段访问！</p></blockquote><p><strong><mark class="hl-label blue">门(GATE)</mark> </strong><br><strong><font color='gree'>另一种从低特权级转移到高特权级的方式就是通过门调用</font></strong> 。<strong>操作系统有调用门、中断门、陷阱门、任务门四种门，它们各有自己的应用环境，但相同点是它们都用来从低特权级的代码段转移到高特权级的代码段</strong> 。下面简单说一下各个门的用途与特权级：<br><strong><u>调用门</u>：</strong> 通过 <code>call</code> 和 <code>jmp</code> 指令进入调用门，操作数为门选择子。<strong><font color='orange'>call 以调用函数的方式向高特权级代码转移；jmp 可以转移到高特权级的代码段，但不改变 CPL</font></strong> 。返回时，使用 <code>retf</code> 返回；调用门可用来实现系统调用；<u>位于 GDT/LDT 中</u>。<br><strong><u>中断门</u>：</strong> 由 <code>int</code> 指令主动发起中断的形式向高特权级代码段转移。Linux 采用中断门实现系统调用。中断将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>中详细展开。另外，<strong><font color='orange'><u>进入中断后，eflags 中的 IF 位自动置零（cli），关闭可屏蔽中断以避免中断嵌套</u></font></strong> 。使用 <code>iret/iretd</code> 返回；<u>仅位于 IDT</u> 。</p><p><strong><u>陷阱门</u>：</strong> 由 <code>int3</code> 指令主动发起中断的形式向高特权级代码段转移，这一般是编译器在调试时使用。<strong><font color='orange'><u>陷阱门和中断门很类似，唯一区别是进入中断后，eflags 中的 IF 位不会自动置零</u></font></strong> 。<u>仅位于 IDT</u> 。<br><strong><u>任务门</u>：</strong> 可以借助中断发起，如果对应的中断向量号是任务门，则发起任务切换；也可以用 call 或 jmp 指令，后接任务门的选择子或 TSS 的选择子。<u>位于 GDT/LDT/IDT 中</u>。</p><h3 id="font-color-red-门（GATE）-font"><font color='red'>门（GATE）</font></h3><p>上文我们粗略了解了门结构，下面我们继续深入剖析。<strong><font color='red'>门结构存在目的就是为了让 CPU 提升特权级</font>，以便完成低特权级下不能完成的工作</strong> 。四种门结构的图示如下：<br><img src="/2022/img/IMG_0539(20221127-174054).PNG" alt="调用门描述符"><br><img src="/2022/img/IMG_0538(20221127-174029).PNG" alt="陷阱门描述符"><br><img src="/2022/img/IMG_0537(20221127-174008).PNG" alt="中断门描述符"><br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>除了任务门以外，其他三种门都是直接指向一段例程（函数)。<strong>和普通段描述符的区别在于，普通段描述符中包含的是<u>段基址</u>和段界限，是在界定内存区域；而这三种描述符中包含的是<u>段选择子</u>和段内偏移地址，它们直接指向内存中的一段程序</strong> 。因此，<strong><font color='orange'>在调用任务门和调用门时，CPU 会忽略调用指令的偏移量</font></strong> ！比如，<code>call 0x9:0x1000</code> ，如果第 9 号段描述符是这两种门描述符，则 CPU 会忽略偏移量 <code>0x1000</code> 。</p><blockquote><p>大家一定疑惑为什么门描述符中还要放目标代码段的选择子，而不直接存放基址？这样迂回好麻烦啊。这一点笔者也不太清楚，但有理由推测，这应该与 LDTR 相同，都是为了引用段描述符的特权级保护（后文将提到）。</p></blockquote><p><strong><font color='orange'>任务门描述符可以放在 GDT、LDT、IDT 中，调用门可以位于 GDT、LDT 中，中断门和陷阱门则只能位于 IDT 中</font></strong> 。正因为调用门和任务门描述符位于 GDT、LDT 中，所以可以通过 <code>call</code> ，<code>jmp</code> 指令调用，原因是它们和普通段描述符类似，都需要通过选择子。而陷阱门和中断门位于 IDT 中，则只能通过中断信号或 <code>int</code> 指令来触发调用。</p><p>门（GATE）这个词很形象，因为“门槛”是调用者特权级的下限，也就是说 <strong>调用者的特权级(CPL)必须高于门描述符的 DPL(门槛)</strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≤门的DPL</span><br></pre></td></tr></table></figure><p>“门顶”则是调用者特权级的上限，<strong><u>调用者特权级不能高于门描述符中目标程序所在的代码段的 DPL</u></strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><p><img src="/2022/img/IMG_0543(20221127-230944).PNG" alt="门的作用相当于蹦床，只起引导作用"></p><blockquote><p><strong>有几点需要说明：</strong></p><ul><li>以上规则适用于调用门，中断门有所不同。</li><li>别忘了，门描述符中装载的是选择子而非段基址，选择子还要去索引目标段描述符。</li><li>为什么要求当前特权级必须高于目标代码段特权级？这点我们在前面已经强调过，这是因为，除了返回指令（iret），任何时候都不允许将控制从高特权级转移到低特权级上，因为操作系统无法相信用户程序的可靠性。</li></ul><p><strong>为什么要通过门这种结构来提升特权级？</strong></p><p>因为门不仅有“门顶”，还有“门槛”，门顶规定只能主动从低特权级转移到高特权级，而门槛规定了能向高特权级进行转移的最低特权级。前者在上面第三点解释了，那后者的原因是什么呢？这是为了防止某些低特权级软件通过门访问一些只为内核服务的程序，比如页故障处理。<strong><font color='orange'>这就是门的本质</font></strong> 。</p></blockquote><p>前面这两个检查，相信大家完全能够理解。然而，实际的特权级检查并非如此简单，这还会牵扯到 RPL，后文将详细剖析。先让我们先看看<strong>实际的特权级检查规则全览</strong> 。</p><h3 id="font-color-red-特权级保护规则-font"><font color='red'>特权级保护规则</font></h3><p><strong><font color='orange'>特权级检查只会发生在往段寄存器赋值的一瞬间</font></strong> ，规则如下：<br><strong>1）<font color='gree'>将控制直接转移到非依从的代码段：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL=目标代码段的DPL </span><br><span class="line">RPL=目标代码段的DPL</span><br></pre></td></tr></table></figure><p>典型例子为 <code>jmp 0x0012:0x2000</code> ，当两个代码段的特权级相同，则检查通过，顺利转移。</p><p><strong>2）<font color='gree'>将控制转移转移到依从代码段：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL  //注意,数值上,CPL大于目标段DPL;实际上,当前特权级低于目标段DPL</span><br><span class="line">RPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><p>控制转移后，当前特权级不变。</p><p><strong>3）<font color='gree'>通过门转移控制权：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL≤门描述符的DPL</span><br><span class="line">RPL≤门描述符的DPL</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，调用门和中断门的特权级检查不同，调用门通过 call 和 jmp 进入，选择子中有 RPL 字段，因此还需要检测 RPL ；<u>而中断门通过中断号调用，所以无法检测 RPL</u> 。</strong> 中断门特权级检查还有几点不同，将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>详述。</p></blockquote><p><strong>4）<font color='gree'>访问数据段时：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL≤目标数据段的DPL</span><br><span class="line">RPL≤目标数据段的DPL</span><br></pre></td></tr></table></figure><p>与代码段转移不同，CPU 只允许高特权级代码段访问低特权级数据段。</p><p><strong>5）<font color='gree'>任何时候，栈段的特权级必须和当前特权级相同：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL=目标栈段描述符的DPL</span><br><span class="line">RPL=目标栈段描述符的DPL</span><br></pre></td></tr></table></figure><p>注意，代码段发生特权级转移时，会自动根据 TSS 将栈更换为同特权级的栈（后文会详解），以上检查只发生在主动给 <code>ss</code> 赋值的时候。</p><p>大家肯定对 RPL 还不太明白，下面我们来理清 RPL，CPL，DPL 的关系。</p><h3 id="font-color-red-剖析-RPL-CPL-DPL-font"><font color='red'>剖析 RPL, CPL ,DPL</font></h3><p><strong><mark class="hl-label blue">DPL</mark> </strong><br>DPL（Descriptor Privilege Level，描述符特权级），位于 GDT/LDT/IDT 的描述符中。<u>对于门描述符，DPL 意味着访问该门的最低特权级；对于段描述符，DPL 意味着访问该段的最高特权级（参考前面的蹦床示意图）</u>。</p><p><strong><mark class="hl-label blue">CPL</mark> </strong><br>CPL（Current Privilege Level，当前特权级），<u>指正在运行的代码所对应的段描述符中的 DPL</u> 。也就是说，当前运行的代码的特权级就是 CPL 。<strong>注意，不要将 CPL 定义为 CS 段寄存器中的 RPL 位（CS.RPL），尽管绝大多数时候 CPL=CS.RPL ，这对后面理解非常重要。</strong></p><p><strong><mark class="hl-label blue">RPL</mark> </strong><br>RPL（Request Privilege Leve，请求特权级），指段寄存器中选择子的低 2 位。注意，什么能发出“请求”？<strong>显然，只有具备能动性的代码段（不一定是当前代码段）才能发出请求，所以 RPL 是指发出访问请求的代码段的特权级</strong> ，这对理解也很重要。</p><blockquote><p>不管是实施控制转移，还是访问数据段，这都能看作是一个请求，请求者请求访问指定的段。因此，<strong>RPL 就是指请求者的特权级</strong> 。<strong>请求者<u>往往</u>是当前代码段自己</strong> ，即 CPL=RPL，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;假设当前代码段的特权级为0</span><br><span class="line">mov eax,0x0009  </span><br><span class="line">mov ds,eax</span><br></pre></td></tr></table></figure><p><strong>由于 CPL 为 0，所以 ds 选择子中的 RPL 也被设置为 0，代表请求者的特权级为 0</strong> 。可是，这个选择子是我们自己设置的呀，我难道不能自己修改 RPL 来伪造请求者的身份吗？想到这点很不错！需要说明的是，上面只是演示，<strong><font color='orange'>实际上选择子是由操作系统提供的（GDT/LDT/IDT都是由操作系统构造，故选择子理所应当也由操作系统提供），操作系统会保障 RPL 的真实身份</font></strong> 。也就是说，<strong><font color='orange'>RPL 一定是为该段寄存器赋值时的代码的特权级</font></strong> ，这话有点绕，还是以上的例子：为 ds 赋值时，该代码段的特权级为 0，因此操作系统会保障 ds 中的 RPL 一定为 0 。怎么保障呢？使用 <code>arpl</code> 指令，其格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arpl 通用寄存器/16位内存, 16位通用寄存器</span><br><span class="line">;即</span><br><span class="line">arpl 用户提交的段选择子,用户代码段CS的值</span><br></pre></td></tr></table></figure><p>具体过程还要涉及栈切换，加上我们的操作系统不会用到该指令，所以此处不做过多讨论，详细请参考《操作系统真相还原》pdf 版第 245 页。有了该指令，即使用户伪造 RPL 也无济于事。</p></blockquote><p>说了半天，我们只了解了 RPL 的内涵，还不知道 RPL 的存在到底有什么必要性。下面对 RPL 的必要性进行阐述。</p><p><strong><mark class="hl-label blue">RPL的必要性</mark> </strong><br><u>假设段选择子不存在 RPL 字段</u>，发生如下场景：某个恶意程序通过一些奇淫巧计获取了内核的数据段选择子，它计划从硬盘读取一个扇区，并将所读数据写入内核的数据段。显然，它自己位于 3 特权级（ring 3），不能直接访问内核数据段。由于涉及硬盘读取，必须通过系统调用访问硬盘，此处使用调用门来进行系统调用。控制转移到调用门后，CPL 从 3 变为 0，此时将内核段选择子传递给内核例程，例程将选择子赋值进 ds，发生特权级检查：CPL=内核数据段描述符的DPL，检测通过。于是，<strong>恶意程序成功向内核数据段写入内容！</strong><br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE19.png" alt=""><br>就这样，恶意程序就这样成功利用调用门的掩护完成了对内核数据段的修改。以上方式出现问题的原因很容易得出：<strong><font color='orange'>受访者不知道访问者的真实身份</font></strong> 。在上例中，访问者的真实身份是恶意程序（ring 3)，然而恶意程序通过调用门这个代理(ring 0)去访问内核数据，内核就以为调用门是真正的请求者（毕竟是调用门直接接触内核的)，于是通过了特权级检查。因此，<strong><font color='orange'>要破解这个问题，我们就必须让内核知道某个请求后有没有背后的请求者，背后真正请求者的特权级是多少</font></strong> 。而 RPL 就是为了解决此问题而生，RPL 代表着 <strong><u>真正</u></strong> 的请求者的特权级。让我们看看当加入了 RPL 后，重复以上情形将发生什么：再一次，恶意程序通过某些方式获取了内核数据段选择子（其中 RPL=0)，当控制权转入调用门时，由于是远转移，处理器会将 cs, eip 等寄存器压栈以保护现场；因此调用门能够从栈中获取恶意程序 cs 中选择子的 RPL（也就是转移前的 CPL)，<strong><u>进而使用 <code>arpl</code> 指令将传入的内核数据段选择子的 RPL 更正为恶意程序自身的 CPL，以保证 RPL 的真实身份</u></strong> ，此时内核数据段选择子的 RPL 变成了 3 ；而后内核例程向 ds 中赋值，发生特权级检查，发现 <code>CPL&lt;=目标数据段的DPL</code> 成立，但 <code>RPL&lt;=目标数据段的DPL</code> 不成立（数据段选择子的RPL=3，而对应描述符的DPL=0)，因此拒绝访问，保卫成功！</p><p>从上面能够看出，<strong>光有 RPL 还不够，必须还要有 <code>arpl</code> 指令保证 RPL 的真实性</strong> 。同时也能发现，<strong>CPL 并不总是等于 RPL，这需要看当前运行的程序在访问数据段或代码段时用的是谁提供的选择子</strong> 。</p><blockquote><p>值得一提的是，<strong>由于效率原因，现代操作系统基本不使用调用门和任务门</strong> ，陷阱门也只在调试时使用。我们的 OS 只用到了中断门。因此，对调用门，任务门，陷阱门不做过多讨论，中断门将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>详细阐述。</p></blockquote><hr><h3 id="font-color-red-特权级下的栈保护-font"><font color='red'>特权级下的栈保护</font></h3><p>之前我们说过，<strong>一个任务被分为用户（私有）和内核（全局）两个部分</strong> ，内核位于第 0 特权级，用户位于第 3 特权级。因此，当特权级发生改变时（系统调用时，从用户态陷入内核态），栈也要发生改变，换句话说，<strong><font color='orange'>不同的特权级应该使用与其同等级的栈</font></strong> 。</p><blockquote><p>不同的特权级应该使用不同的栈，理由如下：</p><ol><li><strong>恶意的低特权级程序可以通过栈获取高特权级的信息，这非常危险。</strong></li><li>如果所有特权级都使用一个栈，那么这种交叉引用将会变得非常混乱。</li><li>用一个栈容纳所有特权级下的数据，栈很可能溢出。</li></ol></blockquote><p>处理器位于 0 特权级时要用 0 特权级的栈，位于 3 特权级时要使用 3 特权级的栈。问题是，一共有 4 个特权级，那么每个任务都应该有 4 个栈，<strong><u>为什么 TSS 中只有 3 个栈呢？这是由于 TSS 中记录的是转移后的高特权级对应的目标栈，因为 ring3 是最低级的，没有更低的特权级会向它转移，所以 TSS 不需要记录 ring3 的栈</u></strong> 。另外，也不是每一个任务都有 4 个栈，这取决于它最低的特权级别。比如 ring3 程序，还能提升 3 级，于是额外拥有 0，1，2 三个特权级的栈；而 ring0 程序则没有额外的栈。下面我们<u>以调用门为例</u>来看看发生特权级转移时，栈是如何变化的。</p><p><strong><font color='gree'>1）</font></strong> 假设当前位于 ring3，有两个参数，欲通过调用门执行 ring0 的内核例程。call 调用门前，先将两个参数压栈，此时的栈理所应当是 ring3 的栈。<br><img src="/2022/img/IMG_0544(20221128-145006).PNG" alt="" style="zoom:67%;" /><br><strong><font color='gree'>2）</font></strong> call 调用门，进行特权级检查，若检查通过，则顺利跳到目标代码段。<br><strong><font color='gree'>3）</font></strong> 由于此时 CPL=0，所以处理器自动在 TSS 中找到合适的栈段选择子 SS0 和 SP0，将其作为新栈。<u>为了在返回时切换回旧栈</u>，需要在新栈中保存旧栈的栈段选择子 SS_old 和栈指针 SP_old：<br><img src="/2022/img/IMG_0545(20221128-150757).PNG" alt="" style="zoom:50%;" /><br><strong><font color='gree'>4）</font></strong> 由于之前压入参数是在旧栈进行的，所以现在需要把参数转移到新栈，处理器怎么知道转移多少个字节呢？这由调用门描述符中的参数个数位给出。通过调用门描述符可知，需要转移两个参数，即 8 字节：<br><img src="/2022/img/IMG_0546(20221128-151203).PNG" style="zoom: 50%;" /></p><blockquote><p>注意，参数复制工作是由 CPU 自动完成，栈切换和参数复制对程序员来说是完全透明的。</p></blockquote><p><strong><font color='gree'>5）</font></strong> 为了将来恢复到用户进程，还需要压入转移前的段选择子 CS 和 EIP：<br><img src="/2022/img/IMG_0547(20221128-153129).PNG" alt="" style="zoom:50%;" /></p><blockquote><p>注意，不论转移前后 CS 中是否是同一个段选择子，CS 都会被重新加载，因此都必须记录 CS 。</p></blockquote><p>转移完成。另外需要注意，<strong><u>如果为平级转移，比如内核程序调用“调用门”，即从 ring0 到 ring0 ，则不会更新当前栈，直接跨过第 3，4 步，来到第 5 步压入 CS 和 EIP</u></strong> 。下面我们再来看看 retf 从调用门返回的过程：<br><strong><font color='gree'>1）</font></strong> 将 EIP_old 和 CS_old 分别弹出到 eip 和 cs 寄存器中，这个过程仍要进行特权级检查！ 若通过检查才能顺利赋值。</p><blockquote><p>你一定觉得返回时的特权级检查很鸡肋，明明我是通过调用门来到高特权级的，怎么返回时还要检查？原因为如下三点：</p><ol><li>retf 也涉及到给 CS 赋值，所以也会有特权级检查。</li><li><strong>retf(从调用门返回)、iret/iretd(从中断门返回) 这两类指令是从高特权级到低特权级的唯一办法</strong> ，而你完全可以使用 retf 来达到远转移的目的。谁说 retf 只能用来返回？给我目标段选择子和偏移量，将其存入栈中，再 retf ，完全可以达到 call 指令的效果。因此，为了防止使用 retf 来进行远转移（而非返回），必须再进行一次特权级检查。</li><li>再者，也可以通过修改栈内的 CS，EIP 来达到返回时进入其他段的目的。其实第 2，3 点也不算正经理由，因为系统调用是系统开发者编写的，开发者总不会这么来玩吧。</li></ol></blockquote><p><strong><font color='gree'>2）</font></strong> 如果有参数，则 ESP_new 跳过参数，指向 ESP_old 。<br><strong><font color='gree'>3）</font></strong> 如果在第 1 步检查中发现特权级发生了改变，则说明切换了新栈，所以从栈中分别弹出 ESP_old 和 SS_old 到 esp 和 ss 中。<br><strong><font color='gree'>4）</font></strong> 如果涉及到特权级改变，则还会检查 DS，ES，FS 和 GS 的内容，如果其中某个寄存器里的选择子所指向的数据段描述符的 DPL 比返回后的 CPL 高(数值上小于)，则会将该寄存器中填充 0 。</p><p>关于第 4 点，做简单解释：当控制转移到内核（ring 0）后，内核程序必然会使用自己的数据段，所以会向 DS/ES/FS/GS 赋予自己的数据段选择子，赋值时发生特权级检查，检查通过则赋值成功，此后对该数据段进行读写时将不再检查。问题就在于此，当从内核返回到用户程序后，DS/ES/FS/GS 很可能还指向内核的数据段，如果此时用户程序对其进行读写，将没有任何限制！因此，<strong>返回后 DS/ES/FS/GS 则可能被自动初始化为 0，如果用户程序直接使用值为 0 的段选择子，则会被索引到 GDT 的第 0 个描述符，而第 0 个描述符是不可用的</strong> ，<strong>从而引发 CPU 第 0x0d 号异常(#GP General Protection)</strong> 。这就是前文提到的为什么 GDT 第 0 号描述符不可用，而 LDT 第 0 号描述符可用的原因。</p><blockquote><p>前文强调过，<strong>特权级检查只发生在向段寄存器赋值的一瞬间，此后任何操作不再受限</strong> 。</p></blockquote><blockquote><p>另外需要注意，发生特权级转移时，调用门和中断门的栈处理是不同的，大概有以下两点：</p><ol><li>中断门还会压入 EFLAGS 寄存器，而调用门不会。</li><li>中断门不能通过栈压入参数，而调用门可以（因为调用门描述符中有4位用来记录参数个数）。</li></ol><p>以上是调用门压栈，关于中断门压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>。</p></blockquote><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加入中断-代码剖析</title>
      <link href="/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a> ，<a href="https://jyx-fyh.github.io/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a><br>本节对应分支：<code>interrupt</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>本节我们为操作系统加入中断，初始化中断描述符表，并为 0~0x2f 中断添加对应的中断处理程序。当前的思路是，在 <code>interrupt.s</code> 中定义实际中断例程的入口函数（ <strong>通过入口函数转移到实际中断例程</strong> ），并利用汇编宏技术得到所有入口函数的地址，形成入口函数的地址数组 <code>interrupt_entry_table</code> ；然后在 <code>idt.c</code> 中引入该数组，进而我们能够很方便地向中断描述符中填写入口函数的地址。现在读者可能不明白这个思路的具体含义，别急，下面做具体阐述。</p><h3 id="font-color-red-代码解析-font"><font color='red'>代码解析</font></h3><p><strong><mark class="hl-label blue">interrupt.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">%define ERROR_CODE nop     ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span><br><span class="line">%define ZERO push 0        ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span><br><span class="line"></span><br><span class="line">extern interrupt_handler_table ;声明中断处理函数的指针数组</span><br><span class="line"></span><br><span class="line">%macro VECTOR 2</span><br><span class="line">INTERRUPT_ENTRY_%1:        ;中断处理entry</span><br><span class="line">    %2</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %1</span><br><span class="line">    call [interrupt_handler_table + %1*4]  ;进入实际中断函数</span><br><span class="line">    add esp, 4             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,0x20            ;中断结束命令EOI</span><br><span class="line">    out 0xa0,al            ;向从片发送</span><br><span class="line">    out 0x20,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,4   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,32位下等同指令iretd</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">;;;;;;;;;以下代码利用宏来定义函数;;;;;;;;;;;;;;;</span><br><span class="line">VECTOR 0x00, ZERO        ;divide by zero</span><br><span class="line">VECTOR 0x01, ZERO        ;debug</span><br><span class="line">VECTOR 0x02, ZERO        ;non maskable interrupt</span><br><span class="line">VECTOR 0x03, ZERO        ;breakpoint</span><br><span class="line">VECTOR 0x04, ZERO        ;overflow</span><br><span class="line">VECTOR 0x05, ZERO        ;bound range exceeded</span><br><span class="line">VECTOR 0x06, ZERO        ;invalid opcode</span><br><span class="line">VECTOR 0x07, ZERO        ;device not avilable</span><br><span class="line">VECTOR 0x08, ERROR_CODE  ;double fault</span><br><span class="line">VECTOR 0x09, ZERO        ;coprocessor segment overrun</span><br><span class="line">VECTOR 0x0a, ERROR_CODE  ;invalid TSS</span><br><span class="line">VECTOR 0x0b, ERROR_CODE  ;segment not present</span><br><span class="line">VECTOR 0x0c, ZERO        ;stack segment fault</span><br><span class="line">VECTOR 0x0d, ERROR_CODE  ;general protection fault</span><br><span class="line">VECTOR 0x0e, ERROR_CODE  ;page fault</span><br><span class="line">VECTOR 0x0f, ZERO        ;reserved</span><br><span class="line">VECTOR 0x10, ZERO        ;x87 floating point exception</span><br><span class="line">VECTOR 0x11, ERROR_CODE  ;alignment check</span><br><span class="line">VECTOR 0x12, ZERO        ;machine check</span><br><span class="line">VECTOR 0x13, ZERO        ;SIMD Floating - Point Exception</span><br><span class="line">VECTOR 0x14, ZERO        ;Virtualization Exception</span><br><span class="line">VECTOR 0x15, ZERO        ;Control Protection Exception</span><br><span class="line">VECTOR 0x16, ZERO        ;reserved</span><br><span class="line">VECTOR 0x17, ZERO        ;reserved</span><br><span class="line">VECTOR 0x18, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x19, ZERO        ;reserved</span><br><span class="line">VECTOR 0x1a, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1b, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1c, ZERO        ;reserved</span><br><span class="line">VECTOR 0x1d, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1e, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1f, ZERO        ;reserved</span><br><span class="line">VECTOR 0x20, ZERO        ;clock 时钟中断</span><br><span class="line">VECTOR 0x21, ZERO        ;键盘中断</span><br><span class="line">VECTOR 0x22, ZERO        ;级联用的</span><br><span class="line">VECTOR 0x23, ZERO        ;串口2对应的入口</span><br><span class="line">VECTOR 0x24, ZERO        ;串口1对应的入口</span><br><span class="line">VECTOR 0x25, ZERO        ;并口2对应的入口</span><br><span class="line">VECTOR 0x26, ZERO        ;软盘对应的入口</span><br><span class="line">VECTOR 0x27, ZERO        ;并口1对应的入口</span><br><span class="line">VECTOR 0x28, ZERO        ;rtc实时时钟</span><br><span class="line">VECTOR 0x29, ZERO        ;重定向</span><br><span class="line">VECTOR 0x2a, ZERO        ;保留</span><br><span class="line">VECTOR 0x2b, ZERO        ;保留</span><br><span class="line">VECTOR 0x2c, ZERO        ;ps/2鼠标</span><br><span class="line">VECTOR 0x2d, ZERO        ;fpu浮点单元异常</span><br><span class="line">VECTOR 0x2e, ZERO        ;硬盘</span><br><span class="line">VECTOR 0x2f, ZERO        ;保留</span><br><span class="line"></span><br><span class="line">;;;;;;;;;中断函数地址表;;;;;;;;;;</span><br><span class="line">global interrupt_entry_table</span><br><span class="line">interrupt_entry_table:</span><br><span class="line">    dd INTERRUPT_ENTRY_0x00</span><br><span class="line">    dd INTERRUPT_ENTRY_0x01</span><br><span class="line">    dd INTERRUPT_ENTRY_0x02</span><br><span class="line">    dd INTERRUPT_ENTRY_0x03</span><br><span class="line">    dd INTERRUPT_ENTRY_0x04</span><br><span class="line">    dd INTERRUPT_ENTRY_0x05</span><br><span class="line">    dd INTERRUPT_ENTRY_0x06</span><br><span class="line">    dd INTERRUPT_ENTRY_0x07</span><br><span class="line">    dd INTERRUPT_ENTRY_0x08</span><br><span class="line">    dd INTERRUPT_ENTRY_0x09</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0f</span><br><span class="line">    dd INTERRUPT_ENTRY_0x10</span><br><span class="line">    dd INTERRUPT_ENTRY_0x11</span><br><span class="line">    dd INTERRUPT_ENTRY_0x12</span><br><span class="line">    dd INTERRUPT_ENTRY_0x13</span><br><span class="line">    dd INTERRUPT_ENTRY_0x14</span><br><span class="line">    dd INTERRUPT_ENTRY_0x15</span><br><span class="line">    dd INTERRUPT_ENTRY_0x16</span><br><span class="line">    dd INTERRUPT_ENTRY_0x17</span><br><span class="line">    dd INTERRUPT_ENTRY_0x18</span><br><span class="line">    dd INTERRUPT_ENTRY_0x19</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1f</span><br><span class="line">    dd INTERRUPT_ENTRY_0x20</span><br><span class="line">    dd INTERRUPT_ENTRY_0x21</span><br><span class="line">    dd INTERRUPT_ENTRY_0x22</span><br><span class="line">    dd INTERRUPT_ENTRY_0x23</span><br><span class="line">    dd INTERRUPT_ENTRY_0x24</span><br><span class="line">    dd INTERRUPT_ENTRY_0x25</span><br><span class="line">    dd INTERRUPT_ENTRY_0x26</span><br><span class="line">    dd INTERRUPT_ENTRY_0x27</span><br><span class="line">    dd INTERRUPT_ENTRY_0x28</span><br><span class="line">    dd INTERRUPT_ENTRY_0x29</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2f</span><br></pre></td></tr></table></figure><p>读者可能又会泄气，怎么又用汇编？能用 C 尽量用 C 不行嘛？哈哈，您的心情我表示理解。使用汇编来编写此文件，有以下几点原因：</p><ol><li>用汇编处理错误码更加方便。</li><li>汇编能够直接发出 EOI 信号。</li><li>使用汇编的宏技术，所有宏函数直接展开，非常方便。</li></ol><p>当然，你也可以使用 C 语言来书写，笔者认为用 C 语言书写此部分应该可以使内核体积更小，毕竟这里的几十个宏函数未来都会被展开，体积就稍微大些。读者可以写两个 C 函数，分别应对有错误码和无错误码的情况。</p><p>接下来剖析代码：</p><ul><li><p>第 5 行，<code>interrupt_handler_table</code> 是位于 <code>idt.c</code> 的指针数组，其中的指针指向实际的中断处理函数。</p></li><li><p>第 7 行，<code>%macro VECTOR 2</code> ，这是汇编宏技术。前面我们使用过 <code>equ</code> 宏定义，它只能定义单行宏；对于多行宏，就需要使用 <code>%macro</code> 实现，其声明方式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%macro 宏名 参数个数</span><br><span class="line">........</span><br><span class="line">代码体</span><br><span class="line">........</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure><p>如果在代码体中想引用某个参数，则必须用 <code>%数字</code> 的方式来引用，参见第 8 行与第 9 行。我们将宏名定义为 VECTOR，并引入了两个参数。怎么压入参数呢？看第 35~82 行，直接在宏名后接上两个参数即可，参数直接用逗号隔开。<strong>注意，宏定义属于预处理指令（伪指令），这些宏会在编译期展开，也就是说，编译后，<code>interrupt.s</code> 中会有 0x30 个第 8~31 行这样的代码段</strong> 。</p></li><li><p>第 8 行为中断入口标号，代表入口函数的地址，下面定义函数指针的数组时会使用这些标号。</p></li><li><p>第 9 行，该行有两种情况，一种是 <code>ZERO</code> 宏对应的 <code>push 0</code> ，另一种是 <code>ERROR_CODE</code> 宏对应的 <code>nop</code> 指令，具体是哪种情况取决于利用宏定义函数时压入的什么参数，参见 35~82 行。注意，<strong><font color='orange'>对于有错误码的中断，CPU 会自动压入错误码；对于没有错误码的中断，CPU 则不进行动作(nop)；然而，对于前者，CPU 在函数返回时主动弹出错误码，必须由我们手动弹出错误码，这点尤其重要！</font></strong> 为了方便操作，有错误码的中断我们不做处理，无错误码的我们就压入 0，这样就统一了各中断函数的弹栈行为，无需特殊处理。关于错误码，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>第 10~14 行，保存当前寄存器环境。由于在 17 行，我们调用了 C 语言编写的实际的中断处理函数，这必将破坏当前的寄存器环境，因此需要保存段寄存器和通用寄存器。其他寄存器会由 CPU 自动保存，关于这部分还请参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>第 16 行，压入中断号，这是实际中断处理函数的参数。在我们的系统中，大多数异常我们不做处理，但发生异常时我们需要知道抛出了哪个异常，因此需要通过中断号来定位错误源。</p></li><li><p>第 17 行，interrupt_handler_table 是 idt.c 中的数组，该数组中装载的是实际中断处理函数的地址。因为是指针数组，指针大小为 4 字节，因此需要用序号乘 4 才能找到函数的地址。</p></li><li><p>第 18 行进行平栈，关于平栈请参见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>。</p></li><li><p>第 26~28 行，发送 EOI 信号，通知 8259A 芯片中断处理结束。这部分内容参见：<a href="https://jyx-fyh.github.io/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/">8259A编程</a> 。</p></li><li><p>第 30 行，主动跨过错误码，原因已在前面阐述。</p></li><li><p>第 86~134 行，定义中断入口数组，即函数指针数组。该数组 <code>interrupt_entry_table[]</code> 会在 <code>dit.c</code> 文件中被引用。</p></li></ul><p><strong><mark class="hl-label blue">global.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OSLEARNING_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSLEARNING_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL0  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL1  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL2  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL3  3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TI_GDT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TI_LDT 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_CODE   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_DATA   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_STACK   SELECTOR_K_DATA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_VIDEO   ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================IDT描述符P================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_P_ON 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_P_OFF 0</span></span><br><span class="line"><span class="comment">//================IDT描述符DPL==============</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_DPL0   0       <span class="comment">//为什么只有0和3？</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_DPL3   3</span></span><br><span class="line"><span class="comment">//==========中断门的s位与type位=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_GATE   0xE     <span class="comment">// S=0(系统段),TYPE=1110(32位中断门)</span></span></span><br><span class="line"><span class="comment">//============================================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> offset_L;       <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    <span class="type">short</span> selector;       <span class="comment">// 代码段选择子</span></span><br><span class="line">    <span class="type">char</span> reserved ;       <span class="comment">// 保留不用</span></span><br><span class="line">    <span class="type">char</span> s_type :<span class="number">5</span>;       <span class="comment">// 系统段:任务门/中断门/陷阱门/调用门</span></span><br><span class="line">    <span class="type">char</span> DPL    :<span class="number">2</span>;       <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    <span class="type">char</span> present:<span class="number">1</span>;       <span class="comment">// 是否有效</span></span><br><span class="line">    <span class="type">short</span> offset_H;       <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; __attribute__((packed));<span class="comment">//声明不要进行对齐</span></span><br><span class="line"><span class="comment">//=================GDT/IDT指针=================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>     base;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="comment">//======加载GDT/LDT指针的函数，直接内联===========</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">load_xdt</span><span class="params">(<span class="keyword">struct</span> xdt_ptr* p, <span class="type">unsigned</span> <span class="type">short</span> limit, <span class="type">unsigned</span> <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;base=base;</span><br><span class="line">    p-&gt;limit=limit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//OSLEARNING_GLOBAL_H</span></span></span><br></pre></td></tr></table></figure><ul><li>结构体 <code>gate_desc</code> 是中断描述符结构。该结构体有两点需要注意：<br>1）使用了位域，即为 <code>s_type</code> ，<code>DPL</code> ，<code>present</code> 字段按位分配而非按字节分配。可别以为声明了 char 就是分配了一个字节。<br>2）结构体声明的末尾 <code>__attribute__((packed))</code> 是在**<font color='orange'>指示编译器不要进行结构体对齐，这点很重要</font>** 。详细参考<a href="https://jyx-fyh.github.io/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a> 。</li><li><code>xdt_ptr</code> 是 IDTR/GDTR 的结构体。当前我们只使用 IDTR，后续还会使用 GDTR 。</li></ul><p><strong><mark class="hl-label blue">idt.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/system.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">idt_ptr</span> ;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*  interrupt_name[IDT_DESC_CNT];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> <span class="title">idt</span>[<span class="title">IDT_DESC_CNT</span>];</span>                 <span class="comment">//idt-中断描述符表</span></span><br><span class="line"><span class="keyword">extern</span> intr_handler interrupt_entry_table[IDT_DESC_CNT];   <span class="comment">//引用interrupt.s中的中断处理函数入口数组,注意，这是一个指针数组</span></span><br><span class="line">       intr_handler interrupt_handler_table[IDT_DESC_CNT]; <span class="comment">//实际中断处理例程的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_idt_desc</span><span class="params">(<span class="keyword">struct</span> gate_desc* p_desc, <span class="type">unsigned</span> <span class="type">char</span> DPL, intr_handler function)</span> &#123;</span><br><span class="line">    p_desc-&gt;offset_L = (<span class="type">unsigned</span> <span class="type">int</span>)function &amp; <span class="number">0x0000FFFF</span>;       <span class="comment">//低16位赋值给offset_L，高位丢弃</span></span><br><span class="line">    p_desc-&gt;offset_H = ((<span class="type">unsigned</span> <span class="type">int</span>)function&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000FFFF</span>; <span class="comment">//低16位赋值给offset_L，高位丢弃</span></span><br><span class="line">    p_desc-&gt;selector = SELECTOR_K_CODE;</span><br><span class="line">    p_desc-&gt;reserved = <span class="number">0</span>;</span><br><span class="line">    p_desc-&gt;s_type   = IDT_DESC_GATE;</span><br><span class="line">    p_desc-&gt;DPL      = DPL;</span><br><span class="line">    p_desc-&gt;present  = IDT_DESC_P_ON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化可编程中断控制器8259A */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化主片 */</span></span><br><span class="line">    outb (PIC_M_CTRL, <span class="number">0x11</span>);   <span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x20</span>);   <span class="comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x04</span>);   <span class="comment">// ICW3: IR2接从片.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x01</span>);   <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化从片 */</span></span><br><span class="line">    outb (PIC_S_CTRL, <span class="number">0x11</span>);<span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x28</span>);<span class="comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x02</span>);<span class="comment">// ICW3: 设置从片连接到主片的IR2引脚</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x01</span>);<span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line">    <span class="comment">/* 打开主片上IR0,也就是目前只接受时钟产生的中断 */</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0xfe</span>);</span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0xff</span>);</span><br><span class="line">    put_str(<span class="string">&quot;pic_init done\n&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;idt_init start\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">    idt_desc_init();         <span class="comment">//初始化中断描述符表</span></span><br><span class="line">    general_handler_regist();    <span class="comment">//默认中断函数注册</span></span><br><span class="line">    pic_init();             <span class="comment">//初始化8259A</span></span><br><span class="line">    load_xdt(&amp;idt_ptr,IDT_DESC_CNT*<span class="number">8</span><span class="number">-1</span>,idt); <span class="comment">//注意，limit=size-1，书中代码有误</span></span><br><span class="line">    <span class="comment">/* 加载idt */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;idt_init done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">general_intr_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> vec_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec_num==<span class="number">0x27</span> || vec_num==<span class="number">0x2f</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    put_str(<span class="string">&quot;\ninterrupt &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_int(vec_num, BG_BLACK+FT_RED,HEX);</span><br><span class="line">    put_str(<span class="string">&quot; occur: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(interrupt_name[vec_num],BG_BLACK+FT_RED);</span><br><span class="line">    put_int(time, BG_BLACK+FT_RED,DEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">general_handler_regist</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;IDT_DESC_CNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        interrupt_handler_table[i]= general_intr_handler;   <span class="comment">//将一般函数的地址安装到中断函数表中</span></span><br><span class="line">        interrupt_name[i]=<span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt_name[<span class="number">0</span>]    = <span class="string">&quot;Divide Error\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">1</span>]    = <span class="string">&quot;Debug Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">2</span>]    = <span class="string">&quot;NMI Interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">3</span>]    = <span class="string">&quot;Breakpoint Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">4</span>]    = <span class="string">&quot;Overflow Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">5</span>]    = <span class="string">&quot;BOUND Range Exceeded Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">6</span>]    = <span class="string">&quot;Invalid Opcode Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">7</span>]    = <span class="string">&quot;Device Not Available Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">8</span>]    = <span class="string">&quot;Double Fault Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">9</span>]    = <span class="string">&quot;Coprocessor Segment Overrun\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xa</span>]  = <span class="string">&quot;Invalid TSS Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xb</span>]  = <span class="string">&quot;Segment Not Present\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xc</span>]  = <span class="string">&quot;Stack Fault Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xd</span>]  = <span class="string">&quot;General Protection Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xe</span>]  = <span class="string">&quot;Page-Fault Exception\n&quot;</span>;</span><br><span class="line">    <span class="comment">//interrupt_name[15]  第15项是intel保留项，未使用</span></span><br><span class="line">    interrupt_name[<span class="number">0x10</span>] = <span class="string">&quot;x87 FPU Floating-Point Error\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x11</span>] = <span class="string">&quot;Alignment Check Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x12</span>] = <span class="string">&quot;Machine-Check Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x13</span>] = <span class="string">&quot;SIMD Floating-Point Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x14</span>] = <span class="string">&quot;Virtualization Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x15</span>] = <span class="string">&quot;Control Protection Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x16</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x17</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x18</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x19</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1a</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1b</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1c</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1d</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1e</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1f</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x20</span>] = <span class="string">&quot;Clock interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x21</span>] = <span class="string">&quot;Keyboard interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x22</span>] = <span class="string">&quot;Clock interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x23</span>] = <span class="string">&quot;Cascade\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x24</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x25</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x26</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x27</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x28</span>] = <span class="string">&quot;RTC\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x29</span>] = <span class="string">&quot;Relocation\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2a</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2b</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2c</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2d</span>] = <span class="string">&quot;FPU Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2e</span>] = <span class="string">&quot;Disk interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2f</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>make_idt_desc() 函数用于构造单个<u>中断门</u>描述符。注意第三个参数，是中断入口函数的指针，<code>typedef void* intr_handler</code> ，该声明在 interrupt.h 中。</li><li>idt_desc_init() 函数用来构造整个 IDT 表。</li><li>pic_init() 函数用来初始化 8259A 芯片，<strong>并将当前设置为只接收时钟中断</strong> 。其中还用到了 outb() 函数，该函数用汇编书写，在 <code>port_io.s</code> 文件中。端口号的宏在 <code>interrupt.h</code> 中。</li><li>general_intr_handler() 便是便是我们期待已久的实际中断程序，不过现在它很简陋。<strong><font color='orange'>先统一将所有的中断处理程序都设置为该函数，未来我们会使用 register_handler() 来注册专门的中断程序</font></strong>。另外，<strong>0x27 和 0x2f 无需处理</strong> 。</li><li>最后，在 general_handler_regist() 中将 interrupt_handler_table 数组的每一个元素赋值为 general_intr_handler 函数的指针。再次强调，现在虽然每个中断都使用同一个函数，但后期对于某些中断我们会将其专门化，现在只是为中断提供基本的信息，以便产生中断时我们能明白发生了什么中断。</li></ul><p>大家可能对各个函数之间的关系感到混乱，下面用一张图来帮助各位理清思绪：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE0.png" alt=""><br><img src="/2022/img/image-20221201140151874.png" alt="运行截图"></p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断/IDT超详解</title>
      <link href="/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a><br>文章参考：<a href="https://blog.csdn.net/wlf_go/article/details/80319417">中断的作用</a> ，《真相还原》，<a href="https://blog.csdn.net/WriteAnything_/article/details/119205756">Bochs源码分析</a> ，《X86汇编：从实模式到保护模式》</p></blockquote><h3 id="font-color-red-什么是中断？-font"><font color='red'>什么是中断？</font></h3><p><strong><font color='orange'>定义：中断是指计算机运行过程中，出现某些情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</font></strong><br>中断是 CPU 对系统发生的某个事件作出的一种反应。引起中断的事件称为<strong>中断源</strong> ；中断源向 CPU 提出处理的请求称为<strong>中断请求</strong> ；发生中断时被打断程序的暂停点成为<strong>断点</strong> ；CPU 暂停现行程序而转为响应中断请求的过程称为<strong>中断响应</strong> ；处理中断源的程序称为<strong>中断处理程序</strong> ；CPU执行有关的中断处理程序称为<strong>中断处理</strong> ；而返回断点的过程称为<strong>中断返回</strong> 。</p><h3 id="font-color-red-中断的意义-font"><font color='red'>中断的意义</font></h3><ul><li><p><strong><font color='orange'>操作系统由事件驱动，而事件是以中断的形式来通知操作系统的，所以操作系统是由中断来驱动的。</font></strong></p></li><li><p><strong>中断机制是现代计算机系统中的基础设施之一，它在系统中起着通信网络作用(相当于信号)，以协调系统对各种外部事件的响应和处理。</strong></p></li><li><p><strong>中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率</strong> 。如果没有中断系统，CPU 就只能按照原来的程序编写的先后顺序，对各个外设进行查询和处理，即 <strong><u>轮询</u></strong> 工作方式，轮询方法貌似公平，但实际工作效率很低，不能及时响应紧急事件。</p></li><li><p><strong>中断能够显著提升并发，从而提高效率。</strong></p><blockquote><p>因为中断是由信号引发，只要收到信号，马上转移执行流，开始中断程序。只要信号频率足够，就能实现并发。</p></blockquote></li></ul><h3 id="font-color-red-中断的分类-font"><font color='red'>中断的分类</font></h3><img src="/2022/img/未命名绘图14-1669431386307-9.png" alt="" style="zoom:80%;" /><ul><li><p><strong><font color='gree'>硬中断</font></strong> ：即来自 CPU 外部的中断，中断源为外部硬件，故而又叫硬件中断。<strong>外中断又分为可屏蔽中断和不可屏蔽中断：</strong></p><ul><li><p><strong><font color='gree'>可屏蔽中断</font></strong> ：<u>绝大多数外中断都是可屏蔽中断</u>，例如网卡收到网络包并通知 CPU；打印机向 CPU 发出提示等。当 eflags 中的 IF 位为 0 时，CPU 忽视可屏蔽中断；IF 为 1 时，接收可屏蔽中断。<strong><font color='red'>IF 仅对可屏蔽中断有效</font></strong> 。</p><blockquote><p>还记得吗？我们可以通过 <code>sti/cli</code> 指令开关外中断，即置 IF 位为 1/0 。</p></blockquote></li><li><p><strong><font color='gree'>不可屏蔽中断</font></strong> ：<u>通知CPU发生了灾难性事件</u> ，如电源掉电、总线奇偶位出错等。</p></li></ul></li><li><p><strong><font color='gree'>软中断</font></strong> ：来自 CPU 内部或软件的中断，分为以下三类：</p><ul><li><p><strong><font color='gree'>陷阱(trap)</font></strong> ：陷阱是软件<u>主动</u>发起的中断，并不是某种内部错误。<strong><font color='red'>陷阱是实现系统 API 函数调用的手段</font></strong> 。<strong>陷阱通过 <code>int</code> 指令调用，如 <code>int 0x80</code></strong> 。</p><blockquote><p>在 Linux 中，使用了一个，也是唯一的一个 trap，就是 int 0x80 系统调用。</p></blockquote></li><li><p><strong><font color='gree'>终止(Abort)</font></strong> ：终止严重错误，如系统表 IDT、GDT 中的数据不一致或无效。发生该类错误时，恢复正常已经非常困难，所以操作系统通常只能把该任务从系统中抹去。</p></li><li><p><strong><font color='gree'>异常(fault)</font></strong> ：异常是 CPU 内部出错所发起的中断，<strong>有些异常可以主动调用，如 bound、int3；另一些异常则无需（不是不能）主动调用，如除零异常</strong> 。笔者了解的<u>可主动调用的异常</u>大概有以下几种：</p><ol><li><p><strong>bound</strong> ：检查数组越界指令，触发 5 号中断，用于检测数组的索引是否在上下边界之内。其格式为：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bound r16,m16</span><br><span class="line">bound r32,m32</span><br></pre></td></tr></table></figure><p>r16/r32 中存放的是数组索引，m32/m16 地址处存放了一对地址，第一个地址是数组的下限(起始)，第二个地址是数组的上限。如果索引不在边界内，则会发出超出边界范围的异常，即 0x5 号异常。</p></li><li><p><strong>ud2</strong> ：未定义指令，表示该指令无效，CPU 无法识别，触发 6 号中断。该指令常用于软件测试，无实际用途。</p></li></ol><blockquote><p>顺便提一下常见的两个<u>陷阱</u>：</p><ol><li>into：中断溢出指令，触发 4 号中断。是否能触发还要看 eflags 寄存器中的 OF 位是否为 1，若不为 1，则直接无视。</li><li>int3：调试断点指令，触发 3 号中断。注意是 int3 而非 int 3，这两者不同。</li></ol><p>需要注意的是，into 与 int3 指令经常被划为异常，实际上它们是陷阱，原因下面阐述。</p></blockquote></li></ul></li></ul><p>这里重点强调陷阱和异常的区别：<strong><font color='red'>陷阱时，会向栈中压入 EIP，该 EIP 指向触发异常的那条指令的<u>下一条指令</u> ；而异常发生时，压入的 EIP 是指向触发异常的那条指令</font></strong> ！<strong><font color='red'>因此，当从异常返回时，异常会重新执行那条指令；而陷阱就不会重新执行</font></strong> 。这一点实际上也是相当重要的，比如我们熟悉的缺页异常（page fault），由于是 fault，所以当缺页异常处理完成之后，还会去尝试重新执行那条触发异常的指令（此时所缺页一般已经被加载进内存）。而上面我们谈到的 into/int3 中断执行完后并不会再执行原指令，所以它应该是 trap 而非 fault 。下面调用除零溢出来证实上面观点，见下图：<br><img src="/2022/img/image-202211252258470191.png" alt=""><br>大家快看！咋们只 div 了一次，却一直循环发生除零错误，这就是因为当异常处理完毕后，还会跳转到之前那条触发异常的指令。图中还夹杂了时钟中断，后续会详解。<strong>需要说明的是，如果你手动调用异常，就不会循环跳转了</strong> ：<br><img src="/2022/img/image-20221125230745566-1669431365728-6.png" alt=""></p><blockquote><p>这部分代码在 <code>interrupt</code> 分支，有兴趣的朋友可以提前玩玩。</p></blockquote><p>下面给出中断的类型分布图：<br><img src="/2022/img/image-20221125231200731-1669431362976-4.png" alt=""></p><p>另外，外中断是通过 INTR(interrupt) 和 NMI(Non Maskable Interrupt) 这两根信号线来通知 CPU 的。<strong>从 INTR 引脚收到的外中断是可屏蔽中断，由 eflags 的 IF 位决定是否接受；从 NMI 引脚收到的是不可屏蔽中断</strong> ，不可忽略。图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE15-1669431351849-2.png" alt=""><br>需要注意的是，由于不可屏蔽中断一旦发生，就意味着局面已经无法挽回，操作系统也无能为力，所以就没必要再细分原因。因此，<strong><font color='orange'>所有不可屏蔽中断都被划入一个中断号，即 0x2</font></strong> 。</p><p><strong><font color='gree'>异常和不可屏蔽中断的中断向量号由 CPU 自动提供，不能修改；可屏蔽中断的中断向量号由中断代理(8259A)提供；陷阱的中断向量号由操作系统提供</font></strong> 。<strong>CPU 为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是： （1）除法错、溢出中断、陷阱 （2）不可屏蔽中断 （3）可屏蔽中断 （4）单步中断。</strong></p><h3 id="font-color-red-中断描述符表IDT-font"><font color='red'>中断描述符表IDT</font></h3><p><strong>中断描述符表（Interrupt Descriptor Table，IDT）</strong> 是 <strong><u>保护模式</u></strong> 下用于储存中断程序入口地址的表。当 CPU 接收到中断时，需要用该中断的中断号去检索 IDT 中对应的描述符，描述符中储存着该中断例程的地址，接着跳到该地址处执行程序。</p><blockquote><p>需要注意的是，实模式下的中断表叫做 <strong>中断向量表（Interrupt Vector Table，IVT）</strong> ，它的作用和 IDT 完全相同，其他不同之处有以下两点：</p><ul><li><u>IVT 的描述符为 4 字节，而 IDT 的描述符为 8 字节</u>。</li><li>IVT 的位置固定在 0x0000~0x03FF ，而 IDT 可放于任意位置（由 IDTR 跟踪）。</li><li>IVT 是由 BIOS 在开机时建立的，中断例程也已经建立好了；而 IDT 以及其对应的中断例程都需要我们自己建立。</li></ul><p>另外，<strong><font color='orange'>BIOS 中断在保护模式下无法使用</font></strong> ，因为其中断例程都是用于 16 位指令架构，不再适用于 32 位保护模式。关于 IVT，详细内容可参考<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。</p></blockquote><p>中断描述符中装着各种门的描述符，<strong>包括<u>任务门</u>、<u>中断门</u>和<u>陷阱门</u>描述符（注意，不包含调用门）</strong> ，这三种描述符的结构和作用请参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> ，就不在此赘述了。</p><p>IDT 与 GDT 的不同之处大概有以下几点：</p><ol><li>GDT 的第 0 个描述符不可用；IDT 的第 0 个描述符是可以用的，且第 0 个中断为著名的除零异常（上面已经演示）。</li><li>GDT 中包含普通段描述符、TSS描述符、LDT描述符、调用门/任务门描述符。而 IDT 则只包含中断门/陷阱门/任务门描述符。</li><li>GDT 最多能容纳 8192 个描述符，<strong>而 IDT 最多只能有 256 个描述符</strong> （即使 IDTR 的索引部分有 13 位）。</li><li>GDT 描述符由操作系统编写者自己定，而 IDT 中第 0~19 号描述符的作用已经写死进 CPU，不能自己决定。</li></ol><p>另外，IDT 的位置由 IDTR 寄存器进行跟踪，其格式和 GDTR 相同（回想一下 IDTR 的结构）：</p><p><img src="/2022/img/2%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1669635127754-1.png" alt=""><br>使用 <code>lidt</code> 进行加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lidt 48位内存数据</span><br><span class="line">;lidt [idt_ptr]</span><br></pre></td></tr></table></figure><h3 id="font-color-red-中断错误码-font"><font color='red'>中断错误码</font></h3><p><strong>有些异常产生时，CPU 会<font color='orange'>自动</font>在中断任务的栈中压入一个错误代码</strong> ，此错误码一般用来报告异常是在哪个段上发生的，因此错误码中包含了选择子等信息。错误码格式如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE163.png" alt=""></p><ul><li><strong>EXT(External Event)</strong> ：此位置 1 时，表示异常由 NMI、硬件中断等引发，</li><li><strong>IDT</strong> ：用于指示该选择子索引是指向哪的。为 1 时，指向中断描述符表(IDT)；为 0 时，指向 GDT 或 LDT 。</li><li><strong>TI</strong> ：<u>仅在 IDT 为 0 时有效</u>。此位为 1 时，指向 GDT；为 0 时，指向 LDT 。</li></ul><p>需要重点强调的是，<strong><font color='orange'>当通过 iret/iretd 指令从中断程序返回时，CPU 并不会自动弹出错误码</font></strong> ！因此，<strong><font color='red'>对于那些有错误码的中断例程(见上文的中断图)，必须在 iret/iretd 前手动弹出错误代码</font></strong> ，否则堆栈将失衡，最终引发程序崩溃。演示如下（先别管代码）：</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/error_code.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>另外，<strong><font color='orange'>对于外部异常（由 CPU 引脚触发），以及用软中断指令 int n 引发的异常，处理器不会压入错误代码，即使它原本是一个有错误代码的异常</font></strong> ！演示如下：</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/positive_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p><strong>能压入错误码的中断属于 0~32 号的异常，外部中断和陷阱不会压入错误码。</strong></p><h3 id="font-color-red-中断处理及其压栈过程-font"><font color='red'>中断处理及其压栈过程</font></h3><blockquote><p><a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> 中剖析了调用门的处理过程，建议读者将中断门处理和调用门处理对比阅读。</p></blockquote><p><strong><font color='gree'>（1）</font></strong> 发生中断，CPU 收到中断向量号，由此在 IDT 中定位到响应中断描述符。<br><strong><font color='gree'>（2）</font></strong> 进行特权级检查。<strong><font color='orange'>由于中断向量号只是一个整数，所以特权级检查并不涉及 RPL</font></strong> 。分以下两种情况：<br>a）由陷阱 <code>int n</code> ，<code>int3</code> ，<code>into</code> 引起的中断，这些中断由用户主动发起，因此进行如下检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL≤门描述符的DPL</span><br><span class="line">其中目标代码段指的是该中断门描述符中的选择子指向的代码段描述符</span><br></pre></td></tr></table></figure><p>​b）由外部设备(可屏蔽中断)和异常引起的，只作如下检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么由外部设备和异常引起的中断不检查门描述符的 DPL ？</strong><br>这点笔者在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a>留下了线索，其中提到“门槛”的作用是防止某些低特权级应用通过门来调用只服务于内核的程序，如页故障处理。而应用能这么做的前提是它可以主动发起门，但，由外部设备和异常引起的中断并不能由用户主动调用，因此也无需用门槛进行检查啦。</p></blockquote><p><strong><font color='gree'>（3）</font></strong> <strong>若特权级检查通过，则将中断门描述符中的选择子加载进 cs</strong> 。然后根据检查结果判断是否要转移到新栈，若发生特权级转移，则会转移到新栈。下面以转移到新栈为例。处理器先临时在其他地方保存旧栈的 SS 和 ESP，记为 SS_old 和 ESP_old，然后在对应 TSS 中找到相同等级的栈并转移到新栈，为了返回时能够切换回旧栈，在新栈中压入临时保存的 ESP_old 和 SS_old：<br><img src="/2022/img/IMG_0548(20221129-094330).PNG" alt="" style="zoom:67%;" /></p><blockquote><p><strong>注意，不管是否发生特权级转移，都会保存之前的 SS 和 ESP！</strong></p></blockquote><p><strong><font color='gree'>（4）</font></strong> 压入 EFLAGS 寄存器。需要注意，中断发生后 EFLAGS 的 NT 位和 TF 位会被自动置零（ <strong><font color='orange'>先将 EFLAGS 压栈再置零</font></strong> ）；<strong>如果中断对应的是中断门，则 IF 也被自动置零；如果中断对应的是任务门/陷阱门，IF 则不会置零</strong> 。详细原因见下文。<br><strong><font color='gree'>（5）</font></strong> 为了中断结束后能够顺利返回，将 CS_old 和 EIP_old 压栈：<br><img src="/2022/img/IMG_0549(20221129-095315).PNG" style="zoom: 50%;" /><br><strong><font color='gree'>（6）</font></strong> 某些异常可能有错误码，有错误码则压栈，无错误码则不做操作：<br><img src="/2022/img/IMG_0550(20221129-095535).PNG" style="zoom:50%;" /><br><strong><font color='gree'>（7）</font></strong> 进行中断处理过程。处理完毕后使用 <code>iret/iretd</code> 返回，栈中内容自动弹出，恢复到转移前的状态。<br><strong><font color='gree'>（8）</font></strong> 如果返回时需要改变特权级，则还会检查 DS/FS/GS/ES 中的内容，如果某个寄存器中选择子指向的数据段描述符的 DPL 比返回后的 CPL 高，则处理器自动将选择子置零。原因在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a>中分析过，不再赘述。</p><p>下面对几个细节进行说明：</p><p><strong><mark class="hl-label blue">关于 IF 置零</mark> </strong></p><ul><li>对于中断门，将 IF 置零，忽略可屏蔽中断。这是为了避免中断嵌套，防止在中断处理时又来一个相同的外中断，这将导致 GP 异常（0xd中断）。</li><li>对于陷阱门，无需将 IF 置零。陷阱门用于调试，允许响应其他中断。</li><li>对于任务门，无需将 IF 置零。任务都应该在开中断的情况下进行，否则就会独占 CPU，多任务系统便退化为单任务系统。</li></ul><p><strong><mark class="hl-label blue">关于 TF 置零</mark> </strong><br>TF（Trap Flag），陷阱标志位，用于调试环境，能够使 CPU 单步执行。处理器执行一条指令前，如果检测到单步标志位 TF 为 1，则在该条指令执行后立即停止，引起 0x1 号中断，0x1 号中断处理程序中可以安排自己想实现的功能，如显示各个寄存器的值以及下一条指令（Debug就是如此，参见<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a>）。问题是，当 TF=1 时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序，注意，中断处理程序也是由一条条指令组成的，如果在执行中断处理程序时，TF=1，则 CPU 在执行完中断处理程序的第一条指令后，又会引发单步中断，重新进入中断处理程序，进而一直在此循环。因此，进入中断前必须将 TF 置 0 。</p><p><strong><mark class="hl-label blue">关于 NT 置零</mark> </strong><br>NT（Next Task Flag），任务嵌套标志位。任务嵌套指旧任务调用了新任务，旧任务挂起，执行流转入新任务。新任务如何返回到旧任务呢？通过两点：1）新任务的 TSS 中记录了旧任务 TSS 的指针，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>。2）新任务的 EFLAGS 中 NT 位被置 1 。<strong><font color='orange'>新任务返回到旧任务也是通过 <code>iret</code> 指令进行的</font></strong> ，那么问题来了：如果在新任务中发生了中断，当执行到 <code>iret</code> 指令时，处理器怎么知道该从中断返回还是从新任务返回到旧任务呢？这就是 NT 位起的作用，<strong>当 NT=0，则 iret 从中断返回；当 NT=1，则 iret 从任务返回</strong> 。</p><p><strong><mark class="hl-label blue">对错误码的压栈处理</mark> </strong><br><strong><font color='red'>对于那些有错误码的中断例程，弹栈时 CPU 不会主动越过错误码，所以我们必须在 iret/iretd 前手动弹出错误代码</font></strong> ，否则堆栈将失衡，最终引发程序崩溃。通常我们接收但无需处理错误码。</p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现系统打印函数/除法溢出</title>
      <link href="/2022/11/20/%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/20/%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><ol><li><p>实现 <code>put_char()</code> 函数，<strong><u>这是最基础的系统级打印函数，其他打印函数都基于此函数</u></strong> 。</p></li><li><p>实现 <code>put_str()</code> 函数，该函数以 <code>put_char()</code> 为基础，极大地方便了字符串的打印。</p></li><li><p>实现 <code>put_int()</code> 函数，该函数以 <code>put_str()</code> 为基础，<strong><u>支持有符号 32 位整型的打印，同时支持十进制与十六进制格式打印</u></strong> 。</p></li><li><p>后续文章将利用以上函数实现 <code>printf()</code> 可变参打印函数。</p><blockquote><p>注意，前三者是系统级打印函数，也就是所谓的系统调用，和普通的库函数(如printf)要区分开。</p></blockquote></li></ol><p><strong>函数原型如下</strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">radix</span>&#123;</span>HEX=<span class="number">16</span>,DEC=<span class="number">10</span>&#125;;</span><br><span class="line">put_char(<span class="type">char</span>, <span class="type">unsigned</span> <span class="type">char</span>);  <span class="comment">//参数1:字符;  参数2:字符属性</span></span><br><span class="line">put_str(<span class="type">char</span>*, <span class="type">unsigned</span> <span class="type">char</span>);  <span class="comment">//参数1:字符串; 参数2:字符属性</span></span><br><span class="line">put_int(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">char</span>, <span class="keyword">enum</span> radix); <span class="comment">//参数1:数字; 参数2:字符属性; 参数3:进制</span></span><br></pre></td></tr></table></figure><p>实现打印函数之前，我们还需要了解一些显存的知识。毕竟是系统调用，多多少少都会直接操作硬件，话不多说，开干。</p><h3 id="font-color-red-显存的端口操作-font"><font color='red'>显存的端口操作</font></h3><p>之前咋们都是通过直接操控 <code>0xb8000</code> 的显存区域来实现屏幕输出，为啥现在要使用端口啦？简单来说，是为了方便。我们之前一直使用如下类似的方式进行打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0xb8000  ;现在是在保护模式下，所以是0xb8000而非0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line">mov [gs:0],&#x27;w&#x27;</span><br><span class="line">mov [gs:2],&#x27;o&#x27;</span><br><span class="line">mov [gs:4],&#x27;w&#x27;</span><br><span class="line">mov [gs:6],&#x27;!&#x27;</span><br></pre></td></tr></table></figure><p>这种方式的麻烦之处在于：</p><ol><li>一行代码只能打印一个字符。显然，我们不可能用这个方法打印一整屏的内容。</li><li>我们必须手动指定打印位置。屏幕内容少时还能接受，一旦屏幕内容较多，打印时稍有不慎就会将之前的内容覆盖。</li></ol><p>而通过操作显存端口来获得光标位置后，我们就可以放心地将字符定位任务交给光标啦。</p><blockquote><p><strong>操作端口的直接原因就是为了获取光标位置。</strong> 需要注意的是，在实模式下可以通过 BIOS 中断来获取光标位置，进入保护模式后就不能再使用 BIOS 中断了，所以必须手动操作端口。</p></blockquote><p>显卡一般有 <u>CGA、EGA、VGA</u> 三种显示标准，功能复杂，这使得显卡具备相当多的寄存器（端口）。我们知道，计算机系统为这些端口统一编址，每个端口占用一个地址（Intel 系统的寄存器地址范围为 0~65535，注意，<strong>这个地址可不是内存地址</strong> ）。如果为显卡的每个端口都分配一个系统端口</p><p>地址，这就十分浪费硬件资源了，毕竟显卡如果这么干，那就意味着其他硬件也能这么干，那端口地址不一会就会分配光啦。所以，制造商根据功能的不同将显卡寄存器分为不同的组（并排列成数组），每个组中有两个特殊的寄存器：1）<strong>Address Register</strong> ；2）<strong>Data Register</strong> 。<strong><u><font color='orange'>Address Register 作为数组的索引，通过该寄存器来指定要访问的寄存器；Data Register 则用来输入输出，相当于所有寄存器的读写窗口</font></u></strong> 。</p><blockquote><p><strong>CGA</strong> ：彩色图形适配器，提供两种标准文字显示模式：40×25×16 色和 <u>80×25×16</u> 色；以及两种常用的图形显示模式：320×200×4 色和 640×200×2 色；<br><strong>EGA</strong> ：增强图形适配器，在显示性能方面(颜色和分辨率)介于 CGA 和 VGA 之间；<br><strong>VGA</strong> ：视频图形阵列，具有分辨率高、显示速率快、颜色丰富等优点，在彩色显示器领域得到了广泛的应用，VGA最早指的是显示器 640×480 这种显示模式。</p></blockquote><p><img src="/2022/img/IMG_0533(20221124-233242).PNG" alt="仅作了解"><br>以上只对显卡寄存器做了个简单的讲解，因为我们待会也只需要通过端口获取光标而已，就不再做过多阐述，避免劝退。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;获取光标</span><br><span class="line">   mov dx, 0x03d4  ;索引寄存器</span><br><span class="line">   mov al, 0x0e   ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   in al, dx   ;得到了光标位置的高8位</span><br><span class="line">   mov ah, al</span><br><span class="line"></span><br><span class="line">   ;再获取低8位</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   in al, dx       ;此时ax中就存放着光标的位置</span><br></pre></td></tr></table></figure><p>注意，读写 8 位端口时，只能用 al 中转；读写 16 位端口时，只能用 ax 中转。</p><h3 id="font-color-red-print-char-font"><font color='red'>print_char</font></h3><p>这三个系统调用我们都使用汇编来写，实际上，这里使用汇编比 C 语言更简单。不用害怕，就 put_char 稍长一点，但其逻辑十分简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">;------------------------   put_char   -----------------------------</span><br><span class="line">;功能描述:把栈中的1个字符写入光标所在处</span><br><span class="line">;-------------------------------------------------------------------</span><br><span class="line">TI_GDT equ  0</span><br><span class="line">RPL0  equ   0</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0</span><br><span class="line">global put_char</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">put_char:</span><br><span class="line">   pushad              ;备份32位寄存器环境</span><br><span class="line">   mov ax, SELECTOR_VIDEO ;需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">;;;;;;;;;  获取当前光标位置 ;;;;;;;;;</span><br><span class="line">   ;先获得高8位</span><br><span class="line">   mov dx, 0x03d4  ;索引寄存器</span><br><span class="line">   mov al, 0x0e   ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   in al, dx   ;得到了光标位置的高8位</span><br><span class="line">   mov ah, al</span><br><span class="line"></span><br><span class="line">   ;再获取低8位</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   in al, dx</span><br><span class="line"></span><br><span class="line">   mov bx, ax                 ;将光标存入bx</span><br><span class="line">   ;下面这行是在栈中获取待打印的字符</span><br><span class="line">   mov ecx, [esp + 36]      ;pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节</span><br><span class="line">   mov edx, [esp + 40]        ;获取字符属性</span><br><span class="line">   cmp cl, 0xd                ;CR(回车)是0x0d,LF(换行)是0x0a</span><br><span class="line">   jz .is_carriage_return</span><br><span class="line">   cmp cl, 0xa</span><br><span class="line">   jz .is_line_feed</span><br><span class="line"></span><br><span class="line">   cmp cl, 0x8                ;backspace的ascii码是8</span><br><span class="line">   jz .is_backspace</span><br><span class="line">   jmp .put_other             ;调转到可显示字符的打印</span><br><span class="line">;backspace的一点说明:</span><br><span class="line">;当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符</span><br><span class="line">;但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,</span><br><span class="line">;这就显得好怪异,所以此处添加了空格或空字符0</span><br><span class="line">.is_backspace:</span><br><span class="line">   dec bx</span><br><span class="line">   shl bx,1</span><br><span class="line">   mov byte [gs:bx], 0x20     ;将待删除的字节补为0或空格皆可</span><br><span class="line">   inc bx</span><br><span class="line">   mov byte [gs:bx], 0x07     ;黑底白字</span><br><span class="line">   shr bx,1</span><br><span class="line">   jmp .set_cursor</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"> .put_other:</span><br><span class="line">   shl bx, 1  ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节</span><br><span class="line">   mov [gs:bx], cl  ; ascii字符本身</span><br><span class="line">   inc bx</span><br><span class="line">   mov byte [gs:bx],dl        ; 字符属性</span><br><span class="line">   shr bx, 1  ; 恢复老的光标值</span><br><span class="line">   inc bx                     ; 下一个光标值</span><br><span class="line">   cmp bx, 2000</span><br><span class="line">   jl .set_cursor             ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值</span><br><span class="line">                              ; 若超出屏幕字符数大小(2000)则换行处理</span><br><span class="line"> .is_line_feed:               ; 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，</span><br><span class="line"> .is_carriage_return:         ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。</span><br><span class="line">                              </span><br><span class="line">   xor dx, dx                 ; dx是被除数的高16位,清0.</span><br><span class="line">   mov ax, bx                 ; ax是被除数的低16位.</span><br><span class="line">   mov si, 80                  </span><br><span class="line">   div si                     </span><br><span class="line">   sub bx, dx                 ; 光标值减去除80的余数便是取整</span><br><span class="line">                              </span><br><span class="line"> .is_CRLF_end:                ; 回车符CRLF处理结束</span><br><span class="line">   add bx, 80</span><br><span class="line">   cmp bx, 2000</span><br><span class="line">   jl .set_cursor</span><br><span class="line"></span><br><span class="line">;屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充</span><br><span class="line"> .roll_screen:                ; 若超出屏幕大小，开始滚屏</span><br><span class="line">   cld</span><br><span class="line">   mov ecx, 960               ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次</span><br><span class="line">   mov esi, 0xb80a0          ; 第1行行首</span><br><span class="line">   mov edi, 0xb8000           ; 第0行行首</span><br><span class="line">   rep movsd</span><br><span class="line"></span><br><span class="line">;将最后一行填充为空白</span><br><span class="line">   mov ebx, 3840              ; 最后一行首字符的第一个字节偏移= 1920 * 2</span><br><span class="line">   mov ecx, 80                ;一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次</span><br><span class="line"> .cls:</span><br><span class="line">   mov word [gs:ebx], 0x0720  ;0x0720是黑底白字的空格键</span><br><span class="line">   add ebx, 2</span><br><span class="line">   loop .cls</span><br><span class="line">   mov bx,1920                ;将光标值重置为1920,最后一行的首字符.</span><br><span class="line"></span><br><span class="line"> .set_cursor:</span><br><span class="line">;将光标设为bx值</span><br><span class="line">;;;;;;; 1 先设置高8位 ;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4             ;索引寄存器</span><br><span class="line">   mov al, 0x0e               ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5             ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">;;;;;;; 2 再设置低8位 ;;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line"> .put_char_done:</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure><p>这里的代码笔者直接扣的《操作系统：真相还原》(略作修改)，代码注释已经非常清晰，下面对部分内容做说明：</p><ul><li>第 7,8 行：为了防止将来因为 GS=0 导致 CPU 抛出异常（选择子不能为0，还记得吗），这和特权级有关，后面文章会剖析。</li><li>第 28,29 行：这里直接使用 esp 来定位参数，并不规范。一般我们会在函数开头 <code>push ebp</code> ， <code>mov ebp,esp</code> ，然后使用 ebp 来定位参数。</li><li>第 77,81 行，<code>cld</code> 与 <code>rep movsd</code> 详见<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。</li></ul><p>以上就是 put_char 的内容，代码多，但逻辑简单。</p><h3 id="font-color-red-put-str-font"><font color='red'>put_str</font></h3><p><code>put_str</code>  以 <code>put_char</code> 为基础，代码相对简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------------------</span><br><span class="line">;put_str 通过put_char来打印以0字符结尾的字符串</span><br><span class="line">;--------------------------------------------</span><br><span class="line">;输入：参数1:字符串 参数2:字符属性</span><br><span class="line">;输出：无</span><br><span class="line">global put_str</span><br><span class="line">put_str:</span><br><span class="line">;由于本函数中只用到了ebx和ecx,只备份这两个寄存器</span><br><span class="line">   push ebx</span><br><span class="line">   push ecx</span><br><span class="line">   push edx</span><br><span class="line">   xor ecx, ecx           ; 准备用ecx存储参数,清空</span><br><span class="line">   mov ebx, [esp + 16]    ; 从栈中得到待打印的字符串地址</span><br><span class="line">   mov edx, [esp + 20]    ; 获取字符属性</span><br><span class="line">.goon:</span><br><span class="line">   mov cl, [ebx]</span><br><span class="line">   cmp cl, 0              ; 如果处理到了字符串尾,跳到结束处返回</span><br><span class="line">   jz .str_over</span><br><span class="line">   push edx               ; 传递字符属性参数</span><br><span class="line">   push ecx               ; 为put_char函数传递参数</span><br><span class="line">   call put_char</span><br><span class="line">   add esp, 8             ; 回收参数所占的栈空间</span><br><span class="line">   inc ebx                ; 使ebx指向下一个字符</span><br><span class="line">   jmp .goon</span><br><span class="line">.str_over:</span><br><span class="line">   pop edx</span><br><span class="line">   pop ecx</span><br><span class="line">   pop ebx</span><br><span class="line"></span><br><span class="line">   ret</span><br></pre></td></tr></table></figure><ul><li>第 13,14 行，同样不规范，请读者试试用 ebp 定位参数。不清楚的朋友可参考：<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a> 。</li><li>第 22 行，外平栈，不熟悉的朋友仍请参考<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a> 。</li></ul><h3 id="font-color-red-put-int-font"><font color='red'>put_int</font></h3><p>put_str 和 put_char 笔者直接使用的《操作系统：真相还原》中的代码，而 put_int 为笔者原创，添加了有符号数打印与十六进制格式打印，代码质量不敢作保证（本人菜比），如有错误，请读者指出。下面内容较多，请读者打起精神继续阅读，哈哈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">;====================put_int===========================================</span><br><span class="line">;参数1：数字  参数2：字符属性 ;参数3:进制</span><br><span class="line">section .data</span><br><span class="line">buffer times 12 db 0     ;字符串缓冲区</span><br><span class="line">sign db 0                ;符号标记</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global put_int</span><br><span class="line">put_int:</span><br><span class="line">    push ebp             ;保存原函数栈底</span><br><span class="line">    mov ebp,esp          ;ebp指向本函数栈底</span><br><span class="line">    pushad               ;保存所有通用寄存器</span><br><span class="line"></span><br><span class="line">    mov eax,[ebp+8]      ;取得参数1</span><br><span class="line">    mov ebx,eax          ;备份</span><br><span class="line">    mov byte [sign],1    ;先默认该数为正</span><br><span class="line">    mov edi,11           ;edi作为变址寄存器,指向buffer[11]</span><br><span class="line">    mov esi,buffer       ;esi作为基址寄存器,指向buffer[0]</span><br><span class="line">    mov cl,31            ;右移的位数如果不是1,则必须使用cl储存</span><br><span class="line">    shr eax,cl           ;将数字右移31位,得到符号位</span><br><span class="line">    cmp eax,1            ;如果符号位为1,则说明该数为负</span><br><span class="line">    jne  .positive       ;如果不为负,则跳转至.positive处理正数</span><br><span class="line"></span><br><span class="line">.negative:</span><br><span class="line">    mov byte [sign],0    ;符号标志位设为0,表示负数</span><br><span class="line">    not ebx              </span><br><span class="line">    inc ebx              ;取反并加1,得到相反数,即得正数,并进入下面.positive</span><br><span class="line"></span><br><span class="line">.positive:</span><br><span class="line">    mov ax,bx</span><br><span class="line">    mov cl,16</span><br><span class="line">    shr ebx,cl</span><br><span class="line">    mov dx,bx            ;以上四步将参数1的高16位存入dx,低16位存入ax</span><br><span class="line">.loop:</span><br><span class="line">    mov cx,[ebp+16]      ;取得进制</span><br><span class="line">    call divdw           ;输入:ax:数字的低16位  dx:数字的高16位  cx:除数|输出：cx:余数 ax:商的低16位 dx:商的高16位</span><br><span class="line">    sub edi,1            ;指定该字符的预放置位置</span><br><span class="line">    cmp cl,10            ;cx存的余数，最大不超过16，故余数一定在cl中，直接使用cl</span><br><span class="line">    jb  .dec             ;如果小于十就跳转到10进制处理，大于10就去16进制处理</span><br><span class="line">.hex:</span><br><span class="line">    add cl,&#x27;a&#x27;-10        ;将该数字转为字母(16进制)</span><br><span class="line">    jmp .@2</span><br><span class="line">.dec:</span><br><span class="line">    add cl,&#x27;0&#x27;           ;将该数字转为数字字符</span><br><span class="line">.@2:</span><br><span class="line">    mov [esi+edi],cl     ;将该字符移入缓冲区</span><br><span class="line">    mov cl,16            </span><br><span class="line">    mov bx,dx</span><br><span class="line">    shl ebx,cl</span><br><span class="line">    mov bx,ax            ;以上4步将商存入ebx</span><br><span class="line">    cmp ebx,0            </span><br><span class="line">    jne .loop            ;如果商为0,则该数处理完毕</span><br><span class="line"></span><br><span class="line">.@1:</span><br><span class="line">    mov cx,[ebp+16]      ;如果为16进制，则在数字前还要加上0x</span><br><span class="line">    cmp cx,16</span><br><span class="line">    jne .sign            ;如果为10进制数，则直接处理符号</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;x&#x27;</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;0&#x27;</span><br><span class="line"></span><br><span class="line">.sign:</span><br><span class="line">    mov al,[sign]</span><br><span class="line">    cmp al,0</span><br><span class="line">    jne .@3              ;若为正数，则跳转到.@3直接打印数字</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;-&#x27;</span><br><span class="line">.@3:</span><br><span class="line">    push dword [ebp+12]</span><br><span class="line">    add  esi,edi</span><br><span class="line">    push esi</span><br><span class="line">    call put_str</span><br><span class="line">    add esp,8</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop ebp              ;恢复原函数栈底</span><br><span class="line">    ret</span><br><span class="line">;============================</span><br><span class="line">;输入：ax:数字的低16位  dx:数字的高16位  cx:除数</span><br><span class="line">;输出：cx:余数 ax:商的低16位 dx:商的高16位</span><br><span class="line">divdw:</span><br><span class="line">    push ax</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,0</span><br><span class="line">    div cx               ;div后,ax存放商,dx存放余数</span><br><span class="line">    mov bx,ax</span><br><span class="line">    pop ax</span><br><span class="line">    div cx</span><br><span class="line">    mov cx,dx</span><br><span class="line">    mov dx,bx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>代码注释很详细，笔者只解释以下几个地方：</p><ul><li><p>如何在 buffer 中定位字符？流程如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.13png.png" alt=""></p></li><li><p>第 10,11 行使用 ebp 来定位参数。笔者在这吃过大亏，曾想当然地省略了第 10 行，结果就是排了一天的错。在函数内使用过的寄存器一定要提前保存！</p></li><li><p>为什么第 39 行除法不直接使用 <code>div</code> 指令，而使用 divdw 函数呢？这是因为 div 可能发生溢出，即 <strong><font color='orange'>除法溢出</font></strong> ，这将引发 CPU 异常。div 指令功能为：如果除数为 16 位，则被除数须为 32 位，高位放在 DX 中，低位放在 AX 中；将商放入 AX，余数放入 DX。而当被除数为 100000，除数为 1 时，商就无法完全存入 AX，从而发生溢出。为了避免这一问题，我们就用 divdw 函数来进行除法操作。divdw 原理剖析见文末。</p></li><li><p>注意，字符串末尾必须为 0 ！在 C 语言中，字符串 “abcd” 会在编译时由编译器在其末尾加 0，但是在汇编中，0 必须要我们自己加！</p><blockquote><p><code>\n</code> 也是如此，在汇编中，以下数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data db&quot;wow!\n&quot;</span><br></pre></td></tr></table></figure><p>最后的 <code>\n</code> 会被解析为 <code>\</code> 和 <code>n</code> ！这是因为高级语言中的 <code>\n</code>  是在编译阶段被识别并处理为 ASCII 码 <code>0x8</code> ，这个转换是编译器的功劳。而我们自己手写汇编时，可不会还经过编译器处理。</p></blockquote></li><li><p>有人可能不明白为什么三个参数在栈中的位置分别是 [ebp+18]，[ebp+12]，[ebp+16]，这意味着这三个参数的大小都是 4 字节。问题在于，我们的函数原型是 <code>put_int(int, unsigned char, enum radix);</code> ，第二个参数是 char 呀，不应该只压入 1 个字节吗？是这样的，<strong><font color='red'>C 语言不管函数参数类型是 char 还是 short 或者 int，压参时每个参数都会压入 4 字节</font></strong> ，关于这点的讨论请参见<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C和汇编混合编程</a> 。</p></li></ul><p>关于上面的除法溢出，可以利用后面将学习的中断描述符表（IDT）来检验，如下：<br><img src="/2022/img/image-20221125162813996.png" alt=""><br>显然，除法溢出引发 CPU 的 0 号异常。</p><p>最后，来看看效果：<br><img src="/2022/img/image-20221125161434097.png" alt=""></p><p>大功告成！</p><blockquote><p>另外，负十六进制数一般是由补码形式来显示的，这里转换就比较复杂，所以上面的 put_int 没考虑这一点，直接在十六进制数前加负号。</p></blockquote><blockquote><p>补更：后续学习中发现有符号整型不够用（比如显示地址，大于 2GB 就为负了），因此还需要一个无符号整型打印函数 put_uint，该函数的实现也只是在 put_int 上稍作修改，具体请参考 <code>memory</code> 分支。</p></blockquote><h3 id="font-color-red-divdw原理浅析-font"><font color='red'>divdw原理浅析</font></h3><p>为避免除法溢出，我们将一次除法分解成两次除法，核心公式为：<br><strong><font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X/n=(H&lt;&lt;16+L)/n=(H/n)&lt;&lt;16+(L/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font></strong></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo separator="true">,</mo><mi>L</mi><mo>=</mo><mi>X</mi><mi mathvariant="normal">%</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H=X&gt;&gt;16,L=X\%(2^{16})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">16</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">%</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>我们一步一步来分析：</p><ol><li>首先我们要知道，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">!</mo><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">X!=(X&gt;&gt;16)&lt;&lt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> ，这个大家一定都清楚。正确的等式（注意是等式，而非赋值）应该为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>X</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">X=(X&gt;&gt;16)&lt;&lt;16+X\%2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8697em;vertical-align:-0.0556em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> ，即得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X=(H&lt;&lt;16+L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 。</li><li>接下来的问题是，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">(H&lt;&lt;16)/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span> 如何得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(H/n)&lt;&lt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> ？这个简单：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>∗</mo><mn>65536</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mi>H</mi><mo>∗</mo><mn>65536</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(H&lt;&lt;16)/n=(H*65536)/n=H*65536/n=(H/n)*65536=(H/n)&gt;&gt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">65536</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">65536/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span><br>得证。</li></ol><p>由此，我们便将 X/n 分解成了 H/n 和 L/n ，这无论如何也不可能发生溢出。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加载内核-代码详解</title>
      <link href="/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">浅析C语言和汇编混合编程</a>，<a href="https://jyx-fyh.github.io/2022/10/09/makefile%E5%85%A5%E9%97%A8/">makefile入门</a><br>本节对应分支：<code>load-kernel</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>让我们看看目录结构：<br><img src="/2022/img/image-20221116184755024.png" alt="目录结构/main.c"><br>相比 <code>open-page</code> 分支，本分支新增了两个文件，一个是 <code>/kernel/main.c</code> (如上)，另一个是 <code>/src/guide.s</code> ：<img src="/2022/img/image-20221116190141563.png" alt="guide.s"></p><p>loader.s 作了改动，下面是分支  <code>load-kernel</code> 相对于 <code>open-page</code> 的修改：<br><img src="/2022/img/image-20221116191353841.png" alt=""><br>显然，<code>load-kernel</code> 从硬盘中读取内核并加载到 KERNEL_ADDR 地址处，最后跳转进入内核，<strong>loader 使命到此结束</strong> 。</p><blockquote><p>loader 的使命虽然结束了，但里面的 GDT 我们可还要用呢，后面注意不能把 loader 覆盖，即使要覆盖，也必须先转移 GDT。</p></blockquote><h3 id="font-color-red-为什么需要引导文件？-font"><font color='red'>为什么需要引导文件？</font></h3><p>容易知道，main.c 就是内核。按之前编写 mbr.s 和 loader.s 的经验，我们可能会想到直接将 main.c 编译成 main.bin 文件，然后将 main.bin 直接加载到内存 KERNEL_ADDR 处，接着再跳转进入内核，这不就大功告成了吗？那么为啥还得先进入 guide.s ，然后再调用内核 kernel_main？感觉它很鸡肋啊…嗯，这个问题也困扰了我好一会。<strong>其实，前面这个想法很容易被否定，原因在于，你怎么能保证 main.bin 文件的开头一定是 kernel_main 函数的入口而不是其他描述信息</strong> ？注意看，kernel_main 函数里面可也是定义了数据的，<strong>所以你又怎么保证 main.bin 文件的开头是指令还是数据</strong> ？综上，直接将 main.bin 加载到某个位置并跳转过去，这个方案是不可取的。你可能又会说，kernel_main 函数中不就定义了两个 char* 指针和一个字符串吗，<code>char*</code> 四字节，字符串 15 字节，总字节数为<code>4+4+15=23</code> ，那么在 loader 中跳转时，我越过这个 23 字节，直接跳到代码处不就行了？哈哈哈，我一开始也这么想过，不过马上就否定了。我们会产生这种想法的原因在于之前 loader 和 mbr 都是用汇编写的（也只能用汇编），而汇编能让我们掌握程序的每一个细节。可 C 语言这种高级语言呢？它虽然大大简化了程序的编写难度，但却对上层屏蔽了很多细节，这些细节我们很难完全把控。所以，由 main.c 转换 main.s 时，<strong><u>你并不清楚 main.s 中的内存布局</u></strong> 。所以，这个想法也被否定啦。因此，我们使用引导文件 guide.s 来引导(guide)程序进入内核。</p><blockquote><p>其实，guide.s 也是可以省略的，我们只需要把 kernel_main 的名字改为 _start ，这样编译器就能识别，并将其作为程序入口。</p></blockquote><h3 id="font-color-red-编译链接解析-font"><font color='red'>编译链接解析</font></h3><p>方案确定了，那么这个引导过程是如何进行的呢？首先，我们将 main.c 和 guide.s 编译为可重定位文件并链接，具体命令见以下 makefile(简化后)：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BUILD= ./build</span><br><span class="line">SRC=./src</span><br><span class="line"></span><br><span class="line">CFLAGS:= -m32           <span class="comment"># 32 位的程序</span></span><br><span class="line">CFLAGS+= -masm=intel    <span class="comment"># 采用intel汇编语法</span></span><br><span class="line">CFLAGS+= -fno-builtin   <span class="comment"># 不需要 gcc 内置函数</span></span><br><span class="line">CFLAGS+= -nostdinc      <span class="comment"># 不需要标准头文件</span></span><br><span class="line">CFLAGS+= -fno-pic       <span class="comment"># 不需要位置无关的代码  position independent code</span></span><br><span class="line">CFLAGS+= -fno-pie       <span class="comment"># 不需要位置无关的可执行程序 position independent executable</span></span><br><span class="line">CFLAGS+= -nostdlib      <span class="comment"># 不需要标准库</span></span><br><span class="line">CFLAGS+= -fno-stack-protector  <span class="comment"># 不需要栈保护</span></span><br><span class="line">CFLAGS:=<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/pure_kernel.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">objcopy -O binary <span class="variable">$(BUILD)</span>/kernel.bin <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/guide.o <span class="variable">$(BUILD)</span>/main.o</span><br><span class="line">ld -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0x00001500</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/main.o: ./kernel/main.c</span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> -g -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/guide.o: <span class="variable">$(SRC)</span>/guide.s</span><br><span class="line">nasm -f elf32 -g <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li><p>第 24~25 行，将 guide.s 编译为 guide.o(可重定位文件) 。注意编译选项：</p><ul><li><code>-f</code> ：大家对这个应该很熟悉了吧，即指定文件输出格式。这里的输出格式为 <code>elf32</code> ，<strong>目的是待会要和 gcc 编译的 elf 格式的目标文件链接，所以格式必须相同</strong> 。</li><li><code>-g</code> ：添加调试信息。<strong><font color='orange'>这点对我们后面调试内核至关重要</font></strong> ！如果你编程能力极强，完全不需要调试，一眼就能看出错误(手动狗头)，那可以忽略该选项。</li><li><code>-o</code> ：不必多说，指定输出文件的名称。</li></ul></li><li><p>第 21~22 行，将 main.c 编译为 main.o(可重定位文件) 。注意编译选项：</p><ul><li><code>$(CFLAGS)</code> ：上面一大堆的 gcc 配置，<strong>这非常重要</strong> ！这是在指示 gcc 不要生成其他无关的东西，我只要 main.c 中的原生汇编代码，别瞎搞。因为一般 .c 文件编译成 .o 文件后都会增加大量描述信息和其他库代码，现在我们不需要这个。</li><li><code>-g</code> ：和之前一样，添加调试信息，用于内核调试。</li><li><code>-c</code> ：只生成可重定位文件。如果不加该选项，会直接生成可执行程序。</li><li><code>-o</code> ：指定输出文件的名称。</li></ul></li><li><p>第 17~18 行，链接 guide.o 和 main.o 。注意链接选项：</p><ul><li><p><code>-m</code> ：指定输出格式为 elf_i386 。</p></li><li><p><code>-Ttext</code> ：指示代码的起始地址。也就是说，你将内核加载到哪个地方，选项后就跟哪个地址；由于 loader.inc 中的 <code>KERNEL_ADDR</code> 为 0x1500，所以这里也为 0x1500。<strong><font color='red'>这个选项的作用和 vstart 完全相同</font></strong> ！所以基础可不能落下，不明白 vstart 的朋友请回 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>。</p><blockquote><p><strong><font color='gree'>由于我们已经开启了分页，所以按理来说指定起始地址时也必须指定虚拟地址</font></strong> ！但是，还记得之前我们已经将第 0 号页表的地址同时写入了第 0 号和第 768 号目录项中吗？所以 <strong>目前</strong> 这里填 0x1500 或 0xc0001500 都没有问题。目前没有问题？以后就有问题啦？是的，未来我们会回到此处并解析这个问题。</p></blockquote></li></ul></li><li><p>第 14~15 行，将 kernel.bin 中最原生的代码段和数据段抠出来，放入 pure_kernel.bin 中。</p><blockquote><p>现在的 kernel.bin 是 ELF 格式，其中含有大量的描述信息（程序头，节头等）和调试信息，而这些是 CPU 看不懂的，不能直接把该文件交给 CPU 运行。所以使用 objcopy 命令，只将其中的代码段和数据段抠出来，并整理到 pure_kernel.bin 中，这才是 CPU 能够运行的文件。关于 objcopy 可参考<a href="https://www.jianshu.com/p/beef56fec4ba">objcopy命令</a> 。</p></blockquote><ul><li><code>-O binary</code> ：指定输入目标为二进制文件。</li></ul></li></ul><blockquote><p>说实话，这些配置是很难找的，至少整个中文网上都是找不到的，即使找到相关介绍，你也不知道怎么去使用。此处的配置由子牙老师提供，笔者在此表示感谢，这至少让我们省了一个月的精力。</p></blockquote><p>说了这么多，大家有没有对这个引导过程产生一点感觉？好吧，挑明了讲，<strong><font color='red'>由于 <code>_start</code> 是默认的程序入口地址（这点已在本节前置文章中讲过），所以可以料到，objcopy 后，pure_kernel.bin 文件的开头就是 <code>guide.s</code> 中 <code>_start</code> 标号处的指令</font></strong> ，即 <code>call kernel_main</code> 。又因为我们指定了代码的起始地址（-Ttext 0x1500），所以 <code>call kernel_main</code> 指令的地址就为 0x1500 。这样，当我们把内核加载到内存 0x1500 后，就可以由 loader 中的最后一条指令 <code>call SELECTOR_CODE:KERNEL_ADDR</code> 跳转到 0x1500 处，然后调用内核。</p><p>你不信 pure_kernel.bin 文件的开头是指令 <code>call kernel_main</code> ？那我们就看看 pure_kernel.bin 长什么样：<img src="/2022/img/image-20221117002754476.png" alt=""><br>看见开头的 <code>E8 02</code> 没？这就是近转移指令 <code>call kernel_main</code> 。这下信了吧，哈哈。</p><h3 id="font-color-red-其他说明-font"><font color='red'>其他说明</font></h3><p><strong><mark class="hl-label blue">count参数</mark> </strong><br>这是 loader.inc 文件：<br><img src="/2022/img/image-20221117092239137.png" alt="loader.inc"><br>以下是 makefile 中写入硬盘的部分：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">./$(DISK):<span class="variable">$(BUILD)</span>/mbr.bin <span class="variable">$(BUILD)</span>/loader.bin <span class="variable">$(BUILD)</span>/pure_kernel.bin</span></span><br><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat <span class="variable">$@</span></span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/mbr.bin of=<span class="variable">$@</span> bs=512  conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/loader.bin of=<span class="variable">$@</span> bs=512  seek=2 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/pure_kernel.bin of=<span class="variable">$@</span> bs=512 seek=50 count=200 conv=notrunc</span><br></pre></td></tr></table></figure><p>看最后一行，seek=50 表示跳过 50 个扇区，从第 50 个扇区(起始为0)开始写，这对应了第四行 inc 配置。但为什么 <code>count=200</code> ？即一次写入 200 个扇区？这是因为后面我们的内核会越来越大，每次更新完内核需要向硬盘中同步，而我们可能会忘记修改 count，导致内核写入不全，所以一次性把 count 设置大一点。额，好吧，其实最方便的是直接不加 count，文件有多大就写多大，这不香嘛？</p><p><strong><mark class="hl-label blue">显存</mark> </strong><br>有人可能不太明白 kernel_main 函数中的第一行 0xb8000 后为啥加上 480，这是因为我们现在的显示模式是 25×80 的文本显示模式，每行 80 个字，25 行，所以一屏最多容纳 2000 字。一个字符占两个字节，第一字节是 ASCII 码，第二字节是字符属性(颜色,闪烁等)，所以如果我们要从第 4 行开始打印，则地址就应该为 <code>0xb8000+80×2×3</code> ，即 <code>0xb8000+480</code> 。</p><blockquote><p>0xb8000 是啥就不必多说了吧。。。</p></blockquote><p><strong><mark class="hl-label blue">char与short</mark> </strong><br>为了使大家更深刻地理解指针，笔者对 kernel_main() 做了如下修改：<br><img src="/2022/img/image-20221119165243020.png" style="zoom:67%;" /><br>第 11 行的 0x2 代表字符属性，黑底绿字。代码含义请读者自行思考。</p><h3 id="font-color-red-运行结果-font"><font color='red'>运行结果</font></h3><p><code>-Ttext 0x1500</code> 或 <code>-Ttext 0xc0001500</code> 都得到如下结果：</p><p><img src="/2022/img/image-20221117094137891.png" alt=""><br>到此为止，我们已经分别在实模式、保护模式、开启分页后、加载内核后打印了信息。</p><blockquote><p>运行方式：转到 makefile 下，点击顺序：clean --&gt; all --&gt; bochs</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析C和汇编混合编程/ABI规则</title>
      <link href="/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节说明：本节内容与编译和链接相关，该部分内容繁杂，不是一篇博客就能说明的，且本文仅为后续文章<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>作铺垫，关于这方面详细的内容请阅读《装载，链接与库》。如有错误，请在评论区提出，谢谢。</p><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核-代码详解</a></p></blockquote><h3 id="font-color-red-C和汇编相互调用-font"><font color='red'>C和汇编相互调用</font></h3><p><strong><mark class="hl-label blue">编写源文件</mark> </strong><br>给出如下两个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：cprint.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">asm_print</span><span class="params">(<span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c_print</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len++]);</span><br><span class="line">asm_print(str, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：asm_print.s</span><br><span class="line">[bits 32]</span><br><span class="line">section .data</span><br><span class="line">str: db &quot;asm_print say hi youyifeng!&quot;,0xa,0x00 </span><br><span class="line">;0x0a是换行符，0x00是字符串结束符，不加的话会把后面字符陆续输出，直到遇到空白字符</span><br><span class="line">;while循环遍历字符串统计字符串长度，遇空白字符结束。汇编不支持NULL</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">extern c_print       ;外部申明引用c_print</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">push str_len</span><br><span class="line">push str</span><br><span class="line"></span><br><span class="line">call c_print</span><br><span class="line">add esp,8        ;cdecl,调用者清理栈空间(外平栈)</span><br><span class="line">mov eax,1        ;调用1号中断,告诉Linux咋们要正常退出</span><br><span class="line">int 0x80</span><br><span class="line"></span><br><span class="line">global asm_print ;定义函数asm_print</span><br><span class="line">asm_print:</span><br><span class="line">push ebp         ;保存原函数栈底</span><br><span class="line">mov ebp,esp      ;ebp指向当前栈帧的栈底</span><br><span class="line">mov eax,4        ;调用4号子功能，需要传入三个参数:ebx,ecx,edx</span><br><span class="line">mov ebx,1        ;此参数为文件描述符，固定3个，0表示标准输入，1表示标准输出，2表示标准错误输出</span><br><span class="line">mov ecx,[ebp+8]  ;长度参数len </span><br><span class="line">mov edx,[ebp+12] ;字符串首地址参数  char *str</span><br><span class="line">int 0x80         ;功能号填写完毕，发起0x80中断</span><br><span class="line">pop ebp          ;恢复ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>让我们先聚焦 cprint.c 文件：</p><ol><li>第 2 行，extern 声明，引入函数 asm_print 。因为在 c_print 函数中调用了 asm_print 函数，而在当前文件中并没有 asm_print 的定义，所以必须进行声明，<strong><font color='orange'>告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后链接时会把定义补上</font></strong> 。这里可以省略 extern 关键字，直接声明函数。</li><li>第 2 行，函数原型给出了参数类型：asm_print 有俩参数，一个是 char* 类型，一个是 int 类型。这里声明了两个参数，和 asm_print.s 中的第14,15 行的两个 push 恰能对应；但看到参数类型时，我们不禁大呼一句卧槽，asm_print 是用汇编写的啊，哪来的类型？哈哈，是的，<strong>汇编语言没有类型之分，只有操作数大小之分</strong> 。那这里为什么可以指定参数类型 char* 和 int 呢？其实，<strong><font color='red'>数据类型，只是在指导编译器如何去解释这个数据以及如何控制它的行为</font></strong> 。比如你声明 <code>char* ptr</code> ，那么编译器就认为 ptr 中装的是地址，且将 ptr 的步长指定为 1(也就是自增自减时以1为单位)；如果你声明 <code>int* ptr</code> ，那么编译器就认为 ptr 中装的是地址，且将 ptr 的步长指定为 4 。好了，由于这里涉及编译原理，笔者暂不熟悉，就不多做解释，以免误导读者。</li></ol><p>另外需要注意的是，<strong><font color='red'>C 语言不管函数参数类型是 char 还是 short 或者 int，压参时每个参数都会压入 4 字节</font></strong> ！这点在我们后面编写供 C 语言调用的汇编函数时有重要作用。演示如下：<br><img src="/2022/img/image-20221125152130185.png" style="zoom:67%;" /></p><p>其汇编代码如下：<br><img src="/2022/img/image-20221125152228134.png" style="zoom:80%;" /></p><p>看，参数 b 先被放入 eax 中，再压入参数，则压入 4 字节；对于 <code>push 3</code> ，32 位下压立即数时，也是压入 4 字节。我们再来看看编译器如何从栈中去参数：<br><img src="/2022/img/image-20221125153009512.png" alt=""><br>注意第 1 行，使用了 word 修饰，因为 b 的类型本就是 short，只占两个字节。movsx 是带符号扩展传送指令，不在此阐述。</p><p>再来看 asm_print.s ：</p><ol><li><p>第 2 行，<code>[bits 32]</code> 声明以下环境为 32 位，之前有提到过，见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a> 。</p></li><li><p>第 10 行，引入 c_print ，与前面提到的不同，此处 extern 关键字不能省略。</p></li><li><p>第 11 行，<code>global</code> 的作用是导出某符号，使其他文件可以发现该符号。<code>_start</code> 是默认的程序入口，这个咋们待会再详细讨论。</p></li><li><p>第 22 行，导出 asm_print ，这样在 cprint.c 中的 cprint() 函数才能调用 asm_print 。</p></li><li><p>第 14,15 行，将两个参数压栈，随后调用 c_print 。</p></li><li><p>第 18 行，由于 c_print() 是由 C 语言编写的函数，所以默认的调用约定是 cdecl，所以必须由调用者手动平栈。对此陌生的朋友可参考<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>。</p><blockquote><p>这里就体现出调用约定的重要性了。如果 c_print() 采用 stdcall（只需要在定义时在函数名前声明 __stdcall），则是被调函数平栈。如果不清楚调用约定，则会导致最终堆栈不平衡，引发程序错误。</p></blockquote></li><li><p>第 24,25 行，也请参见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a> 。</p></li><li><p>第 30 行，0x80 是 Linux 下系统调用的统一入口，具体的子功能在 eax 中指定。后续会详述该部分内容。</p></li></ol><p><strong>简单总结</strong> ：</p><ul><li>在汇编中导出符号供外部引用，使用关键字 <code>glbal</code> ；引用外部文件的符号使用 <code>extern</code> 。</li><li>在 C 文件中只要将符号定义为全局就能供外部引用，无需额外关键字；引用外部符号时用 <code>extern</code> 声明。</li></ul><p><strong><mark class="hl-label blue">编译</mark> </strong><br>分别编译上述两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c cprint.c -o cprint.o</span><br><span class="line">nasm -f elf32 asm_print.s -o asm_print.o</span><br></pre></td></tr></table></figure><p><code>-m32</code> 与 <code>-f elf32</code> 是在指定编译器将源文件编译为 32 位的 ELF 文件格式。</p><p><strong><mark class="hl-label blue">链接</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 asm_print.o cprint.o -o print</span><br></pre></td></tr></table></figure><p><code>-m elf_i386</code> 同样是在指定指令架构。最终得到可执行文件 print 。</p><p><strong><mark class="hl-label blue">运行</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./print</span><br><span class="line">asm_print say hi youyifeng!</span><br></pre></td></tr></table></figure><h3 id="font-color-red-初识ELF文件-font"><font color='red'>初识ELF文件</font></h3><p>在以上过程中，我们链接 asm_print.o 和 cprint.o 这两个文件后便能直接运行该程序。问题是，计算机是怎么知道程序的入口在哪的呢？由于程序内的地址是在链接时就编排好了（重定位），所以链接阶段就必须确定好程序入口。<strong><font color='orange'>于是链接器规定，默认只把名为 _start 的函数(或标号)作为程序的入口符号</font></strong>。如果要另行指定入口，则需要使用 <code>-e</code> 参数来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将入口符号指定为main</span></span><br><span class="line">ld -m -e main elf_i386 asm_print.o cprint.o -o <span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>那么问题又来了，入口符号确定了，计算机又从哪获得该符号对应的地址呢？这就不得不提到 ELF 文件格式了。其实，我们早在本系列的前期文章就已经接触到了 ELF 的雏形，即<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。<strong>ELF 文件格式同程序加载器一样，都是调用程序和被调程序的一种协议，而协议的意义在于通用性</strong> 。也就是说，只要遵守协议，那么一个调用方就能调用多种用户程序，比如，调用方一般都为操作系统，而操作系统能调用无数种类，不同厂商开发的应用程序。<strong>Linux 的可执行程序为 ELF 格式，ELF 格式采用文件头 header+文件体 body 的形式</strong> 。文件头用来描述程序的布局，包括入口，代码段，程序段的地址等。有了文件头的好处是调用方式变得通用，坏处是这些文件不再是纯粹的二进制可执行文件了，CPU 不能直接运行。<strong>所以，将 ELF 可执行文件读入内存后，必须先解析文件头，找到程序的入口地址，然后直接跳转到入口处，CPU 才能够运行该程序</strong> 。好了，ELF 的知识较繁杂，就不在此处展开了，想了解详情的朋友可参阅《装载，链接与库》。</p><p>接下来，就进入激动人心的时刻了：<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">载入内核</a> 。</p><h3 id="font-color-red-ABI-规则-font"><font color='red'>ABI 规则</font></h3><p>ABI（Application Binary Interface，应用程序二进制接口），描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的接口。ABI涵盖了各种细节，如：</p><ul><li>数据类型的大小、布局和对齐；</li><li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数等。</li><li>系统调用的编码和一个应用如何向操作系统进行系统调用；</li><li>以及在一个完整的操作系统ABI中，目标文件的格式、程序库等等。</li></ul><p>这里我们不展开，只强调 ABI 中这样一个规定：位于 Intel386 体系上的所有<u>通用</u>寄存器都具有全局性，因此在函数调用时，所有通用寄存器对被调函数和主调函数都可见。但是，规定要求 epb、ebx、esi、edi、esp 这五个寄存器归主调函数使用，其他寄存器随便供被调函数使用。换句话说，<strong><u><font color='gree'>不管被调函数中是否使用了这五个寄存器，当被调函数返回时，这几个寄存器都不应该被改变</font></u></strong> 。这实际上是属于编译原理的范畴，这些规定会被编译器严格遵守，因此，当我们使用 C 语言编写函数时，无需关心这些东西。但在 C 和汇编混合编程时，就需要留点心了：当 C 函数调用我们自己写的汇编函数时，需要保证调用前后这五个寄存器的值不变。其实，我们之前是直接通过 pushad 和 popad 来保存主调函数现场的，但现在咋们就只需要保证这五个寄存器不变就好啦！另外：</p><ol><li><strong>eax 用来储存返回值</strong> 。</li><li><strong>esp 一般无需压栈保存，它是通过内外平栈（见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>）来保证堆栈平衡（即调用前后 esp 不变）的</strong> 。下面举例为证：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b)                   </span><br><span class="line">&#123;</span><br><span class="line">00FB1750  push        ebp  </span><br><span class="line">00FB1751  mov         ebp,esp  </span><br><span class="line">00FB1753  sub         esp,0C0h  </span><br><span class="line">00FB1759  push        ebx  </span><br><span class="line">00FB175A  push        esi  </span><br><span class="line">00FB175B  push        edi  </span><br><span class="line">00FB175C  mov         edi,ebp  </span><br><span class="line">00FB175E  xor         ecx,ecx  </span><br><span class="line">00FB1760  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FB1765  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FB1767  mov         ecx,offset _206B94B3_源@c (0FBC000h)  </span><br><span class="line">00FB176C  call        @__CheckForDebuggerJustMyCode@4 (0FB130Ch)  </span><br><span class="line">return a + b;</span><br><span class="line">00FB1771  mov         eax,dword ptr [a]  ;[ebp+8]</span><br><span class="line">00FB1774  add         eax,dword ptr [b]  ;[ebp+0Ch]</span><br><span class="line">&#125;</span><br><span class="line">00FB1777  pop         edi  </span><br><span class="line">00FB1778  pop         esi  </span><br><span class="line">00FB1779  pop         ebx  </span><br><span class="line">00FB177A  add         esp,0C0h  </span><br><span class="line">00FB1780  cmp         ebp,esp  </span><br><span class="line">00FB1782  call        __RTC_CheckEsp (0FB1235h)  ;上行和本行，检查堆栈平衡(ebp==esp)</span><br><span class="line">00FB1787  mov         esp,ebp  </span><br><span class="line">00FB1789  pop         ebp  </span><br><span class="line">00FB178A  ret  </span><br></pre></td></tr></table></figure><p>看见第 3、6、7、8 行的压栈没？这就和上文很好地呼应了，不信你自己试试。</p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启分页-代码详解</title>
      <link href="/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>阅读<a href="">开启分页机制</a>是本节的前置要求。<br>本节代码对应分支 <code>open-page</code> 。</p></blockquote><p><strong><mark class="hl-label blue">boot.inc</mark> </strong><br>在进入保护模式的基础上，<code>boot.inc</code> 增添了如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;========页目录地址和页表起始地址===========</span><br><span class="line">PAGE_DIR_POS    equ  0x00100000            ;目录表起始位置为1MB处</span><br><span class="line">PAGE_TABLE_POS  equ  PAGE_DIR_POS + 4096   ;页表起始位置</span><br><span class="line">;===========页表相关属性===================</span><br><span class="line">PG_P     equ   1b</span><br><span class="line">PG_RW_R equ  00b</span><br><span class="line">PG_RW_W equ  10b</span><br><span class="line">PG_US_S equ  000b</span><br><span class="line">PG_US_U equ  100b</span><br></pre></td></tr></table></figure><ul><li>和 GDT 相同，<strong>页目录也可以放置在内存中的任何地方</strong> ，这里我们直接将其放在 <code>0x100000</code> 处。</li><li>为了使内存紧凑，这里让页表紧挨着页目录。注意，这不是必须的！页目录表大小为 4KB，所以页表地址在页目录地址的基础上加 4096 (0x1000)。</li></ul><p>以下为内存映像图：<br><img src="/2022/img/未命名绘图9.png" style="zoom:67%;" /></p><p><strong><mark class="hl-label blue">loader.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.s</span><br><span class="line">;%include &quot;boot.inc&quot;</span><br><span class="line">;%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段</span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06]</span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;GDT</span><br><span class="line">;第0描述符不可用</span><br><span class="line">    GDT_BASE        dd    0x00000000</span><br><span class="line">                    dd    0x00000000</span><br><span class="line">;第1描述符CODE</span><br><span class="line">    DESC_CODE       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_CODE_HIGH4</span><br><span class="line">;第2描述符DATA</span><br><span class="line">    DESC_DATA       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_DATA_HIGH4</span><br><span class="line">;第3描述符VIDEO</span><br><span class="line">    DESC_VIDEO      dd    0x80000007</span><br><span class="line">                    dd    DESC_VIDEO_HIGH4</span><br><span class="line"></span><br><span class="line">    GDT_SIZE        equ   $ - GDT_BASE</span><br><span class="line">    GDT_LIMIT       equ   GDT_SIZE - 1</span><br><span class="line">;GDT指针</span><br><span class="line">    gdt_ptr         dw    GDT_LIMIT</span><br><span class="line">                    dd    GDT_BASE</span><br><span class="line"></span><br><span class="line">    SELECTOR_CODE   equ   ((DESC_CODE - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_DATA   equ   ((DESC_DATA - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_VIDEO  equ   ((DESC_VIDEO- GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">    loader_msg      db    &#x27;r&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;a&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;-&#x27;,11000010b</span><br><span class="line">                    db    &#x27;m&#x27;,11000010b,&#x27;o&#x27;,11000010b,&#x27;d&#x27;,11000010b,&#x27;e&#x27;,11000010b</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br><span class="line">start: ;程序入口</span><br><span class="line">mov ax,0             ;转移到loader代码后,如果不想立即进入保护模式</span><br><span class="line">mov ds,ax            ;则最好先将各段寄存器清0</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">print:</span><br><span class="line">mov ax,0xb800        ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,loader_msg    ;ds:si</span><br><span class="line">mov di,0             ;es:di</span><br><span class="line">mov cx,18            ;9个字符,占18字节</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">;========================================================</span><br><span class="line">;1.打开A20</span><br><span class="line">;2.加载GDT</span><br><span class="line">;3.置PE=1</span><br><span class="line">prepare:</span><br><span class="line">;关中断</span><br><span class="line">    cli</span><br><span class="line">;打开A20</span><br><span class="line">    in   al,0x92</span><br><span class="line">    or   al,0000_0010B</span><br><span class="line">    out  0x92,al</span><br><span class="line">;加载GDT</span><br><span class="line">    mov  ax,0</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line">;CR0的第0位置1</span><br><span class="line">    mov  eax,cr0</span><br><span class="line">    or   eax,0x0000_0001</span><br><span class="line">    mov  cr0,eax</span><br><span class="line">;此后进入保护模式</span><br><span class="line">    jmp  dword SELECTOR_CODE:p_mode_start ;刷新流水线,装载CODE选择子</span><br><span class="line">;======================================================</span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">    mov ax,SELECTOR_DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov esp,BASE_ADDR       ;可以找其他合适的地方作为栈顶，这里使用BASE_ADDR</span><br><span class="line">    mov ax,SELECTOR_VIDEO</span><br><span class="line">    mov gs,ax</span><br><span class="line"></span><br><span class="line">    mov byte [gs:160],&#x27;p&#x27;   ;在保护模式下打印</span><br><span class="line">    mov byte [gs:161],11000010b</span><br><span class="line">    </span><br><span class="line">call setup_page</span><br><span class="line">sgdt [gdt_ptr]          ;store gdt,将GDTR中的信息存到标号gdt_ptr处</span><br><span class="line">mov  ebx,[gdt_ptr+2]    ;此时ebx中为GDT的基地址</span><br><span class="line"></span><br><span class="line">;显存段是第3个段描述符，段描述符8字节,24~31段基址在高4字节</span><br><span class="line">or dword [ebx+8*3+4],0xc0000000   ;c刚好对应高字节</span><br><span class="line"></span><br><span class="line">;将gdt的基址加上0xc0000000使其位于内核镜像所在的高地址</span><br><span class="line">add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">add esp, 0xc0000000     ;将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">mov eax, PAGE_DIR_POS   ;把页目录地址赋给cr3</span><br><span class="line">mov cr3, eax</span><br><span class="line"></span><br><span class="line">mov eax, cr0            ;打开cr0的pg位(第31位)</span><br><span class="line">or eax, 0x80000000</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">lgdt [gdt_ptr]          ; 重新加载</span><br><span class="line"></span><br><span class="line">mov byte [gs:320], &#x27;V&#x27;  ;视频段段基址已经被更新</span><br><span class="line">mov byte [gs:322], &#x27;i&#x27;     </span><br><span class="line">mov byte [gs:324], &#x27;r&#x27;     </span><br><span class="line">mov byte [gs:326], &#x27;t&#x27;     </span><br><span class="line">mov byte [gs:328], &#x27;u&#x27;     </span><br><span class="line">mov byte [gs:330], &#x27;a&#x27;     </span><br><span class="line">mov byte [gs:332], &#x27;l&#x27;     </span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">;将页目录要存放的内存清零,每次清空4bytes,清1024次,共4KB</span><br><span class="line">setup_page:</span><br><span class="line">mov ecx,1024</span><br><span class="line">mov esi,0</span><br><span class="line">.clear:</span><br><span class="line">mov dword [PAGE_DIR_POS+esi],0</span><br><span class="line">add esi,4</span><br><span class="line">loop .clear</span><br><span class="line"></span><br><span class="line">;创建页目录项,向页目录项中安装各个页表的物理地址</span><br><span class="line">.create_PDE:</span><br><span class="line">mov eax,PAGE_TABLE_POS       ;此时eax为第0个页表的物理位置</span><br><span class="line">mov ebx,eax                  ;备用</span><br><span class="line"></span><br><span class="line">;下面在第0和0xc00目录项中安装第0个页表的地址，一个页表可表示4MB内存,</span><br><span class="line">;这样虚拟地址中高1GB空间的起始4MB和低3GB空间的起始4MB都指向相同的页表。详见博客分析</span><br><span class="line">;这是在为内核映射做准备。</span><br><span class="line">or  eax, PG_US_U | PG_RW_W | PG_P        ;写入目录项属性,RW,PG位和US都为1</span><br><span class="line">mov [PAGE_DIR_POS + 0*4], eax            ;安装第0个目录项,对应虚拟地址0~4MB</span><br><span class="line">mov [PAGE_DIR_POS + 768*4], eax          ;安装第768个目录项,对应虚拟地址3GB~3GB+4MB</span><br><span class="line"></span><br><span class="line">mov eax, PAGE_DIR_POS</span><br><span class="line">or  eax, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">mov [PAGE_DIR_POS + 1023*4], eax ;使最后一个目录项(第1023项)指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建第0页表的部分表项(PTE)</span><br><span class="line">mov ecx,256                      ;1M低端内存/每页大小4KB=256</span><br><span class="line">mov esi,0</span><br><span class="line">mov edx,PG_US_U | PG_RW_W | PG_P ;属性为7,US=1,RW=1,P=1;高12~31位的物理页地址为0,所以直接mov</span><br><span class="line">.create_PTE:</span><br><span class="line">mov [PAGE_TABLE_POS+4*esi],edx</span><br><span class="line">add edx,4096                     ;一个页表项一个物理页框,包含的物理空间为4KB</span><br><span class="line">inc esi</span><br><span class="line">loop .create_PTE                 </span><br><span class="line"></span><br><span class="line">;创建虚拟地址高1GB空间其他对应的目录项</span><br><span class="line">mov eax,PAGE_TABLE_POS+4096*1    ;此时eax为第1个页表的物理位置</span><br><span class="line">or  eax,PG_US_U | PG_RW_W | PG_P ;页目录项的属性US,RW和P位都为1</span><br><span class="line">mov ecx, 254                     ;范围为第769~1022的所有目录项数量,第1023目录项已经安装</span><br><span class="line">mov esi, 769                     ;从第769目录项开始</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">mov ebx,PAGE_DIR_POS</span><br><span class="line">mov [ebx+esi*4], eax</span><br><span class="line">inc esi</span><br><span class="line">add eax, 4096</span><br><span class="line">loop .create_kernel_pde</span><br><span class="line">ret</span><br><span class="line">;========================================================</span><br><span class="line">program_end  equ  $-BASE_ADDR</span><br></pre></td></tr></table></figure><p>首先，务必先理清楚<u>页目录表</u>、<u>页目录项</u>、<u>页表</u>、<u>页表项</u>的关系，否则上面的代码将会看得你一头雾水！另外再次强调，页目录项和页表项中装载的是物理地址，这点很重要。为方便对照，将<a href="">开启分页机制</a>中的页目录项/页表项的结构图搬过来：</p><img src="/2022/img/IMG_0522(20221113-175513).PNG" style="zoom: 67%;" /><p>让我们先聚焦 <code>setup_page</code> ，从第 123 行代码开始。</p><ol><li><p>第 137 行，<code>PG_US_U | PG_RW_W | PG_P</code> ，这三位为 1，其他位都为 0 。</p></li><li><p>第 140 行，为什么要将第 0 号页表的地址装载到第 0 号目录项中？原因是：分页机制是在 loader 中开启的，而 loader 本身已经位于 1MB 物理内存中，所以我们必须保证开启分页前后 <code>CS : EIP</code> 都正确指向 1MB 内的相关 loader 代码，<strong><font color='orange'>即必须保证之前段机制下的线性地址和分页后的虚拟地址所对应的物理地址一致</font></strong> 。<strong>也就是说虚拟地址下的 1MB 内存与真实物理地址下的 1MB 内存是完全一一对应的</strong> 。还是举个例子：开启分页前一瞬间 <code>CS:IP=0x0000:1002</code> 即 <code>0x00001002</code>，<u>这是真实的物理地址</u>；开启分页后执行的一条指令的地址为 <code>CS:IP=0x0000:1004</code> ，由于已经开启分页，这就成了虚拟地址，即 <code>0x00001004</code> 。按照<a href="">分页机制</a>中的计算方法，这个虚拟地址将映射到第 0 号页目录，因为其中装载的是第 0 号页表的地址，进而到第 0 号页表，虚拟地址中的 <code>1</code> 则将其映射到第 1 号页表项，对应的物理页框为 <code>0x1000</code> (<u>后续147~155行代码会将物理页框写入页表项</u>)，最后加上偏移地址 <code>0x04</code> ，得到物理地址 <code>0x00001004</code> 。可见，开启分页前后物理地址和虚拟地址是相同的。</p></li><li><p>第 141 行，为什么将第 0 号页表的地址装载到第 768 号目录项中？原因是：<strong>第 768 号目录项对应的虚拟地址是 3GB~3GB+4MB，我们的内核镜像就在此处。实际内核位于低 1MB 的内存中，现在将其映射到内存 3GB 处，所以必须把第 0 号页表的地址装载到第 768 号目录项中</strong> 。</p><blockquote><p><strong>必须说明的是，第 2, 3点之所以能够顺利将虚拟地址下的 1MB 内存与真实物理地址下的 1MB 内存一一映射，其基础是 147~155 代码，这段代码将虚拟 1MB 与物理 1MB 地址空间一一对应。</strong></p></blockquote></li><li><p>第 145 行，为什么往最后一个(1023)目录项中安装目录表自身的地址？<strong><font color='orange'>这是为了在开启分页后，通过虚拟地址找到页表，这样才能动态操作页表</font></strong> 。二级页表是一种动态的数据结构，要申请一大块内存时可能会添加页表项，释放一块内存时可能会删减页表项。而页表和页目录都是存在于内存中的，要对其进行删减就必须知道它的地址，问题是现在已经进入了虚拟地址空间，我们该如何访问它呢？通过往最后一个目录项中安装目录表自身的地址可以迂回实现。当虚拟地址为 <code>0xfffff000</code> ，即高 10 位和中间 10 位都为 <code>0x3ff(1023)</code> 时，通过高 10 位访问到第 1023 目录项，取得其中的地址；因为该地址为目录表自身地址，所以通过中间 10 位进行索引时会以该地址为基准， <strong>也就是说，第一次索引和第二次索引都是在目录表中进行的（原本第一次索引是在目录表中，第二次索引在页表中）；第二次索引后，取得的地址仍为目录表自身起始地址，<u><font color='gree'>而 CPU 会将其当作物理页框地址来使用</font></u>；最后 12 位页内偏移地址置为 0，<font color='orange'>则最终虚拟地址就被映射成了目录表起始地址</font></strong> 。<strong>如果想访问目录表项，将 <code>0xfffff000</code> 改为 <code>0xfffffxxx</code> 即可，其中 <code>xxx</code> 为 <code>索引值*4</code> ，原因不再赘述。如果想访问页表项，则高 10 位为 <code>0x3ff</code> ，中间 10 位为索引值，此时得到相应页表的起始地址，CPU 将其作为物理页框地址，加上最后 12 位，为 <code>索引值*4</code> ，最终映射成某页表项的地址</strong> 。此方式的核心在于：CPU 很笨，通过目录项原本应该取得页表的地址，然后访问该页表；然而此方式通过目录项取得的却仍是目录表的起始地址，但 CPU 可不知道这个是目录表的地址，它仍将其看作页表地址，并用中间 10 位继续索引。用代码描述可能更清晰：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr对应的页目录表索引,其实直接addr&gt;&gt;22也是可以的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr对应的页表索引</span></span></span><br><span class="line"><span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line"><span class="comment">//此时pte即为虚拟地址vaddr对应的PTE的地址</span></span><br><span class="line"><span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line"><span class="comment">//此时pde即为虚拟地址vaddr对应的PDE的地址</span></span><br></pre></td></tr></table></figure></li><li><p>第 148 行，注意这里只填充了一张页表的四分之一，一张页表可映射 4MB 内存，但我们的内核当前只有不到 1MB，所以只映射了 1MB 的空间。</p></li><li><p>第 157~168 行，物理内核不是只映射在高 1GB 虚拟空间的最低 1MB 处吗？为什么还要安装高 1GB 虚拟地址对应的其他目录项？<strong><font color='gree'>这是为了实现内核完全共享</font></strong> 。所有用户进程的高 1GB 虚拟空间都会被映射到物理内核处，<strong>所以在为用户进程创建页表时，我们必须把内核页目录中第 768~1022 目录项复制到用户进程页目录的相同位置处（第 1023 目录项指向用户目录表的起始位置）</strong> 。如果不这样的话，进程陷入内核时，内核可能因为申请大量内存而新增页表，此时就必须手动将新增的内核页表同步到其他进程的页目录中，否则就只能部分共享。手动同步是很麻烦的，最简单的方式就是提前把高 1GB 的目录项定下来，未来创建用户进程页目录时直接复制过去。<strong>这是实现内核共享的关键！</strong></p><blockquote><p>读者可能还是对这点存有疑惑，不要慌，学到<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理基础篇</a>后，你将恍然大悟。</p></blockquote></li></ol><p>以上是对 <code>setup_page</code> 代码的解析，下面我们聚焦 91~199 行代码。</p><ol><li>第 91 行，<code>sgdt</code> 即 <code>store gdt</code> ，作用是将 GDTR 中的基地址和边界重新倒(dump)在指定地址处。因为无法直接在 GDTR 中修改，所以要先倒出来，在内存中修改，然后再使用 <code>lgdt</code> 重新加载进去。此处 <code>sgdt</code> 似乎有点鸡肋，因为 <code>gdt_ptr</code> 还在内核中，没有被覆盖。</li><li>第 95 行，将显存段的基地址放在了 3GB 处。打印功能涉及硬件(显存)，所以是在内核中实现的，用户要打印须陷入内核，然后再调用打印功能，<strong>肯定不能让用户直接控制显存</strong> 。因此显存段的段基址要改为 3GB 以上。</li><li>第 98 行，将 GDT 也移入内核空间，将其基地址加上 3GB 。<strong>这不是必须的，如果分页后不重复加载 GDT，也可以不修改 GDT 的基址</strong> 。</li><li>第 100 行，将栈指针也指向内核空间，这点原因暂不清楚，后续补充。</li></ol><p>最终效果如下：<br><img src="/2022/img/image-20221115112336872.png" alt=""></p><p>另外，也可以通过 C 语言来设置页表，读者可自行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启分页机制</title>
      <link href="/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://www.zhihu.com/question/436136392">为什么要分页</a> ，《操作系统真相还原》《x86汇编：从实模式到保护模式》《操作系统之哲学原理》《装载、链接与库》<br>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a> 。</p></blockquote><h3 id="font-color-red-为什么分页？-font"><font color='red'>为什么分页？</font></h3><p>分页机制 <strong>最早</strong> 是为了解决内存碎片利用的问题。举例如下：<br><img src="/2022/img/IMG_0523(20221115-141809).PNG" style="zoom:67%;" /><br>在图 1 中，内存被完美利用，还多出 15MB 可用内存。来到图 2，进程 B 运行完毕，从内存中移除，则原来的 20MB 内存变为空闲，则现在一共有 35MB 可用内存。而后进程 D 想要运行，但其需要的内存大小为 20MB+3KB，没有空闲内存段装得下。没办法，即使一共有 35MB 可用内存，<strong>由于必须要连续的空闲内存</strong> ，进程 D 就只有等待进程 A 或 进程 C 加载完毕，腾出空间后才能载入内存运行。</p><p>显然，等待是不能等待的，谁知道这些进程什么时候运行完呢。细心的你可能会发现，<strong>以上问题并不在于内存不够，而在于无法利用“断开”的内存</strong> 。当运行许多进程后，可用内存就会参差不齐，形成大量内存碎片，虽然总可用内存数量很客观，但却完全无法利用。为了解决这个问题，便提出了分页的概念。<strong><font color='gree'>分页和虚拟内存是两个密不可分的概念</font></strong> 。接下来让我们看看这两个概念是如何解决以上问题的。<br>聚焦问题本质，<strong>其根本在于程序必须连续地占用内存</strong> ，你不能将某个程序的一部分代码放在 20MB 处，另一部分放在 15MB 处。那怎么办呢？接下来便是 <strong>抽象</strong> 大展身手的时候了（抽象贯穿了整个计算机体系）：<strong><font color='orange'>我们让程序运行在虚拟地址空间中，使它以为自己运行在连续的线性地址上，而幕后我们将虚拟地址空间映射到实际物理内存中，实际上它仍运行在物理内存中(这有点废话)</font></strong> ，这样就欺骗了程序，目的达成。哈哈，可能你还有点迷糊，那么请看下图：<br><img src="/2022/img/IMG_0524(20221115-150238).PNG" style="zoom: 67%;" /></p><p>通过这种方式，我们就能充分利用内存碎片了。而这只是引入分页机制最初的目的，现在它还具备以下几个重要功能：</p><ul><li><p><strong>控制内存访问权限</strong> 。</p></li><li><p><strong>方便内存和硬盘的交换</strong> 。</p><blockquote><p>开启分页后，将以页为单位进行内存和硬盘的交换。某一程序不常用的页会被清出内存，存入硬盘，这也增加了内存的利用率。</p></blockquote></li><li><p><strong>分页是平坦模型的基础</strong> 。</p><blockquote><p>32 位 4G 平坦内存模型下，段的意义不大；64 位模式下段已经完全失去意义。</p></blockquote></li></ul><p>这几个功能的具体实现后面我们将会说到。</p><h3 id="font-color-red-分页实现机制-font"><font color='red'>分页实现机制</font></h3><p>现在我们知道，开启分页后，程序都运行在虚拟地址空间中，而虚拟地址则被映射到物理内存。那么，总应该找个地方来存放这种映射关系吧？是的，存放这种映射关系的地方就是页表。</p><p><strong><mark class="hl-label blue">一级页表</mark> </strong><br>页的标准大小是 4KB，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> 字节；当页数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 时，覆盖的内存空间就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 字节，即 4GB 。所以在一级页表模型中，一张页表有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项，每个页表项对应着一个页：<br><img src="/2022/img/IMG_0525(20221115-155044).PNG" style="zoom:67%;" /></p><p><strong>页表也是存放在内存中的，页表项大小为 4 字节，所以这样一张页表的大小为 4MB</strong> 。现在问题是，线性地址(开启分页后，也叫虚拟地址)如何转化为物理地址呢？很简单，<u>将 32 位线性地址的高 20 位作为页表索引，用来寻找页表项；将低 12 位作为页内偏移</u>。比如虚拟地址为 <code>0x92f11f23</code> ，则 <code>0x92f11</code> 为索引，对应页表中第 <code>0x92f11</code> 个页表项，假设该页表项中装的 <strong><u>物理页框</u></strong> 为 <code>0x20001</code> ，那么该物理页框加上低 12 位 <code>0xf23</code> ，最终得到物理地址 <code>0x20001f23</code> 。这个计算过程由页部件自动实现。</p><blockquote><p>物理页框即为内存中某页的起始地址。<strong><font color='gree'>物理页框一定是 4K 的整数倍</font></strong> ，即最后 12 位一定为 0 (二进制下)。</p></blockquote><p><strong><mark class="hl-label blue">两级页表</mark> </strong><br>两级页表在一级页表的基础上增添了页目录表（ <strong><font color='red'>在两级页表结构中，页目录表称为一级页表，页表称为二级页表</font></strong> ）：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE10.png" alt=""><br>1024 个目录项对应 1024 张页表，每张页表有 1024 个页表项，每个页表项对应 4KB 的物理内存，即 <code>1024×1024×4KB=4GB</code> ，仍覆盖了 32 位下的整个内存空间。<strong><font color='orange'>二级页表下的映射方式为：将虚拟地址的高 10 位作为目录表索引，中间 10 位作为页表索引，低 12 位作为页内偏移</font></strong> 。比如虚拟地址 <code>0x1f25e9a2</code> ，其高 10 位为 124，即访问第 124 个目录项(起始为第0个目录项)，假设该目录项指向 A 页表；中间 10 位为 1136，则访问 A 页表中的第 1136 个页表项，假设该页表项中的物理页框为 <code>0xff120000</code> ；最后 12 位为 <code>0x9a2</code> ，作为页内偏移地址；故最终该虚拟地址映射到的物理地址为 <code>ff1209a2</code> 。</p><p><strong><mark class="hl-label blue">页表项和页目录项结构</mark> </strong><br><img src="/2022/img/IMG_0526(20221115-170651).PNG" style="zoom:80%;" /></p><ul><li><p>页目录项和页表项中的地址只有 31~12 共计 20 位，这是因为其中装载的都是物理页地址，而标准页大小为 4KB，故地址都是 4KB 的倍数，即低 12 为一定为 0，所以不再花多余空间记录。</p></li><li><p>标志位：</p><ul><li><p><strong>AVL</strong> ：软件/操作系统使用该位，CPU 不使用该位。</p></li><li><p><strong>G</strong> ：Global，全局位。表示当前页是否是全局的，而不是属于某一特定任务的。1 表示为全局页，0 则表示非全局页。该位 TLB 相关，详见文末。</p></li><li><p><strong>PAT</strong> ：页属性表支持位。PAT位使 CPU 能够支持不同页大小的分页管理。当 PAT=0 时，每一页的大小为 4KB；当 PAT=1 时，每一页的大小是 4MB，或是其它大小。该位只存在于页表项。</p></li><li><p><strong>D</strong> ：Dirty，脏页位。<strong>当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1 。<font color='orange'>此项仅对页表项有效，不会修改目录项的 D 位。</font></strong></p><blockquote><p>操作系统在进行内存页调度时，如果发现需要被换出的内存页 D 位为 1 时，则需要将对应物理内存页数据写回虚拟页对应的磁盘交换区，保证磁盘/内存数据的一致性；当发现需要被换出的物理内存页的 D 位为 0 时，表示当前页自从换入物理内存以来没有被修改过，和磁盘交换区中的数据一致，<strong>便直接将其覆盖，而不进行磁盘的写回</strong> ，减少不必要的 I/O 以提高效率。</p></blockquote></li><li><p><strong>A</strong> ：Accessed，访问位。和段描述符中的 A 位和 P 位相同，这两位结合能够实现虚拟内存管理，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">段描述符详解</a> 。</p></li><li><p><strong>PCD</strong> ：页级高速缓存禁止位。PCD 为 1 时，表示访问当前物理页禁用高速缓存；PCD 为 0 时，表示访问当前物理页时允许使用高速缓存。</p></li><li><p><strong>PWT</strong> ：页级通写位。PWT 为 1 时，表示当前物理页的高速缓存采用通写法；PWT 为 0 时，表示当前物理页的高速缓存采用回写法。</p><blockquote><p>PWT与PCD位的使用，涉及到了80386高速缓存的工作原理与内存一致性问题，笔者暂不清楚。</p></blockquote></li><li><p><strong>US</strong> ：User/Supervisor，用户/管理位。当 US 为 1 时，标识当前页是用户级别的，允许所有当前特权级的任务进行访问。当 US 为 0 时，表示当前页是属于管理员级别的，只允许当前特权级为0、1、2的任务进行访问，而当前特权级为 3 的用户态任务无法进行访问。</p></li><li><p><strong>RW</strong> ：Read/Write，读写位。标识当前页是否能够写入。当 RW 为 1 时，代表当前页可读可写；当 RW 为 0 时，代表当前页是只读的。</p></li><li><p><strong>P</strong> ：present，存在位。标识当前虚拟内存页是否存在于物理内存页中。当 P 位为 1 时，表示当前虚拟内存页存在于物理内存中，可以直接进行访问。当 P 位为 0 时，表示对应的物理内存页不存在，需要新分配物理内存页或是从磁盘中将其调度回物理内存。<strong>该位和 A 位共同实现虚拟内存管理</strong> 。</p></li></ul></li></ul><h3 id="font-color-red-两级页表的优越性-font"><font color='red'>两级页表的优越性</font></h3><p>两级页表比一级页表优越在哪？首先我们来看一级页表的缺点：</p><ul><li><p><strong><font color='orange'>一级页表的所有表项必须连续存放</font></strong> （因为你只能通过索引访问，而不是通过地址访问表项），这需要很大一片连续的空间（4MB）。</p></li><li><p><strong><font color='orange'>一级页表必须完整</font></strong> 。然而进程在一段时间内只会访问几张页表，因此没必要让所有页表项常驻内存。当进程很多时，页表占用的内存将会非常可观！</p><blockquote><p>为什么一级页表必须完整？因为一级页表承担的职责是将虚拟地址翻译成物理地址，如果虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。</p></blockquote></li></ul><p>对比之下，我们来看两级页表的优点：</p><ul><li><p>由于页目录项中装载的是页表的物理起始地址（物理页框），而不是索引，<strong><font color='orange'>所以页表可以不连续存放</font></strong> （但页表项还是要连续存放）。这也许能使我们利用一些零散的空间。</p><blockquote><p><strong><font color='orange'>需要注意，由于页目录项中只能容纳页表地址的 31~12 位，所以页表必须以 4K 对齐！也就是说页表的起始地址必须是物理页框。</font></strong></p></blockquote></li><li><p><strong><font color='orange'>页表可以不存在</font></strong> 。<strong>页目录表覆盖到了全部虚拟地址空间</strong> ，所以页表就可以在需要时创建。相对于一级页表结构(4MB)，这大大节省了内存空间。</p><blockquote><p><strong><font color='gree'>顶级页表（页目录表）必须完全创建，且常驻内存，即必须涵盖全部虚拟地址空间</font></strong> 。这里提前说一下，小伙伴们阅读下节内容<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>后会发现实际上我们并没有完全创建页目录项（只创建了第0、768~1022、1023号页目录项），这是为什么呢？注意，<strong><u>“页目录表必须完全创建”指的是必须为页目录表预留 4KB 内存</u></strong> ，且须将此片内存初始化为 0 ；<strong>至于是否安装全部页目录项，可按需进行（一般不会一次性安装全部目录项）</strong> 。为什么需要将页目录表初始化为 0 ，这将在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶-分配页内存</a>中详细阐述。<br>值得说明的是，在 i386 的 Linux 下，创建虚拟内存空间只是分配一个页目录表就行了，甚至不需要创建页映射关系，这些映射关系会等到后面程序发生缺页错误时再进行映射。</p></blockquote></li><li><p><strong><font color='orange'>页表可以不在内存中</font></strong> 。由于程序的局部性原理，一段时间内只会访问少量页表，所以可以将其他页表放入硬盘，并标记相应的页目录项（标记 P 位），需要的时候再从硬盘调入内存。</p><blockquote><p>如果对应的页不在内存中，CPU 将发出缺页中断，由缺页中断程序将所缺页调入内存。那么缺页中断程序如何知道虚拟页面在磁盘中的哪个地方呢？它并不知道。但它知道产生缺页中断进程所对应的源程序文件名和产生缺页中断的虚拟地址，中断程序会根据虚拟地址计算该地址在对应程序文件中的偏移量，然后要求文件系统在该文件此偏移量处进行文件读取，一般会读取多个页。详细内容后续会进行说明。</p></blockquote></li></ul><p>另外需要说明的是，现代操作系统大多都采用 3~5 级页表了。</p><h3 id="font-color-red-开启分页-font"><font color='red'>开启分页</font></h3><p><strong><font color='orange'>通过将 CR0 寄存器的 PG(第 31 位) 置 1 开启分页机制</font></strong> ：<br><img src="/2022/img/IMG_0516(20221102-163923)-1668327746253-1.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0                 </span><br><span class="line">or  eax, 0x80000000</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><p>但一般而言，<strong><font color='orange'>在此之前，需要将页目录表的起始地址赋给 CR3 寄存器</font></strong>。CR3 结构如下：<br><img src="/2022/img/IMG_0520(20221113-163114).PNG" alt=""></p><p>其中 PCD 和 PWT 用户设置高速缓存的相关特性，在此置 0 即可。所以，可以直接用以下方式赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, PAGE_DIR_POS   ;把页目录地址(0x00100000)赋给cr3</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure><p><strong>注意，CR3 中装载的是物理地址，而非虚拟地址！</strong></p><h3 id="font-color-red-几类地址的关系-font"><font color='red'>几类地址的关系</font></h3><ul><li>物理地址：就是真实的内存地址，不必多说。</li><li>逻辑地址：不论在实模式还是保护模式，都指段内偏移地址。</li><li>有效地址：和逻辑地址相同。</li><li>线性地址：在保护模式下，未开启分页时，线性地址就是物理地址；开启分页后，线性地址又叫虚拟地址。</li><li>虚拟地址：<strong><font color='red'>用来描述任务或进程的地址空间，每个进程都有 4GB 虚拟地址空间！</font></strong> 开启分页后，进入虚拟地址空间。</li></ul><h3 id="font-color-red-TLB-font"><font color='red'>TLB</font></h3><p>我们已经知道，虚拟地址转化成物理地址需要访问多次内存，以上还只是两级页表，如果换成五级页表，那么转换效率将下降得非常明显！那有没有办法解决呢？有的，仍然利用程序的局部性原理，如果一个页面被访问，该页面中的其他地址很有可能随后就被访问，这样我们就能将该页面的翻译结果放入缓存，后面访问该页内中的地址时直接在缓存中取得相应页框，而无须每次访问该页面中的地址时都翻译一次，这样就能大大提高效率。</p><p>该缓存就是 <strong>TLB(Translation Lookaside Buffer)</strong> ，又称为<u>快表</u> 。快表的结构如下：<br><img src="/2022/img/IMG_0527(20221116-151219).PNG" alt=""></p><p><strong>处理器会在寻址前用虚拟地址的高 20 位来匹配 TLB 中每个项的虚拟页框号，如果匹配成功（命中），则返回对应的物理页框号</strong> ；<strong>如果不中，则按原方式寻找物理页框，获得物理页框后再更新 TLB</strong> 。</p><blockquote><p>需要注意的是，这种匹配方式并不是挨个比较，想一想，如果按顺序挨个比较的话，只要 TLB 中的表项稍多，那么搜索 TLB 的时间就可能多于查找多级表所需要的时间了，这样 TLB 就失去了意义。所以，比较时并不是按顺序比较，而是与所有表项同时比较！这种离谱的操作需要特殊的电路，这也就是 TLB 如此昂贵的原因。</p></blockquote><p>另外，不同于其他普通缓存，TLB 涉及到内存访问（取指令，取数据），如果不能时刻保证其中地址的有效性，那么程序将必然出错！这么说，TLB 就需要时刻更新。可是若实时读取内存中的页表去更新 TLB 的话，这又回到了内存查找映射的老路，TLB 又失去了意义。<strong><font color='orange'>因此，TLB 并不自动更新，处理器也不负责 TLB 的有效性，它将 TLB 的维护工作交给操作系统开发人员</font></strong> ，毕竟是由操作系统开发人员负责的页表维护，他们肯定知道何时修改了哪些页表或条目。TLB 对开发人员不可见，但有两种以下方式可以间接更新 TLB：</p><ol><li><p>重新加载 CR3 。将 CR3 读出来再重新写入，这会使整个 TLB 失效。</p></li><li><p>使用指令 <code>invlpg</code> 。该指令用来刷新 TLB 中某个虚拟页框对应的条目，所以操作数也是虚拟地址：<code>invlpg [m]</code> 。</p><blockquote><p>未来我们在编写内存管理代码时会用到该指令。</p></blockquote></li></ol><h3 id="font-color-red-内核与用户的关系-font"><font color='red'>内核与用户的关系</font></h3><p>不同于实模式，我们现在实现的是多任务调度系统，多个任务能够同时运行。进程可以有很多个，但操作系统，或者说内核，只有一个，<strong><font color='orange'>因此内核必须共享给所有用户进程</font></strong> 。进而，我们需要设计内存布局，以达到所有进程共享内核的目的，<u>这需要通过规划页表来实现</u>。</p><p>保护模式下，用户进程以低特权级身份运行，内核则以高特权级运行，当用户进程要访问硬件资源时，需要向操作系统申请，由操作系统代办，然后将结果返回给用户。换句话说，<strong><font color='gree'>一个完整的程序分为用户代码（私有部分）和操作系统代码（全局部分）</font></strong> ，两者相互配合才能完成任务。</p><blockquote><p>特权级相关内容后面会详细说到，耐不住的同学请移步<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a></p></blockquote><p>前面我们说过，<strong>虚拟地址空间是用来描述任务或进程的，每个进程都有 4GB 的虚拟地址</strong> 。为了实现内核共享，我们将虚拟地址空间分为两个部分：<strong><font color='orange'>一部分划给内核，占高 1 GB；另一部分划给用户进程，占低 3 GB</font></strong> 。进一步说，我们会将所有用户的 3~4GB 虚拟地址空间指向同一个操作系统，也就是所有进程的 3~4GB 虚拟地址都指向同一片物理页。具体方式和代码请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进入保护模式-代码详解</title>
      <link href="/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong><font color='orange'>MBR --&gt; Loader --&gt; Kernel</font></strong><br>本节代码只涉及 MBR 和 Loader 部分，暂未考虑内核代码。同时，为规范操作，我们使用 [加载器-用户程序] 方式将 Loader 从硬盘载入内存。这种方式非常漂亮，同时能让你理解重定位的本质，详细请阅读<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器-重定位</a> (本节前置要求，务必阅读)。</p></blockquote><blockquote><p>本节代码对应分支 <code>protected-mode</code> 。</p></blockquote><p><strong><mark class="hl-label blue">配置文件</mark> </strong><br>本节的 MBR 可以直接引用 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 一文中的 MBR 代码，并在文件头引入配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION mbr align=16 vstart=0x7c00                                     </span><br><span class="line">;....................以下省略....................</span><br></pre></td></tr></table></figure><p>其中 <code>loader.inc</code> 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.inc</span><br><span class="line">BASE_ADDR    equ 0x900 ;最好不超过0xFFFF,原因在下文解释</span><br><span class="line">START_SECTOR equ 2     ;从硬盘的第2(lba)扇区将加载器载入内存</span><br></pre></td></tr></table></figure><p>接着，定义保护模式的配置文件 <code>boot.inc</code> 。将此图和以下代码对比阅读：<br><img src="/2022/img/IMG_0499(20221101-085023).PNG" alt="其中的含义参见《全局描述符表 &amp; 段选择子概述》"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：boot.inc ,包含保护模式中要用到的段选择子,描述符等内容</span><br><span class="line">;以下为段描述符的子属性</span><br><span class="line">DESC_G_4K         equ   1000_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_DB_32        equ    100_0000_0000_0000_0000_0000B </span><br><span class="line">DESC_L            equ     00_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_AVL          equ      0_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_LIMIT_CODE2  equ        1111_0000_0000_0000_0000B</span><br><span class="line">DESC_LIMIT_DATA2  equ        DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2 equ        0000_0000_0000_0000_0000B</span><br><span class="line">DESC_P            equ             1000_0000_0000_0000B</span><br><span class="line">DESC_DPL_0        equ              000_0000_0000_0000B</span><br><span class="line">DESC_DPL_1        equ              010_0000_0000_0000B</span><br><span class="line">DESC_DPL_2        equ              100_0000_0000_0000B</span><br><span class="line">DESC_DPL_3        equ              110_0000_0000_0000B</span><br><span class="line">DESC_S_SYS        equ                0_0000_0000_0000B</span><br><span class="line">DESC_S_DATA       equ                1_0000_0000_0000B</span><br><span class="line">DESC_TYPE_CODE    equ                  1000_0000_0000B;只执行1000</span><br><span class="line">DESC_TYPE_DATA    equ                  0010_0000_0000B;可读写0010</span><br><span class="line"></span><br><span class="line">;以下为段描述符的高四位(低四位在loader.s中定义)</span><br><span class="line">DESC_CODE_HIGH4   equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_CODE + 0X00</span><br><span class="line">DESC_DATA_HIGH4   equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_DATA + 0X00</span><br><span class="line">DESC_VIDEO_HIGH4  equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_DATA + 0X0b</span><br><span class="line">;========段选择子属性=============</span><br><span class="line">RPL0   equ   00B</span><br><span class="line">RPL1   equ   01B</span><br><span class="line">RPL2   equ   10B</span><br><span class="line">RPL3   equ   11B</span><br><span class="line">TI_GDT equ   000B</span><br><span class="line">TI_LDT equ   100B</span><br></pre></td></tr></table></figure><p>下面对以上宏定义进行说明：</p><ul><li>将各个子属性进行宏定义，最后相加组成段选择子的高四字节（低四字节后续定义）。相比一大串莫名奇妙的数字，这样更加直观。</li><li>第 7, 8 行，将 DATA 和 CODE 的 4 位段界限全设置为 1（后面会将 DATA 和 CODE 的另外16位段界限全设为1），由于 G=1，粒度为 4KB，所以实际段大小为 4GB。第 21,24 行 <code>0x00&lt;&lt;24</code> 以及末尾加上 0x00，这是在将高4字节中的段基址设为 0（后面会将 DATA 和 CODE 的另外16位段基址全设为0），所以段基址为 0。<strong><font color='orange'>将段基址设为 0，段界限设为 4GB，这样做是为了形成平坦模型</font></strong> ，即整个内存都在一个段中。平坦模型使用起来很方便，后期我们会慢慢体会到。</li><li>第 29 行，为啥最后加的 0x0b？之前说过，文本显示适配器的内存地址为 <code>0xb8000~0xbffff</code> ，<strong><font color='orange'>为了方便显存的操作，显存段不使用平坦模型</font></strong> ，所以将段基址设置为 0xb8000，其中的 b 在段描述符的高 4 字节上，这就是为啥 26 行末尾加 0x0b；显存的段大小为 <code>0xbffff-0xb8000=0x7fff</code> ，粒度为 4KB，因此段界限为 <code>0x7fff÷4KB=7</code> ，这将在段描述符的低 4 位设置，高 4 位直接设 0 即可。</li><li>第 15,16 行，SYS 表明该段是系统段；DATA 不是指数据段，<u>而是相对于 SYS 而言的</u>，代码段/数据段/栈段都属于 DATA 。</li><li>以上宏定义并未定义栈段，这是因为此处将栈段和数据段定义在了一起，即 DATA 段。关于为什么栈段和数据段能够放在一个段中，参见<a href="https://jyx-fyh.github.io/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/">内存段与段寄存器保护</a> 。</li><li><code>_</code> 仅作分隔符，方便阅读，编译时会自动忽略。</li></ul><p><strong><mark class="hl-label blue">loader.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.s</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06] </span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;GDT</span><br><span class="line">;第0描述符不可用</span><br><span class="line">    GDT_BASE        dd    0x00000000</span><br><span class="line">                    dd    0x00000000</span><br><span class="line">;第1描述符CODE</span><br><span class="line">    DESC_CODE       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_CODE_HIGH4</span><br><span class="line">;第2描述符DATA   </span><br><span class="line">    DESC_DATA       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_DATA_HIGH4</span><br><span class="line">;第3描述符VIDEO</span><br><span class="line">    DESC_VIDEO      dd    0x80000007</span><br><span class="line">                    dd    DESC_VIDEO_HIGH4</span><br><span class="line">    </span><br><span class="line">    GDT_SIZE        equ   $ - GDT_BASE</span><br><span class="line">    GDT_LIMIT       equ   GDT_SIZE - 1    </span><br><span class="line">;GDT指针</span><br><span class="line">    gdt_ptr         dw    GDT_LIMIT    </span><br><span class="line">                    dd    GDT_BASE</span><br><span class="line"></span><br><span class="line">    SELECTOR_CODE   equ   ((DESC_CODE - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_DATA   equ   ((DESC_DATA - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_VIDEO  equ   ((DESC_VIDEO- GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    </span><br><span class="line">    loader_msg      db    &#x27;r&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;a&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;-&#x27;,11000010b</span><br><span class="line">                    db    &#x27;m&#x27;,11000010b,&#x27;o&#x27;,11000010b,&#x27;d&#x27;,11000010b,&#x27;e&#x27;,11000010b</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br><span class="line">start: ;程序入口          </span><br><span class="line">mov ax,0             ;转移到loader代码后,</span><br><span class="line">mov ds,ax            ;将各段寄存器清0是头等大事</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">print:</span><br><span class="line">mov ax,0xb800        ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,loader_msg    ;ds:si</span><br><span class="line">mov di,0             ;es:di</span><br><span class="line">mov cx,18            ;9个字符,占18字节</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">;========================================================</span><br><span class="line">;1.打开A20</span><br><span class="line">;2.加载GDT</span><br><span class="line">;3.置PE=1</span><br><span class="line">prepare: </span><br><span class="line">;关中断</span><br><span class="line">    cli</span><br><span class="line">;打开A20</span><br><span class="line">    in   al,0x92</span><br><span class="line">    or   al,0000_0010B</span><br><span class="line">    out  0x92,al</span><br><span class="line">;加载GDT</span><br><span class="line">    mov  ax,0</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line">;CR0的第0位置1</span><br><span class="line">    mov  eax,cr0</span><br><span class="line">    or   eax,0x0000_0001</span><br><span class="line">    mov  cr0,eax</span><br><span class="line">;此后进入保护模式</span><br><span class="line">    jmp  dword SELECTOR_CODE:p_mode_start ;刷新流水线,装载CODE选择子</span><br><span class="line">;======================================================</span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">    mov ax,SELECTOR_DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov esp,BASE_ADDR       ;可以找其他合适的地方作为栈顶，这里使用BASE_ADDR</span><br><span class="line">    mov ax,SELECTOR_VIDEO</span><br><span class="line">    mov gs,ax</span><br><span class="line"></span><br><span class="line">    mov byte [gs:160],&#x27;p&#x27;</span><br><span class="line">    mov byte [gs:161],11000010b</span><br><span class="line">    jmp $</span><br><span class="line">;========================================================</span><br><span class="line">program_end  equ  $-BASE_ADDR </span><br></pre></td></tr></table></figure><p>以上代码的解释：</p><ul><li><p>为什么此 loader 段的 <code>vstart</code> 不能像<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>中的 loader 段一样设为 0 ？有以下两个原因：</p><ol><li><p>注意第 75 行代码，该代码执行后，代码段的段基址为 0（因为CODE段描述符的段基址之前被全设为0了），进入了平坦模式，所以在内存中寻址并取得指令就全靠偏移地址啦！该行代码将直接跳转至 <code>p_mode_start</code> 处。那么，<code>p_mode_start</code> 的值为多少呢？这个问题至关重要。如果我们将 loader 段的 <code>vstart</code> 设为 0，那么标号 <code>p_mode_start</code> 的值就为 79 行代码相对于文件头的偏移量，本文件编译后所得二进制文件大小大概为 172 字节，所以 <code>p_mode_start</code> 相对于文件头的偏移大概为 140(0x8C) 字节，即 <code>p_mode_start=0x8C</code> 。问题在于，我们已经将此 loader 载入到内存 0x900 处，如果跳转到  <code>0x8C</code>  处，显然将执行错误的代码。实际应该跳转到 <code>0x98C</code> 处，而 <code>vstart=BASE_ADDR</code> 便能将 <code>p_mode_start</code> 以 0x900 开始计算偏移，这样就能跳转到正确位置啦！说清楚真不容易。。</p></li><li><p>再注意第 30 行的 GDT_BASE。要知道，GDT_BASE 为 32 位段基地址，<strong>CPU 是直接在内存中的 <code>GDT_BASE</code> 处来找到 GDT 的</strong> 。说到这读者就应该懂了吧？原因和上点相同。</p><blockquote><p>vstart 不好理解，具体参见 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p></blockquote></li></ol></li><li><p>整个 loader 自成一段，这是为了方便。你也可以将以上代码分成数据段和代码段，<strong><font color='pink'>但务必注意，除 loader 段外的其他段不能用 vstart 修饰</font></strong> ！</p></li><li><p>第 8 行，偏移地址为什么是 <code>start-BASE_ADDR</code> ，因为在 MBR 最后的跳转指令(71行) <code>jmp far [0x04]</code> 的效果是 <code>jmp 0x900:偏移地址 </code> ，所以要此处放置的必须是 start 标号相对于本文件开头的偏移量。</p></li><li><p>第 29 行，注意 GDT 的 LIMIT 等于 SIZE-1（因为偏移从0开始算）。</p></li><li><p>第 23 行，<code>(DESC_CODE - GDT_BASE)/8</code> 得到索引值（段描述符为8字节），<code>&lt;&lt;3</code> 将索引值移到正确的位置上。<br><img src="/2022/img/3未命名绘图-1667637847644-1.png" style="zoom:50%;" /></p></li><li><p>第 61 行，关闭中断。<strong><font color='orange'>保护模式下的中断机制和实模式不同，原有的中断向量表不再适用，BIOS 中断无法继续使用</font></strong>。</p></li><li><p>第 87 行，之前我们说过，为了方便显存操作，对 VIDEO 段仍使用分段模型而非平坦模型。</p></li><li><p>注意！最后 <code>program_end equ $-BASE_ADDR</code> 得到整个文件二进制代码的大小。</p></li></ul><p>最后需要单独强调的是，第 41~46 行代码并非必须要执行。这主要针对的是打印信息，即后面要用到的 ds 寄存器。如果 ds 不清零，则后续寻找字符时，<code>ds:loader_msg</code> 就是错误的地址，原因见上面第 1、2 点。然而如果按照我们上面的这种方式，则该 loader 必须加载到内存 0xFFFF 以内！否则打印无法正常进行（保护模式仍然能够正确进入）。这是因为打印时还在实模式，有效地址最大还是 16 位，如果 loader_msg 的标号超过 0xFFFF，那么有效地址就无法容纳 loader_msg。如果想把这 loader 加载到内存任意位置，则无需清零段寄存器，且第 50 行代码需要改为：<code>mov si,loader_msg-BASE_ADDR </code> 。<br>执行结果如下：<br><img src="/2022/img/image-20221105222138942.png" alt="image-20221105222138942"></p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进入保护模式五部曲</title>
      <link href="/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
      <url>/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">进入保护模式-代码详解</a><br>参考：《操作系统真相还原》《x86汇编：从实模式到保护模式》</p></blockquote><h3 id="font-color-red-五部曲概览-font"><font color='red'>五部曲概览</font></h3><ul><li>打开 A20 地址线</li><li>加载 GDT</li><li>将 CR0 寄存器的 PE 位设置为 1</li><li>关闭中断</li><li>刷新流水线</li></ul><blockquote><p>以上五个步骤没有顺序，但为了保险起见，最好将操作 CR0 放在最后一步。</p></blockquote><h3 id="font-color-red-打开-A20-地址线-font"><font color='red'>打开 A20 地址线</font></h3><p>8086/8088 CPU 的地址总线为 20 位，寻址空间为 1MB 。当地址超过 1MB 时，地址就会发生回绕，即重新从 0 算起，相当于对 1MB 求模。这种缺陷被当时很多程序员利用，成为了一个编程技巧，并写入了程序（一旦用得多，就必须考虑兼容）。后来的 80286 CPU的地址总线扩展到 24 位，寻址空间达到 16MB 。考虑到 80286 需要兼容 8086 实模式，即在实模式下必须只使用 20 位地址线，以确保能够发生回绕。为实现这一目的，CPU 在 A20 地址线(第21根地址线)处设置了一个开关(A20Gate)，在实模式下关闭，则最大地址空间为 1MB，能够发生回绕；在保护模式下打开，寻址空间扩展到 24 位。</p><p>32位 CPU 类似，只有打开 A20Gate 后，地址空间才能由 1MB 扩展到 4GB，从而进入更大的空间。</p><p>打开 A20Gate 的方法很简单，<strong><font color='orange'>将 0x92 端口的第 1 位(起始位是第0位)置 1 即可</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in  a1,0x92       #先读进来</span><br><span class="line">or  al,0000_0010B #第1位置1</span><br><span class="line">out 0x92,al       #再写出去</span><br></pre></td></tr></table></figure><h3 id="font-color-red-加载GDT-font"><font color='red'>加载GDT</font></h3><p><strong><font color='orange'>使用指令 <code>lgdt</code> (load gdt)将 GDT 的信息加载进 GDTR</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt  gdt_ptr</span><br></pre></td></tr></table></figure><p><code>gdt_ptr</code> 是标号，代表 GDT 所在的地址，<strong>指向一个包含了 48 位的内存区域。该区域的高 32 位必须为 GDT 的基地址，低 16 位为边界</strong> 。该指令在实模式和保护模式下都能够使用。<strong><font color='orange'>注意，必须先加载 GDT 才能够进入保护模式</font></strong> ！由于实模式下的内存空间为 1MB，所以只有先将 GDT 放在 1MB 内存以内，进入保护模式后可以转移 GDT 的位置。</p><h3 id="font-color-red-置-PE-位为-1-font"><font color='red'>置 PE 位为 1</font></h3><p>CR0 寄存器的 PE 位(第 0 位)是进入 32 位保护模式的开关，开启后，对指令的解释将改变，参见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a>。CR0 结构如下：<br><img src="/2022/img/IMG_0516(20221102-163923).PNG" alt=""><br>各位的解释如下：<br><img src="/2022/img/image-20221102164337278.png" alt=""></p><p>置 1 方式和打开 A20Gate 差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,cr0</span><br><span class="line">or  eax,1</span><br><span class="line">mov cr0,eax</span><br></pre></td></tr></table></figure><p>此后，CPU 就进入到保护模式啦！</p><h3 id="font-color-red-关闭中断-font"><font color='red'>关闭中断</font></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure><p>准确来说是禁止可屏蔽中断。从实模式进入保护模式时，不关中断也是可以的，如果中断发生在实模式进入保护模式之前和之后都没有问题，但若在模式切换进行时发生中断就会发生异常了，这个情况概率比较低。具体原因笔者也不太明白，可参考<a href="https://www.zhihu.com/question/532841878">为什么保护模式需要使用cli指令禁止硬件中断？)</a></p><blockquote><p>另外，保护模式下不能再使用 BIOS 中断。</p></blockquote><h3 id="font-color-red-刷新流水线-font"><font color='red'>刷新流水线</font></h3><p>其实本来只有前三步曲，但进入保护模式后还有一个相当重要的步骤必须马上进行：刷新流水线。未进入保护模式时，CPU 使用 16 位指令格式译码，进入保护模式后，使用 32 位指令格式译码（两者区别参见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a>）。而进入保护模式这一瞬间，有很多实模式下的指令之前已经进入了流水线，而保护模式对这些指令的解释有所不同，可能引发错误，所以必须清空流水线。关于流水线，参见<a href="https://jyx-fyh.github.io/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/">处理器微架构</a> 。<strong><font color='orange'>使用 jmp 指令即可刷新流水线</font></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SELECTOR_CODE:p_mode_start</span><br></pre></td></tr></table></figure><p>关于这条指令的详细解释，参见<a href="https://jyx-fyh.github.io/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">进入保护模式-代码详解</a> 。</p><blockquote><p>另外，其实在置 PE 位为 1 和刷新流水线的这段时间内，系统实际上是处于 16 位保护模式下。这是因为置 PE 为 1 后，即刚进入保护模式时，CS 的描述符高速缓存器中仍然是实模式下的内容（此时还没来得及更新），其 D 位是 0，因此在刷新流水线前，处理器运行在 16 位保护模式下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存段与段寄存器保护</title>
      <link href="/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-修改段寄存器时的保护-font"><font color='red'>修改段寄存器时的保护</font></h3><p>处理器在变更段寄存器以及描述符高速缓存器时，会检查代入值的合法性，若不合法，则抛出异常。将段选择子送入段寄存器时，CPU 的固件会自动确认选择子和该选择子对应的段描述符的正确性。<br><strong><font color='gree'><u>对选择子的检查内容包括</u></font></strong>：</p><ol><li><p><strong>选择子的索引是否超界</strong> ，即对应的段描述符是否在 GDT 范围内。要求 <code>索引号×8+7 &lt;= 边界</code> 。若超过边界，则产生异常中断 13，同时段寄存器的原值不变。</p></li><li><p><strong>选择子的索引是否为 0</strong> 。在<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">全局描述符表 &amp; 段选择子概述</a>一文中说过，GDT 的第 0 个描述符不可用。对于 DS,ES,FS,GS 这四个段寄存器，可以向其中加载索引为 0 的段选择子，CS,SS 段寄存器则不可。</p><blockquote><p>虽然能够加载索引为 0 的段选择子，但访问内存时就会出错并抛出中断。CPU 使用这种特殊的设计来保证系统安全。</p></blockquote></li></ol><p><strong><font color='gree'><u>对段描述符的检查内容包括</u></font></strong>：</p><ol><li><strong>结合 S 位判断 TYPE 字段的有效性</strong> 。比如 <code>0000</code> 就是无效值。</li><li><strong>检查描述符类型是否和段寄存器用途匹配</strong> 。段的类别检查规则如下：<br><img src="/2022/img/image-20221101211058505.png" style="zoom:80%;" /><br>大概原则可以总结为：<br>1）只有可执行的段才能加载进 CS；<br>2）只有可读写的段才能加载进 SS；<br>3）至少可读的段才能加载进 DS, GS, ES, FS；<br><strong>注意，可读的代码类似于 ROM，既可以用 CS 执行，也可被 DS,ES,FS,GS 当作数据访问</strong> ！</li><li><strong>检查 P 位</strong> 。若 P=0 ，则表示该段虽然已经被定义，但并不在内存中，抛出异常中断11。应当定义相应的中断处理程序，抛出异常后，把该描述符对应的段从硬盘中调入内存，中断返回时，处理器再进行操作。</li></ol><h3 id="font-color-red-对代码段的保护-font"><font color='red'>对代码段的保护</font></h3><p>EIP 中装着下一条指令的偏移地址。在获取下一条指令前，CPU 会检查 EIP 的有效性，以防止执行超出范围之外的指令。检查方式为：<code>0&lt;=(EIP+指令长度-1)&lt;=实际段界限</code> ，其中 <strong><code>实际段界限=(段界限+1)×粒度-1</code></strong> 。跨越边界的指令同样不允许执行，这种指令也已经被包含在此公式中。</p><h3 id="font-color-red-对数据段的保护-font"><font color='red'>对数据段的保护</font></h3><p>同代码段类似，其检查方式为：<code>0&lt;=(EA+操作数的长度-1)&lt;=实际段界限</code> 。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x2000],edx</span><br></pre></td></tr></table></figure><p>其中 EA=0x2000 。</p><h3 id="font-color-red-对栈段的保护-font"><font color='red'>对栈段的保护</font></h3><p>同上类似，其检查方式为：<code>(ESP-操作数长度)&gt;=实际段界限</code> 。</p><p>你可能会在源代码中进行以下的栈段定义：<br><img src="/2022/img/6%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt="注意图中为偏移地址，不是物理地址"><br>将 ESP 初始值设为 <code>0x7c00</code> ，段界限设为 <code>0x7A00</code> ，粒度设为 1 字节，扩展方向设为向下 (E位为1) ，则定义出 <code>0x7C00~0x7A00</code> 的栈段。虽然 ESP 不能低于 <code>0x7A00</code> ，但它却能够一直 POP 从而高于 <code>0x7C00</code> ，这仍然超过了我们指定的空间。最可怕的是，即使高于 <code>0x7C00</code> ，CPU 也不会抛出异常，这很有可能导致我们悄无声息地改变其他内存空间中的重要数据或代码，从而使程序崩溃。<strong><font color='orange'>正确的栈段定义应该采用如下方式：</font></strong><br>将段描述符中的段基址设为 <code>0x00007c00</code> ，段界限设为 <code>0x000FFFFE</code> ，粒度设为 4KB（即设 G 为1) ，初始 ESP 设为 0 。则实际段界限为 <code>FFFFEFFF</code> ，又因为 ESP 的最大值为 <code>FFFFFFFF</code> ，所以操作该段时，CPU 的检查规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFFEFFFF&lt;=(ESP-操作数长度)&lt;=0xFFFFFFFF</span><br></pre></td></tr></table></figure><p>访问内存时，<code>物理地址=段基址+ESP</code> ，所以该栈段的栈底 <strong>物理地址</strong> 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007C00 + 0xFFFFF000 = 0X00006C00</span><br></pre></td></tr></table></figure><p>该栈段的最高端地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007C00 + 0xFFFFFFFF = 0X00007BFF</span><br></pre></td></tr></table></figure><p>从而，该栈段被限制在物理地址 <code>0x00006C00 ~ 0x00007BFF</code> 范围内，长为 512 字节 。这波操作实在 666 。稍加思考就能发现，上面的方法是 <strong><font color='orange'>通过 ESP 本身的最大值限制来为栈段创造了一个上边界</font></strong> 。</p><p>注意，<strong>数据段和栈段的段基址可以相同</strong> 。比如，上面讲的栈的基地址设为 <code>0x7c00</code> ，但其栈底元素所占内存为 <code>0x7BFC~0x7BFF</code> ；若讲数据段的基地址也设为 <code>0x7C00</code> ，则起始数据的内存就是从 <code>0x7C00</code> 开始。</p><p>实际上，可以将数据段作为栈段，这种方式定义起来比较简单，但其中有些细节问题笔者还未搞清楚，搞明白后再更新。</p><h3 id="font-color-red-利用段别名修改代码段-font"><font color='red'>利用段别名修改代码段</font></h3><p>一般情况下，任何指令都不允许向代码段写入数据，而且，只有可读的代码才允许访问。但很多时候又需要对代码作一些修改，比如调试程序时需要加入断点指令 int3。此时，就不能使用原描述符来进行访问，而应该重新定义一个段描述符，并将其定义成可读写的段，这样就可以通过这个新定义的段描述符来修改之前的代码段。像这样，当多个不同的描述符指向同一个段时，把另外的描述符称为该段的别名。</p><blockquote><p>如果两个程序想共享同一个内存区域，也可以采用此方式。</p></blockquote><blockquote><p>文章参考：《操作系统真相还原》《x86汇编语言：从实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDT&amp;段描述符&amp;选择子概述</title>
      <link href="/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了方便程序的浮动装配(重定位)，处理器访问内存时采用了 [段地址+偏移地址] 的策略，这是 IA-32 的基因。在保护模式下，段有了新的作用——权限管理的单位，<strong>操作系统将一定权限赋予给某些段</strong> ，当段内指令访问内存或进行其他操作时，<strong>CPU 会根据段的权限来检查其行为的可行性</strong> ，如果其行为越界，则会阻止并抛出异常。那么这些权限是如何记录的呢？请见下文。</p><h3 id="font-color-red-段描述符-font"><font color='red'>段描述符</font></h3><p>段的各类权限信息和其地址都被记录在 <strong>段描述符</strong> 中，其结构如下：</p><img src="/2022/img/IMG_0499(20221101-085023).PNG" style="zoom: 67%;" /><ul><li><p>段基址共 32 位，段界限共 20 位。可见它们都是“断开”的，这是因为需要兼容 80286 的 16 位保护模式，详细原因可见下一点。这种散乱分布不利于 CPU 获取段基址和段界限，<strong>所以段描述符中的内容会被整理好后存入描述符高速缓存器，CPU 直接从缓存器中获取段基址和段界限</strong> 。注意，<strong>对于数据段和代码段来说，段界限决定了偏移量的最大值；对于栈段而言，段界限决定了偏移量的最小值</strong> ，其细节差异在<a href="https://jyx-fyh.github.io/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/">内存保护与寄存器保护</a>中有详细阐述。<strong>实际段界限等于 <code>(段界限+1)*粒度-1</code></strong> (减1是因为偏移从0开始)。段基址可选在任何地方，但最好与 16 位对齐。以段基址为起点开始偏移，如下：<br><img src="/2022/img/1%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt="栈段与代码/数据段的段基址可以相同, 后续详述"></p></li><li><p><strong>G</strong> ：段界限的粒度。G=0 时，粒度为 1 字节，则段最大扩展范围为 64KB；G=1 时，粒度为 4KB，则段最大扩展范围为 4GB。</p></li><li><p><strong>D/B</strong> ：默认 操作数/堆栈指针 大小。D=0 时表示该段指令中的偏移地址和操作数为 16 位，栈操作使用 SP 寄存器，偏址用 IP；D=1 时表示该段指令中的偏移地址和操作数为 32 位，栈操作使用 ESP 寄存器，偏址用 EIP。设置该标志位是为了兼容 80286 的 16 位保护模式。16 位保护模式基本绝迹，该位总是为 1。</p></li><li><p><strong>L</strong> ：64 位代码段标志，保留给 64 位处理器使用，现在直接置 0 即可。</p></li><li><p><strong>AVL</strong> ：软件可以使用的位，处理器不使用它，但使用该位是不安全的，谁也不知道 Intel 公司未来是否会使用该位。</p></li><li><p><strong>P</strong> ：段存在位。用来描述该段是否在内存中。当内存紧张时，有可能只建立描述符但对应的内存空间不存在，此时应将 P 设为 0；另外，内存紧张时，可能会把用得很少的段从内存移到硬盘中，腾出空间给急需内存的应用，此时同样应该将 P 清零，当需要该段时，再移入内存并置 P 为 1。<strong>这是多任务系统下常见的虚拟内存调度策略</strong> 。P 位通常由操作系统负责设置，由 CPU 负责检查。</p></li><li><p><strong>DPL</strong> ：Descriptor Privilege Level，描述符特权级。CPU 支持 4 种特权级：0，1，2，3，数字越小特权越高。<strong>注意，特权级描述的是要访问该段的最低特权级</strong> 。比如，若该段 DPL=2，则只有 DPL 为 0、1、2 的段才能访问该段。</p></li><li><p><strong>S</strong> ：指定描述符的类型。S=0 表示该段为系统段；S=1 表示该段为数据段/代码段/栈段。<strong>S 位和 TYPE 位配合才能确定段描述符的确切类型</strong> 。</p></li><li><p><strong>TYPE</strong> ：共 4 位，用于表示内存段或门的子类型。<br><strong>当 S=1 时</strong> ：对于代码段而言，这 4 位是 X, C ,R ,A；对于数据段/栈段而言，这 4 位是 X, E ,W ,A：<br><img src="/2022/img/image-20221101105041738.png" alt="" style="zoom: 67%;" /></p><ul><li>X：是否可执行。数据段/栈段总是不可执行，代码总是可执行。</li><li>E：扩展方向。<strong>栈段向下扩展，数据段向上扩展</strong> 。</li><li>W：是否可写。</li><li>C：指示段是否为特权级依从(Conforming)；C=0 表示非依从的代码段，这样的代码段只能供与它特权级相同的代码段调用，或通过门调用；C=1 表示可依从的代码段，可以被特权级比它低的代码段调用。好奇的同学可提前阅读<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> 。</li><li>R：是否可读。代码段一定可执行，一定不可写。是否可读，取决于 R 。<strong>若 R=1，则可以把此段当作 ROM 使用</strong> 。注意，是否可读是针对于其他代码段而言，而非 CPU ，CPU 不能读，哪还怎么运行。</li><li>A：指示最近是否访问过。创建该描述符时总是置 A 为 0；每当该段被访问，就置此位为 1。<strong>对 A 置 1 由 CPU 负责，置 0 由操作系统负责(创建时除外)，操作系统通过定期监视该位状态来统计该段的使用频率。当内存紧张时，就可以把不经常用的段转移到硬盘中，从而实现虚拟内存管理。</strong></li></ul><p><strong>当 S=0 时</strong> ：<br><img src="/2022/img/IMG_0502(20221101-114007).PNG" style="zoom: 67%;" /></p></li></ul><p>段描述符一共占 8 字节，每个段在使用之前都必须用段描述符“注册登记”。现代计算机都是多任务系统，所以会同时存在多个段，这些段描述符会被集中存放在内存中，这片集中存放的区域就构成了一个描述符表。</p><h3 id="font-color-red-描述符高速缓存器-font"><font color='red'>描述符高速缓存器</font></h3><p>8086 CPU中，访问内存时，会先将段寄存器中的值左移四位，再和 IP 的值相加，得到物理地址。<u>在 32 位 CPU 的实模式下</u>，获取物理段地址的方式得到了优化：当引用一个段时，先将 CS 的中左移四位得到物理段地址，然后将该值放入 <strong>描述符高速缓存器</strong> 。此后就一直使用该缓冲器中的值，直到该段寄存器被重新赋值。这样一来，就省去了左移四位的时间，进一步提高了 CPU 访问内存的效率。<strong><font color='orange'>注意，在实模式下，缓存器仅低 20 位有效，其他位全部为 0</font></strong> 。<u>在保护模式下</u>，当引用一个段时，段描述符中的内容会被<u>整理好</u>后存入缓存器，之后 CPU 访问内存时直接使用缓存器，直到该段寄存器被重新赋值。也就是说，<strong>在 32 位 CPU 下，实模式和保护模式都能够使用描述符高速缓存器</strong> ，只是细节上略有差别。</p><blockquote><p>整理的结果包括：1）结合零散的段界限和段基址；2）粒度*段界限，得到真实的段界限。</p></blockquote><p><strong>描述符高速缓存器是 32 位 CPU 中<u>段寄存器的扩展部分</u>，用来“整齐”存放段基址和段界限以及段属性。描述符高速缓存器是不可见的，由 CPU 内部使用</strong> ，其结构如下：<br><img src="/2022/img/IMG_0506(20221101-172536).PNG" alt=""><br>可见，80386 后的处理器将段描述符整理进缓冲器前，都事先将粒度(G位)乘以段界限(20位)得到真实的段界限(32位)，再存入缓存器。</p><p><strong><font color='orange'>再次强调，32 位 CPU 下，每个段寄存器都具有一个描述符高速缓存器。</font></strong> 其实准确来说，32 位 CPU 的段寄存器分为 16 位可见部分和不可见部分，不可见部分就是描述符高速缓存器，具体位数随 cpu 型号而变。</p><h3 id="font-color-red-全局描述符表GDT-font"><font color='red'>全局描述符表GDT</font></h3><p>全局描述符（Global Descriptor Table，<strong>GDT</strong> ）为整个软硬件系统服务。<strong><font color='orange'>进入保护模式前，必须定义全局描述符表</font></strong> 。<strong>GDT 可以存放在内存的任意位置</strong> ，为了定位 GDT，CPU 内部有一个全局描述符寄存器（ <strong>GDTR</strong> ），该寄存器为 48 位，其结构如下：<br><img src="/2022/img/2未命名绘图.png" alt=""  /><br>基地址部分保存的是 GDT 在内存中的起始地址，边界在数值上等于 GDT 的大小减 1 ，换句话说，边界的值就是表内最后一字节相对于基地址的偏移量。<strong>表最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> ，每个段描述符大小为 8 字节，故 GDT 最多能够装下 8192 个段描述符</strong> 。</p><p>GDT 可以在内存中的任何位置，但由于必须在进入保护模式之前定义 GDT ，而实模式下最多能访问 1MB 内存，所以一般将 GDT 定义在 1MB 以内的地址中。可以在进入保护模式后移动 GDT 的位置，但需要重新加载 GDTR 。</p><p><strong><font color='orange'>使用指令 <code>lgdt</code> (load gdt)将 GDT 的信息加载进 GDTR</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt  gdt_ptr</span><br></pre></td></tr></table></figure><p><code>gdt_ptr</code> 是标号，代表 GDT 所在的地址，<strong>指向一个包含了 48 位的内存区域。该区域的高 32 位必须为 GDT 的基地址，低 16 位为边界</strong> 。该指令在实模式和保护模式下都能够使用。</p><p>注意，<strong><font color='orange'>GDT 中第 0 个描述符不可用</font></strong> ，这是因为，如果使用的段选择子未经初始化，其值就为零，这便会访问到第 0 个段描述符继而处理器发生异常。这样就避免了忘记初始化而直接使用段选择子。</p><h3 id="font-color-red-段选择子-font"><font color='red'>段选择子</font></h3><p>我们已经知道，在保护模式下，段寄存器中装的不再是段基址，而是段选择子。段选择子索引到 GDT 表中的段描述符，然后 CPU 通过段描述符获得真实的段基址和偏址，从而进行段访问。段选择子结构如下：<br><img src="/2022/img/3未命名绘图.png" style="zoom: 67%;" /></p><ul><li><p>描述符索引：占高 13 位，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup><mo>=</mo><mn>8192</mn></mrow><annotation encoding="application/x-tex">2^{13}=8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8192</span></span></span></span> ，和 GDT 能容纳的最多描述符个数相对应。<code>索引值×8+GDT基地址</code> 就能够定位到 GDT 中的表项。</p></li><li><p>TI：Table Indicator，描述符表指示器。TI=0 时，表示描述符在 GDT 中；TI=1 时，表示描述符在 LDT 。一般设置为 0 即可。</p></li><li><p>RPL：Request Privilege Leve，请求特权级。</p><blockquote><p>RPL，RCL，RDL 的区别？</p></blockquote></li></ul><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p>用一张图来总结以上四者的关系：<br><img src="/2022/img/4未命名绘图.png" style="zoom:67%;" /></p><h3 id="font-color-red-关于-G-位和-D-B-位的疑惑-font"><font color='red'>关于 G 位和 D/B 位的疑惑</font></h3><p>前面说过，D/B 位为 0 时，表明该段模拟 16 位保护模式，段最大为 64KB 。但描述符中是 20 位段界限，即使粒度为 1 字节，最大段界限也能达到 1MB 。那么，CPU是否允许在 D/B 为 0 时，20 位段界限全部有效？或者，仅允许 16 位段界限有效（这似乎很好解释了为什么描述符中的段界限是断开的两部分）？粒度是否能为 4KB？</p><blockquote><p>文章参考：《操作系统真相还原》《x86汇编语言：从实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位保护模式概览</title>
      <link href="/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/"/>
      <url>/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li>基本工作模式</li><li>线性地址</li><li>寄存器扩展</li><li>寻址扩展</li><li>模式反转</li><li>指令扩展</li><li>全局描述符表、特权级、分页等</li></ul><h3 id="font-color-red-基本工作模式-font"><font color='red'>基本工作模式</font></h3><p>Intel 32 位处理器架构简称 IA-32，尽管 8086 是 16 位的处理器，但它也是 32 位架构内的一部分。<strong>16 位到 32 位，不单单是地址线和数据线的扩展</strong> ，实际上还有更多的部分，包括高速缓存、流水线、浮点处理部件、多处理器（核）管理、多媒体扩展、乱序执行、分支预测、虚拟化、温度和电源管理等。</p><p>80286 首次提出保护模式的概念。<strong>80286 的地址线扩充到 24 位，能够访问 16 MB的内存，但即使这样</strong> ，<strong><font color='gree'>其仍然遵守内存分段模型，即使用 [段地址+偏址] 方式来访问内存，这是<u>整个 IA-32 的基因</u></font></strong> 。在保护模式下，<strong><font color='orange'>段寄存器中存放的不再是段地址，而是段选择子，段选择子映射到段描述符，段描述符中记录了段基址和段界限以及各种权限</font>。</strong> 同时，<strong><font color='orange'>访问内存也不再需要将段地址向左移动四位，而是直接将段地址和偏移地址相加</font></strong> 。这样一来，段地址就无须位于 16 字节对齐的地方，而可以在 16 MB内存的任何角落。<strong>然而，80286 的偏移地址仍被限制在 64KB</strong> ，对段长度的限制阻碍了 80286 的应用，这是其最大的败笔。</p><blockquote><p>虽然段地址可以不在 16 字节对齐的地方，但对齐有利于提高 CPU 寻址的效率。实际操作时，仍然会对齐。</p></blockquote><p>80386 是划时代的，它的地址线和寄存器扩充到了 32 位，能够访问 4GB 的内存，其偏移地址也能达到 4GB！<strong>但如前文所说，分段是 IA-32 的基因，80386 也使用 [段地址+偏址] 方式来访问内存</strong> 。在 32 位模式下，处理器要求在加载程序时，先定义该程序所拥有的段(段描述符)，然后才允许使用这些段。定义段时，除了基地址外，还附加了段界限、特权级别、类型等属性，当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。80386 及其后续的 32 位处理器都兼容实模式，<u>而且在刚加电启动时，这些处理器都位于实模式下，只有经过一番设置后才会进入保护模式</u> 。</p><p>需要强调的是，<strong><font color='orange'>实模式并不是说 32 位的 CPU 退化成了 16 位的 CPU，即使是在实模式下，其也能够使用 32 位 CPU 的资源</font></strong> 。也就是说，32 位 CPU 在 16 位实模式下，其本质仍然是 32 位 CPU，仍具备操作 32 位寄存器和 32 位操作数的能力！另外，<u>不存在 32 位实模式</u>（只能说32位 CPU 下的实模式）。</p><blockquote><p>可以这么说：实模式一般指 8086 工作模式，而 32 位 CPU 的实模式是 8086 工作模式的扩展。</p></blockquote><h3 id="font-color-red-线性地址-font"><font color='red'>线性地址</font></h3><p>IA-32 支持多任务，在多任务环境下，操作系统会给每个任务分配内存空间。在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。<strong>时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务</strong>。为了解决这个问题，IA-32 处理器支持分页功能， 分页功能将物理内存空间划分成逻辑上的页。<strong>页的大小是固定的，一般为 4KB，通过使用页，可以 简化内存管理</strong> 。当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（Linear  Address），线性地址还要经页部件转换后，才是物理地址。</p><p>段的管理是由处理器的段部件负责进行的，段部件将段地址和偏移地址相加，得到访问内存的地址。<strong><font color='orange'>不开启分页时，段部件产生的地址就是物理地址</font></strong> 。<strong><font color='orange'>当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（Linear  Address），线性地址还要经页部件转换后，才是物理地址</font></strong> 。</p><p>注意，<strong>线性地址是用来<font color='orange'>描述任务的地址空间</font>的一种概念</strong> ，IA-32 处理器上的<strong>每个任务都拥有 4GB 的虚拟内存空间</strong> ，这是一段长 4GB 的平坦空间（平坦模型），就像一段平直的线段，因此叫线性地址空间。详细内容将在后续博客中讨论。</p><blockquote><p><strong><font color='gree'>平坦模型一定在分页机制下运行，分页机制是内存平坦模型的基础</font></strong> 。</p></blockquote><h3 id="font-color-red-寄存器扩展-font"><font color='red'>寄存器扩展</font></h3><ol><li>16 位下的 8 个通用寄存器被扩展到 32 位：eax，ebx，ecx，edx，esp，ebp，edi，esi；就如前文所说，即使在实模式下也可以使用这些 32 位寄存器。注意：1）指令的源操作数和目的操作数必须有相同的长度；2）<strong>32 位通用寄存器的高 16 位不可独立使用</strong> ，低 16 位保持对 16 位处理器的兼容。</li><li>标志寄存器 FLAGS 由 16 位扩展到 32 位 EFLAGS，低 16 位与之前保持一致，见汇编入门一文；高 16 位将在后续文章阐述。</li><li>段寄存器仍为 16 位，但其中不再存放段基址，而是存放 16 位的段选择子。<strong>增添了两个新段寄存器：FS，GS</strong> 。</li><li><strong>每个段寄存器都包含一个 64 位的不可见部分，称为描述符高速缓存寄存器</strong> ，其中装着被整理后的段描述符。引入该寄存器的原因是：1）段描述符在内存中，获取较慢；2）段描述符中，段基址被分成 3 部分，段界限被分成两部分，CPU 无法直接使用，需要整理放入寄存器后才能供CPU使用。</li></ol><h3 id="font-color-red-寻址扩展-font"><font color='red'>寻址扩展</font></h3><p>实模式的内存寻址方式：<br><img src="/2022/img/IMG_0496(20221031-144326).PNG" style="zoom: 50%;" /><br>32 位 CPU 的寻址方式：<br><img src="/2022/img/IMG_0497(20221031-144451).PNG" style="zoom:50%;" /></p><p>可见，32 位保护模式允许所有通用寄存器作为 <strong>基址寄存器</strong> ，除 ESP 之外的所有通用寄存器也可以作为 <strong>变址寄存器</strong> ，同时变址寄存器还能够乘上固定的比例因子。注意，<u>实模式下不能使用 SP 作为基址寄存器，而 32 位保护模式下可以使用 ESP 作为基址寄存器</u> 。</p><h3 id="font-color-red-模式反转-font"><font color='red'>模式反转</font></h3><p>IA-32 的指令格式：</p><table><thead><tr><th>前缀</th><th>操作码</th><th>寻址方式和操作类型</th><th>立即数</th><th>偏移量</th></tr></thead></table><p>以上格式起源于 16 位处理器，32 位处理器在此基础上扩展了数据的宽度，其他基本保持不变。虽然 32 位采用的是和 16 位相同的指令格式，<strong>但寻址方式和寄存器的定义却是另起炉灶的</strong> 。考虑如下机器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8B 50 02</span><br></pre></td></tr></table></figure><p>其对应的 16 位指令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dx,[bx+si+0x02]</span><br></pre></td></tr></table></figure><p>其对应的 32 位指令位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,[eax+0x02]</span><br></pre></td></tr></table></figure><p>所以说，<strong><font color='orange'>相同的机器代码在两种模式下可能对应着不同的指令</font></strong> 。而我们在前文中已经反复强调，在32位 CPU 的实模式中仍然可以使用 32 位寄存器，那么问题来了，对于机器代码 <code>8B 50 02</code> ，CPU 怎么知道将它翻译成 16 位指令还是 32 位指令呢？为解决此问题，编写程序时必须使用 bits 关键字指定运行环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#有无[]都可</span><br><span class="line">bits 16</span><br><span class="line">[bits 16]</span><br><span class="line">bits 32</span><br><span class="line">[bits 32]</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>如果不指定，则默认为 [bits 16]</font></strong>  。指定环境后，如果某条指令在 A 模式下使用了 B 模式下的寄存器，则该指令的机器码就会加上前缀 <code>0x66</code> ，来临时反转当前模式。比如在 16 位模式下，<code>inc ax</code> 的机器码为：<code>0x40</code> ，而 <code>inc eax</code> 的指令则为 <code>66 40</code> 。因此，<strong>前缀 <code>0x66</code> 具有临时反转当前模式的作用</strong> 。</p><p>值得一提的是，<strong><font color='orange'>对于 <code>mov 段寄存器,通用寄存器</code> 这样的指令，在 16 位和 32 位模式下的机器码完全相同</font></strong>。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">mov ds,ax</span><br><span class="line">[bits 32]</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>这两条指令的机器码都为 <code>8E D8</code> 。为什么这样设计？因为有前缀会使处理器多花一个时钟来处理，而这样的指令很频繁，而且牵涉到内存段的访问，所以也很重要，因此它们被设计得相同。</p><h3 id="font-color-red-指令扩展-font"><font color='red'>指令扩展</font></h3><ul><li><p>对于 shl，shr 指令，在实模式下使用 cl 寄存器存储移动的位数，在 32 位保护模式下同样如此。</p></li><li><p><code>mul bx</code> ，实模式下，另一个乘数在 ax 中，积的高位放在 dx 中，低位放在 ax 中。在 32 位下，<u>积直接放在 eax 中</u>。<br><code>mul ebx</code> ，另一个乘数放在 eax 中，积的高位放在 edx，低位放在 eax 中。<br><code>div bx</code> ，实模式下，被除数高位在 dx 中，低位在 ax 中，商存放在 ax，余数放在 dx 中。<u>32 位下相同</u>。<br><code>div ebx</code> ，被除数高位放在 edx，低位放在 eax，商放在 eax，余数放在 edx。</p></li><li><p>对于 push 指令：</p><ul><li><p>立即数：<br>无论是实模式还是保护模式，压入 16 位，则栈指针减 2；压入 32 位，则栈指针减 4 。<strong>压入 8 位数据则按当前模式默认大小压入</strong> ，见下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#实模式下：</span><br><span class="line">push byte  0x1  #sp-=2</span><br><span class="line">push word  0x1  #sp-=2</span><br><span class="line">push dword 0x1  #sp-=4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#保护模式下：</span><br><span class="line">push byte  0x1  #esp-=4</span><br><span class="line">push word  0x1  #esp-=2</span><br><span class="line">push dword 0x1  #esp-=4</span><br></pre></td></tr></table></figure></li><li><p>段寄存器：<br>按当前模式的默认操作数大小压入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#实模式下：</span><br><span class="line">push es #sp-=2</span><br><span class="line">#保护模式下：</span><br><span class="line">push es #sp-=4</span><br></pre></td></tr></table></figure></li><li><p>通用寄存器和内存：</p><p>无论在保护模式还是实模式，如果压入 16 位，则栈指针减 2；如果压入 32 位，则栈指针减 4；</p></li></ul></li></ul><p>保护模式的其他特性如全局描述符表、特权级、分页等内容较多，也是保护模式的精髓，后续将单独记录。</p><blockquote><p>文章参考：《操作系统真相还原》《x86实模式到保护模式》<a href="https://blog.csdn.net/Zheng__Huang/article/details/122494192">分段、分页和平坦模型</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理器微架构</title>
      <link href="/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-流水线-font"><font color='red'>流水线</font></h3><p>CPU 流水线技术 (pipeline) 是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令<strong>并行处理</strong> ，以加速程序运行过程的技术。采用流水线技术后，并没有加速单条指令的执行，每条指令的操作步骤一个也不能少，<strong>只是多条指令的不同操作步骤同时执行</strong> ，因而从总体上加快了指令流速度，缩短了程序执行时间。</p><p>比如，假设执行一条指令需要经过如下步骤：1）取指令；2）译码；3）执行。如果按 <strong><font color='orange'>串行</font></strong> 方式来运行指令，如下：<br><img src="/2022/img/IMG_0489(20221030-190533).PNG" style="zoom:67%;" /></p><p>可见，每执行一个指令，就需要 3 个时钟。要知道，<strong>完成各个操作的单元是相互独立的、<font color='orange'>并行</font>的</strong> ，译码时，取指令单元就处于等待中；执行时，取指令单元和译码单元就处于空闲。所以，要想加快 CPU 执行速度，就不能让这些单元处于空闲，要让它们忙起来。流水线工作方式就是让这些单元并行，如下：<br><img src="/2022/img/IMG_0490(20221030-191339).PNG" style="zoom:67%;" /></p><p>以上是一个简单的三级流水线，而奔腾 CPU 可是达到了惊人的 32 级流水线，这是怎么做到的呢？很简单，就是 <strong><font color='orange'>不断地细分这些操作，让更多的微操作并行处理</font></strong> 。显然，流水线级数越多，每级所花的时间越短，时钟周期就越短，指令速度越快，指令平均执行时间也就越短。</p><blockquote><p>实际上，现代处理器的流水线操作可不止以上三个，还包括：写回执行结果、寄存器分配、重命名、微操作排序、引退等。</p></blockquote><p>需要注意的是，<strong>CPU 是按<u>内存中</u>指令的顺序来填充流水线的</strong> ，当前指令和下一条指令在空间上是紧挨着的。如果当前执行的指令是 jmp，那么下一条指令已经被送上流水线译码，下下条指令已经被送上流水线取指，但问题是，jmp 后就不会执行这些指令，而是跑到其他地方执行另外的指令了，所以当前流水线就废了。所以，<strong><font color='orange'>当 CPU 遇上 jmp 指令时，就会清空流水线</font></strong> 。</p><blockquote><p><strong><font color='gree'>串行、并行：</font></strong><br><strong>并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，<u>异步是多个任务并行的前提条件</u>。</strong></p></blockquote><h3 id="font-color-red-分支预测-font"><font color='red'>分支预测</font></h3><p>当程序出现分支（if, switch）将不利于过深流水线，整条流水线可能将会无效化。<strong><font color='orange'>流水线越长，处理器在用错误的分支填充流水线时，浪费的时间越多</font></strong> 。为了缓解这个问题，1996 年的 Pentium Pro 处理器引入了分支预测技术。分支预测的核心问题就是预测某个转移条件是否成立。当然，之所以叫预测，是因为不能百分百地判断是否一定发生跳转。但从统计学的角度上来看，某些事情一旦发生，下次发生该事件的概率就比较大，一个典型例子便是循环：<code>for(int i=0;i&lt;10;i++)</code> ，i 第一次小于 10，其后 9 次都小于 10 ，这种情况就能够较为精准地预测。<br><strong>在处理器内部有一个分支预测部件，即 BTB (Branch Target Buffer)</strong>  。BTB 中记录着分支指令地址，当 CPU 遇到分支时，先用该分支地址在 BTB 中查找，如果找到相同地址的指令，则根据跳转统计信息判断是否把相应预测分支搬上流水线。如果预测失败，则清空流水线，刷新 BTB，这个代价较大。</p><h3 id="font-color-red-乱序执行-font"><font color='red'>乱序执行</font></h3><p>乱序执行（out-of-order execution）是指 CPU 采用的允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。在这种方式下，可以避免因为获取下一条程序指令所引起的处理器等待，取而代之地处理下下条可以立即执行的指令。当然，<strong><font color='orange'>这种方式必须保证指令之间不具备相关性</font></strong> 。比如，如下两行代码就不能乱序执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[10]</span><br><span class="line">mov bx,ax</span><br></pre></td></tr></table></figure><p>而如下三行代码则可以乱序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[10]</span><br><span class="line">mov dx,ax</span><br><span class="line">mov bx,cx</span><br></pre></td></tr></table></figure><p>显然，第 3 行代码和第 1、2 行无关，所以可以在第一行代码访问 [10] 内存时(较慢)，将 cx 赋值给 bx 。</p><p>可见，指令之间越不相关，就越能够乱序执行。所以当务之急便是提高指令之间的不相干性，如何做到呢？<strong><font color='orange'>同流水线的策略一样，不断细分指令，将其分成由多步组合的微操作</font></strong> 。微操作级别的指令往往具有较低的相关性，比如以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[0x10]</span><br><span class="line">push eax</span><br><span class="line">call func</span><br></pre></td></tr></table></figure><p><code>push eax</code> 可以分为两步操作：1）<code>sub esp,4</code> 2）<code>mov [esp],eax</code> 。第一步访问内存的等待时间较长，所以可在等待时执行 <code>sub esp,4</code> ；而执行完 <code>sub esp,4</code> 后，可以直接执行 <code>call func</code> ，因为此指令只需要知道 esp 的最新位置，并将其减 4，无需知道 eax 的值。所以在访问内存时，CPU 就已经通过乱序执行完成了第二行代码的一部分和第三行代码，这无疑大大地提高了 CPU 的运行效率。</p><h3 id="font-color-red-高速缓存-font"><font color='red'>高速缓存</font></h3><p>高速缓存是用来解决如 CPU 这类高速运行器件与硬件这类低速运转器件的速度不匹配问题。<strong>寄存器速度最快，原因在于它使用的是触发器，其工作速度是纳秒级别</strong> ；而硬盘是机电设备，速度最慢，工作速度一般为毫秒级。因为要等待内存(DRAM)和硬盘这样的慢速设备，CPU 的工作速度就被大大拖慢。为解决这一矛盾，就必须使用一种比内存更快的储存器作为缓冲区，使 CPU 不用等待，直接从缓冲区取走数据。于是，高速缓存应运而生。</p><blockquote><p>内存也可以用触发器实现，即 SRAM，但造价很高，一般容量只有几 MB。</p></blockquote><p>高速缓存是位于 CPU 和内存(DRAM)之间的一个静态储存器(SRAM)。<strong><font color='orange'>高速缓存的用处源于程序运行时的局部性规律</font></strong> 。比如，数据一般是在内存里集中存放的(如数组)，访问某个数据后，下次很可能就会访问临近的数据；一个数据被访问后，也很有可能再次被访问。利用这种局部性原理，可以把处理器正访问的或可能将访问的数据或指令放入高速缓存中。于是，每当 CPU 要访问内存时，就会先检索高速缓存，如果缓存中有相应内容，则可以用极快的速度取走，这称为<u>命中</u> ，反之则<u>不中</u> 。在不中的情况下，<strong>处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容</strong> 。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为<u>不中惩罚</u> 。</p><p>现代处理器一般都有多级缓存：</p><p><img src="/2022/img/20220709092100-1667177627583-3.png" alt="缓存分级"></p><h3 id="font-color-red-寄存器重命名-font"><font color='red'>寄存器重命名</font></h3><p>考虑如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[mem1]</span><br><span class="line">shl eax,3</span><br><span class="line">mov [mem2],eax</span><br><span class="line">mov eax,[mem3]</span><br><span class="line">add eax,2</span><br><span class="line">mov [mem4],eax</span><br></pre></td></tr></table></figure><p>仔细观察这几行代码，可以发现，前三行和后三行做了两件毫不相干的事，即使它们使用了相同的寄存器 eax：前三行执行乘法，后三行执行加法。所以 CPU 会为后三条指令使用另一个不同的临时寄存器来代替 eax，因此乘法和加法就能并行处理！</p><blockquote><p>注意，并不是所有类似的乘法和加法都能并行处理。上述例子的乘法仅通过左移就能实现，不需要用到加法器，而其他大多数乘法需要用到加法器，此时就不能并行处理。</p></blockquote><p>由此可以推测，当给某个寄存器通过 mov 指令赋予新值时，就大概可以判定此时发生了新的不相干事件，此时就能够使用寄存器重命名。当所有操作完成后，那个代表 eax 寄存器最终结果的临时寄存器中的内容将被回写到真实的 eax 寄存器中，这称为 <strong><u>引退</u></strong> 。</p><p>所有通用寄存器甚至段寄存器都有可能被重命名。</p><blockquote><p>文章参考：《操作系统真相还原》《x86实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘基础及其读写</title>
      <link href="/2022/10/30/%E8%AF%BB%E5%86%99%E7%A1%AC%E7%9B%98/"/>
      <url>/2022/10/30/%E8%AF%BB%E5%86%99%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-硬盘组成概述-font"><font color='red'>硬盘组成概述</font></h3><ul><li><strong>盘片</strong></li><li><strong>盘面</strong></li><li><strong>磁头</strong></li><li><strong>磁道</strong></li><li><strong>扇区</strong></li><li><strong>柱面</strong></li></ul><h4 id="font-color-gree-盘片、盘面和磁头-font"><font color='gree'>盘片、盘面和磁头</font></h4><p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，称为盘面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘面的编号和磁头编号相对应，从上到下从零开始，如最上边的盘片有 0 面和 1 面，再下一个盘片就编号为 2 面和 3 面。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。如下图：<br><img src="/2022/img/01.jpg" style="zoom:67%;" /></p><blockquote><ul><li>早期的硬盘不工作的时候，磁头停靠在靠近主轴接触盘片的表面，即线速度最小的地方，这里是一个不存放任何数据的特殊区域，称为启停区或着陆区，启停区以外就是数据区。</li><li>在硬盘的最外圈，离主轴最远的磁道称为 0 磁道，<strong>硬盘数据的存放是从最外圈 0 磁道开始的</strong> 。即硬盘数据从最外圈开始，而停止时磁头又是在最内圈启停区。</li><li>0磁道非常重要，我们知道，系统的引导程序就在 0 柱面 0 磁道 1 扇区的前 446 Bytes，后 64 字节是分区表，最后两字节是结束标志 0x55 和 0xaa。0磁道属于隐藏磁道，这个磁道的 63 个扇区属于隐藏扇区。操作系统的所有命令，除了 FDISK 以外都不能访问它们。就连格式化程序 FORMAT，对它们也无能为力。</li></ul></blockquote><h4 id="font-color-gree-扇区和磁道-font"><font color='gree'>扇区和磁道</font></h4><p>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。<strong>扇区是硬盘的最小读写单元</strong> ，<u>数据容量</u>通常是 512 字节。<strong>每个扇区包括 512 个字节的数据和扇区头</strong> ，扇区头包含本扇区的信息，主要有本扇区的磁道号、磁头号、扇区号，用来供硬盘定位机构使用。<br><img src="/2022/img/03.jpg" alt=""></p><blockquote><p>越靠外的磁道旋转的线速度越快，读取数据的速率也就越快。</p></blockquote><h4 id="font-color-gree-柱面-font"><font color='gree'>柱面</font></h4><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有 <strong>相同编号的磁道形成一个圆柱</strong> ，称之为柱面。硬盘的柱面数与一个盘面上的磁道数是相等的。 如下图：<br><img src="/2022/img/SouthEast.jpeg" alt=""><br><strong>柱面是一个用来优化数据读写的概念</strong> 。需要注意的是，硬盘读写数据是柱面顺序来读的，而不是按磁道顺序来读的。举个例子，磁头读完 0 面 0 磁道后，接着读 1 面 0 磁道，再读 2 面 0 磁道，一直将该柱面读完。我们很容易认为磁头是这样读取数据的：磁头读完 0 面 0 磁道后，接着读 0 面 1 磁道，再读 0 面 2 磁道…为什么按柱面读取数据呢？因为按柱面读取数据就会大大减少寻道时间。参见后文<a href="#%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%8F%96%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4">硬盘读取响应时间</a>。</p><h3 id="font-color-red-硬盘容量计算-font"><font color='red'>硬盘容量计算</font></h3><p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p><blockquote><p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p></blockquote><h3 id="font-color-red-硬盘读取响应时间-font"><font color='red'>硬盘读取响应时间</font></h3><ol><li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前硬盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li><li>旋转延迟：将数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于硬盘转速。普通硬盘一般都是 7200rpm，慢的 5400rpm。</li><li>数据传输时间：完成传输所请求的数据所需要的时间。</li></ol><blockquote><p>读写一次硬盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高硬盘传输效率，应着重考虑减少寻道时间和延迟时间。</p></blockquote><h3 id="font-color-red-硬盘寻址方式-font"><font color='red'>硬盘寻址方式</font></h3><p><strong><mark class="hl-label blue">CHS方式</mark> </strong><br><strong>CHS</strong> (Cylinder/Head/Sector) 方式通过柱面、磁头、扇区来定位。 由于早期硬盘的每个磁道的扇区数一样多（外圈磁颗粒稀疏），整体硬盘空间大小也不大，所以此方式比较高效。但 CHS 模式支持的硬盘容量有限，用 8bit 来存储磁头地址，用 10bit 来存储柱面地址，用 6bit 来存储扇区地址，而一个扇区共有 512 Byte，这样使用 CHS 寻址一块硬盘最大容量为 <code>256 * 1024 * 63 * 512B = 8064 MB</code>（约8.4GB）。<strong><u>CHS 下扇区从 1 开始编号</u></strong> 。</p><p><strong><mark class="hl-label blue">LBA方式</mark> </strong><br>现在很多硬盘采用同密度盘片，意味着内外磁道上的扇区数量不同，扇区数量增加，容量增加，CHS 很难定位寻址，所以 LBA 方式应运而生。在 LBA 地址中，地址不再表示实际硬盘的实际物理地址（柱面、磁头和扇区）。LBA 编址方式将 CHS 这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的物理扇区的 C/H/S 编号通过一定的规则转变为一线性的编号，系统效率得到大大提高，避免了烦琐的磁头/柱面/扇区的寻址方式。在访问硬盘时，由硬盘控制器再将这种逻辑地址转换为实际硬盘的物理地址。<strong><u>LBA 下扇区从 0 开始编号</u></strong> 。</p><h3 id="font-color-red-块-簇-font"><font color='red'>块/簇</font></h3><p>硬盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与硬盘打交道的最小单位是硬盘块。通俗的来讲，在 Windows 下如NTFS 等文件系统中叫做簇；在 Linux 下如 Ext4 等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。<br>为什么存在硬盘块？1）读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。2）分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来硬盘块的概念，在系统中认为块是最小的单位。</p><h3 id="font-color-red-page-font"><font color='red'>page</font></h3><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p><h3 id="font-color-red-扇区、块-簇、page的关系-font"><font color='red'>扇区、块/簇、page的关系</font></h3><ol><li>扇区： 硬盘的最小读写单元</li><li>块/簇： 是操作系统针对硬盘读写的最小单元</li><li>page： 是内存与操作系统之间操作的最小单元。</li></ol><p>扇区 &lt;= 块/簇 &lt;= page</p><h3 id="font-color-red-硬盘预读-font"><font color='red'>硬盘预读</font></h3><p>硬盘存取，硬盘 I/O 涉及机械操作。硬盘是由大小相同且同轴的圆形盘片组成，硬盘可以转动(各个硬盘须同时转动)。硬盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个硬盘的内容。磁头不动，硬盘转动，但磁臂可以前后动，用于读取不同磁道上的数据。磁道就是以盘片为中心划分出来的一系列同心环。磁道又划分为一个个小段，叫扇区，是硬盘的最小存储单元。</p><p>硬盘读取时，系统将数据逻辑地址传给硬盘，硬盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道——寻道，消耗的时间叫——寻道时间，硬盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫——旋转时间，这一系列操作是非常耗时。<br><strong>为了尽量减少I/O操作，计算机系统一般采取预读的方式，预读的长度一般为页（page）的整倍数</strong> 。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和硬盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和硬盘以页为单位交换数据。<strong>当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向硬盘发出读盘信号，硬盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行</strong> 。<br>计算机系统是分页读取和存储的，一般一页为4KB（8个扇区，每个扇区125B，8*125B=4KB），每次读取和存取的最小单元为一页，而硬盘预读时通常会读取页的整倍数。根据局部性原理，程序运行期间所需要的数据通常比较集中，当一个数据被用到时，其附近的数据也通常会马上被使用。由于硬盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），所以即使只需要读取一个字节，硬盘也会读取一页的数据。</p><h3 id="font-color-red-磁盘碎片-font"><font color='red'>磁盘碎片</font></h3><p>文件系统碎片是文件系统将文件内容非连续排列以方便就地修改其内容的结果。<strong>磁盘碎片会增加磁盘磁头移动频率，即增加了寻道时间，会降低磁盘读写性能，进而影响操作系统操作系统及软件性能</strong> 。另外，文件系统不能承受无限制的碎片。对现有碎片的更正称为碎片重组，是将文件和可用空间重新组织为连续区域的过程。<br><img src="/2022/img/1373708-20181204140705426-1630212745.png"  /><br><strong>需要注意的是，固态磁盘(SSD)不是真正的磁盘，也不是“旋转的”，所以没有文件碎片问题</strong> 。</p><h3 id="font-color-red-Linux-下读写硬盘-font"><font color='red'>Linux 下读写硬盘</font></h3><ol><li><p><strong>创建硬盘</strong> ：利用 Bochs 的 bximg bool 创建硬盘，在 bochs 文件夹下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat ./build/hd.img</span><br></pre></td></tr></table></figure><p>参数解释：<br><code>-q</code> ：以静默模式创建，不会和用户交互<br><code>-hd</code> ：创建硬盘，<code>-fd</code> 创建软盘；后面的 16 笔者也不太清楚。<br><code>-func=create</code> ：表明创建硬盘。<br><code>-imgmode</code> ：硬盘类型，有 flat，sparse，growing 三种。<br><code>-secsize</code> ：硬盘大小，以 MB 为单位。<br><code>./build/hd.img</code> ：为硬盘位置及其名称。<br><strong>也可以直接输入 bximage 然后一步一步按提示创建。</strong></p></li><li><p><strong>写入硬盘</strong> ：使用 LInux 的 dd 命令写入硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./app.bin of=./hd.img bs=512 seek=100 conv=notrunc</span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>if=文件名</td><td>输入文件名，默认为标准输入。即指定源文件。</td></tr><tr><td>of=文件名</td><td>输出文件名，默认为标准输出。即指定目的文件。</td></tr><tr><td>ibs=bytes</td><td>一次读入bytes个字节，即指定一个块大小为bytes个字节。</td></tr><tr><td>obs=bytes</td><td>一次输出bytes个字节，即指定一个块大小为bytes个字节。</td></tr><tr><td>bs=bytes</td><td>同时设置读入/输出的块大小为bytes个字节。</td></tr><tr><td>cbs=bytes</td><td>一次转换bytes个字节，即指定转换缓冲区大小。</td></tr><tr><td>skip=blocks</td><td>从输入文件开头跳过blocks个块后再开始复制。</td></tr><tr><td>seek=blocks</td><td>从输出文件(硬盘)开头跳过blocks个块后再开始复制。</td></tr><tr><td>count=blocks</td><td>仅拷贝blocks个块，块大小等于ibs指定的字节数。</td></tr><tr><td>conv=&lt;关键字&gt;</td><td>关键字可以有 11 种，通常用 notrunc 就行。</td></tr></tbody></table></li></ol><blockquote><p>文章参考<a href="https://www.cnblogs.com/whl320124/articles/10063813.html">硬盘详解</a>，<a href="http://www.daileinote.com/computer/sys_about/01">硬盘介绍</a> ，<a href="https://blog.csdn.net/xd_1437/article/details/103253632">硬盘介绍</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bochs虚拟机的使用</title>
      <link href="/2022/10/27/bochs%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/27/bochs%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-bochs简介-font"><font color='red'>bochs简介</font></h3><p>bochs 是一个虚拟机（模拟器），能够完整的模拟一台计算机。详细来讲 bochs 是 X86 硬件平台的开源模拟器，完全可以通过软件来给我们提供各种所需的硬件资源。和 bochs 类似的虚拟机软件还有我们常用的 VMware、Virtuabox，但区别也是明显的。bochs 是完全依靠软件来模拟整个环境的：从启动到重启包括 PC 的外设键盘、鼠标、磁盘以及网卡等，全部都是由软件来模拟的，而其余软件则不然(部分依赖于硬件)。也就是说，bochs 可以从头到尾模拟整个硬件环境。它可以从PC机刚启动的那一刹那起就开始模拟。同时，bochs 带有强大的调试功，能够直接单步调试二进制文件，我们可以看到二进制代码在硬件上运行的每一步！<strong>后面咋们的操作系统都将由 bochs 运行</strong> 。</p><h3 id="font-color-red-bochs安装与配置-font"><font color='red'>bochs安装与配置</font></h3><blockquote><p>本自制操作系统笔记系列都在 Ubuntu 下进行，关于 Bochs 在 Windows 下的使用，可参考 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 一文末尾。</p></blockquote><ol><li><p>前往 <a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/">bochs官网</a> 下载 2.7 版本：<code>bochs-2.7.tar.gz</code> 。必须为 2.7 版本，后面的 bochs 配置仅对此版本有效。</p></li><li><p>安装依赖：解压后进入 bochs-2.7 目录，在终端执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx11-dev libc6-dev build-essential xorg-dev libgtk2.0-dev libreadline-dev</span><br></pre></td></tr></table></figure></li><li><p>生成配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-debugger-gui --enable-x86-debugger --enable-a20-pin --enable-fast-function-calls --enable-debugger</span><br></pre></td></tr></table></figure></li><li><p>编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>安装完毕，但此时 bochs 还只是一台裸机，无法运行。</p></li><li><p>bochsrc 配置：<br>在 bochs 目录中创建 bochsrc，写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: unmapped=<span class="literal">true</span>, biosdev=<span class="literal">true</span>, speaker=<span class="literal">true</span>, extfpuirq=<span class="literal">true</span>, parallel=<span class="literal">true</span>, serial=<span class="literal">true</span></span><br><span class="line">config_interface: textconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># display_library: x</span></span><br><span class="line"><span class="comment"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两个一起开启</span></span><br><span class="line"><span class="comment">#魔术断点：</span></span><br><span class="line">magic_break: enabled=1 </span><br><span class="line"><span class="comment">#gui调试</span></span><br><span class="line">display_library: x, options=<span class="string">&quot;gui_debug&quot;</span></span><br><span class="line"></span><br><span class="line">memory: host=32, guest=32</span><br><span class="line">romimage: file=<span class="string">&quot;/usr/local/share/bochs/BIOS-bochs-latest&quot;</span>, address=0x00000000, options=none</span><br><span class="line">vgaromimage: file=<span class="string">&quot;/usr/local/share/bochs/VGABIOS-lgpl-latest&quot;</span></span><br><span class="line">boot: disk</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"><span class="comment"># no floppya</span></span><br><span class="line">floppya: image=<span class="string">&quot;a.img&quot;</span>, status=inserted</span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=<span class="literal">true</span>, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/hd.img&quot;</span>, mode=flat</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=<span class="literal">true</span>, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=<span class="literal">false</span></span><br><span class="line">ata3: enabled=<span class="literal">false</span></span><br><span class="line">optromimage1: file=none</span><br><span class="line">optromimage2: file=none</span><br><span class="line">optromimage3: file=none</span><br><span class="line">optromimage4: file=none</span><br><span class="line">optramimage1: file=none</span><br><span class="line">optramimage2: file=none</span><br><span class="line">optramimage3: file=none</span><br><span class="line">optramimage4: file=none</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">vga: extension=vbe, update_freq=5, realtime=1</span><br><span class="line">cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0</span><br><span class="line">cpuid: level=6, stepping=3, model=3, family=6, vendor_string=<span class="string">&quot;GenuineIntel&quot;</span>, brand_string=<span class="string">&quot;              Intel(R) Pentium(R) 4 CPU        &quot;</span></span><br><span class="line">cpuid: mmx=<span class="literal">true</span>, apic=xapic, simd=sse2, sse4a=<span class="literal">false</span>, misaligned_sse=<span class="literal">false</span>, sep=<span class="literal">true</span></span><br><span class="line">cpuid: movbe=<span class="literal">false</span>, adx=<span class="literal">false</span>, aes=<span class="literal">false</span>, sha=<span class="literal">false</span>, xsave=<span class="literal">false</span>, xsaveopt=<span class="literal">false</span>, smep=<span class="literal">false</span></span><br><span class="line">cpuid: smap=<span class="literal">false</span>, mwait=<span class="literal">true</span></span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line"><span class="comment"># no gdb stub</span></span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">private_colormap: enabled=0</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment"># no cmosimage</span></span><br><span class="line"><span class="built_in">log</span>: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: action=ignore</span><br><span class="line">info: action=report</span><br><span class="line">error: action=report</span><br><span class="line">panic: action=ask</span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2, enabled=<span class="literal">false</span>, toggle=ctrl+mbutton</span><br><span class="line">speaker: enabled=<span class="literal">true</span>, mode=system</span><br><span class="line">parport1: enabled=<span class="literal">true</span>, file=none</span><br><span class="line">parport2: enabled=<span class="literal">false</span></span><br><span class="line">com1: enabled=<span class="literal">true</span>, mode=null</span><br><span class="line">com2: enabled=<span class="literal">false</span></span><br><span class="line">com3: enabled=<span class="literal">false</span></span><br><span class="line">com4: enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>接下来就需要创建硬盘，并写入 mbr 使其运行起来。详细内容参见：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>文末。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解函数调用过程和约定\extern c</title>
      <link href="/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/"/>
      <url>/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文涉及汇编知识，没有基础的朋友请移步<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。<br>本文参考：<a href="https://blog.csdn.net/doubleintfloat/article/details/78522881">为什么用0xcc初始化内存</a> ，<a href="https://blog.csdn.net/sap_jack/article/details/1041220">C/C++函数调用约定与函数名称修饰规则</a></p></blockquote><h3 id="font-color-red-函数执行流-font"><font color='red'>函数执行流</font></h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR开辟栈帧 --&gt; 分配栈内存 --&gt; 保存现场 --&gt; 代码逻辑 --&gt; 恢复现场 --&gt; 恢复栈帧  </pre></div><blockquote><p><strong>栈帧本质上是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）</strong></p></blockquote><p>我们使用 VS 反汇编以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">00041DB0  push        ebp               ;保存原函数栈底</span><br><span class="line">00041DB1  mov         ebp,esp           ;ebp指向新栈底</span><br><span class="line">00041DB3  sub         esp,0E4h          ;开辟栈帧，大小为0x0E4H</span><br><span class="line">00041DB9  push        ebx               ;6,7,8行保存现场</span><br><span class="line">00041DBA  push        esi  </span><br><span class="line">00041DBB  push        edi  </span><br><span class="line">00041DBC  lea         edi,[ebp-24h]     ;将起始地址ebp-24h填入edi</span><br><span class="line">00041DBF  mov         ecx,9             ;重复stos的次数</span><br><span class="line">00041DC4  mov         eax,0CCCCCCCCh    ;内存初始值设置为0xCCCCCCCC</span><br><span class="line">00041DC9  rep stos    dword ptr es:[edi];开始初始化内存</span><br><span class="line"></span><br><span class="line">;---------------------------------忽略以下两行代码，vs增加的调试指令</span><br><span class="line">00041DCB  mov         ecx,offset _206B94B3_源@c (01AB000h)  </span><br><span class="line">00041DD0  call        @__CheckForDebuggerJustMyCode@4 (041307h)  </span><br><span class="line">;--------------------------------------------------------------</span><br><span class="line">int a = 1;</span><br><span class="line">00041DD5  mov         dword ptr [a],1   ;a是vs转换后的结果,方便我们查看,实际上a为[ebp-8]</span><br><span class="line">int b = 2;</span><br><span class="line">00041DDC  mov         dword ptr [b],2   ;实际上b为[ebp-14h]</span><br><span class="line">int c = add(1, 2);</span><br><span class="line">00041DE3  push        2                 ;压入形参</span><br><span class="line">00041DE5  push        1  </span><br><span class="line">00041DE7  call        _add (04139Dh)    </span><br><span class="line">00041DEC  add         esp,8             ;外平栈</span><br><span class="line">00041DEF  mov         dword ptr [c],eax ;将返回值赋值给c,c实际为[ebp-20h]</span><br><span class="line">return 0;</span><br><span class="line">00041DF2  xor         eax,eax           ;返回值为0</span><br><span class="line">&#125;</span><br><span class="line">000A17E4  pop         edi  </span><br><span class="line">000A17E5  pop         esi  </span><br><span class="line">000A17E6  pop         ebx  </span><br><span class="line">000A17E7  add         esp,0E4h  </span><br><span class="line">000A17ED  cmp         ebp,esp  </span><br><span class="line">000A17EF  call        __RTC_CheckEsp (0A1235h)  </span><br><span class="line">000A17F4  mov         esp,ebp  </span><br><span class="line">000A17F6  pop         ebp  </span><br><span class="line">000A17F7  ret  </span><br><span class="line">;=============================================================</span><br><span class="line">int add(int a, int b)                   ;与上类似，不再注释</span><br><span class="line">&#123;</span><br><span class="line">00FB1750  push        ebp  </span><br><span class="line">00FB1751  mov         ebp,esp  </span><br><span class="line">00FB1753  sub         esp,0C0h  </span><br><span class="line">00FB1759  push        ebx  </span><br><span class="line">00FB175A  push        esi  </span><br><span class="line">00FB175B  push        edi  </span><br><span class="line">00FB175C  mov         edi,ebp  </span><br><span class="line">00FB175E  xor         ecx,ecx  </span><br><span class="line">00FB1760  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FB1765  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FB1767  mov         ecx,offset _206B94B3_源@c (0FBC000h)  </span><br><span class="line">00FB176C  call        @__CheckForDebuggerJustMyCode@4 (0FB130Ch)  </span><br><span class="line">return a + b;</span><br><span class="line">00FB1771  mov         eax,dword ptr [a]  ;[ebp+8]</span><br><span class="line">00FB1774  add         eax,dword ptr [b]  ;[ebp+0Ch]</span><br><span class="line">&#125;</span><br><span class="line">00FB1777  pop         edi  </span><br><span class="line">00FB1778  pop         esi  </span><br><span class="line">00FB1779  pop         ebx  </span><br><span class="line">00FB177A  add         esp,0C0h  </span><br><span class="line">00FB1780  cmp         ebp,esp  </span><br><span class="line">00FB1782  call        __RTC_CheckEsp (0FB1235h)  ;上行和本行，检查堆栈平衡(ebp==esp)</span><br><span class="line">00FB1787  mov         esp,ebp  </span><br><span class="line">00FB1789  pop         ebp  </span><br><span class="line">00FB178A  ret  </span><br></pre></td></tr></table></figure><p>分析：</p><ol><li><p>虽然开辟了 0xe4 的空间，但仅初始化了 0x24 个字节的内存。</p></li><li><p>为什么要用 0xcc 初始化内存？</p><blockquote><p>x86系列处理器从其第一代产品英特尔8086开始就提供了一条专门用来支持调试的指令，即 INT 3,其机器码就是我们熟悉的0XCC，转换成十进制为-858993460，转换成汉字就是“烫”。简单地说，这条指令的目的就是使CPU中断（break）到调试器，以供调试者对执行现场进行各种分析。<strong>如果因为缓冲区或堆栈溢出时程序指针意外指向了这些区域，那么便会因为遇到INT 3指令而马上中断到调试器</strong> 。<strong>debug 模式才会用 0xcc 初始化内存</strong> 。</p></blockquote></li><li><p>第 9 行 lea 指令比 mov 指令更方便。以下两种方式等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea   edi,[ebp-24h]</span><br><span class="line">;=================================</span><br><span class="line">sub   ebp,24h</span><br><span class="line">mov   edi,ebp</span><br></pre></td></tr></table></figure></li><li><p>第 12 行：stos指令，它的功能是将 eax 中的数据放入的 edi 所指的地址中 ，同时，edi 会增加 4 个字节，rep 使指令重复执行 ecx 中填写的次数。</p></li><li><p>第 59 行，<strong><font color='gree'>eax 寄存器通常用来装载返回值</font></strong> 。</p></li><li><p>第 10 行用到了 ecx，那么为啥保存现场时没 push ecx 呢？这涉及到 ABI 规则，参见另一篇文章<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C和汇编混合编程</a>。</p></li><li><p>第 26 行，由于之前 push 了两个参数，<strong>现在要恢复栈状态以保持堆栈平衡，所以必须平栈</strong> ，此处 __cdecl 采用外平栈。内平栈方式见文末。</p></li><li><p>第 19，21，56，57 行代码，可以看出编译器 <strong><font color='gree'>通过 EBP 来访问形参和创建局部变量</font></strong> 。  为啥用 EBP 定位？因为 EBP 指向栈底，固定不动，而 ESP 指向栈顶，会发生浮动，所以 EBP 才能作为基准。</p></li><li><p><strong>第 36 行的 <code>__RTC_CheckEsp</code> 函数是用来检测堆栈平衡的，即是否有 ESP=EBP</strong> 。</p></li></ol><p>结合上面代码及其注释，给出如下堆栈图（绿色箭头为 ESP，红色箭头为 EBP）：<br><img src="/2022/img/未命名绘图-1667179108102-1.png" style="zoom:67%;" /><br>可见，EBP 永远指向当前(被调)函数的栈底，而当前栈底保存的永远是调用函数栈底。</p><h3 id="font-color-red-调用约定-font"><font color='red'>调用约定</font></h3><p>C/C++ 调用约定和平台相关，不同平台有不同调用方式，常见有如下几种：</p><table><thead><tr><th>调用方式</th><th>平台</th><th>传参方式</th><th>平栈方</th></tr></thead><tbody><tr><td>__stdcall (pascal)</td><td>Windows API</td><td>压栈传参，从右向左</td><td>内平栈（被调用者）</td></tr><tr><td>__cdel</td><td>C/C++默认方式；<br />可变参函数必须使用此方式</td><td>压栈传参，从右向左</td><td>外平栈（调用者）</td></tr><tr><td>__fastcall</td><td>Linux 下默认</td><td>32位：用 ECX 和 EDX 传送右两个参数，其余栈传递<br />64位：右六个参数用寄存器传参，其他用栈传。<br />栈传递仍从右向左。</td><td>Linux:外平栈<br />Windows:内平栈</td></tr><tr><td>__thiscall</td><td>C++ 成员函数</td><td>参数个数确定：this指针通过通过 ECX 传递给被调用者；<br />如果参数个数不确定：this指针在所有参数压栈后被压入堆栈</td><td>参数个数确定：内平栈<br />参数个数不定：外平栈</td></tr></tbody></table><p><strong><mark class="hl-label blue">C语言编译时函数名修饰约定规则</mark> </strong></p><table><thead><tr><th>调用惯例</th><th>名字修饰</th></tr></thead><tbody><tr><td>cdecl</td><td>下划线+函数名， 如函数 max() 的修饰名为 <code>_max</code></td></tr><tr><td>stdcall</td><td>下划线+函数名+@+参数的字节数， 如函数 int max(int m, int n) 的修饰名为 <code>_max@8</code></td></tr><tr><td>fastcall</td><td>@+函数名+@+参数的字节数，如 int add(int c,int b,int c) 的修饰名为 <code>@add@12</code></td></tr></tbody></table><p><strong><mark class="hl-label blue">C++编译时非成员函数函数名修饰约定规则</mark> </strong><br>C++的函数名修饰规则有些复杂，但是信息更充分，通过分析修饰名不仅能够知道函数的调用方式，返回值类型，参数个数甚至参数类型。<strong><font color='gree'>在 Visual C++ 下</font></strong> ，不管_cdecl，_fastcall还是_stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。对于_stdcall方式，参数表的开始标识是 <code>@@YG</code>，对于_cdecl方式则是 <code>@@YA</code> ，对于_fastcall方式则是 <code>@@YI</code> 。参数表后以 <code>@Z</code> 标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。参数表的拼写代号如下所示：</p><table><thead><tr><th>X</th><th>D</th><th>E</th><th>F</th><th>H</th><th>I</th><th>J</th><th>K</th><th>M</th><th>N</th><th>_N</th><th>U</th></tr></thead><tbody><tr><td>void</td><td>char</td><td>unsigned char</td><td>short</td><td>int</td><td>unsigned int</td><td>long</td><td>unsigned long</td><td>float</td><td>double</td><td>bool</td><td>struct</td></tr></tbody></table><p><strong>函数参数表的第一项实际上是表示函数的返回值类型</strong> 。举例如下：</p><table><thead><tr><th>函数原型</th><th>生成函数名</th></tr></thead><tbody><tr><td><strong>int __cdecl add(int a, int b)</strong></td><td><strong>?add@@YGHHH@Z</strong></td></tr><tr><td><strong>int __fastcall sub(int a, int b)</strong></td><td><strong>?sub@@YIHHH@Z</strong></td></tr><tr><td><strong>int __stdcall mul(int a, int b)</strong></td><td><strong>?mul@@YAHHH@Z</strong></td></tr></tbody></table><p><strong><code>HHH</code></strong> ：第 1 个 H 表示返回值为 int，第 2、3 个 H 表示两个参数的类型为 int。</p><p><strong>指针的方式有些特别，用 PA 表示指针，用 PB 表示 const 类型的指针</strong> 。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。如下：</p><table><thead><tr><th>函数原型</th><th>生成函数名</th></tr></thead><tbody><tr><td><em><em>int __cdecl add(int</em> a, int</em> b)**</td><td><strong>?sub@@YIHPBH0@Z</strong></td></tr><tr><td><em><em>int __fastcall sub(const int</em> a,const int</em> b)**</td><td><strong>?add@@YAHPAH0@Z</strong></td></tr></tbody></table><p><strong>U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束</strong> ，如果相同类型的结构体连续出现，以“0”代替，一个“0”代表一次重复，如下：</p><table><thead><tr><th>函数原型</th><th><strong>生成函数名</strong></th></tr></thead><tbody><tr><td><strong>int __cdecl add(stu a, stu b)</strong></td><td><strong>?add@@YAHUstu@@0@Z</strong></td></tr></tbody></table><p><strong><mark class="hl-label blue">C++编译时成员函数函数名修饰约定规则</mark> </strong><br>函数名字和参数表之间插入以“@”字符引导的类名；其次是参数表的开始标识不同，公有（public）成员函数的标识是 <code>@@QAE</code> ，保护（protected）成员函数的标识是 <code>@@IAE</code> ，私有（private）成员函数的标识是 <code>@@AAE</code>，如果函数声明使用了 const 关键字，则相应的标识应分为 <code>@@QBE</code> ，<code>@@IBE</code> 和 <code>@@ABE</code> 。如果参数类型是实例的引用，则使用 <code>AAH</code> ，对于 const 类型的引用，则使用 <code>ABH</code> 。</p><blockquote><p>注意，以上仅是 Visual C++ 编译器下的修饰规则，gcc 则是另一套规则。记是记不住的，这辈子都记不住，只需大概了解即可。</p></blockquote><h3 id="font-color-red-平栈方式-font"><font color='red'>平栈方式</font></h3><p>平栈方式分为内平栈(被调用者平栈)和外平栈(调用栈平栈)。内平栈已在上述代码中分析过，下面我们观察外平栈的方式。之前的代码默认采用的 __cdecl ，下面代码显式采用 __stdcall，其他代码不变，汇编如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00611750</span>  push        ebp  </span><br><span class="line"><span class="number">00611751</span>  mov         ebp,esp  </span><br><span class="line"><span class="number">00611753</span>  sub         esp,<span class="number">0</span>C0h  </span><br><span class="line"><span class="number">00611759</span>  push        ebx  </span><br><span class="line"><span class="number">0061175</span>A  push        esi  </span><br><span class="line"><span class="number">0061175B</span>  push        edi  </span><br><span class="line"><span class="number">0061175</span>C  mov         edi,ebp  </span><br><span class="line"><span class="number">0061175</span>E  xor         ecx,ecx  </span><br><span class="line"><span class="number">00611760</span>  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">00611765</span>  rep stos    dword ptr es:[edi]  </span><br><span class="line"><span class="number">00611767</span>  mov         ecx,offset _206B94B3_源@c (<span class="number">061</span>C000h)  </span><br><span class="line"><span class="number">0061176</span>C  call        @__CheckForDebuggerJustMyCode@<span class="number">4</span> (<span class="number">061130</span>Ch)  </span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="number">00611771</span>  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00611774</span>  add         eax,dword ptr [b]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00611777</span>  pop         edi  </span><br><span class="line"><span class="number">00611778</span>  pop         esi  </span><br><span class="line"><span class="number">00611779</span>  pop         ebx  </span><br><span class="line"><span class="number">0061177</span>A  add         esp,<span class="number">0</span>C0h  </span><br><span class="line"><span class="number">00611780</span>  cmp         ebp,esp  </span><br><span class="line"><span class="number">00611782</span>  call        __RTC_CheckEsp (<span class="number">0611235</span>h)  </span><br><span class="line"><span class="number">00611787</span>  mov         esp,ebp  </span><br><span class="line"><span class="number">00611789</span>  pop         ebp  </span><br><span class="line"><span class="number">0061178</span>A  ret         <span class="number">8</span>  </span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">006117</span>A0  push        ebp  </span><br><span class="line"><span class="number">006117</span>A1  mov         ebp,esp  </span><br><span class="line"><span class="number">006117</span>A3  sub         esp,<span class="number">0E4</span>h  </span><br><span class="line"><span class="number">006117</span>A9  push        ebx  </span><br><span class="line"><span class="number">006117</span>AA  push        esi  </span><br><span class="line"><span class="number">006117</span>AB  push        edi  </span><br><span class="line"><span class="number">006117</span>AC  lea         edi,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">006117</span>AF  mov         ecx,<span class="number">9</span>  </span><br><span class="line"><span class="number">006117B</span>4  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">006117B</span>9  rep stos    dword ptr es:[edi]  </span><br><span class="line"><span class="number">006117B</span>B  mov         ecx,offset _206B94B3_源@c (<span class="number">061</span>C000h)  </span><br><span class="line"><span class="number">006117</span>C0  call        @__CheckForDebuggerJustMyCode@<span class="number">4</span> (<span class="number">061130</span>Ch)  </span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="number">006117</span>C5  mov         dword ptr [a],<span class="number">1</span>  </span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="number">006117</span>CC  mov         dword ptr [b],<span class="number">2</span>  </span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">006117</span>D3  push        <span class="number">2</span>  </span><br><span class="line"><span class="number">006117</span>D5  push        <span class="number">1</span>  </span><br><span class="line"><span class="number">006117</span>D7  call        _add@<span class="number">8</span> (<span class="number">0611104</span>h)  </span><br><span class="line"><span class="number">006117</span>DC  mov         dword ptr [c],eax  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">006117</span>DF  xor         eax,eax  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">006117E1</span>  pop         edi  </span><br><span class="line"><span class="number">006117E2</span>  pop         esi  </span><br><span class="line"><span class="number">006117E3</span>  pop         ebx  </span><br><span class="line"><span class="number">006117E4</span>  add         esp,<span class="number">0E4</span>h  </span><br><span class="line"><span class="number">006117</span>EA  cmp         ebp,esp  </span><br><span class="line"><span class="number">006117</span>EC  call        __RTC_CheckEsp (<span class="number">0611235</span>h)  </span><br><span class="line"><span class="number">006117F</span>1  mov         esp,ebp  </span><br><span class="line"><span class="number">006117F</span>3  pop         ebp  </span><br><span class="line"><span class="number">006117F</span>4  ret  </span><br></pre></td></tr></table></figure><p>观察到第 27 行，<code>ret 8</code> ，这条指令很奇怪，因为我们以前都是直接 <code>ret</code> ，怎么这个 ret 后面还有数字？这其实就是内平栈，该指令的作用相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop  eip </span><br><span class="line">pop  cs</span><br><span class="line">add  esp,8</span><br></pre></td></tr></table></figure><p>最后的 <code>add esp,8</code> 就起到了平栈的作用。</p><h3 id="font-color-red-extern-“c”-font"><font color='red'>extern “c”</font></h3><p>使用 C/C++ 语言开发软件的程序员经常碰到这样的问题：有时候是程序编译没有问题，但是链接的时候总是报告函数不存在（经典的LNK 2001错误），有时候是程序编译和链接都没有错误，但是只要调用库中的函数就会出现堆栈异常。这些现象通常是出现在 C 和 C++ 的代码混合使用的情况下或在 C++ 程序中使用第三方的库的情况下（不是用C++语言开发的），其实这都是函数调用约定（Calling Convention）和函数名修饰（Decorated Name）规则惹的祸。函数调用方式决定了函数参数入栈的顺序，是由调用者函数还是被调用函数负责清除栈中的参数等问题，而函数名修饰规则决定了编译器使用何种名字修饰方式来区分不同的函数，如果函数之间的调用约定不匹配或者名字修饰不匹配就会产生以上的问题。一个具体的常见例子是 C++ 代码中的 <code>extern &quot;c&quot;</code> 语句，考虑具体的场景如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前头文件func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> extern <span class="string">&quot;c&quot;</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>假设我们在 C++ 项目中包含了 <code>func.h</code> 并使用了其中的 function() 函数，且函数的定义是通过 C 编译的静态链接库 func.lib 引入的，那么如果没有 <code>extern &quot;c&quot;</code> 语句，将会报链接错误。这是因为：如果没有 <code>extern &quot;c&quot;</code> ，则 C++ 编译器可能会将项目中的 function 解析为 <code>?function@@YIHHH@Z</code> ，但是，由于 func.lib 是提前用 C 语言编译好的，其中的 function 已经被解析为 <code>_function@8</code> ，如此一来，我们编译好的 C++ 项目在链接 func.lib 后，就无法通过 <code>?function@@YIHHH@Z</code> 找到 <code>_function@8</code> ，于是提示找不到函数定义，即报链接错误。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析重定位——程序加载器/vstart解析</title>
      <link href="/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文通过汇编来阐述重定位的原理，不了解汇编的同学请先移步 <a href="https://jyx_aha.gitee.io/hexo/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编语言入门指南</a> 。<br>本文参考李忠先生的《x86汇编语言：从实模式到保护模式》，若需了解详情，可移步本书（书上的例子较难，本文例子经过了简化）。<br>另外，本文仅在实模式下，通过汇编来描述重定位的基本过程，实际程序的重定位肯定更加复杂，如果想深刻了解程序的加载过程，请阅读神书《链接，装载与库》。<br>本文参考：《操作系统真相还原》《汇编语言第四版》《x86汇编语言：从实模式到保护模式》，<a href="https://blog.csdn.net/m0_37570820/article/details/79403382">程序的加载</a></p></blockquote><p>需要注意的是，编译软件必须使用 nasm，不可使用 masm。原因是 nasm 可以生成 .bin 文件，.bin 文件是纯二进制文件，可以直接输入到 CPU 运行，不像 elf 或 pe 文件那样有许多描述信息。 <strong>可执行文件中包含描述信息和指令</strong> ，这些描述信息就是我们重点要说的内容，而 masm 会自动生成描述信息，掩盖了这样过程，不利于我们探究重定位；相反，nasm 可以由我们自己来规划描述信息。废话不多说，让我们开始吧。</p><h3 id="font-color-red-vstart-和-section-xxx-start-究竟是什么？-font"><font color='red'>vstart 和 section.xxx.start 究竟是什么？</font></h3><p><strong><mark class="hl-label blue">前置结论</mark> </strong><br>很多朋友学习 nasm 时，都会对这两个关键词产生疑惑，最大的原因在于没有实际的应用场景，无法仔细体会其中的用处。后面当我们手写加载器和用户程序头部时，大家就会明白其中的奥秘。现在先让我们大概理解这两个关键词的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#代码没有意义，仅作演示</span><br><span class="line">section code1 align=16</span><br><span class="line">mov ax,bx</span><br><span class="line">section code2 align=16</span><br><span class="line">mov bx,ax</span><br><span class="line">section data align=16</span><br><span class="line">db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>使用 <code>align=16</code> 使 section 以 16 位对齐。以上代码生成的二进制文件如下：<br><img src="/2022/img/image-20221031090603921.png" alt=""></p><p>接着，我们交换 <code>code1</code> 段和 <code>code2</code> 段的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code2 align=16</span><br><span class="line">mov bx,ax</span><br><span class="line">section code1 align=16</span><br><span class="line">mov ax,bx</span><br><span class="line">section data align=16</span><br><span class="line">db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应二进制代码如下：<br><img src="/2022/img/image-20221031090709540.png" alt=""><br>可以发现，第一行二进制代码和第二行互换了位置。由此我们知道， <strong><font color='orange'>.asm 汇编文件和其生成的 .bin 二进制文件是完全一一对应的关系，.bin 中的代码在内存的布局和 .asm 中的代码布局相同</font></strong> 。这是我们得到的第一个结论。下面继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">mov ax,s</span><br><span class="line">section data align=16</span><br><span class="line">s:db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应代码如下：<br><img src="/2022/img/image-20221031090803933.png" alt=""></p><p>由 <code>B8 10</code> 可知，标号 S 的地址为 <code>0x10</code> ，恰好能和第二行代码的地址对应。由此我们得到第二个结论： <strong><font color='orange'>编译器给 .bin 程序中各符号分配的地址，就是各符号相对于 .asm 文件开头的偏移量</font></strong> 。</p><p><strong><mark class="hl-label blue">vstart</mark> </strong><br>对代码做如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">mov ax,s</span><br><span class="line">section data align=16 vstart=0</span><br><span class="line">s:db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应二进制代码如下：<br><img src="/2022/img/image-20221031090858316.png" alt=""><br><code>B8 10</code> 变成了 <code>B8 00</code> ，可见，<code>vstart</code> 关键字改变了 S 标号的汇编地址，原本 S 标号的地址是此标号相对于文件开头的偏移量，而现在 S 标号的地址是以 data 段为起点的偏移量。换句话说， <strong><font color='red'><code>vstart</code> 能够使段内所有标号的汇编地址都以此段的开头处计算，而非以整个程序的开头(即.asm文件开头)计算！</font></strong></p><p>注意！听完上述 vstart 的作用后，我们很容易认为 vstart 能够告诉编译器将程序加载到某个固定的 <strong>偏移</strong> 地址，这么一看，编译器似乎具备了加载器的功能。其实不然，vstart 的作用仅仅是告诉编译器：“嘿，老兄，请你把我后面定义的 <strong>标号地址</strong> 从xxx为起点开始编址吧”，别无他用。它只负责编址，不负责加载，加载程序是加载器的事。 <strong><font color='orange'>所以，用 vstart 的时机是：我预先知道我的程序将来会被加载到某个偏移地址处</font></strong> 。拿确切的例子来说，BIOS(加载器)会将 MBR 引导程序加载到 <code>0000:7c00</code> 处，所以 MBR 程序段必须用 <code>vstart=7c00</code> 修饰（不用管段地址，段地址由加载器决定，<u>即使是加载到 1100:7c00，一样可以执行</u>）。 <strong>一般情况下使用 <code>vstart=0</code> (利于重定位)，这是因为段在内存中都以 16 位对齐，所以进入段时，偏移地址总是从零开始，如果标号的汇编地址和内存中的偏移地址不一致，就会发生错误</strong>  。来看个简单的例子吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code align=16 vstart=8</span><br><span class="line">s:</span><br><span class="line">push cs</span><br><span class="line">push s</span><br><span class="line">mov bp,sp</span><br><span class="line">jmp dword [bp]  ;ret</span><br></pre></td></tr></table></figure><p>其二进制代码为：<code>0E 68 08 00 89 E5 66 FF 66 00</code> 。将这段程序加载到物理地址 <code>10000</code> 处，内存映像如下图：<br><img src="/2022/img/image-20221025162254596-1667178594381-1.png" alt=""></p><p>由于 <code>vstart=8</code> ，所以标号 S 代表的偏移地址也为 8，这就导致第 6 行代码 jmp 到错误位置 <code>1000:8</code> 处，然而实际应该 jmp 到 <code>1000:0</code> 处。这就是汇编地址与段内偏移地址不对应的后果。还一头雾水，不急，这个的确很绕，咋们继续，相信看完后面你就可以理解了。</p><blockquote><p>另外，<code>vstart=xxx</code> 与 <code>org xxx</code> 功能相同。</p></blockquote><p><strong><mark class="hl-label blue">section.xxx.start</mark> </strong><br><code>section.xxx.start</code> 是某段相对于程序开头的偏移量。举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section data align=16 vstart=0</span><br><span class="line">msgdb&#x27;hello world&#x27;</span><br><span class="line">section code align=16 vstart=0</span><br><span class="line">mov ax,section.code.start</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20221031091035242.png" alt=""><br>可见，<code>section.code.start=0x10</code> ，这就是 code 段相对于文件开头的偏移量。你一定会问，这玩意儿有啥用？唯一作用就是用来重定位。怎么个玩法？请继续阅读下文。</p><h3 id="font-color-red-什么是程序加载器？-font"><font color='red'>什么是程序加载器？</font></h3><p>一个编译好的用户程序，放到磁盘中，是如何被加载到内存并运行的呢？大概的流程是加载器先把磁盘中的应用程序加载到内存并把执行权移交给应用程序。分为以下几个步骤：</p><ol><li>从磁盘读取应用程序并装入内存（加载器的作用1）。</li><li>应用程序被装入内存后需要加载器对内存中的应用程序部分地址进行重定位（加载器的作用2）。</li><li>加载器将执行权移交应用程序（加载器的作用3）。</li></ol><p>一般来说，加载器和用户程序对彼此而言都是黑盒子，它们不了解对方的功能和结构。那加载器如何启动用户程序呢？这就需要加载器和用户程序在事先协商一个接口，加载器通过接口去启动用户程序。实际的做法是，将这个接口放在每个用户程序的开头，即用户程序头部，加载器按约定从头部提取信息并完成加载。 <strong>用户程序头部在源程序中以一个段的形式出现。</strong> 用户程序头部至少要包含如下信息：</p><ol><li><strong>用户程序的尺寸</strong> ，以字节为单位。加载器需要根据其尺寸来决定读取多少个逻辑扇区。</li><li><strong>用户程序的入口</strong> ，包括段地址和偏移地址。注意，这里的段地址并不是真正的段地址，而是 <code>section.xxx.start</code> ，加载器通过这个段地址来计算出内存中真正的逻辑段地址。</li><li><strong>段重定位表及其表项个数</strong> 。用户程序中的所有段都会被重定位，并将位置记录在表中。</li></ol><h3 id="font-color-red-程序加载器的工作流程-font"><font color='red'>程序加载器的工作流程</font></h3><p>下面我们以 MBR（加载器） 加载 OBR（用户程序）为例展开讨论。</p><blockquote><p>MBR 和 OBR 和操作系统相关，概念不难，自行百度。注意，加载器和用户程序是相对概念，对于 BIOS 和 MBR，前者是加载器，后者是用户程序；对于 MBR 和 OBR，前者是加载器，后者是用户程序。可见，这是一种链式加载，各自完成指定的任务，不断交接接力棒。</p></blockquote><p><strong><mark class="hl-label blue">1.初始化和决定加载位置</mark> </strong><br>要加载一个程序，需要决定两个事情：1）从哪取：用户程序位于硬盘上的哪个逻辑扇区(<code>START_SECTOR</code>)。2）放在哪：内存中什么地方是空闲的(<code>BASE_ADDR</code>)。</p><p>将程序放在哪由操作系统决定；如何知道程序所在扇区，这个笔者暂时不清楚，暂且认为加载器能够通过某种方式获得用户程序所在扇区，我们暂不纠结这个问题，将注意力放在加载过程中。</p><p><strong><mark class="hl-label blue">2.将程序加载进内存</mark> </strong><br>知道用户程序所在硬盘中的位置后，加载器访问硬盘，将用户程序读到内存中指定的位置。不过此时程序还无法运行，因为程序中可能有多个段（代码段或数据段），要从 code_A 段跳转到 code_B 段，或在 code_A 段访问 data_C 段的数据，就必须知道相应段的段地址，这必须经过段的重定位后才能确定。</p><p><strong><mark class="hl-label blue">3.重定位</mark> </strong></p><p>重定位的操作者是加载器，提供重定位信息的是用户程序。段重定位信息由 <code>section.xxx.start</code> 和 <code>BASE_ADDR</code> 确定。加载器利用此二者计算出各个段在内存中的逻辑段地址，并将其回填到用户程序头部。</p><p><strong><mark class="hl-label blue">4.将控制权移交给用户程序</mark> </strong><br>用户程序取得控制权，接下来便可利用头部中的重定位表跳转于各个段之间。</p><p>以上是程序加载器的简单概述，下面我们结合代码来进行说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">;===============文件说明：用户程序==================================================</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    header_end:                </span><br><span class="line"> ;===============================================================================</span><br><span class="line"> ;code1——清屏并打印hello</span><br><span class="line">SECTION code_1 align=16 vstart=0</span><br><span class="line">printh:           ;打印hello    </span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ax,0xb800 ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,0</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">start: ;程序入口</span><br><span class="line">mov ax,ds</span><br><span class="line">mov es,ax                  ;es作header基准,ds作用户数据段</span><br><span class="line">mov ax,es:[stack_segment]  ;设置用户的堆栈！</span><br><span class="line">mov ss,ax                    </span><br><span class="line">mov sp,stack_end   </span><br><span class="line"></span><br><span class="line">mov ax,es:[data_1_segment] ;设置用户的数据段！</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">mov ax,0x600  </span><br><span class="line">mov bx,0x700  </span><br><span class="line">mov cx,0  </span><br><span class="line">mov dx,0x184f    </span><br><span class="line">int 0x10  </span><br><span class="line">call printh    ;打印hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push word es:[code_2_segment] ;注意，是word而非dword</span><br><span class="line">push printw   </span><br><span class="line">retf                     ;转移到code_2</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">jmp $          ;在此处循环</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line"> ;code2——打印&#x27;world&#x27;</span><br><span class="line">SECTION code_2 align=16 vstart=0</span><br><span class="line">printw:</span><br><span class="line"></span><br><span class="line">mov ax,es:[data_2_segment]</span><br><span class="line">mov ds,ax </span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,80;打印world</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">push word es:[code_1_segment]</span><br><span class="line">push stop</span><br><span class="line">retf           ;返回code_1</span><br><span class="line"></span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_1 align=16 vstart=0 </span><br><span class="line">db &#x27;h&#x27;,00000111B</span><br><span class="line">db &#x27;e&#x27;,00000111B</span><br><span class="line">db &#x27;l&#x27;,00000111B</span><br><span class="line">db &#x27;l&#x27;,00000111B</span><br><span class="line">db &#x27;o&#x27;,00000111B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_2 align=16 vstart=0 </span><br><span class="line">db &#x27;w&#x27;,11000010B</span><br><span class="line">db &#x27;o&#x27;,11000010B</span><br><span class="line">db &#x27;r&#x27;,11000010B</span><br><span class="line">db &#x27;l&#x27;,11000010B</span><br><span class="line">db &#x27;d&#x27;,11000010B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">times 256 db 0</span><br><span class="line">stack_end:</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION trail align=16 </span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">         BASE_ADDR     equ 0x10000       ;将用户程序加载到物理位置BASE_ADDR处</span><br><span class="line">         START_SECTOR  equ 100           ;BASE_ADDR的末位必须为0</span><br><span class="line">                                         ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">                                         ;常数的声明不会占用汇编地址                                    </span><br><span class="line">SECTION mbr align=16 vstart=0x7c00                                     </span><br><span class="line">         ;设置堆栈段和栈指针 </span><br><span class="line">         mov ax,0      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,ax</span><br><span class="line">         </span><br><span class="line">         mov eax,BASE_ADDR               ;eax低4位一定为0</span><br><span class="line">         mov cl ,4                       ;移动多位，必须使用cl</span><br><span class="line">         shr eax,cl                      </span><br><span class="line">         mov ds,ax                       ;令DS和ES指向该段以进行操作</span><br><span class="line">         mov es,ax                        </span><br><span class="line">    </span><br><span class="line">         ;以下读取程序的起始部分 </span><br><span class="line">         xor di,di</span><br><span class="line">         mov si,START_SECTOR             ;程序在硬盘上的起始逻辑扇区号 </span><br><span class="line">         xor bx,bx                       ;加载到DS:0x0000处 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">      </span><br><span class="line">         ;以下判断整个程序有多大</span><br><span class="line">         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 </span><br><span class="line">         mov ax,[0]</span><br><span class="line">         mov bx,512                      ;512字节每扇区</span><br><span class="line">         div bx</span><br><span class="line">         cmp dx,0</span><br><span class="line">         jnz @1                          ;未除尽，因此结果比实际扇区数少1 </span><br><span class="line">         dec ax                          ;已经读了一个扇区，扇区总数减1 </span><br><span class="line">   @1:</span><br><span class="line">         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">         jz direct</span><br><span class="line">         </span><br><span class="line">         ;读取剩余的扇区</span><br><span class="line">         push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">         mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line">   @2:</span><br><span class="line">         mov ax,ds</span><br><span class="line">         add ax,0x20                     ;得到下一个以512字节为边界的段地址</span><br><span class="line">         mov ds,ax  </span><br><span class="line">                              </span><br><span class="line">         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 </span><br><span class="line">         inc si                          ;下一个逻辑扇区 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">         loop @2                         ;循环读，直到读完整个功能程序 </span><br><span class="line"></span><br><span class="line">         pop ds                          ;恢复数据段基址到用户程序头部段 </span><br><span class="line">      </span><br><span class="line">         ;计算入口点代码段基址 </span><br><span class="line">   direct:</span><br><span class="line">         mov eax,[0x06]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [0x06],ax                   ;回填修正后的入口点代码段基址 </span><br><span class="line">      </span><br><span class="line">         ;开始处理段重定位表</span><br><span class="line">         mov cx,[0x0a]                   ;需要重定位的项目数量</span><br><span class="line">     cmp cx,0</span><br><span class="line">     jz  jmpToLoader                 ;如果为0项，直接跳转</span><br><span class="line">         mov bx,0x0c                     ;重定位表首地址</span><br><span class="line">          </span><br><span class="line"> realloc:</span><br><span class="line">         mov eax,[bx]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [bx],ax                     ;回填段的基址</span><br><span class="line">         add bx,4                        ;下一个重定位项（每项占4个字节） </span><br><span class="line">         loop realloc </span><br><span class="line"></span><br><span class="line"> jmpToLoader:     </span><br><span class="line">         jmp far [0x04]                  ;转移到用户程序  </span><br><span class="line"> </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;      DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line"></span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base:                       ;计算16位段地址</span><br><span class="line">                                         ;输入：eax低20位有效,最低4位为0</span><br><span class="line">                                         ;返回：AX=16位段基地址 </span><br><span class="line">         add eax,BASE_ADDR</span><br><span class="line">     mov cl,4</span><br><span class="line">     shr eax,cl</span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------         </span><br><span class="line"> times 510-($-$$) db 0</span><br><span class="line"> db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">用户程序剖析</mark> </strong></p><blockquote><p>建议读者赋值粘贴代码到 notepad++，文件格式为 .asm，这样方便代码阅读和定位（双击标号即可定位）。</p></blockquote><ul><li>头部是用户程序和加载器之间的接口，它们遵循事先规定好的约定。头部必须为单独一个 section。</li><li>第 4 行，通过 <code>program_end</code> 确定了用户程序的大小。这是如何做到的呢？注意 102 行，段定义没有 <code>vstart=0</code> ，所以该段内标号的汇编地址是从文件头开始算的，所以该标号就是文件尾相对文件的的偏移量，即文件的大小。</li><li>第 39 行是易错的地方，务必要将 ds 备份，此时 ds 是用户程序被载入内存的位置，<strong>之后访问头部时，都必须使用此值作为段基址</strong> 。用 es 保存此值，而后 ds 用来充当 data 段的段基址(比如 45 行)。</li><li>58 行，分别将 code_2 的段基址和偏移地址压栈后，使用 retf 远转移到 code_2。谁说函数调用必须用 call 或 jmp 的？这里使用 retf 的好处是跳转后不用手动清理栈。</li><li><strong><font color='gree'>注意，除了最后一个段外，每个段都必须用 <code>vstart=0</code> 修饰！这样利于段在内存中的浮动装配（重定位），这点非常重要！</font></strong></li><li><strong><font color='gree'>为什么段重定位表的表项大小为 dd，即四个字节呢？段寄存器不是才两个字节大小吗？是这样的：还没重定位的时候，这里装的就是 <code>section.xxx.start</code> ，它是 xxx 段相对于文件开头的偏移量，这个偏移量可能大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> ，所以要用 4 个字节，32 位来装。需要注意的是，<code>section.xxx.start</code> 的最低 4 位（二进制下）一定是 0，这是因为我们的每个段都使用 <code>align=16</code> 对齐，所以每个段相对于文件开头的偏移量一定是 16 的整数倍，故最低四位一定是 0。</font></strong></li></ul><p>其他内容不在赘述，注释已经比较详尽了。</p><p><strong><mark class="hl-label blue">加载器剖析</mark> </strong></p><ul><li>整个文件自成一段。mbr 段使用 <code>vstart=0x7c00</code> 修饰，原因是它知道 BIOS(MBR的加载器) 会将其加载到偏移地址为 0x7c00 的地方(0000:7c00)。</li><li>第 2，3 行相当于 C 语言中的宏定义，使用 <code>equ</code> 来进行赋值。可以将这两句放在 <code>boot.inc</code> 文件中，然后在第一行引入该文件：<code>%include 'boot.inc'</code> 。不过引入头文件这用法似乎只有在 linux 下才行。</li><li>第 24 行，简单举个例子：用户程序大小为 520 字节，除以 512，商 1 余 8，则该程序仍占用两个扇区。</li><li>第 34 行，直接将段地址加上 0x20，即向后移动 512 字节。为什么不用偏移地址加上 512 字节呢？要知道，读取硬盘的数据一般是相对较大的，很多时候都超过了 64KB，一旦超过 64KB，偏移地址就会回卷，将之前的内存覆盖。</li><li>第 11 行，实模式下可以使用 32 位寄存器，原因参见 <a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">保护模式概览</a></li><li>第 12 行，左移或右移多位，必须将位数用 cl 装载，不能直接 <code>shr eax,4</code> 。</li></ul><p>本文对硬盘的读取不展开描述，详细请参考《x86汇编：从实模式到保护模式》第137页，《操作系统真相还原》第 131 页。</p><h3 id="font-color-red-运行-font"><font color='red'>运行</font></h3><blockquote><p>不想折腾的同学请使用 windows 平台完成运行。硬盘文件下载：<a href="https://pan.baidu.com/s/1ycMfrsJCeKlMTki0yAagnA?pwd=gzwb">链接</a>，提取码：gzwb</p></blockquote><p><strong><mark class="hl-label blue">Windows</mark> </strong><br>1）将上面的两份代码分别写入 “loader.asm” 和 “app.asm” 中。<br>2）使用 nasm 生成 .bin 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.asm -o app.bin</span><br><span class="line">nasm -f bin loader.asm -o loader.bin</span><br></pre></td></tr></table></figure><p>3）将 .bin 文件写入硬盘。通过上面的链接获取硬盘文件及其写入工具，打开 <code>fixvhdwt</code> ，硬盘选择 <code>LEECHUNG.vhd</code> ，数据文件选择 <code>loader.bin</code> ，然后写入逻辑第 0 扇区即可。重复以上步骤，将 <code>app.bin</code> 写入第 100 扇区。<br>4）在 bochs 安装目录下找到 bochsdbg.exe，打开后按下图顺序操作：<br><img src="/2022/img/image-20221031091508919.png" alt=""><br>第 7 步点击 Boot Option 后，将 boot Drive1 改成 disk 即可。<br>5)运行。点击菜单界面右上方的 start，然后在命令行输入 <code>c</code> ，虚拟机屏幕出现 hello world 即成功。</p><p><strong><mark class="hl-label blue">Linux</mark> </strong></p><p>1）先下载 bochs，参见配置过程参见 <a href="https://jyx-fyh.github.io/2022/10/27/bochs%E4%BD%BF%E7%94%A8/">bochs使用</a>。在 bochs 文件夹中打开终端，输入以下命令创建硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat ./build/hd.img</span><br></pre></td></tr></table></figure><p>2）接着在 <code>bochsrc</code> 中修改如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/hd.img&quot;</span>, mode=flat</span><br></pre></td></tr></table></figure><p>3）在 bochs-2.7/build 目录下，将之前的两份代码分别写入 <code>loader.s</code> 和 <code>app.s</code> ，然后使用如下命令分别生成 .bin 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.s -o app.bin</span><br><span class="line">nasm -f bin loader.s -o loader.bin</span><br></pre></td></tr></table></figure><p>注意，可能会报错，提示 <code>app.s</code> 中有五行错误，只需将 <code>es:[xxx_segment]</code> 改为 <code>[es:xxx_segment]</code> 即可，这是 nasm 在 LInux 和 Windows 的小差别。<br>4）使用如下命令将.bin 文件写入硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./loader.bin of=./hd.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./app.bin of=./hd.img bs=512 count=1 seek=100 conv=notrunc  //将app写入100扇区</span><br></pre></td></tr></table></figure><p>5）在 bochs-2.7 目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc</span><br></pre></td></tr></table></figure><p>两次回车，出现如下界面：<br><img src="/2022/img/image-20221031091633667.png" alt=""><br>点击左上方的 continue，出现以下界面即为成功：<br><img src="/2022/img/image-20221031091711096.png" alt=""><br>world 后面的 F 哪来的我也很懵逼。。。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make clean的必要性&amp;自动找寻头文件</title>
      <link href="/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
      <url>/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本人初学 makefile，对此问题有认识不足之处，烦请在评论区指出错误或补充您的观点，谢谢。</p></blockquote><p><strong>什么时候必须 <code>make clean</code> ？</strong><br><strong><font color='orange'>当依赖文件中没有显式写出头文件时，如果仅改动了头文件，那么必须 <code>make clean</code></font></strong> 。否则不会重新编译，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################mekefile</span></span><br><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">gcc -c ./src/add.c -o add.o</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o</span><br><span class="line"><span class="comment">#######################main.c</span></span><br><span class="line"><span class="comment">#include &quot;../header/add.h&quot;</span></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a=0;</span><br><span class="line">    int b=1;</span><br><span class="line">    int c=add(a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#######################add.c</span></span><br><span class="line"><span class="comment">#include &quot;../header/add.h&quot;</span></span><br><span class="line">int add(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#######################add.h</span></span><br><span class="line"><span class="comment">#ifndef UNTITLED_ADD_H</span></span><br><span class="line"><span class="comment">#define UNTITLED_ADD_H</span></span><br><span class="line">int add(int a,int b);</span><br><span class="line"><span class="comment">#endif //UNTITLED_ADD_H</span></span><br></pre></td></tr></table></figure><p>先 <code>make</code> 依次，成功。在 <code>make</code> 一次，提示：<code>make: 'calc.exe' is up to date.</code> 。然后将 add.h 改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNTITLED_ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNTITLED_ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNTITLED_ADD_H</span></span></span><br></pre></td></tr></table></figure><p>然后再 <code>make</code> ，仍然提示：<code>make: 'calc.exe' is up to date.</code> ，说明 make 没有检测 add.h 的变动。此时 <code>make clean</code> ，接着 <code>make</code> ，就会报错，提示函数定义和函数原型对不上号：<br><img src="../../public/2022/img/image-20221009185915392.png" alt=""></p><p>以上情况就体现了 <code>make clean</code> 的必要性。</p><p>如果想及时追踪到头文件的改动，就必须把头文件纳入依赖：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="keyword">vpath</span> %.h ./header</span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c add.h</span></span><br><span class="line">gcc -c ./src/add.c -o add.o</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o</span><br></pre></td></tr></table></figure><p>但这又会引入另一个新的问题：如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。所以，我们可以让 make 自动找寻源文件中包含的头文件，并生成一个依赖关系。gcc/g++ 编译器有命令：<code>gcc -MM file</code> ，可以生成 <code>file</code> 文件中使用的头文件的路径，还是拿上面的例子说明：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MM ./src/main.c</span><br><span class="line"><span class="section">main.o: src/main.c  src/../header/add.h</span></span><br></pre></td></tr></table></figure><p>还没学完，后续补充。。。。<br>详细内容：<a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解前缀树(字典树)</title>
      <link href="/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前缀树又叫字典树，通常用来高效地查询字符串，比如查询库中是否有以某个子字符串为前缀的字符串，某个字符串出现的次数等。前缀树是 N 叉树的一种特殊形式，每一个节点会有多个子节点，通往不同子节点的 <strong>路径上</strong> 有着不同的字符，子节点中包含两种信息：pass(经过此字符的次数)，end(以此字符结尾的次数)。说多了没用，直接上图：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1665450930848-1.png" alt=""></p><p>0-‘a’，1-’b’，2-‘c’，每个节点对应的下标即代表相应字母，除 root 外的其他节点中包含着该字母的信息。<br>细心的同学应该发现，root 的 end 域只可能为 0，因为这代表着插入了一个空字符串，这是不被允许的。所以我们似乎可以利用这个 end 域做些坏事。容易知道，root 的 pass 域代表着此前缀树中一共有<font color='orange'>多少个</font>字符串（相同字符串会被重复计数），那么，我如果想知道一共有<font color='orange'>多少种</font>字符串呢？此时，就要利用 root 的 end 域来记录了。详细注释已在代码给出，不在赘述。代码如下(仅支持小写字母)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">preNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pass;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">preNode* arr[<span class="number">26</span>];</span><br><span class="line"><span class="built_in">preNode</span>() :<span class="built_in">pass</span>(<span class="number">0</span>), <span class="built_in">end</span>(<span class="number">0</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">arr[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trieTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">preNode  root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">trieTree</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span>;<span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string str)</span></span>;<span class="comment">//返回某个字符串出现的个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delOnce</span><span class="params">(string str)</span></span>;<span class="comment">//只删一次，如果删除失败，返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delAll</span><span class="params">(string str)</span></span>;<span class="comment">//删除所有str，如果删除失败，返回false</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefixSearch</span><span class="params">(string str)</span></span>;<span class="comment">//返回以str为前缀的字符串的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">counts</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.pass; &#125;<span class="comment">//所有单词总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nonRepeatCounts</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.end; &#125;<span class="comment">//不重复单词的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trieTree root;</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">delAll</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line"><span class="type">int</span> r = root.<span class="built_in">counts</span>();</span><br><span class="line"><span class="type">int</span> n = root.<span class="built_in">nonRepeatCounts</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不重复单词个数：&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;总单词个数：&quot;</span> &lt;&lt; r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trieTree::insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">preNode *tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;pass++;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;arr[p]==<span class="literal">NULL</span>)</span><br><span class="line">tmp-&gt;arr[p] = <span class="keyword">new</span> preNode;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;end == <span class="number">0</span>)<span class="comment">//插入重复字符串，root-&gt;end不计数</span></span><br><span class="line">root.end++;</span><br><span class="line">tmp-&gt;end++;</span><br><span class="line">tmp-&gt;pass++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trieTree::search</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp-&gt;end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trieTree::delOnce</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line">tmp-&gt;pass--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>()<span class="number">-1</span>; i++)<span class="comment">//遍历到str的倒数第二个字符</span></span><br><span class="line">&#123;                                     <span class="comment">//因为如果最后一个字符的end=0</span></span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;             <span class="comment">//就必须delete该节点，然后将指向</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)          <span class="comment">//该节点的指针赋值为NULL</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">tmp-&gt;pass--;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;end--;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass--;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trieTree::delAll</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line">root.end--;</span><br><span class="line"><span class="type">int</span> cnt = tmp-&gt;end;</span><br><span class="line">tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;pass -= cnt;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass == cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass -= cnt;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;end -= cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trieTree::prefixSearch</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp-&gt;pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是链式实现，当字符种类很多时，一般就采用哈希实现，此方式后面有时间再给出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言入门</title>
      <link href="/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-什么是汇编语言？-font"><font color='red'>什么是汇编语言？</font></h3><p>我们最初学习编程时，一般都是学习高级语言，诸如 C++，Java，Python 等，通过一定语法编写代码，然后运行，代码就能够顺利地在电脑中跑起来。但是，计算机实际上并不认识高级语言，它只认识如 <code>01011001</code> 这样的二进制数字。0，1 虽然简单，但无数个代表着高低电平的 0 和 1 组合却能指挥计算机完成几乎所有你能想到的任务。<br>早期的程序是由科学家们手工编写二级制代码完成的，面对巨量的，毫无规律的 0 和 1，其工作量可想而知。为了解决这一窘况，汇编语言应运而生。其实， <strong><font color='orange'>汇编语言严格来说并不是一门语言，而仅仅只是一套助记符，它与二进制代码一一对应</font></strong> 。如下图，汇编语言与人类语言更为接近，便于阅读和记忆。<br><img src="/2022/img/image-20221001232413430.png" alt="左边是二进制代码的十六进制格式，右边是对应的汇编代码" style="zoom:67%;" /><br><strong>汇编语言直接运行于硬件之上</strong> 。<strong>由于 CPU 硬件设计和内部架构的不同，其对应的指令集（机器语言）也不同，每一种 CPU 都有自己的汇编指令集</strong> 。 <strong><font color='orange'>所以，汇编语言依赖于硬件体系，不便于移植</font></strong> 。对于同一个程序，如果在这台机器上可以运行，而到另一台机器上就必须重新改写某些代码以适应机器，那这样就太麻烦了。再之，汇编代码只比机器代码容易阅读了一点而已，理解起来还是很困难。</p><h3 id="font-color-red-汇编语言的种类-font"><font color='red'>汇编语言的种类</font></h3><p><strong>从汇编格式上：</strong> 分为 <strong>Intel</strong> 和 <strong>AT&amp;T</strong> 两种风格，两者是 X86 架构的不同写法。<strong>Intel 格式和 AT&amp;T 格式的区别只是符号系统的区别</strong> 。前者常见于 Windows，masm 仅支持 Intel；而 AT&amp;T 在 Unix 中更常见，GNU 汇编器的默认格式就是 AT&amp;T。<br><strong>从架构体系上：</strong> 分为 <strong>复杂指令集(CISC)</strong> 和 <strong>精简指令集(RISC)</strong> ，前者的代表是 <strong>X86架构</strong> ，后者代表是 <strong>ARM</strong> 架构。RISC 多用于移动端，全世界超过95%的智能手机和平板电脑都采用 ARM 架构；CISC 多用于 PC 端和服务器端，苹果的 PC 机使用的 CPU(M1) 是 ARM 架构。</p><h3 id="font-color-red-汇编语言的组成-font"><font color='red'>汇编语言的组成</font></h3><ol><li><strong>汇编指令</strong> ，如 <code>mov</code> ，有对应的机器码。</li><li><strong>伪指令</strong> ，如 <code>segment</code> 和 <code>end</code> ，由汇编器识别，没用机器码，计算机不执行。</li><li><strong>其他符号</strong> ，如 <code>+</code> 、 <code>-</code> 等，由汇编器识别，没有机器码。</li></ol><p><strong>汇编指令是汇编语言的核心。</strong> 其中，伪指令根据编译器的不同而有所变化。</p><h3 id="font-color-red-CPU总线-font"><font color='red'>CPU总线</font></h3><p>CPU 读写硬件中的数据时，必须经过下面三类信息的交互：</p><ol><li><strong>地址信息</strong> ：储存单元的地址</li><li><strong>控制信息</strong> ：选择器件，读或写的命令.</li><li><strong>数据信息</strong> ：读或写的内容。</li></ol><p>以上三种信息分别由 <strong>地址总线、控制总线、数据总线</strong> 传递。总线将 CPU 与其他芯片连接起来。以下是 CPU 从地址为 3 的内存中读取数据的过程：<br><img src="/2022/img/IMG_0463(20221012-154228).PNG" style="zoom:67%;" /></p><ol><li>CPU 通过地址线将位置信息发送给内存</li><li>CPU 通过控制线向内存发送读命令，选中储存器芯片，并通知它将从内存读取数据。</li><li>储存器将相应位置的数据通过数据线传送给 CPU。</li></ol><p><strong>总线的宽度：</strong> 一根导线上只能传送两种状态：低电平与高电平，对应着 0 和 1；那么 32 根导线一次传送的最大数据为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 。总线所包含的导线数目即为总线宽度。<br><strong><font color='orange'>地址总线的宽度代表着 CPU 的寻址能力，即最多能用多少内存；数据总线的宽度决定了 CPU 对数据的读写能力，平时我们说的 32/64 位机器，指的就是机器的数据总线宽度(寄存器的宽度)；控制总线的宽度决定了 CPU 对外部器件的控制能力。</font></strong></p><p><strong>8080，8088，80286，80386 的地址总线宽度分别为 16，20，24，32，则它们的寻址能力分别为：64KB，1MB，16MB，4GB</strong> 。</p><h3 id="font-color-red-硬件概览-font"><font color='red'>硬件概览</font></h3><p><strong><mark class="hl-label blue">主板</mark> </strong><br>主板上有核心器件（CPU，储存器等）和一些主要器件（外围芯片组，扩展插槽等），这些器件通过总线相连。</p><p><strong><mark class="hl-label blue">接口卡</mark> </strong><br>所有可被程序控制的硬件设备都必须受到 CPU 控制。但 CPU 不能直接控制这些设备，直接控制设备的是接口卡，而 CPU 通过总线与接口卡相连，利用接口卡来间接控制设备。简单来说，CPU 通过总线向接口卡发送命令，接口卡根据收到的命令来指挥设备工作。<br><strong><mark class="hl-label blue">储存器芯片</mark> </strong><br>从读写属性上分为两类：</p><ol><li><strong>ROM (Read Only Memory)</strong> ，随机储存器可写可读，但必须带电储存，关机后数据丢失；</li><li><strong>RAM (Random Access Memory)</strong>  ，只读储存器只可读，关机后内容不丢失；</li></ol><p>从功能上大概分为以下几类：</p><ol><li><strong><font color='gree'>随机储存器</font></strong> ：用于存放供 CPU 使用的绝大部分程序和数据。<strong>主随机储存器一般由主板上的 RAM 和扩展插槽上的 RAM 组成。</strong></li><li><strong><font color='gree'>装有 BIOS (Basic IO System) 的 ROM</font></strong> ：<font color='orange'>BIOS 是由主板和各类插口卡（网卡、显卡等）厂商提供的系统软件，通过它来利用该设备进行最基本的输入输出。主板上的 ROM 存储着系统 BIOS ；显卡上的 ROM 中储存着显卡的 BIOS；网卡中的 ROM 存储着网卡的 BIOS</font>。<strong>机器加电后，启动 BIOS 程序进行一系列的机器初始化动作，然后装入操作系统的初始文件，引导操作系统启动</strong> 。<strong>BIOS是固化在硬件的一种程序</strong> 。BIOS 中包含以下内容：<ul><li>硬件系统的检测和初始化程序。</li><li>外部中断和内部中断的中断例程。</li><li>对硬件设备进行 I/O 的中断例程。</li><li>其他和硬件系统相关的中断例程。</li></ul></li><li><strong><font color='gree'>接口卡</font></strong> ：某些接口卡需要对大批量的输入输出进行储存，其上就会装有 RAM。最典型的就是显卡上的 RAM (显存)。显卡随时将显存中的数据向显示器输出，所以我们才能看见屏幕上的内容。</li></ol><img src="/2022/img/IMG_0465(20221012-172337).PNG" alt="各类储存器的逻辑连接" style="zoom: 67%;" /><h3 id="font-color-red-工作模式-font"><font color='red'>工作模式</font></h3><p>8086/8088 CPU 为单任务操作系统，可以直接操控内存，是不安全的。Intel 进而推出 80286，具备了对多任务系统的支持，首次提出了保护模式的概念。80286 拥有 24 根地址线，可访问 16 MB 的内存，其 16 位段寄存器中也不再存放段地址，而是存放段选择子，真正的段地址位于描述符高速缓存中；其偏移地址最大仍为 64 KB，这是很大的缺陷。而后来的 80386 是划时代的，拥有 32 根地址线，可访问 4 GB 内存；其段偏移量也是 32 位的，在最典型的情况下，可以将 4GB 当作一个段来使用，即平坦模型。它支持以下三个模式：</p><ol><li>实模式：相当于一个 8086</li><li>保护模式：多任务环境，建立保护机制。</li><li>虚拟 8086 模式：可以从保护模式切换到实模式，这种方式方便用户在保护模式下运行 8086 程序。</li></ol><p>80286 CPU 的缺陷在于，它只提供实模式和保护模式，没有提供虚拟模式，这很不利于用户的工作。</p><h3 id="font-color-red-内存地址空间-font"><font color='red'>内存地址空间</font></h3><p><strong><font color='red'>利用接口卡与主储存器，CPU 便能够将所有硬件抽象成内存，通过修改内存来完成对各类硬件的控制！</font></strong> 将所有储存器看作一个由若干储存单元组成的逻辑储存器，这个逻辑储存器就是我们常说的内存地址空间。<br><img src="/2022/img/IMG_0466(20221012-173407).PNG" style="zoom:67%;" /></p><p><strong>每个物理储存器都在这个地址空间中占有一定位置，CPU 在这个位置上读写数据，实际上就在对应的物理储存器中读写数据。</strong></p><p>实模式内存分布如下：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70.png" alt=""></p><p>一般而言，如果需要向内存空间写入数据的话,要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元向里面写入，这可能导致程序的崩溃。<strong>注意，我们在纯DOS方式(实模式)下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在CPU实模式下的DOS没有能力对硬件系统进行全面、严格的管理。但在Windows 2000、Unix这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操根本不可能的，硬件已被这些操作系统利用CPU保护模式所提供的功能全面而严格地管控</strong> 。<br><strong><font color='orange'>在DOS中，<code>0:0200~0:02FF</code> 这段 256 字节的空间一般为空闲，可随意使用。</font></strong></p><h3 id="font-color-red-数据表示-font"><font color='red'>数据表示</font></h3><ul><li>字节：8 bits；字节是计算机的最小操作单元，比特是最小存储单元。</li><li>字：2 字节，即 16 bits；由高位字节和低位字节组成，高低位指的是数据的高低位，而非地址的高低。</li><li>常用表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20}=1MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{24}=16MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span></li><li>一个两位十六进制数可以使用一个字节储存，一个四位十六进制数可以用两个字节存储，以此类推。比如 AX 中存放 0XFFEE，那么 AH 中为 0XFF，AL 中为 0XEE。这种方式可以很容易地看出数据的组成，利于直观分析。</li><li>在小端机器中，低地址存放字型数据的低位数据，高地址存放字型数据的高位数据。</li></ul><h3 id="font-color-red-8086寻址方案-font"><font color='red'>8086寻址方案</font></h3><p><strong>8086 CPU有 20 位地址总线，达到 1 MB寻址能力，所以内存空间也只有 1MB</strong> 。但 8086 CPU是 16 位结构，即，其寄存器最大宽度为 16 位 (或者说，其运算器一次最多可以处理16位数据，寄存器和运算器之间的通路为16位) ，所以如果只是简单发出地址，那么只能一次性处理或存储 16 位地址。所以，<strong>8086 使用两个 16 位地址合成一个 20 位物理地址</strong> ，即 <strong><font color='orange'>物理地址=段地址×16+偏移地址，其中，段地址×16又叫做基础地址</font></strong> 。<br><img src="/2022/img/IMG_0467(20221012-193401).PNG" style="zoom:67%;" /><br>有几点需要注意：</p><ol><li>乘 16 即右移 4 位。</li><li>段地址×16 必然是 16 的倍数，所以段起点必然也为 16 的倍数，比如 10010H。</li><li>一个物理地址可能由多种运算得到，比如，10010H 可能由 1001H×16+0 得到，也可能由 1000H×16+0010H得到。</li><li><strong>由于偏移地址为 16 位，所以一个段的最大长度为 64KB</strong></li><li><strong>段始终以 16 字节对齐</strong> ，如果 data 段只有 14 字节，范围为 1001:0 ~ 10001:D，code 段也会从 1002:0 开始。</li></ol><h3 id="font-color-red-内存定位的多种方式-font"><font color='red'>内存定位的多种方式</font></h3><img src="/2022/img/IMG_0471(20221013-163812).PNG" style="zoom:80%;" />注意：<ol><li><p><strong>在 [ ] 中，BX/SI/DI/BP 可以分别单独出现；</strong></p></li><li><p><strong>或只能以四种组合出现：BX 与 SI，BX 与 DI，BP 与 SI，BP 与 DI；</strong></p><blockquote><p>这样理解：BX 与 BP 为基址寄存器，DI 与 SI 为变址寄存器。</p></blockquote></li><li><p><strong>只要含 BP，默认段寄存器就为 SS</strong> ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#错误方式：</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-指令的执行过程-font"><font color='red'>指令的执行过程</font></h3><ol><li><p>从 CS : IP 指向的内存单元读取指令，将指令送入指令缓冲器。</p><blockquote><p>指令缓冲器<strong>可防止高速处理器在数据传输序列期间被锁定到慢速 I/O 设备，或减少较快和较慢设备之间的速度不匹配</strong> 。</p></blockquote></li><li><p>IP = IP + 所读指令的长度，从而指向下一条指令。</p><blockquote><p>容易发现，指令的长度是可变的，那么 CPU 如何判断指令的长度呢？对于可变长编码，我们应该可以想到一条思路：每个指令的机器码都不可能是其他机器码的前缀。</p></blockquote></li><li><p>执行指令。然后转到步骤一，重复以上过程。</p></li></ol><p>指令从低到高地址依次执行。</p><h3 id="font-color-red-中断-font"><font color='red'>中断</font></h3><h4 id="font-color-gree-内中断-font"><font color='gree'>内中断</font></h4><p><strong>内中断分为软中断和异常</strong> ，指的是 CPU 本身执行当前指令时所发生的中断。内中断具体分为： <strong>1）由软中断指令 int 启动的中断；2）在一定条件下由 CPU 自身启动的中断(异常)</strong> 。当 CPU 内部发生以下情况时，会发出中断信息：</p><ol><li><p>除法错误</p></li><li><p>单步执行</p></li><li><p>执行 into 指令</p><blockquote><p>本指令检测 OF 标志位,当 OF=1 时,说明已发生溢出，立即产生一个<u>中断类型为 4 的中断</u>,当 OF＝0 时，本指令不起作用。本指令可用于溢出处理，影响 TF 和 IF 标志位。</p></blockquote></li><li><p>执行 int 指令</p><blockquote><p>指令格式为 int N，N 是字节型立即数，为中断码。</p></blockquote></li></ol><p><strong><mark class="hl-label blue">中断向量表</mark> </strong><br>CPU 用中断类型码来标识中断信息，中断码长度为 1 字节，可表示 256 中断信息。<br>CPU 侦测到中断码后，根据 <strong>中断向量表</strong> ( <strong>IVT</strong> ) 找到中断码对应的中断处理程序入口地址，并放入 CS:IP 中，执行程序。 <strong><font color='orange'>中断向量表在开机时由 BIOS 程序加载进内存，并放在 <code>0000:0000 ~ 0000:03ff</code> 这 1024 个字节中，其中 <code>0000:0200~0000:02ff这256字节一般为空闲</code></font></strong> 。中断向量表是PC系统中最重要的内存区。中断向量表每个表项长 4 字节，所以中断向量表最多有 256 个中断信息。</p><blockquote><p>DOS 也提供中断例程。BIOS 完成硬件检测和初始化后，调用 int 19h 进行操作系统的引导，从此将计算机交给操作系统。DOS 启动后，将自己提供的中断例程载入内存，并建立响应中断向量表项。<strong>DOS 只有 int 21h 一个例程，但可以根据 ah 中的功能号调用子功能，这就是为什么程序返回指令为 <code>mov ax,4c00和int 21h</code></strong>  。</p></blockquote><p><strong><mark class="hl-label blue">中断过程</mark> </strong><br><strong>用中断码 N 找到中断向量，并用它设置 CS:IP，这个过程由 CPU 硬件自动完成</strong> ，此过程被称为中断过程。由于处理完中断后，之前的程序应该恢复，所以执行中断前需要保存 CPU 现场（保存标志寄存器即可，其他寄存器会在中断处理内部保存）。中断过程如下：</p><ol><li>取得中断码 N</li><li>pushf</li><li>TF=0，IF=0</li><li>push CS</li><li>push IP</li><li>IP=N×4，CS=N×4+2</li></ol><p>以上过程由 cpu 硬件自动完成，无需人为干预。</p><p><strong><mark class="hl-label blue">中断处理程序规范</mark> </strong></p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>iret</li></ol><p><strong><mark class="hl-label blue">响应中断的特殊情况</mark> </strong><br>有些情况下，CPU 执行完当前指令后，即使发生中断，也不会响应。比如，向 SS 寄存器传送数据后，就算发生单步中断，CPU 也不会响应。原因是 SS:SP 联合指向栈顶，对它们的赋值应该连续完成，即，向 SS 赋值后，应立即向 SP 赋值，否则一旦 SS 赋值后发生中断， SS:SP 就指向了错误的栈顶，将引起错误。</p><p><strong><mark class="hl-label blue">int中断</mark> </strong><br><code>int n</code> 调用中断码为 n 的中断过程。int 和 call 类似，都是调用一段程序。系统将某些子程序以 int 中断的方式提供给应用程序调用。比如程序返回指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><h4 id="font-color-gree-外中断-font"><font color='gree'>外中断</font></h4><p>CPU 通过外中断来处理外设引发的事件。 <strong><font color='orange'>外中断分为可屏蔽中断和不可屏蔽中断，IF 只对外中断有效</font></strong> ：当 IF=1，进入中断程序后，允许转向可屏蔽中断；IF=0则不可。遇上不可屏蔽中断，无论 IF 为多少，都转向不可屏蔽中断。几乎所有外中断都是可屏蔽中断，电源断电等引起不可屏蔽中断。</p><h3 id="font-color-red-端口-font"><font color='red'>端口</font></h3><p><strong><mark class="hl-label blue">什么是端口</mark> </strong><br><strong>CPU 可以直接从以下三个地方直接读取数据：</strong></p><ol><li><strong>CPU 内部寄存器</strong></li><li><strong>内存单元</strong></li><li><strong>端口</strong></li></ol><p>前两者我们已经很清楚，那么端口是什么呢？端口是各种接口芯片上可供 CPU 读写的寄存器。CPU 将不同接口芯片的寄存器映射在内存中，形成统一的端口地址空间，这样就方便了对端口的读写。CPU 通过<font color='orange'>读写端口或内存映射</font>来间接访问硬件。关于端口更详细的讨论，见 <a href="https://blog.ours1984.top/posts/iomp/#%E8%BE%B9%E9%99%85%E6%95%88%E5%BA%94">端口详解</a> 。</p><p><strong><mark class="hl-label blue">读写端口</mark> </strong><br>使用 <code>in</code> 和 <code>out</code> 指令读写端口，且只能使用 AX 或 AL 存放从端口读入或要输出到端口的指令，访问 8 位端口用 AL，16 位端口用 AX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#从60h号端口读数据，传送给al寄存器</span><br><span class="line">in al,60h</span><br><span class="line">#向20h号端口输入数据。</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure><h3 id="font-color-red-寄存器用法总结-font"><font color='red'>寄存器用法总结</font></h3><p>8086 CPU 中所有寄存器都是 16 位，而 8086 上一代 CPU 中寄存器都为 8 位， <strong><font color='orange'>为了保证兼容，使基于上一代 CPU 编写的程序稍加修改就能运行于 8086 之上，8086 CPU 中的通用寄存器（AX, BX, CX, DX）都可以分为两个可独立使用的 8 位寄存器。</font></strong></p><p><strong><mark class="hl-label blue">通用寄存器</mark> </strong></p><p><strong>8 个通用寄存器：<font color='gree'>AX、BX、CX、DX、SI、DI、SP、BP</font></strong> ；下面列出这几个寄存器的名字，以展现其常见用途：<br><strong>AX</strong> ：累加器(Accumulator)；<br><strong>BX</strong> ：基地址寄存器(Base Register)；<br><strong>CX</strong> ：计数寄存器（Count Register）；<br><strong>DX</strong> ：数据寄存器（Data Register）；<br><strong>SI</strong>  ： 源索引寄存器(Source Index Register)；<br><strong>DI</strong>  ：目标索引寄存器(Destination Index Register)；<br><strong>BP</strong> ：基址针寄存器(Base Pointer Register)；<br><strong>SP</strong> ：栈指针寄存器(Stack Pointer Register)；</p><p><strong><font color='gree'>AX , BX , CX , DX</font></strong> 常用来存放一般性数据。<strong>它们可以分为两个独立的寄存器</strong> ，比如 AX 可分为 AH 和 AL，BX 可分为 BH 和 BL，其他同理。<strong>注意，H 指数据高位，L 指数据低位，而非地址的高低</strong>。<strong>当数据溢出时，舍弃高位。</strong></p><p><strong><font color='gree'>SI , DI , SP , BP</font></strong> 常用于寻址操作。<strong>它们不可分为两个独立的寄存器</strong> 。</p><p>其中寄存器的专门用法为：</p><ol><li>AX：<ul><li><strong>存放被除数</strong> ：如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，<font color='orange'>高位放在 DX 中，低位放在 AX 中</font>。</li><li><strong>存放商</strong> ：如果除数为 8 位，则将<font color='orange'>商放入 AL，余数放入 AH</font>；如果除数为 16 位，<font color='orange'>则将商放入 AX，余数放入 DX</font>。</li><li><strong>存放乘数与积</strong> ：若为 8 位乘法，其中一个乘数放在 AL 中，结果放在 AX 中；若为 16 位，其中一个乘数放在 AX 中，<font color='orange'>结果高位放在 DX 中，低位放在 AX 中</font>。</li><li><strong>常用作累加器和返回值</strong> 。</li></ul></li><li>BX：<strong>[ ] 中只能为立即数、BX、SI 、DI 或 BP</strong> 。利用 Loop 和 [BX/SI/DI/BP] 可以方便地完成对内存的连续操作。 <strong><font color='orange'>但注意 [BX/SI/DI] 的默认段寄存器为 DS；[BP] 默认的段寄存器为 SS；</font></strong></li><li>CX：大多与循环或者条件判断相关，比如：<ul><li>Loop 的循环计数器</li><li><code>jcxz</code> 指令的条件判断寄存器。</li><li>控制 <code>rep</code> 指令的循环次数。</li><li>CL 存放 shl 和 shr 的位移。</li></ul></li><li>DX：被用来放整数除法产生的余数，见 AX；</li><li>SI ：见 BX；在很多字符串操作指令中, DS:SI 指向源串,而 ES:DI 指向目标串。</li><li>DI ：见 BX，SI；用 DI 与 SI 可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</li><li>BP：见 BX； <strong>BP 的作用之一就是在栈中找到函数的形参，栈中的局部变量也是通过 BP 来定位的</strong> ；</li><li>SP：[SP] 永远指向栈顶， <strong>[SP] 的默认段寄存器为 SS</strong> ；BP 和 SP 都和栈相关。</li></ol><p><strong><mark class="hl-label blue">段寄存器</mark> </strong><br><strong><font color='gree'>CS , DS , SS , ES</font></strong></p><ul><li><p>CS：代码段寄存器，配合 IP 寄存器使用。</p></li><li><p>DS：数据段寄存器，其偏址寄存器只能为：BX，BP，SI，DI。 <strong><font color='orange'>[BX/SI/DI] 的默认段寄存器为 DS</font></strong> ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure></li><li><p>SS：栈段寄存器，配合 SP 寄存器使用。<strong>任意时刻，SS : SP 指向栈顶元素</strong> 。</p></li><li><p>ES：附加段寄存器。作用与 DS 差不多，<strong>DS 偏指数据来源段，ES 偏指数据输出段</strong> ，比如源字符串和目标字符串，详见 movsb 的使用。</p></li></ul><p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器；也不能直接在段寄存器上做运算</font></strong> ；</p><p><strong><mark class="hl-label blue">标志寄存器</mark> </strong><br>flag 寄存器是按位起作用的，其中每一位都有不同的含义：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1665748273693-1.png" alt=""></p><ul><li>ZF：零标志位。它记录相关指令（ add、sub、mul、div、inc、or、and 操作）执行后，结果是否为0 。ZF = 1结果不为0，ZF = 0结果为0。</li><li>PF：奇偶标志位。它记录指令执行后，结果的所有二进制位中 1 的个数是否为偶数，如果为偶数则 PF = 1，为奇数，PF = 0。</li><li>SF：符号标志位。它记录指令执行后，结果是否为负（就是看它二进制的第一位是不是1），如果为负数则SF = 1，结果为正，SF = 0。</li><li>CF：进位标志位。在进行 <strong><font color='orange'>无符号数运算</font></strong> 的时候，它记录了运算结果的最高有效位是否向更高位进位，或从更高位借位。</li><li>OF：溢出标志位。OF记录了 <strong><font color='orange'>有符号数运算</font></strong> 的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。</li><li>DF：方向标志位。配合串传送指令 movsb，movsw 等使用。<strong>cld 指令将 DF 置为 0，则正向传送；std 将其置为 1，则反向传送</strong> 。详见后续 movsb 指令的使用。</li><li>IF ：用于中断，<strong>仅对可屏蔽中断有效</strong> 。当前中断进行时，若碰上其他可屏蔽中断，如果此时 IF=1，则暂停当前中断，转向其他中断；如果 IF=0，则必须执行完当前中断后，才能执行其他中断。若碰上不可屏蔽中断，则无论 IF 为多少，当前中断暂定，转向其他中断。<strong>sti 指令设置 IF=1，cli 设置 IF=0。</strong></li><li>TF：TF=1，机器进入单步工作方式，每条机器指令执行后，显示结果及寄存器状态，若TF=0，则机器处在连续工作方式。此标志为调试机器或调试程序发现故障而设置。</li><li>AF：辅助进位标志。在进行算术运算的时候，当两个字节相加减时，如果从第 3 位向第 4 位(从第0位算起)形成了进位或借位，则AF=1，否则AF=0；</li></ul><p><strong>mov、push、pop等传送指令不修改标志寄存器的信息。</strong> 如何在 debug 中查看标志寄存器，请移步<a href="#%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">工具使用</a>   。</p><p><strong><mark class="hl-label blue">指令指针寄存器</mark> </strong><br>IP 配合 CS 使用，<strong>IP 永远指向<font color='orange'>下一条指令</font>的偏移地址</strong>。任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。</p><h3 id="font-color-red-汇编指令用法总结-font"><font color='red'>汇编指令用法总结</font></h3><p><strong><mark class="hl-label blue">mov</mark> </strong><br><code>mov</code> 指令被称为传送指令，用于修改内存或寄存器的值。 <strong><font color='orange'>注意，<code>mov</code> 指令无法用来设置 CS，IP 的值</font></strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br></pre></td></tr></table></figure><p>注意，<code>mov</code> 只能有如下几种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,立即数</span><br><span class="line">mov 寄存器,寄存器</span><br><span class="line">mov 寄存器,内存单元</span><br><span class="line">mov 内存单元,寄存器</span><br><span class="line">mov 段寄存器,寄存器</span><br><span class="line">mov 内存单元,立即数</span><br></pre></td></tr></table></figure><p>不能 <code>mov 内存单元,内存单元</code> 和 <code>mov 段寄存器,立即数</code> 。 <strong><font color='orange'>需要说明的是，<code>mov 内存单元,立即数</code> 时，必须指明其数据类型是字还是字节：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr[0],12h</span><br><span class="line">mov word ptr[0],1234h</span><br></pre></td></tr></table></figure><p>其中，<code>ptr</code> 不可省略。以上规则同样适用于 <code>sub</code> ，<code>add</code> 指令。</p><p><strong><mark class="hl-label blue">jmp</mark> </strong></p><p><code>jmp</code> 指令用于指令的跳转，有以下几种用法：</p><ul><li><p><code>jmp 段:偏移</code> ：同时修改 CS : IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 1000:0012</span><br><span class="line">#5</span><br><span class="line">mov cs,1000h</span><br><span class="line">mov ip,0012h</span><br></pre></td></tr></table></figure></li><li><p><code>jmp reg</code> ： 修改 IP 为 reg 寄存器中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp ax</span><br><span class="line">#效果等价于</span><br><span class="line">mov ip,ax</span><br></pre></td></tr></table></figure></li><li><p><code>jmp short 标号/数值</code> ：执行段内短转移，对 IP 的修改范围为 -128~127；此方式是利用<font color='orange'>当前 jmp 指令的下一条指令</font>到标号的偏移量来跳转的，而非利用标号的绝对地址来跳转。实际上 <code>jmp short 标号</code> 的功能为 <code>IP=IP+8位位移</code> ；位移在汇编时期算出，用补码表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,1</span><br><span class="line">    inc ax</span><br><span class="line">jmp short start</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p><code>jmp near 标号/数值/寄存器/内存</code> 执行段内近转移；同 <code>jmp short 标号</code> 类似，利用相对移位进行跳转，但对 IP 的修改范围为 -32768~32767，为 16 位位移。</p></li><li><p><code>jmp far 内存/数值</code> 执行段间转移，又称远转移。与前两者不同，此方式利用的是 CS:IP 绝对地址。</p></li><li><p><code>jmp word ptr 内存单元</code> 段内转移。</p></li><li><p><code>jmp dword ptr 内存单元</code> 段间转移，<strong>内存单元中高地址的字存放段地址，低地址的字存放偏移地址。</strong></p></li></ul><p><strong><mark class="hl-label blue">add与sub</mark> </strong><br><code>add</code> 与 <code>sub</code> 分别执行加法和减法。所支持格式和 <code>mov</code> 相同。</p><p><strong><mark class="hl-label blue">pop与push</mark> </strong><br><code>push ax</code> ：（1）<code>SP = SP - 2</code>       （2）<code>mov SS:[SP],ax</code> ；</p><p><code>pop ax</code>   ：（1）<code>mov ax,SS:[SP]</code> （2）<code>SP = SP + 2</code> ；</p><p><strong>注意以下几点：</strong></p><ol><li><strong><font color='orange'>8086 的入栈出栈必须以字为单位进行操作</font></strong></li><li><strong><font color='orange'>操作数只能为内存或寄存器，不能为立即数，比如：<code>push 12</code> </font></strong></li><li><strong><font color='orange'>SS:SP 指向栈顶，没有寄存器自动指向栈底(一般用BP手动指向栈底)，所以必须自己操心栈顶超界的问题，栈顶 SS:SP 超界会导致严重后果。</font></strong></li><li><strong>栈顶的变化范围为 0~FFFF，栈满时如果仍继续压栈，会循环覆盖之前的内容。</strong></li></ol><img src="/2022/img/未命名绘图-1665624319178-11.png" style="zoom:67%;" /><p><strong><mark class="hl-label blue">pusha与popa</mark> </strong><br><code>pusha</code> 指令的作用是把通用寄存器压栈。寄存器的入栈顺序依次是：AX,CX,DX,BX,SP,BP,SI,DI。<code>popa</code> 指令按照相反顺序将同样的寄存器弹出堆栈。<strong>过程用一个或多个寄存器来返回结果时，不应使用 PUSHA 和 POPA，因为其值会被 POPA 覆盖</strong> 。</p><p><strong><mark class="hl-label blue">inc与dec</mark> </strong></p><p><code>inc</code> 对寄存器自增 1，<code>dec</code> 对寄存器自减 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inc ax</span><br><span class="line">dec bx</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">dec byte ptr [bx]</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">Loop</mark> </strong><br><code>loop</code> 的格式为：<code>loop 标号</code> ；进行 Loop 操作时进行如下两步操作：</p><ol><li><p><code>cx = cx - 1</code></p></li><li><p>判断 CX 中的值，不为零则跳转到标号继续循环，为零则往下运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,5</span><br><span class="line">s:  </span><br><span class="line">inc ax</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure></li></ol><p>注意，是先减再判断！ <strong>循环指令都是短转移。</strong></p><p><strong><mark class="hl-label blue">and与or</mark> </strong><br>分别是按位与和按位或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10010010B</span><br><span class="line">and al,11101111B</span><br><span class="line">or  al,11101110B</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">test</mark> </strong><br>Test 对两个参数 (目标，源) 执行 AND 逻辑操作（&amp;&amp;而非&amp;），并根据结果设置标志寄存器，<strong>结果本身不会保存</strong> 。</p><p><code>TEST AX,BX</code> 与 <code>AND AX,BX</code> 命令有相同效果，只是 Test 指令不改变 AX 和 BX 的内容，而 AND 指令会把结果保存到 AX 中。</p><p><strong><mark class="hl-label blue">div</mark> </strong><br><strong><code>div</code> 指令进行无符号除法操作，<code>idiv</code> 执行有符号除法</strong> 。如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，高位放在 DX 中，低位放在 AX 中。<strong>存放商</strong> ：如果除数为 8 位，则将商放入 AL，余数放入 AH；如果除数为 16 位，则将商放入 AX，余数放入 DX。有以下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div 十六位/八位寄存器</span><br><span class="line">div word/byte ptr 内存地址</span><br></pre></td></tr></table></figure><p>计算 100001 ÷ 100（186A1H ÷ 64H）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1H</span><br><span class="line">mov dx,186AH</span><br><span class="line">mov cx,64H</span><br><span class="line">div cx</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">mul</mark> </strong><br><strong><code>mul</code> 为无符号数乘法，<code>imul</code> 为有符号数乘法</strong> 。相乘的数，要么都是 8 位，要么都是 16 位。<br>8 位：一个默认放在 AL 中，另一个由操作数给出，放在 8 位寄存器或内存中(<u>不能为立即数</u>)；结果默认放在 AX中。</p><p>16 位：一个默认放在 AX 中，另一个由操作数给出，放在 16 位寄存器或内存中(<u>不能为立即数</u>)；结果高位放在 DX 中，低位放在 AX 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#8位</span><br><span class="line">mov al,5h</span><br><span class="line">mov bl,15h</span><br><span class="line">mul bl</span><br><span class="line">#16位</span><br><span class="line">mov ax,0fffh</span><br><span class="line">mov dx,1111h</span><br><span class="line">mul dx</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">jcxz</mark> </strong><br><code>jcxz</code> 指令为有条件转移指令， <strong><font color='orange'>所有的有条件转移指令都为短转移</font></strong> 。当 CX=0 ，则进行跳转。另外，根据</p><p><strong><mark class="hl-label blue">ret与retf</mark> </strong><br><code>ret</code>   ：（1）IP = SS:[SP]；（2）SP = SP+2；相当于POP IP；<br><code>ret imm</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）SP = SP+imm；相当于 POP IP，SP+=imm；通常用于内平栈。</p><p><code>retf</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）CS = SS:[SP]；（4）SP = SP+2；</p><p><strong><mark class="hl-label blue">call</mark> </strong><br><code>call 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）jmp near 标号；<strong>实现段内转移</strong><br><code>call far 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）jmp far 标号；<strong>实现段间转移</strong><br><code>call 16位reg</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = reg；<strong>实现段内转移</strong></p><p><code>call word ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = 内存单元中的值；<br><code>call dword ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）CS = 内存中高地址的字；（6）IP = 内存中低地址的字</p><p><strong><mark class="hl-label blue">adc</mark> </strong><br>带进位加法指令。指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc operand1,operand2</span><br></pre></td></tr></table></figure><p>功能：oprand1 = operand1 + operand2 + CF<br>这个指令的作用看上去比较鸡肋，但实际上对于大数运算很有帮助。首先我们知道这样一个常识：<br><strong>加法分两步执行：1）低位相加；2）高位相加再加上低位相加的进位值。</strong> 例如下面的指令与 <code>add ax,bx</code> 有完全相同的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br><span class="line">#结果储存在ax中</span><br></pre></td></tr></table></figure><p>16 位 CPU 如何计算 32 位数的运算？比如 <code>11FF89FF33420010</code> + <code>12983476FFAAB444</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,11FF89FF #ax存第一个加数的高位</span><br><span class="line">mov bx,33420010 #bx存第一个加数的低位</span><br><span class="line">add bx,FFAAB444</span><br><span class="line">adc ax,12983476</span><br><span class="line">#结果在ax与bx中，ax存高位，bx见低位</span><br></pre></td></tr></table></figure><blockquote><p>这个指令是字长还只有8位时发明的，当时八位寄存器经常难以承担运算任务，所以 adc 必不可少。现在已经进入 32/64 位时代，除了科学计算，一般都够用了。</p></blockquote><p><strong><mark class="hl-label blue">sbb</mark> </strong><br>带位减法指令，原理和 adc 相同，不再解释。</p><p><strong><mark class="hl-label blue">cmp</mark> </strong><br>cmp 指令用来比较大小，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp operand1,operand2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##对于无符号数，通过zf,cf来判断：</span><br><span class="line">如果(ax)=(bx)则(ax)-(bx)=0,所以: zf=1;</span><br><span class="line">如果(ax)≠(bx)则(ax)-(bx)≠0,所以: zf=0;</span><br><span class="line">如果(ax)&lt;(bx)则(ax)-(bx)将产生借位,所以: cf=1;</span><br><span class="line">如果(ax)&gt;=(bx)则(ax)-(bx)不必借位,所以: cf=0;</span><br><span class="line">如果(ax)&gt;(bx)则(ax)-(bx)既不必借位,结果又不为0,所以: cf=0并且zf=0;</span><br><span class="line">如果(ax)&lt;=(bx)则(ax)-(bx)既可能借位,结果可能为0,所以: cf=1或zf=1。</span><br><span class="line">##对于有符号数：通过zf,sf,cf来判断</span><br><span class="line">如果ax&lt;bx则ax-bx&lt;0,所以: (sf=1并且of=0)或(sf=0,of=1)</span><br><span class="line">如果ax=bx则ax-bx=0,所以: zf=1</span><br><span class="line">如果ax&gt;=bx则ax-bx&gt;=0,所以: sf=0并且zf=0</span><br><span class="line">如果ax&gt;bx则ax-bx&gt;0,所以: sf=1并且of=1</span><br></pre></td></tr></table></figure><p>要理解这种工作机制背后的思想。</p><p><strong><mark class="hl-label blue">根据比较结果进行跳转</mark> </strong><br><strong>无符号比较：</strong></p><table><thead><tr><th>指令</th><th>含义</th><th>检测标志位</th><th>助记</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf=1</td><td>jump if equal</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf=0</td><td>jump if not equal</td></tr><tr><td>jb</td><td>小于则转移</td><td>cf=1</td><td>jump if blow</td></tr><tr><td>jnb</td><td>不小于则转移</td><td>cf=0</td><td>jump if not blow</td></tr><tr><td>ja</td><td>大于则转移</td><td>cf=0且zf=0</td><td>jump if above</td></tr><tr><td>jna</td><td>不大于则转移</td><td>cf=1或zf=1</td><td>jump if not above</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx</span><br><span class="line">jne start</span><br></pre></td></tr></table></figure><p>其他根据比较结果进行跳转的指令参考<a href="http://c.biancheng.net/view/3567.html">跳转指令汇总</a></p><p><strong><mark class="hl-label blue">movsx</mark> </strong></p><p>常用的有 movsb，movsw，movsd 。<br>将源字符串高效地传送到目的地，movsb 相当于以下几步操作：<br>1）<code>ES:[DI]=DS:[SI]</code><br>2）如果 DF=0，则 <code>SI++,DI++</code> ；如果 DF=1，则 <code>SI--,DI--</code> ；<br>movsw 类似，只是每次移动两个字节：如果 DF=0，则 <code>SI+=2,DI+=2</code> ；如果 DF=1，则 <code>SI-=2,DI-=2</code> ；<br>movsd 则每次移动四个字节。</p><p>cld 指令将 DF 置为 0，std 将其置为 1。<br>movsb 与 movsw 通常和 rep 指令搭配使用，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">###等价于</span><br><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>可见，rep 的功能就是根据 CX 中的值重复循环后面的指令。程序演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db 11h,22h,33h,44h,55h,66h,77h,88h</span><br><span class="line">db 8 dup(0)</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,8</span><br><span class="line">mov cx,8</span><br><span class="line">rep movsb</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">pushf与popf</mark> </strong></p><p>pushf 的功能是<font color='orange'>标志寄存器</font>的值压栈，popf 从栈中弹出数据，送入标志寄存器中。该指令与中断有关，详见 <a href="#%E4%B8%AD%E6%96%AD">中断</a></p><p><strong><mark class="hl-label blue">iret</mark> </strong><br>功能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>该指令用于中断程序的返回。</p><p><strong><mark class="hl-label blue">shl与shr</mark> </strong><br><code>shl</code> 逻辑左移，<code>shr</code> 逻辑右移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl ax,1</span><br><span class="line">mov cl,4</span><br><span class="line">shl ax,cl</span><br></pre></td></tr></table></figure><p>当移动位数大于 1 时，必须将移动位数放入 CL；<strong>以上指令将最后移出的一位写入 CF 中</strong> 。</p><p><strong><mark class="hl-label blue">seg</mark> </strong></p><p>取得某一标号的段地址。</p><p><strong><mark class="hl-label blue">程序返回</mark> </strong><br>使用如下命令进行程序返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>此指令相当于 main() 函数中的 <code>return 0</code> 语句。</p><h3 id="font-color-red-伪指令总结-font"><font color='red'>伪指令总结</font></h3><blockquote><p><strong>以下伪指令为 masm 的格式</strong> ，nasm 与 masm 格式的区别见文末。</p></blockquote><p>伪指令由汇编器识别并进行相关汇编工作，没有对应的机器码。 <strong><font color='red'>可执行文件由描述信息和程序组成，程序来源于源程序( .asm文件 )中定义的指令和数据；描述信息则来自于 .asm 文件中的伪指令，比如程序入口地址就由伪指令 end 提供</font></strong> 。 <strong><font color='gree'>注意，伪指令的类型随汇编器的种类不同而不同，比如 masm 和 nasm 就不一样，以下伪指令为 masm 的格式。</font></strong><br>常见伪指令如下：</p><ol><li><p><code>segment</code> 和 <code>ends</code> 是成对出现的伪指令，用来定义一个段；前者说明段的开始，后者说明段的结束。</p></li><li><p><code>end</code> （注意不是 <code>ends</code> ）用来标记整个汇编程序的结束，<strong>其后可以跟标号，指明程序的入口</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,ds:[0]</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>end start</code> 指明程序入口为第八行的 <code>start</code> 。</p></li><li><p><code>assume</code> 用来假设某一段寄存器和程序中某个用 <code>segment</code> 和 <code>ends</code> 定义的段相关联。</p></li><li><p><code>+</code> 、<code>-</code> 号等，只能用立即数，在汇编时期就会算出结果。如：<code>mov ax,90-4</code></p></li><li><p><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明段内存空间，即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack1 segment</span><br><span class="line">dw 0FFFF,0FFFF,0FFFF</span><br><span class="line">stack1 ends</span><br><span class="line"></span><br><span class="line">stack2 segment</span><br><span class="line">db 11,22,33,44</span><br><span class="line">stack2 ends</span><br></pre></td></tr></table></figure></li><li><p><code>dup</code> 指令用来声明装载重复数据的内存空间，比如上面代码中第 2 行可以写作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   stack1 segment</span><br><span class="line">   dw 3 dup(0FFFF)</span><br><span class="line">   stack1 ends</span><br><span class="line"></span><br><span class="line">7. `offset` 用来取得标号到段首的偏移量，如下：</span><br><span class="line"></span><br><span class="line">   ```assembly</span><br><span class="line">   codesg segment</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">   start:</span><br><span class="line">   mov bx,offset start</span><br><span class="line">   code ends</span><br></pre></td></tr></table></figure><p>bx 中即取得 start 标号地址（实际就是第五行 <code>mov</code> 的地址）到 codesg （第二行 <code>mov</code> 的地址）的偏移量。可以用 offset 求某段的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov bx,45h</span><br><span class="line">mov cx,8</span><br><span class="line">push cx</span><br><span class="line">push bx</span><br><span class="line">mov dx,offset s - offset start</span><br><span class="line">s:nop</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure></li><li><p>汇编中除了汇编指令和伪指令外，还有标号，例如 <code>codesg segment</code> 中的 <code>codesg</code> 。标号是地址的助记符，标号本身即代表地址。如下代码第 9 行。<strong>注意，<code>:</code> 只能在代码段使用</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p>数据标号：带有单元长度的标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a dw 0FFFFh,0EEEEh</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">inc b[0] ##无需word ptr</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-汇编规则总结-font"><font color='red'>汇编规则总结</font></h3><ul><li><p>注释以分号 <code>;</code> 开头。</p></li><li><p>指令的两个操作对象的位数必须一致，以下是不正确的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bl</span><br><span class="line">add bh,1000</span><br></pre></td></tr></table></figure></li><li><p>AH 与 AL 是两个独立的寄存器，不要错误地认为 <code>add al,93H</code> 指令产生的进位会储存在 AH 中。</p></li><li><p>数据在内存 21F60 单元中，专业说法应该为：2000:1F60 单元中。</p></li><li><p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器，也不允许直接在段寄存器上做运算</font></strong> ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">mov ss,1100</span><br><span class="line">#正确</span><br><span class="line">mov ax,1100</span><br><span class="line">mov ss,ax</span><br></pre></td></tr></table></figure></li><li><p>mov 指令中给出 16 位寄存器，就进行 16 位数据传送；若给出 8 位寄存器，则进行 8 位数据传送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure><p><strong>对于没有寄存器参与的内存单元操作指令中，必须要用 <code>word ptr</code> 和 <code>byte ptr</code> 指明操作长度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [0],0fffh</span><br><span class="line">inc byte [0]</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>注意，在编写汇编代码时，如果数字后没H或没有前缀0x，则视为十进制数，汇编过程中自动再转为十六进制。</font></strong></p></li><li><p>为了使程序更加清晰合理，一般将数据、代码、栈放在不同的段中。由于寄存器最大为 16 位，所以一个段的容量最大也为 64KB</p></li><li><p><strong>8086 CPU 的转移指令分为以下几类：1）无条件转移指令(jmp)；2）条件转移指令(jcxz)；3）循环指令(loop)；4）call 与 ret；5）中断</strong></p></li><li><p>如前所述，<code>jmp short 标号</code> ，<code>jmp near 标号</code> ，<code>jcxz 标号</code> ，<code>loop 标号</code> 都是根据相对位移来进行转移的。这样做的好处是方便了程序的整体移动。比如我把这段程序中的某段代码移植到其他程序中，就只需要更改段寄存器。</p></li><li><p>设置 SS 后必须紧接着设置 SP！！！原因见内中断。</p></li></ul><h3 id="font-color-red-程序设计规范-font"><font color='red'>程序设计规范</font></h3><p>后续补充、、、先列个目录：</p><ul><li>10.10 参数和结果的传递</li><li>10.11批量数据的传递</li><li>10.12寄存器冲突</li><li>在子程序内部保存用到的寄存器。</li></ul><h3 id="font-color-red-代码实验-font"><font color='red'>代码实验</font></h3><p>一. 往屏幕中间输出 hello（masm下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;h&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;o&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,1660</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>彩色模式详见王爽《汇编语言第四版》第188页。</p><h3 id="font-color-red-工具使用-font"><font color='red'>工具使用</font></h3><blockquote><p>汇编工具下载链接：<a href="https://pan.baidu.com/s/19TWArrfgDA06_IOYwUUDlg?pwd=gzwb">汇编工具</a><br>提取码：gzwb</p></blockquote><p><strong><mark class="hl-label blue">工具的安装和配置</mark> </strong></p><p>Debug 是 Dos 和 Windows 都提供的 <strong>实模式 (8086方式)</strong> 程序的调试工具，它可以查看 CPU 中各种寄存器的值和内存的使用情况，并能够在机器码级跟踪程序的运行。参见 <a href="https://blog.csdn.net/plus_re/article/details/60761467">DosBox安装</a> 。DosBox 安装好后直接将 LINK.exe 、masm.exe 和 Debug.exe 放入 DosBox 的根目录中。</p><p><strong><mark class="hl-label blue">Debug指令</mark> </strong></p><ul><li><p>R：查看或改变寄存器的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r</span><br><span class="line">AX=0000 BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC 073F:0100  0000ADD[BX+SI],ALDS:0000=CD</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r AX</span><br><span class="line">AX 0000</span><br><span class="line">:FFFF</span><br><span class="line">-r </span><br><span class="line">AX=FFFF BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC </span><br><span class="line">073F:0100  0000  ADD[BX+SI],ALDS:0000=CD #下一次要执行的指令</span><br></pre></td></tr></table></figure><p>第二行最后八对字母是标志寄存器的状态，含义如下：</p><table><thead><tr><th>标志</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>OF</td><td>OV</td><td>NV</td></tr><tr><td>SF</td><td>NG</td><td>PL</td></tr><tr><td>ZF</td><td>ZR</td><td>NZ</td></tr><tr><td>PF</td><td>PE</td><td>PO</td></tr><tr><td>DF</td><td>DN</td><td>UP</td></tr><tr><td>AF</td><td>AC</td><td>NA</td></tr><tr><td>IF</td><td>EI</td><td>DI</td></tr></tbody></table></li><li><p>D：查看内存中的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>E：修改内存中的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-e 1000:0</span><br><span class="line">1000:0000   00.FF   00.11 #按空格继续修改，回车终止</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   FF 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li><li><p>U：将内存中的指令翻译成汇编指令。</p></li><li><p>T：执行一条机器指令。</p></li><li><p>A：以汇编指令的形式向内存写入机器指令；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br><span class="line">073F:0100 MOV AX,FF</span><br><span class="line">073F:0103 ADD BX,EE</span><br><span class="line">-u 073F:0100</span><br><span class="line">073F:0100  BBFF00    MOV AX,FF</span><br><span class="line">073F:Θ103  81C3EE00  ADD BX,ΕΕ</span><br></pre></td></tr></table></figure></li><li><p>P：执行指令，不过遇到子程序代码时，直接完成子程序的执行，类似于 VS 调试时使用 F10，而 T 相当于 F11；遇到循环时，直接执行到 CX=0；</p></li><li><p>G： 该命令后面可以跟地址和断点，运行到内存指定位置的代码后暂停，如果不加参数默认是从当前IP运行到程序结束。</p></li></ul><p><strong><font color='orange'>注意，在debug中所有数据被视为十六进制，不能在数据后再加H；而在编写汇编代码时，如果数字后没H，则视为十进制数，汇编过程中再转为十六进制。</font></strong></p><p><strong><mark class="hl-label blue">生成可执行文件</mark> </strong><br>编写 test.asm 后保存，在 DosBox 中输入 <code>masm</code> ，然后输入 <code>test.asm</code> ，连续回车；接着输入 <code>link test.obj</code> ，连续回车；最后 <code>debug test.exe</code> 即可。</p><h3 id="font-color-red-Dos下exe文件加载过程-font"><font color='red'>Dos下exe文件加载过程</font></h3><img src="/2022/img/IMG_0468(20221013-103739).PNG" style="zoom:80%;" /><p>程序加载后，DS 指向 PSP 的起点，CS 指向程序的入口。PSP 的作用和程序加载器差不多，关于程序加载器，见另一篇文章：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p><h3 id="font-color-red-补充：nasm-的使用-font"><font color='red'>补充：nasm 的使用</font></h3><p>后续学习操作系统的过程中我们都会在 Linux 下采用 nasm 。原因 nasm 可以直接生成纯二进制文件，不夹杂其他的文件信息，而 masm 则会自动生成文件信息（利用 assume, start, end 等伪指令生成信息），不利于我们探究其中的细节。</p><p><strong><mark class="hl-label blue">命令行语法</mark> </strong><br>1）将文件进行汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将myfile.s生成bin文件，生成的文件名为myfile</span></span><br><span class="line">nasm -f bin myfile.s</span><br><span class="line"><span class="comment">#将myfile.s生成bin文件，指定生成的文件名为myfile.bin</span></span><br><span class="line">nasm -f bin myfile.s -o myfile.bin</span><br></pre></td></tr></table></figure><blockquote><ul><li>汇编文件后缀在 Linux 下以 <code>.s</code> 为主，在 Windows 下以 <code>.asm</code> 为主。</li><li><code>.bin</code> 文件是纯二进制文件，其中只包含汇编指令，可以直接给 CPU 使用。而 ELF 或 PE 文件是二进制可执行文件，除了指令外还包含很多文件信息，用来给程序加载器使用。</li></ul></blockquote><p>2）生成列表文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f coff myfile.s -l myfile.lst</span><br></pre></td></tr></table></figure><p>列表文件很方便我们对照阅读汇编代码和其对应的二进制代码：<br><img src="/2022/img/image-20221030102024363.png" alt=""></p><p>3）预包含文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm myfile.s -p myinc.inc</span><br></pre></td></tr></table></figure><p>跟在源文件开头写上 <code>%include &quot;myinc.inc&quot;</code> 是等效的。这种包含头文件的方式将在后面我们写加载器时带来很大的方便。</p><p><strong><mark class="hl-label blue">伪指令</mark> </strong><br><strong>1）段定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section .data [vstart] [align]</span><br></pre></td></tr></table></figure><p>masm 的段定义格式为 <code>data segment</code> 。关键字 vstart 很不好理解，关于 vstart 和 align 的详细讨论参见：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p><blockquote><p><code>.data</code> ，<code>.code</code> ，<code>.bss</code> ，<code>.text</code> 是标准的段名。<br><code>.data</code> ：用来存放程序中已初始化的全局变量的一块内存区域；<br><code>.bss</code>   ：用来存放程序中未初始化的全局变量的一块内存区域；<br><code>.code\.text</code> ：用来存放程序代码</p></blockquote><p><strong>2）$ 和 $$</strong><br>此二者常用来计算偏移量或文件大小。$ 表示当前行的汇编地址， $$ 表示本 section 的起始汇编地址， 它们两都受 vstart 影响。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section .data vstart=0x100</span><br><span class="line">db &quot;hello&quot;</span><br><span class="line">db $-$$</span><br></pre></td></tr></table></figure><p>以上 $ 的值为 <code>0x100+5=0x105</code> ，$$ 的值为 0x100 。</p><p><strong>3）声明重复内存单元</strong><br>masm 中使用如下格式声明重复的零内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw 100 dup(0)</span><br></pre></td></tr></table></figure><p>nasm 则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 100 db 0</span><br></pre></td></tr></table></figure><p><strong>4）段前缀</strong><br>在 masm 下可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[1000]</span><br></pre></td></tr></table></figure><p>在 nasm 下则必须这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[ds:1000]</span><br></pre></td></tr></table></figure><p><strong>5）指明内存操作数的大小</strong><br>在 masm 中必须使用 <code>size ptr</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte ptr [1000]</span><br></pre></td></tr></table></figure><p>在 nasm 中不需要加 <code>ptr</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte [1000]</span><br></pre></td></tr></table></figure><p><strong>6）equ 定义宏</strong><br>equ 用来为标识符定义一个整型常量，它的作用类似 C 语言中的宏。equ 不占任何内存，编译时会自动替换成相应值。</p><p><strong>7）定义数据</strong></p><ul><li><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明初始化内存空间（用于 .data 段），即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</li><li><code>resw</code> ，<code>resb</code> ，<code>resd</code> ，<code>resq</code> 用来声明非初始化内存空间（用于 .bss 段）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写加强堆</title>
      <link href="/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/"/>
      <url>/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>不了解堆结构的同学请先移步《<a href="https://jyxcpp.netlify.app/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/">堆与堆排序</a>》</p></blockquote><p><strong><mark class="hl-label blue">什么是加强堆？</mark> </strong><br>我们现在知道，堆结构主要用来处理海量数据下的动态优先级问题，需要频繁入队和频繁把优先级最高的元素出队。但有一种情形是普通堆结构难以高效处理的：一旦堆中的数据发生改变，如果不维护，此堆将作废无法使用；如果维护，那么定位发生变动的元素所需要的时间复杂度就为 O(N) ，其性能变得低效。为了应对堆中数据可能发生改变的情况，加强堆闪亮登场。</p><p>加强堆与普通堆的不同之处在于：加强堆使用了一张哈希表来记录元素及其所在位置。当元素发生变动时，可以由这张表快速定位到所在位置，从而进行相应调整。注意，哈希表的键为元素，值为其对应的位置，即数组下标；而数组本身也是算一张索引表，数组下标是索引，数组内容则是元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heapGreater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">unordered_multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; indexMap;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">tmp = indexMap.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap.<span class="built_in">find</span>(a)-&gt;second = indexMap.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap.<span class="built_in">find</span>(b)-&gt;second = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (heap[(cur - <span class="number">1</span>) / <span class="number">2</span>] &lt; heap[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[(cur - <span class="number">1</span>) / <span class="number">2</span>], heap[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>((cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; ((<span class="type">int</span>)heap.<span class="built_in">size</span>() - <span class="number">1</span>))<span class="comment">//heap.size()返回的是无符号数size_t，若返回0，减1后为最大正数</span></span><br><span class="line"><span class="keyword">return</span>;                          <span class="comment">//所以必须要强制转为int</span></span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; (<span class="type">int</span>)heap.<span class="built_in">size</span>() &amp;&amp; heap[leftChd + <span class="number">1</span>] &gt; heap[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (heap[largest] &gt; heap[cur])<span class="comment">//大堆顶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[largest], heap[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (indexMap.<span class="built_in">find</span>(var) != indexMap.<span class="built_in">end</span>())<span class="comment">//不能加重复值！这是本实现的局限性</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">heap.<span class="built_in">push_back</span>(var);</span><br><span class="line">indexMap.<span class="built_in">emplace</span>(var,heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">heapInsert</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[<span class="number">0</span>], heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">heap.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> index = indexMap.<span class="built_in">find</span>(var)-&gt;second;</span><br><span class="line"><span class="built_in">swap</span>(heap[index], heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);<span class="comment">//参数可以直接写var</span></span><br><span class="line">heap.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (index != heap.<span class="built_in">size</span>())<span class="comment">//！当要删除的元素位于堆末尾时，pop后不再做以下操作，否则越界。注意此处是已经pop后的，易错写为heap.size()-1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heaplify</span>(index);</span><br><span class="line"><span class="built_in">heapInsert</span>(index);<span class="comment">//两个只会执行其中一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> var1, <span class="type">int</span> var2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (var1 == var2)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> index = indexMap.<span class="built_in">find</span>(var1)-&gt;second;</span><br><span class="line">heap[index] = var2;</span><br><span class="line">indexMap.<span class="built_in">emplace</span>(var2, index);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(var1);</span><br><span class="line"><span class="built_in">heaplify</span>(index);</span><br><span class="line"><span class="built_in">heapInsert</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heapGreater shit;</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">32</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">60</span>);</span><br><span class="line">shit.<span class="built_in">modify</span>(<span class="number">10</span>, <span class="number">121</span>);</span><br><span class="line">shit.<span class="built_in">remove</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">while</span> (shit.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; shit.<span class="built_in">peek</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">shit.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础-约束</title>
      <link href="/2022/09/28/Mysql%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/"/>
      <url>/2022/09/28/Mysql%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>约束用来保证数据库中数据的有效性和正确性。</strong></p><h3 id="font-color-red-主键约束-font"><font color='red'>主键约束</font></h3><p>主键（PRIMARY KEY）的完整称呼是“主键约束”，是 MySQL 中使用最为频繁的约束。一般情况下，为了便于 DBMS 更快的查找到表中的记录，都会在表中设置一个主键。使用主键应注意以下几点：</p><ul><li><strong>每个表只能定义一个主键。</strong></li><li><strong>创建主键时，自动创建主键索引</strong></li><li><strong>主键值必须唯一标识表中的每一行，且不能为 NULL</strong> ，即表中不可能存在有相同主键值的两行数据。这是唯一性原则。</li><li>一个字段名只能在联合主键字段表中出现一次。</li><li><strong>联合主键不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则。</strong></li></ul><p><strong><mark class="hl-label blue">创建主键</mark> </strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大线段重合问题， TopK问题</title>
      <link href="/2022/09/24/%E5%8A%A0%E5%BC%BA%E5%A0%86%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/09/24/%E5%8A%A0%E5%BC%BA%E5%A0%86%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-最大线段重合问题-font"><font color='red'>最大线段重合问题</font></h3><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定很多线段,每个线段都有两个数 [start, end] ，表示线段开始位置和结束位置，左右都是闭区间规定：1）线段的开始和结束位置一定都是整数值；2）线段重合区域的长度必须&gt;=1，也就是说仅顶点重合并不算重合区域。返回线段最多重合区域中,包含了几条线段。</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong></p><p>我们一步一步分析。<br>首先，怎么判断两条线段不重合？容易想到，当 <code>line1.left &gt;= line2.right</code> 或 <code>line1.right&lt;=line2.left</code> 时，就可以判定这两条线段不重合了。如下，<code>line1.right&lt;line2.left</code> ，<code>line3.left&gt;line2.right</code> 所以 line2 与 line1、line3 都不重合。<br><img src="/2022/img/未命名绘图-16641125875741.png" alt="" style="zoom:80%;" /></p><p>接着，如何判断两条线段不重合？仔细分析后可以发现，当 <code>line1.left&lt;=line2.left&lt;line1.right</code> 时，line1 与 line2 就发生重合(无需考虑 line2.right )，如下图：<br><img src="/2022/img/未命名绘图-16641133105063.png" style="zoom:80%;" /></p><p><strong>有读者一定会疑问，当 <code>line2.left&lt;=line1.left&lt;line2.right</code> 时，不也能重合吗？</strong> <strong><font color='red'>注意，这种情况和上面的情况是相同的，只不过 line1 与 line2 互换了名字而已，这点很重要</font></strong> 。为了避免出现这两种情况的混淆，<strong>我们有必要先根据线段左端点的位置给所有线段排个序</strong> ，如下图：<br><img src="/2022/img/未命名绘图-16641151643545.png" style="zoom:80%;" /><br>排好序后，我们判断是否重合时，就只需要考虑后面线段的左端点是否大于 <strong>前面线段的右端点（<font color='orange'>基准</font>）</strong> ，即只用考虑 <code>line2.left&lt;line1.right</code> ，因为排序后必有 <code>line1.left&lt;=line2.left</code> 。<br>接着，我们来分析上图中的三条线段。<code>line2.left&lt;line1.right</code> ，故 line2 与 line1 重合；<code>line3.left=line1.right</code> ，故 line3 与 line1 不重合；<code>line3.left&lt;line2.right</code> ，故 line3 与 line2 重合，即现在有两种情况重合，且重合数都为 2。那么问题来了，我们该记录哪种情况的重合数呢？都记录？有必要吗？实际上，只需要记录 line2 与 line3 的重合数即可，这是因为后续加入的线段的左端点不可能小于 3（因为之前我们已经对所有线段完成了排序），所以后续线段不可能再与 line1 发生重合，故可以直接将 line1 丢弃（标记为绿色）；如下图：<br><img src="/2022/img/未命名绘图-16641610218953.png" style="zoom:80%;" /></p><p>引入 line4，可见现在的最大重合数为 3，但这只是我们看出来的，还需要有一个固定的逻辑比较流程。如何得到最大重合数为 3？<code>line4.left&lt;line2.right</code> 且 <code>line4.left&lt;line3.right</code> ，所以得到重合数为 3？嗯，思路大致没错，聪明的你可能还会继续优化：只需要有 <code>line4.left&lt;line3.right</code> 就可以直接得到 3，你给出的理由是：既然 <code>line3.right&lt;line2.right</code> ，又因为 <code>line4.left&lt;line3.right</code> ，所以一定有 <code>line4.left&lt;line2.right</code> ，即不等式的传递性。果真是这样吗？那如果是下图情况呢：<br><img src="/2022/img/未命名绘图-16641621240717.png" style="zoom:80%;" /></p><p>显然，<code>line4.left&lt;=line3.right</code> ，重合数只有 2。但请注意，上图出现了我们之前讨论过的情况：后续线段左节点&gt;=前面线段右节点，即<code>line4.left&gt;=line2.right</code> 。按照之前的方案，我们将先 line2 丢弃：<br><img src="/2022/img/未命名绘图-16641624724099.png" style="zoom:80%;" /><br>继续，由于 <code>line4.left&lt;line3.right</code> ，所以得到重合数为 2。</p><p>由上分析，可知大致比较过程为：<strong>当加入新线段 lineN 时，依次丢弃之前的右端点小于等于 lineN.left 的线段，剩下的线段数即为最大重合数。</strong></p><p>啊？不对呀？万一碰到下面情况：<br><img src="/2022/img/未命名绘图-166416373697811.png" style="zoom:80%;" /><br>line4 将之前所有线段都弹出了，只剩 line4 一条线段了，但最大重合数不是 1，而是 2 呀！没错，所以我们还需要一个变量 max 来记录最大重合数，若当前重合数 <code>cur&gt;=max</code> ,则 <code>max=cur</code> ；若 <code>cur&lt;max</code> 则 <code>max=max</code> ，即 <code>max=cur&gt;max?cur:max;</code> 。就上图而言，加入 line4 时，max=2；加入 line4 ，弹出之前的线段后，cur=1；cur&lt;max，所以 max 仍然为 2。</p><p>下面给出全过程图示：<br><img src="/2022/img/未命名绘图-166416692487213.png" style="zoom:80%;" /></p><p>注意：左边灰色大框是堆结构，栈顶为堆中右端点最小的 right。</p><p>其实本算法中，堆结构并不关键，堆只是提供了取集合中最小值的便捷，难的还是其过程分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//sort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(line* arr, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[(cur - <span class="number">1</span>) / <span class="number">2</span>].end &gt; arr[cur].end)<span class="comment">//小顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur - <span class="number">1</span>) / <span class="number">2</span>], arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, (cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(line* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> smallest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>].end &lt; arr[leftChd].end ? leftChd + <span class="number">1</span> : leftChd;<span class="comment">//取出左右子树中最小的</span></span><br><span class="line"><span class="keyword">if</span> (arr[smallest].end &lt; arr[cur].end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[smallest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, smallest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapPop</span><span class="params">(line* arr, <span class="type">int</span>&amp; heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[heapSize - <span class="number">1</span>]);</span><br><span class="line">heapSize--;</span><br><span class="line"><span class="built_in">heaplify</span>(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//====================================================================================================</span></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function">line* <span class="title">generateRandomline</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">line* arr = <span class="keyword">new</span> line[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i].start = <span class="built_in">rand</span>() % max;</span><br><span class="line">arr[i].end = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">if</span> (arr[i].start == arr[i].end)</span><br><span class="line">arr[i].end += (<span class="built_in">rand</span>() % max / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[i].start &gt; arr[i].end)</span><br><span class="line"><span class="built_in">swap</span>(arr[i].start, arr[i].end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">line* <span class="title">cpyArr</span><span class="params">(line* src, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">line* des = <span class="keyword">new</span> line[size];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, size * <span class="built_in">sizeof</span>(line));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCover2</span><span class="params">(line* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> minStart = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.start &lt; b.start; &#125;);</span><br><span class="line">minStart = arr[<span class="number">0</span>].start;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.end &gt; b.end; &#125;);</span><br><span class="line">maxEnd = arr[<span class="number">0</span>].end;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxEnd - minStart; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> point = (<span class="type">double</span>)minStart + (<span class="type">double</span>)i + <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">double</span>)arr[k].start&lt;point &amp;&amp; (<span class="type">double</span>)arr[k].end&gt;point)</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">count = count &gt; tmp ? count : tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCover</span><span class="params">(line* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heapSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.start &lt; b.start; &#125;);</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].end &lt;= arr[i].start &amp;&amp; heapSize &gt; <span class="number">0</span>)<span class="comment">//&lt;=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heapPop</span>(arr, heapSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">heapSize++;</span><br><span class="line">arr[heapSize - <span class="number">1</span>].end = arr[i].end;</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, heapSize<span class="number">-1</span>);</span><br><span class="line">max = max &gt; heapSize ? max : heapSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">1000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">10000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000</span>;<span class="comment">//线段终点最大位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line">line* arr_1 = <span class="built_in">generateRandomline</span>(max, arrLen);</span><br><span class="line">line* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="type">int</span> count_1 = <span class="built_in">maxCover</span>(arr_1, arrLen);</span><br><span class="line"><span class="type">int</span> count_2 = <span class="built_in">maxCover2</span>(arr_2, arrLen);</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count_1 = &quot;</span> &lt;&lt; count_1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count_2 = &quot;</span> &lt;&lt; count_2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; arr_2[i].start &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; arr_2[i].end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  success&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">line* arr = <span class="keyword">new</span> line[<span class="number">8</span>];</span><br><span class="line">arr[<span class="number">0</span>].start = <span class="number">0</span>, arr[<span class="number">0</span>].end = <span class="number">8</span>;</span><br><span class="line">arr[<span class="number">1</span>].start = <span class="number">2</span>, arr[<span class="number">1</span>].end = <span class="number">6</span>;</span><br><span class="line">arr[<span class="number">2</span>].start = <span class="number">1</span>, arr[<span class="number">2</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">3</span>].start = <span class="number">3</span>, arr[<span class="number">3</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">4</span>].start = <span class="number">4</span>, arr[<span class="number">4</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">5</span>].start = <span class="number">3</span>, arr[<span class="number">5</span>].end = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">6</span>].start = <span class="number">0</span>, arr[<span class="number">6</span>].end = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">7</span>].start = <span class="number">0</span>, arr[<span class="number">7</span>].end = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">maxCover</span>(arr, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-TopK问题-font"><font color='red'>TopK问题</font></h3><blockquote><p>进行下面问题的探讨之前，请先移步《<a href="https://jyxcpp.netlify.app/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/">加强堆</a>》 ，而后此问题将迎刃而解。</p></blockquote><h3 id="font-color-red-TopK实际应用-font"><font color='red'>TopK实际应用</font></h3><p><strong><mark class="hl-label blue">应用情形</mark> </strong><br>某大型电商举办促销活动，从早上 8 点开始到晚上 12 点结束，这段时间内购买商品最多的前 K 位用户可以获得奖励，最终结果以 12 点的统计情况为准。为了提高用户参与活动的积极性，电商希望在平台官网实时更新并显示当前的得奖区用户（前K位用户）。排名具体规则如下：<br>1）得奖系统分为得奖区和候选区，任何用户只要购买数&gt;0，一定在这两个区域中的一个；<br>2）某用户发生购买商品事件，购买商品数+1；发生退货事件，购买商品数-1；如果购买数不足以进入得奖区的用户，进入候选区；<br>3）每次都是最多 K 个用户得奖，K 也为传入的参数如果根据全部规则，得奖人数确实不够 K 个，那就以不够的情况输出结果；<br>4）如果某个用户购买商品数为 0，但是又发生了退货事件，则认为该事件无效，得奖、候选名单和上一个事件发生后一致；<br>5）购买数最大的前 K 名用户进入得奖区，<strong>在最初时如果得奖区没有到达 K 个用户，那么新来的用户直接进入得奖区；</strong><br>6）当前事件发生的时间是指该操作对应的数组下标，比如下面代码中，5 对应的时间为其下标，即 6；<br>7）如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（ <strong>大于才能替换</strong> ）；<strong>如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户；如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户；</strong><br>8）<strong>从得奖区出来进入候选区的用户，进入候选区的时间就是当前事件的时间；从候选区出来进入得奖区的用户，进入得奖区的时间就是当前事件的时间；</strong><br>其实上述规则虽然很多，但并不复杂，反而非常贴切实际生活，尤其是第 7、8 点，这些规则能够促使你不仅要买的多，也必须买的早。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">3</span> , <span class="number">3</span> , <span class="number">1</span> , <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"> op = [T , T , T , T, F, T, F]</span><br></pre></td></tr></table></figure><p>以上代码中 arr[ ] 表示客户编号，op[ ] 表示客户操作；数组内容依次表示：3 用户购买了一件商品，3 用户购买了一件商品，1 用户购买了一件商品，2 用户购买了一件商品，1 用户退货了一件商品，2 用户购买了一件商品，5 用户退货了一件商品…</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong><br><font color='orange'>注意字眼：“大型电商”——海量数据，“实时更新”——动态插入，“前K位”——优先级队列</font> 。<strong>显然，这是一类海量数据+动态插入的优先级队列问题，首先考虑用堆来解决。容易想到，候选区与得奖区应该使用两个堆分别进行维护。又观察到同一个用户可以在多个时间段进行加购和退货操作，所以必须动态调整该用户在堆中的位置，所以考虑使用加强堆</strong> 。具体过程如下：<br><img src="/2022/img/未命名绘图-16648848835431.png" style="zoom: 67%;" /></p><p>可别忘了规则中提到的几点：</p><ol><li>heap1是候选堆，heap2是得奖区。</li><li>候选区的堆顶是该堆中购买商品最多的用户，如果多个用户购买商品的数量相同，则时间点早的用户优先。得奖区的堆顶是该堆中购买商品最少的用户，如果多个用户购买商品的数量相同，则时间点早的用户优先。</li><li>当得奖区用户数没达到 K 时，新用户直接进入得奖区。</li><li>交换堆顶时，两个用户的时间点都会更新为当前的时间。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> buy;</span><br><span class="line"><span class="type">int</span> time;</span><br><span class="line"><span class="built_in">client</span>(<span class="type">int</span> _id, <span class="type">int</span> _buy, <span class="type">int</span> _time) :<span class="built_in">id</span>(_id), <span class="built_in">buy</span>(_buy), <span class="built_in">time</span>(_time) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myKey</span><span class="comment">//自定义哈希规则，注意const不能少</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> client&amp; a)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(a.id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isEqual</span><span class="comment">//自定义判断键是否相等规则，注意const不能少</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> client&amp; a, <span class="type">const</span> client&amp; b)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.id == b.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">topK</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">hp</span> &#123; cnd, win &#125;;<span class="comment">//cnd为candidate侯选区，win为得奖区</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">batchRank</span><span class="params">()</span></span>;<span class="comment">//批量排名，数据一次性交付时使用此方法1</span></span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">bool</span> buy)</span></span>;<span class="comment">//数据动态加入，边加边维护</span></span><br><span class="line"><span class="built_in">topK</span>(<span class="type">int</span>*user,<span class="type">bool</span>*buy,<span class="type">int</span> size,<span class="type">int</span> k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(client&amp; a, client&amp; b, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> cur, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span> cur, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comparator</span><span class="params">(<span class="type">const</span> client&amp; cur, <span class="type">const</span> client&amp; dad, hp p)</span></span>;<span class="comment">//比较器，减少了代码量。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapHeapTops</span><span class="params">()</span></span>;<span class="comment">//交换两个堆的堆顶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//解决流程</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;client&gt;&gt; heap;<span class="comment">//二维动态数组，heap[cnd]是候选堆，heap[win]是得奖堆</span></span><br><span class="line">unordered_multimap &lt; client, <span class="type">int</span>, myKey, isEqual&gt; indexMap1;<span class="comment">//候选堆的反向索引表</span></span><br><span class="line">unordered_multimap&lt;client, <span class="type">int</span>, myKey, isEqual&gt; indexMap2;<span class="comment">//得奖堆的反向索引表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;user;<span class="comment">//用户id</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;buy;<span class="comment">//用户购买情况</span></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">topK::batchRank</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= <span class="number">0</span>||user.<span class="built_in">size</span>()==<span class="number">0</span>||buy.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;client&gt;();<span class="comment">//返回空数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solution</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;client&gt;tops;<span class="comment">//注意不能直接在得奖堆上排序，否则后续无法add，所以另开数组进行排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap[hp::win].<span class="built_in">end</span>() - heap[hp::win].<span class="built_in">begin</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tops.<span class="built_in">push_back</span>(heap[hp::win][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(tops.<span class="built_in">begin</span>(), tops.<span class="built_in">end</span>(), [](client a, client b) &#123; </span><br><span class="line"><span class="keyword">return</span> a.buy != b.buy ? a.buy &gt; b.buy:a.time &lt; b.time; &#125;);<span class="comment">//购买商品多的排前面，如果一样多，买的早的排前面</span></span><br><span class="line"><span class="keyword">return</span> tops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">topK::add</span><span class="params">(<span class="type">int</span> id, <span class="type">bool</span> buy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;user.<span class="built_in">push_back</span>(id);</span><br><span class="line"><span class="keyword">this</span>-&gt;buy.<span class="built_in">push_back</span>(buy);</span><br><span class="line"><span class="built_in">solution</span>(user.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">vector&lt;client&gt;tops;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap[hp::win].<span class="built_in">end</span>() - heap[hp::win].<span class="built_in">begin</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tops.<span class="built_in">push_back</span>(heap[hp::win][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(tops.<span class="built_in">begin</span>(), tops.<span class="built_in">end</span>(), [](client a, client b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.buy != b.buy ? a.buy &gt; b.buy:a.time &lt; b.time; &#125;);</span><br><span class="line"><span class="keyword">return</span> tops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topK::<span class="built_in">topK</span>(<span class="type">int</span>* user,<span class="type">bool</span>* buy,<span class="type">int</span> size,<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;client&gt;heapCnd;</span><br><span class="line">vector&lt;client&gt;heapWin;</span><br><span class="line">heap.<span class="built_in">push_back</span>(heapCnd);</span><br><span class="line">heap.<span class="built_in">push_back</span>(heapWin);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;user.<span class="built_in">push_back</span>(user[i]);</span><br><span class="line"><span class="keyword">this</span>-&gt;buy.<span class="built_in">push_back</span>(buy[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::swap</span><span class="params">(client&amp; a, client&amp; b,hp p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//互换两用户在堆内的位置</span></span><br><span class="line">    client tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">    <span class="comment">//索引表中的位置信息也要互换</span></span><br><span class="line"><span class="keyword">if</span> (p == hp::cnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = indexMap1.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap1.<span class="built_in">find</span>(a)-&gt;second = indexMap1.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap1.<span class="built_in">find</span>(b)-&gt;second = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = indexMap2.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap2.<span class="built_in">find</span>(a)-&gt;second = indexMap2.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap2.<span class="built_in">find</span>(b)-&gt;second = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::heapInsert</span><span class="params">(<span class="type">int</span> cur,hp p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comparator</span>(heap[p][cur],heap[p][(cur<span class="number">-1</span>)/<span class="number">2</span>],p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][(cur - <span class="number">1</span>) / <span class="number">2</span>], heap[p][cur], p);</span><br><span class="line"><span class="built_in">heapInsert</span>((cur - <span class="number">1</span>) / <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::heaplify</span><span class="params">(<span class="type">int</span> cur,hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; (<span class="type">int</span>)heap[p].<span class="built_in">size</span>() - <span class="number">1</span>)<span class="comment">//int!!!!</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> tar = leftChd + <span class="number">1</span> &lt; heap[p].<span class="built_in">size</span>() &amp;&amp; <span class="built_in">comparator</span>(heap[p][leftChd + <span class="number">1</span>], heap[p][leftChd],p) ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comparator</span>(heap[p][tar] , heap[p][cur],p))<span class="comment">//注意位置不能换！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][tar], heap[p][cur],p);</span><br><span class="line"><span class="built_in">heaplify</span>(tar,p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topK::comparator</span><span class="params">(<span class="type">const</span> client&amp; cur, <span class="type">const</span> client&amp; dad,hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==hp::cnd)</span><br><span class="line"><span class="keyword">return</span> cur.buy != dad.buy ? cur.buy &gt; dad.buy:cur.time &lt; dad.time;</span><br><span class="line"><span class="keyword">if</span>(p==hp::win)</span><br><span class="line"><span class="keyword">return</span> cur.buy != dad.buy ? cur.buy &lt; dad.buy : cur.time &lt; dad.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::remove</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pos = p == hp::cnd ? indexMap1.<span class="built_in">find</span>(usr)-&gt;second : indexMap2.<span class="built_in">find</span>(usr)-&gt;second;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][heap[p].<span class="built_in">size</span>() - <span class="number">1</span>], heap[p][pos], p);</span><br><span class="line">heap[p].<span class="built_in">pop_back</span>();</span><br><span class="line">p == hp::cnd ? indexMap1.<span class="built_in">erase</span>(usr) : indexMap2.<span class="built_in">erase</span>(usr);</span><br><span class="line"><span class="keyword">if</span> (pos != heap[p].<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, p);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::push</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[p].<span class="built_in">push_back</span>(usr);</span><br><span class="line">p == hp::cnd ? indexMap1.<span class="built_in">emplace</span>(usr, heap[p].<span class="built_in">size</span>() - <span class="number">1</span>) : indexMap2.<span class="built_in">emplace</span>(usr, heap[p].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">heapInsert</span>(heap[p].<span class="built_in">size</span>() - <span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::swapHeapTops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">indexMap1.<span class="built_in">erase</span>(heap[hp::cnd][<span class="number">0</span>]);</span><br><span class="line">indexMap2.<span class="built_in">erase</span>(heap[hp::win][<span class="number">0</span>]);</span><br><span class="line">indexMap1.<span class="built_in">emplace</span>(heap[hp::win][<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">indexMap2.<span class="built_in">emplace</span>(heap[hp::cnd][<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">client tmp = heap[hp::cnd][<span class="number">0</span>];</span><br><span class="line">heap[hp::cnd][<span class="number">0</span>] = heap[hp::win][<span class="number">0</span>];</span><br><span class="line">heap[hp::win][<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::solution</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">client <span class="title">tmp</span><span class="params">(user[i], <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (indexMap1.<span class="built_in">find</span>(tmp) != indexMap1.<span class="built_in">end</span>())<span class="comment">//若usr在候选堆中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos = indexMap1.<span class="built_in">find</span>(tmp)-&gt;second;</span><br><span class="line">client&amp; usr = heap[hp::cnd][pos];</span><br><span class="line">buy[i] ? usr.buy++ : usr.buy--;</span><br><span class="line">usr.time = i;</span><br><span class="line"><span class="keyword">if</span> (usr.buy &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">remove</span>(usr, hp::cnd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, hp::cnd);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, hp::cnd);</span><br><span class="line"><span class="keyword">if</span> (heap[hp::cnd][<span class="number">0</span>].buy &gt; heap[hp::win][<span class="number">0</span>].buy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swapHeapTops</span>();</span><br><span class="line">heap[hp::cnd][<span class="number">0</span>].time = i;</span><br><span class="line">heap[hp::win][<span class="number">0</span>].time = i;<span class="comment">//更新时间</span></span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>, hp::win);<span class="comment">//交换堆顶后，需要下沉</span></span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>, hp::cnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexMap2.<span class="built_in">find</span>(tmp) != indexMap2.<span class="built_in">end</span>())<span class="comment">//若usr在得奖区中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos = indexMap2.<span class="built_in">find</span>(tmp)-&gt;second;</span><br><span class="line">client&amp; usr = heap[hp::win][pos];</span><br><span class="line">buy[i] ? usr.buy++ : usr.buy--;</span><br><span class="line">usr.time = i;</span><br><span class="line"><span class="keyword">if</span> (usr.buy &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">remove</span>(usr, hp::win);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, hp::win);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, hp::win);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//若是新参与者</span></span><br><span class="line">&#123;</span><br><span class="line">buy[i] ? tmp.buy++ : tmp.buy--;</span><br><span class="line">tmp.time = i;</span><br><span class="line"><span class="keyword">if</span> (tmp.buy &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (heap[win].<span class="built_in">size</span>() &lt; k)</span><br><span class="line"><span class="built_in">push</span>(tmp, hp::win);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">push</span>(tmp, hp::cnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> user[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">bool</span> buy[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="function">topK <span class="title">issue</span><span class="params">(user, buy, <span class="keyword">sizeof</span>(user) / <span class="keyword">sizeof</span>(<span class="type">int</span>), k)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> res = issue.<span class="built_in">batchRank</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : res)</span><br><span class="line">cout &lt;&lt; i.id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">    issue.<span class="built_in">add</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">res = issue.<span class="built_in">add</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : res)</span><br><span class="line">cout &lt;&lt; i.id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关细节在注释中，除此外还需要强调：</p><ol><li>开辟二维vector是为了减少判断哪个堆的代码量，比如在 heaplify() 和 heapInsert() 中，直接使用 hp 对某个堆进行操作，无需判断是哪个堆，减少了代码量。</li><li>比较器也在本算法中发挥了较大作用，减少了代码量，提高可读性，同时便于维护。关于比较器，详细参见：<a href="https://jyxcpp.netlify.app/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/">仿函数与比较器</a> 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较器与仿函数</title>
      <link href="/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/"/>
      <url>/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-比较器-font"><font color='red'>比较器</font></h3><p>比较器用于自定义数据类型的比较，主要有两种方式：</p><ol><li><p>基于函数的比较器<br><strong>C++用模板实现十分方便，而且这种方式不仅能够传函数比较器，还可以传仿函数和lambda函数</strong> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> _age,string _name):<span class="built_in">age</span>(_age),<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> stu&amp; a, <span class="type">const</span> stu&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> stu&amp; a,<span class="type">const</span> stu&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator c=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(arr[k], arr[k + <span class="number">1</span>]))<span class="comment">//使用比较器</span></span><br><span class="line"><span class="built_in">mySwap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu arr[] = &#123; <span class="built_in">stu</span>(<span class="number">22</span>,<span class="string">&quot;xuan&quot;</span>),<span class="built_in">stu</span>(<span class="number">15</span>,<span class="string">&quot;han&quot;</span>),<span class="built_in">stu</span>(<span class="number">18</span>,<span class="string">&quot;shan&quot;</span>) &#125;;</span><br><span class="line"><span class="built_in">mySort</span>&lt;stu&gt;(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(stu),cmp1);</span><br><span class="line">    <span class="comment">//mySort&lt;stu&gt;(arr, sizeof(arr) / sizeof(stu),cmp2());//仿函数(结构体)</span></span><br><span class="line">    <span class="comment">//mySort&lt;stu&gt;(arr, sizeof(arr) / sizeof(stu),[](const stu&amp; a,const stu&amp;b)//lambda</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> a.age&lt;b.age;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">cout &lt;&lt; i.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于 C 语言，也可以利用回调函数，即函数的参数为函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mySwap</span><span class="params">(<span class="keyword">struct</span> stu* a, <span class="keyword">struct</span> stu* b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">tmp</span> =</span> *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp1</span><span class="params">(<span class="keyword">struct</span> stu* a, <span class="keyword">struct</span> stu* b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b-&gt;age - a-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mySort</span><span class="params">(<span class="keyword">struct</span> stu* arr, <span class="type">int</span> size, <span class="type">int</span> (*cmp)(<span class="keyword">struct</span> stu*, <span class="keyword">struct</span> stu*))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cmp(&amp;arr[k], &amp;arr[k + <span class="number">1</span>])&gt;<span class="number">0</span>)</span><br><span class="line">mySwap(&amp;arr[k], &amp;arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">arr</span>[] =</span> &#123; &#123;.age=<span class="number">22</span>,.name=<span class="string">&quot;xuan&quot;</span>&#125;,&#123;.age=<span class="number">45</span>,.name=<span class="string">&quot;han&quot;</span>&#125;,&#123;.age=<span class="number">18</span>,.name=<span class="string">&quot;shan&quot;</span>&#125; &#125;;</span><br><span class="line">mySort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu), cmp1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>, arr[i].name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-仿函数-font"><font color='red'>仿函数</font></h3><p><strong>仿函数 (functor) 并非函数，其本质就是重载了 () 操作符 的 struct 或 class</strong> ，由于重载了（）操作符，所以使用它的时候就像在调用函数一样，于是就被称为“仿”函数啦。<br>仿函数使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> _age,string _name):<span class="built_in">age</span>(_age),<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> stu&amp; a,<span class="type">const</span> stu&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator c=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(arr[k], arr[k + <span class="number">1</span>]))<span class="comment">//使用比较器</span></span><br><span class="line"><span class="built_in">mySwap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu arr[] = &#123; <span class="built_in">stu</span>(<span class="number">22</span>,<span class="string">&quot;xuan&quot;</span>),<span class="built_in">stu</span>(<span class="number">15</span>,<span class="string">&quot;han&quot;</span>),<span class="built_in">stu</span>(<span class="number">18</span>,<span class="string">&quot;shan&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">mySort</span>&lt;stu&gt;(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(stu),<span class="built_in">cmp2</span>());<span class="comment">//传结构体必须传实例，所以要加括号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">cout &lt;&lt; i.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆与堆排序</title>
      <link href="/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-完全二叉树-font"><font color='red'>完全二叉树</font></h3><p><strong><mark class="hl-label blue">什么是完全二叉树？</mark> </strong><br>如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是 <strong><font color='orange'>满二叉树</font></strong> ；也可以这样解释：如果二叉树中除了叶子结点，每个结点都有左右两个子树，则此二叉树称为满二叉树。如下两个树都是满二叉树：<br><img src="/2022/img/未命名绘图-16638463052091.png" style="zoom:80%;" /></p><p>而 <strong><font color='orange'>完全二叉树</font></strong> 的定义为：<u>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树</u>。也可以这么定义：<u>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树</u>。如下两棵树就是完全二叉树：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638465286303.png" alt=""></p><p><strong><mark class="hl-label blue">完全二叉树的表示</mark> </strong><br>二叉树]的存储结构有两种，分别为顺序存储和链式存储。这里我们采用顺序存储。<strong>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</strong> 图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638474045907.png" alt=""></p><p>以数组下标 i 表示节点的位置，可得以下公式：</p><ul><li><code>节点i的父节点=[(i-1)/2]</code> ，[ ] 表示向下取整。比如上图中值为 9 的节点，其下标为 4，[ (4-1) / 2 ] = 1，所以其父节点位置为 1，值为 6。</li><li><code>节点i的左孩子=2*i+1</code> ，<code>节点i的右孩子=2*i+2</code> 。</li></ul><h3 id="font-color-red-堆-font"><font color='red'>堆</font></h3><p><strong><mark class="hl-label blue">堆的定义</mark> </strong><br>定义1：堆是一种特殊的完全二叉树，其每一个节点的值都是在以该节点为根节点的树中最大(小)的值。定义2：堆中某个结点的值总是不大于或不小于其父结点的值；如下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638493337779.png" alt=""></p><p><strong><mark class="hl-label blue">堆的作用</mark> </strong></p><p><strong>堆的重要作用是用来实现<font color='orange'>优先级队列</font></strong> 。什么是优先级队列呢？优先级队列（priority queue） 是多个元素的集合，每个元素都有一个优先权；对优先级队列执行的操作有 <strong>（1）查找（2）插入一个新元素 （3）删除</strong> ； <u>一般情况下，查找操作用来搜索优先权最大（即数值最大或最小）的元素，删除操作用来删除该元素 。</u>  <strong><font color='orange'>优先级队列是用来处理动态问题的</font>，需要频繁入队和频繁把优先级最高的元素出队。</strong><br>小伙伴们一定会产生这样一个疑问：既然堆是用来动态提取集合中的最大值或最小值，那为什么不直接排序呢？排序后不也能很快找到最大或最小值吗？没错，当数据量小时，可以直接使用排序。但当数据量很大时，数组中每次进来一个新的数据，你难道得全部重新排序一下吗？显然不合适，此时就需要用到堆。建好堆后，<u>数据 <strong>动态</strong> 的插入和删除，时间复杂度都为O(logn)；查询最大/小值，时间复杂度为O(1)</u>，具体分析见后文。</p><blockquote><p>笔者在知乎看见一个很好的类比：<br>题主不愿意洗袜子，又不想穿臭袜子，期望穿臭了就扔。但是穿一次就扔太浪费，而且有时候天气热，有时候凉，袜子穿的次数不定，比较环保标准是拿起袜子来闻一下，如果臭得受不了了就扔掉它。又假设题主期望批量买袜子，避免麻烦，一次性买了三百只袜子，以每只袜子至少可以穿两次论够穿两年。扔的时候也希望一起扔，不要一只只地扔以免麻烦。</p><p>计划开始执行的前半年里是轻松的，基本上早上起床随手抓来袜子都可以穿，但慢慢的局势开始恶化，起床后闻了十双袜子都臭不可闻，费半天劲才能找到一双可以穿的袜子。</p><p>在这种场景下，把所有的袜子排成一个按味道排列的小顶堆就是个优化解法。我们假设题主从最开始就有建堆，这样每天离家时，穿堆顶最不臭的那双袜子走人，回家时袜子脱下来重新插入到堆中，插入过程最多闻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次袜子；明天直接就可以穿堆顶的袜子。当堆顶的袜子臭不可闻时，就全部扔掉重买一批。</p><p>如上，堆排序对现实生活也有巨大的指导意义。<br>其他关于堆的详细介绍，参见：<a href="https://www.zhihu.com/question/466078026">堆的意义？</a></p></blockquote><p><strong><mark class="hl-label blue">堆的构建</mark> </strong><br>堆的构建有两种方式：</p><ol><li><strong>从上往下构建</strong> ，当数据不是一次性交付时（比如每次只输入一个数)，采用此方式；该方法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>从下往上构建</strong> ，当数据一次性交付时，采用此方式构建；该方法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。复杂度分析见后文。</li></ol><p><strong><mark class="hl-label red">1.从上往下构建</mark> </strong><br>核心为 heapInsert() 方法。以构建大堆为例：</p><ol><li>当加入一个新数字时，heapSize++，将该数字放入数组堆末尾，即 arr[heapSize-1]位置；</li><li>接着将 arr[heapSize] 与其父节点进行比较，如果 arr[heapSize] 大于父节点的值，则 swap 此二节点；否则重复 1。</li><li>swap 后继续比较该节点与其新的父节点，如果前者大于后者，则再次 swap，如此反复，直到该节点不再大于其父节点。</li></ol><p>过程图示如下：<br><img src="/2022/img/未命名绘图-166390312717915.png" style="zoom:67%;" /><br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[(cur<span class="number">-1</span>)/<span class="number">2</span>] &lt; arr[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur<span class="number">-1</span>)/<span class="number">2</span>],arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr,(cur<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本方法采用递归实现，也可迭代实现。</li><li>如果要改为小顶堆，将第 3 行的 &lt; 改为 &gt; 即可。</li><li><strong>注意：第 3 行的 &lt; 不能改为 &lt;=，否则当 <code>cur = 0</code> 时，将会一直重复。</strong></li><li>heapInsert() 无需 heapSize，因为是从当前位置往前 swap，而不是往后 swap。</li></ul><p><strong><mark class="hl-label red">2.从下往上构建</mark> </strong><br>核心为 heaplify() 方法，以构建大顶堆为例：<br><img src="/2022/img/未命名绘图-166390135670413.png" style="zoom:80%;" /><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>] &gt; arr[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (arr[largest] &gt; arr[cur])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[largest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, largest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="built_in">heaplify</span>(arr, i, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size</code> 和 <code>heapSize</code> 在建堆时没有用处，在后续删除堆顶时才会体现其用处。</li><li>注意第 6 行代码的作用：如果没有右孩子，那么直接选择左孩子为比较对象；如果有右孩子，则选出左右孩子中最大的那个作为比较对象。</li></ul><p><strong><mark class="hl-label blue">删除堆顶</mark> </strong><br>删除堆顶的步骤很简单：</p><ol><li><p>交换堆顶和堆中最后一个节点。</p></li><li><p>删除最后一个节点，即缩小堆的大小（heapSize–）</p><blockquote><p>注意，数组 arr 是堆 heap 的物理结构，arr 的大小应大于 heapSize；<strong>堆通过 heapSize 的加减进行伸缩。</strong><br>另外需要注意的是，由于是排序，一次性交付整个待排序的数组，所以堆可以直接在数组首部构建，无需额外空间复杂度；但在其他很多情况下，堆一般可直接由可变长数组（vector）实现；两者原理是一样的。</p></blockquote></li><li><p>堆顶调用 heaplify()；</p></li></ol><p>图示如下：<br><img src="/2022/img/未命名绘图-166390433704719.png" style="zoom:80%;" /></p><h3 id="font-color-red-堆排序-font"><font color='red'>堆排序</font></h3><p>堆排序就是不断删除堆顶的过程，每次堆顶都移到数组的 heapSize-1 的位置，所以对于大顶堆，排序结果就应该为升序；对于小顶堆，排序结果就为降序。<br>代码如下（附带对数器）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===================================================================================================</span></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[(cur - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur - <span class="number">1</span>) / <span class="number">2</span>], arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, (cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>] &gt; arr[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (arr[largest] &gt; arr[cur])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[largest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, largest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heaplify</span>(arr, i, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt;= size; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//heapInsert(arr, i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[size - <span class="number">1</span> - i]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, <span class="number">0</span>, size - i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; arr[k + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[k];</span><br><span class="line">arr[k] = arr[k + <span class="number">1</span>];</span><br><span class="line">arr[k + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================================================================================</span></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">10000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">100000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">heapSort</span>(arr_2, arrLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, arrLen) == <span class="literal">false</span>) &#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fuck!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout &lt;&lt; arr_1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;success   &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-复杂度分析-font"><font color='red'>复杂度分析</font></h3><p><strong>从上向下建堆的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，原因如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>1</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>&lt;</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">log1+log2+log3+...+logN&lt;NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，即复杂度上限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>&lt;</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi><mo>&lt;</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN&lt;log(N+1)+log(N+2)+log(N+3)+...+log2N&lt;Nlog2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，即当 <strong>数据倍增</strong> 后，复杂度下限仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，故复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>  。</p><p><strong>从下向上建堆的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，原因如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>×</mo><mn>0</mn><mo>+</mo><mfrac><mi>N</mi><mn>4</mn></mfrac><mo>×</mo><mn>1</mn><mo>+</mo><mfrac><mi>N</mi><mn>8</mn></mfrac><mo>×</mo><mn>2</mn><mo>+</mo><mfrac><mi>N</mi><mn>16</mn></mfrac><mo>×</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mrow><mn>1</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow></msup></mfrac><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">M=\frac{N}{2}×0+\frac{N}{4}×1+\frac{N}{8}×2+\frac{N}{16}×3+...+\frac{N}{2^{1+logN}}×logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2298em;vertical-align:-0.3574em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.6426em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.782em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>最终可证得 M 收敛于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；<br><strong>heapInsert 与 heaplify 的复杂度都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ；</p><p><strong>删除堆顶的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，其证明同从上向下建堆。故最后算法整体的时间复杂度也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。<br><strong>堆排序的额外空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong> ，在原数组中就能完成排序，<strong>heapSize 起到了关键作用</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引</title>
      <link href="/2022/09/18/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/09/18/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-索引简介-font"><font color='red'>索引简介</font></h3><p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p><ol><li><strong>顺序访问</strong></li></ol><p>顺序访问是在表中实行 <strong>全表扫描</strong> ，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。顺序访问实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。</p><ol start="2"><li><strong>索引访问</strong></li></ol><p>索引访问是通过遍历索引来访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引之所以快，是因为其底层采用 B+ 树，详细内容见：<a href="https://zhuanlan.zhihu.com/p/77383599">Mysql索引</a> .</p><p>索引最大的优点就是在海量数据下能够大幅提高查询速度。当然，索引也有缺点：1）索引需要占磁盘空间；2）当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。<strong>索引可以提高查询速度，但是会影响插入记录的速度</strong> 。因为，<strong>向有索引的表中插入记录时，数据库系统会按照索引进行排序</strong> ，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。<strong>这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> ID       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> ID          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> score    <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> score       <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">4</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> score<span class="operator">=</span><span class="number">149</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> score         <span class="operator">|</span> score <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>使用 EXPLAIN 分析查询情况，使用 score 索引查找时，扫描的行数为 1；使用 name 无索引查找时，扫描的行数为 4，为全表扫描。</p><h3 id="font-color-red-索引类型-font"><font color='red'>索引类型</font></h3><h4 id="font-color-gree-按逻辑划分-font"><font color='gree'>按逻辑划分</font></h4><ol><li><p><strong>普通索引</strong> 。<br>普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。<strong>普通索引允许在定义索引的列中插入重复值和空值。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_id <span class="keyword">ON</span> tb_student(id);</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引</strong> 。<br>创建唯一性索引的目的不是为了提高访问速度，<strong>而是为了避免数据出现重复</strong> 。<strong>唯一索引列的值必须唯一，允许有空值，且允许存在多个空值</strong> 。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_id <span class="keyword">ON</span> tb_student(id);</span><br></pre></td></tr></table></figure></li><li><p><strong>主键索引</strong> 。<br>创建主键时，自动成为索引。主键索引是一种特殊的唯一索引，<strong>不允许值重复或者值为空</strong> 。创建主键索引通常使用 <code>PRIMARY KEY</code> 关键字，不能使用 <code>CREATE INDEX</code> 语句创建主键索引。</p></li><li><p><strong>空间索引</strong> 。<br>空间索引主要用于地理空间数据类型 GEOMETRY，不常用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SPATIAL INDEX index_line <span class="keyword">ON</span> tb_student(line);</span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引</strong> 。<br>全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。<strong>在 MySQL 中只有 MyISAM 存储引擎支持全文索引。</strong> 实际开发中，不采用 mysql 自带的全文索引（其效率不高），而使用全文搜索框架 Solr 和 ElasticSearch。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_info <span class="keyword">ON</span> tb_student(info);</span><br></pre></td></tr></table></figure></li></ol><h4 id="font-color-gree-按实现划分-font"><font color='gree'>按实现划分</font></h4><ol><li><p><strong>BTREE索引</strong> 。<br>目前大部分的索引都是采用 B-树索引来存储的。B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：</p><ul><li>查询必须从索引的最左边的列开始。</li><li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li><li>存储引擎不能使用索引中范围条件右边的列。</li></ul></li><li><p><strong>哈希索引</strong><br>又叫散列索引。仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。哈希速度比 BTREE 更快，但缺点也很明显：</p><ul><li>相对于 B-树索引来说，建立哈希索引会耗费更多的时间。</li><li>只支持等值比较，如 “=” ，“IN()” 或 “&lt;=&gt;”。</li><li>不能使用 HASH 索引排序</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的.</li></ul><table><thead><tr><th><strong>存储引擎</strong></th><th><strong>允许的索引类型</strong></th></tr></thead><tbody><tr><td>MyISAM</td><td>BTREE</td></tr><tr><td>InnoDB</td><td>BTREE</td></tr><tr><td>MEMORY/HEAP</td><td>HASH, BTREE</td></tr></tbody></table></li></ol><h4 id="font-color-gree-按数量划分-font"><font color='gree'>按数量划分</font></h4><ol><li><p><strong>单列索引</strong> 。<br>单列索引就是索引只包含原表的一个列。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。</p></li><li><p><strong>多列索引</strong> 。<br>也称为复合索引或组合索引。相对于单列索引来说，<strong>组合索引是将原表的多个列共同组成一个索引</strong> 。多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。<strong>但是，只有查询条件中使用了这些字段中<u>第一个字段</u>时，索引才会被使用。</strong> 例如，在表中的 id、name 和 sex 字段上建立一个多列索引，那么，只有查询条件使用了 id 字段时，该索引才会被使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_na <span class="keyword">ON</span> tb_student(id,name,sex);</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-创建索引-font"><font color='red'>创建索引</font></h3><p><strong><mark class="hl-label blue">使用 CREATE INDEX 语句</mark> </strong><br>可以使用专门用于创建索引的 CREATE INDEX 语句在一个已有的表上创建索引，<strong>但该语句不能创建主键</strong> 。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>长度<span class="operator">&gt;</span>] [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;长度&gt;</code> ：可选项。指定使用列前的 length 个字符来创建索引。<strong>使用列的一部分创建索引有利于减小索引文件的大小</strong> ，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，<strong>BLOB 或 TEXT 类型的列也必须使用前缀索引</strong> 。</p><blockquote><p>前缀最长为255字节。对于 MyISAM 和 InnoDB 表，前缀最长为1000字节。注意前缀的限长以字节计，而CREATE  INDEX语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。<br>另外，当查询条件的前缀与索引前缀相同时，索引也起不到作用。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> ID       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> ID          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> ID<span class="operator">=</span><span class="string">&#x27;12134&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> ID            <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span>    <span class="number">80.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> ID<span class="operator">=</span><span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> ID            <span class="operator">|</span> ID   <span class="operator">|</span> <span class="number">15</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，ID 索引长度为 4。</p></blockquote></li><li><p><code>ASC|DESC</code> ：可选项。<code>ASC</code> 指定索引按照升序来排列，<code>DESC</code> 指定索引按照降序来排列，默认为 <code>ASC</code> 。</p><blockquote><p>目前(2005年)，<code>ASC|DESC</code>  关键词被分析，但是被忽略；索引值均以递增顺序存储。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX ID <span class="keyword">ON</span> stu_info(ID);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用 CREATE TABLE 语句</mark> </strong> 索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###指定主键索引</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY [索引类型] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###创建普通索引</span><br><span class="line">KEY <span class="operator">|</span> INDEX [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###创建唯一索引</span><br><span class="line"><span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ID <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ID <span class="type">VARCHAR</span>(<span class="number">8</span>) ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY(ID,`name`));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> staff (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `mgr`  <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id     <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNIQUE</span>(id));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>在使用 CREATE TABLE 语句定义列选项的时候，可以通过直接在某个列定义后面添加 PRIMARY KEY 的方式创建主键。而当主键是由多个列组成的多列索引时，则不能使用这种方法，只能用在语句的最后加上一个 PRIMARY KRY(&lt;列名&gt;，…) 子句的方式来实现。</p></blockquote><p><strong><mark class="hl-label blue">使用 ALTER TABLE 语句</mark> </strong><br>使用 ALTER TABLE 语句向已有的表添加索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###添加普通索引，一般用INDEX不用KEY</span><br><span class="line"><span class="keyword">ADD</span> INDEX<span class="operator">|</span>KEY [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###添加主键</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###添加唯一索引</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu_info <span class="keyword">ADD</span> INDEX (score);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，以上创建索引时，不指定索引名则索引名同列名。</strong> 同一张表中，索引名不能重复。</p></blockquote><h3 id="font-color-red-查看索引-font"><font color='red'>查看索引</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> no1sc.staff;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> staff <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> id       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Table</td><td>表示创建索引的数据表名，这里是 tb_stu_info2 数据表。</td></tr><tr><td>Non_unique</td><td>表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td></tr><tr><td>Key_name</td><td>表示索引的名称。</td></tr><tr><td>Seq_in_index</td><td>表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td></tr><tr><td>Column_name</td><td>表示定义索引的列字段。</td></tr><tr><td>Collation</td><td>表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</td></tr><tr><td>Cardinality</td><td>索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</td></tr><tr><td>Sub_part</td><td>表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。</td></tr><tr><td>Packed</td><td>指示关键字如何被压缩。若没有被压缩，值为 NULL。</td></tr><tr><td>Null</td><td>用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。</td></tr><tr><td>Index_type</td><td>显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</td></tr><tr><td>Comment</td><td>显示评注。</td></tr></tbody></table><h3 id="font-color-red-删除索引-font"><font color='red'>删除索引</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> staff;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> staff <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> id       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX id <span class="keyword">ON</span> staff;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> staff;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-注意事项-font"><font color='red'>注意事项</font></h3><p><strong><mark class="hl-label blue">索引在什么时候会失效</mark> </strong></p><ol><li><strong>LIKE 关键字配置的字符串不能以“%”开头；</strong></li><li><strong>使用多列索引时，查询条件必须要使用这个索引的第一个字段；</strong></li><li><strong>使用 OR 关键字时，OR 关键字连接的所有条件都必须使用索引</strong> 。</li></ol><p><strong><mark class="hl-label blue">提高索引效率</mark> </strong></p><ol><li><p><strong>选择唯一性索引</strong><br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p></li><li><p><strong>为经常需要排序、分组和联合操作的字段建立索引</strong><br>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p></li><li><p><strong>为常作为查询条件的字段建立索引</strong><br>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</p></li><li><p><strong>限制索引的数目</strong><br>索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。</p></li><li><p><strong>尽量使用数据量少的索引如果索引的值很长，那么查询的速度会受到影响。</strong><br>例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。</p></li><li><p><strong>数据量小的表最好不要使用索引</strong><br>.由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p></li><li><p><strong>尽量使用前缀来索引</strong><br>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p></li><li><p><strong>删除不再使用或者很少使用的索引</strong><br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-视图</title>
      <link href="/2022/09/16/MySQL-%E8%A7%86%E5%9B%BE/"/>
      <url>/2022/09/16/MySQL-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-视图是什么-font"><font color='red'>视图是什么</font></h3><p><strong>MySQL 视图（View）</strong> 是一种虚拟存在的表，同真实表一样，视图也由列和行构成，<strong>但视图并不实际存在于数据库中</strong> 。行和列的数据来自于定义视图的查询中所使用的表（ <strong>基表</strong> ），并且还是在使用视图时动态生成的。<strong>数据库中只存放了视图的定义（.frm文件），并没有存放视图中的数据</strong> ，这些数据都存放在定义视图查询所引用的基表中。使用视图查询数据时，数据库会从基表表中取出对应的数据。因此，视图中的数据是依赖于基表表中的数据的。<strong>一旦基表中的数据发生改变，显示在视图中的数据也会发生改变；在视图中修改数据，基表中的数据也会发生改变。</strong><br>从下图可见，创建视图后，只生成了视图的 <code>.frm</code> 文件，没有 <code>.ibd</code> 文件，这是因为 <code>customer_info.frm</code> 与 <code>customer_view.frm</code> 的数据都是由 <code>customer_info.ibd</code> 提供。<br><img src="/2022/img/image-20220917103106816.png" alt=""></p><h3 id="font-color-red-视图的作用-font"><font color='red'>视图的作用</font></h3><p><strong><mark class="hl-label blue">保密</mark> </strong><br>看这样一个需求：公司职员表的信息很多（姓名、薪水、部门、上级、工号、电话等），而其中有些信息属于个人隐私（薪水、电话），我们希望将此表下放到某管理员时，他只能看到其中的部分信息（姓名、部门、上级、工号），此时，就需要生成原表的一张视图，视图中只包含这一部分信息，然后再将此视图下放给该管理员。不恰当地说，“视图相对于对原表的封装”，对用户有部分不可见性。<br><strong><mark class="hl-label blue">性能</mark> </strong><br>关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这时，数据库查询通常会用到连接(JOIN)。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起,就可以避免使用JOIN查询数据。<br><strong><mark class="hl-label blue">灵活性</mark> </strong><br>如果系统中有一张旧的表,这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。</p><p>值得一提的是，长期以来，大多数互联网公司的《<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>开发规范》中都有一条规范：在MySQL中禁止（或建议不要）使用视图。究其原因，主要是由于在MySQL中视图的查询性能不好，同时带来了管理维护上的高成本。</p><h3 id="font-color-red-视图的用法-font"><font color='red'>视图的用法</font></h3><h4 id="font-color-gree-创建视图-font"><font color='gree'>创建视图</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> <span class="keyword">AS</span> <span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>创建视图前，先给出下面基本数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> room_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> location <span class="operator">|</span> state <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-1</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-2</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-3</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">003</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-4</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">004</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">10</span><span class="number">-5</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">005</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">11</span><span class="number">-6</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">006</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">11</span><span class="number">-7</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">007</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">12</span><span class="number">-8</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">008</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">12</span><span class="number">-9</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">009</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">13</span><span class="number">-10</span>    <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span> <span class="number">10</span><span class="number">-11</span>    <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> ID     <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">511323</span> <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">18990889826</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">511345</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> <span class="number">17390199497</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">532435</span> <span class="operator">|</span>   <span class="number">45</span> <span class="operator">|</span> <span class="number">18932981949</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">343234</span> <span class="operator">|</span>   <span class="number">34</span> <span class="operator">|</span> <span class="number">14342324323</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">343323</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> <span class="number">32232123343</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>1）创建基于单表的视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name`, room_id <span class="keyword">FROM</span> customer_info;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>2）创建基于多表的视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, room_info.room_id, room_info.type</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> customer_info,  room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> customer_info.room_id<span class="operator">=</span>room_info.room_id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span> type         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span> 总统套房       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>3）基于视图创建视图（视图嵌套）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view3</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> customer_view2;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view3;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure><p><strong>不建议视图嵌套创建，不仅影响效率，也会提高后期维护成本。</strong> <strong>视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。</strong></p><p>另外，对于创建视图中的 SELECT 语句的指定存在以下限制：</p><ul><li><strong>用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基表和其他视图的相关权限。</strong></li><li>SELECT 语句不能引用系统或用户变量。</li><li>SELECT 语句不能包含 FROM 子句中的子查询。</li><li>SELECT 语句不能引用预处理语句参数。</li></ul><h4 id="font-color-gree-删除视图-font"><font color='gree'>删除视图</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="number">1</span><span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>视图名<span class="number">2</span><span class="operator">&gt;</span> …]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">VIEW</span> customer_view2;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，删除视图后，建立在本视图上的视图也将不可用；比如将 <code>customer_view2</code> 删掉，<code>customer_view3</code> 将不可用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view3;</span><br><span class="line">ERROR <span class="number">1356</span> (HY000): <span class="keyword">View</span> <span class="string">&#x27;custom_info.customer_view3&#x27;</span> <span class="keyword">references</span> invalid <span class="keyword">table</span>(s) <span class="keyword">or</span> <span class="keyword">column</span>(s) <span class="keyword">or</span> <span class="keyword">function</span>(s) <span class="keyword">or</span> definer<span class="operator">/</span>invoker <span class="keyword">of</span> <span class="keyword">view</span> lack rights <span class="keyword">to</span> use them</span><br></pre></td></tr></table></figure><p>可以使用 <code>CHECK TABLE</code> 来检查此类问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> customer_view3 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">   <span class="keyword">Table</span>: custom_info.customer_view3</span><br><span class="line">      Op: <span class="keyword">check</span></span><br><span class="line">Msg_type: Error</span><br><span class="line">Msg_text: <span class="keyword">Table</span> <span class="string">&#x27;custom_info.customer_view2&#x27;</span> doesn<span class="string">&#x27;t exist</span></span><br><span class="line"><span class="string">*************************** 2. row ***************************</span></span><br><span class="line"><span class="string">   Table: custom_info.customer_view3</span></span><br><span class="line"><span class="string">      Op: check</span></span><br><span class="line"><span class="string">Msg_type: Error</span></span><br><span class="line"><span class="string">Msg_text: View &#x27;</span>custom_info.customer_view3<span class="string">&#x27; references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them</span></span><br><span class="line"><span class="string">*************************** 3. row ***************************</span></span><br><span class="line"><span class="string">   Table: custom_info.customer_view3</span></span><br><span class="line"><span class="string">      Op: check</span></span><br><span class="line"><span class="string">Msg_type: error</span></span><br><span class="line"><span class="string">Msg_text: Corrupt</span></span><br><span class="line"><span class="string">3 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p>第 6 行表明，其基表 <code>customer_view2</code> 不存在。</p><h4 id="font-color-gree-查看视图-font"><font color='gree'>查看视图</font></h4><p>1）查看结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>2）查看定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_view1 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                <span class="keyword">View</span>: demo_view1</span><br><span class="line">         <span class="keyword">Create</span> <span class="keyword">View</span>: <span class="keyword">CREATE</span> ALGORITHM<span class="operator">=</span>UNDEFINED DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `demo_view1` <span class="keyword">AS</span> <span class="keyword">select</span> `stuinfo`.`name` <span class="keyword">AS</span> `name`,`stuinfo`.`age` <span class="keyword">AS</span> `age` <span class="keyword">from</span> `stuinfo` <span class="keyword">order</span> <span class="keyword">by</span> `stuinfo`.`age`</span><br><span class="line">character_set_client: utf8</span><br><span class="line">collation_connection: utf8_general_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">######或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> demo_view1 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                <span class="keyword">View</span>: demo_view1</span><br><span class="line">         <span class="keyword">Create</span> <span class="keyword">View</span>: <span class="keyword">CREATE</span> ALGORITHM<span class="operator">=</span>UNDEFINED DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `demo_view1` <span class="keyword">AS</span> <span class="keyword">select</span> `stuinfo`.`name` <span class="keyword">AS</span> `name`,`stuinfo`.`age` <span class="keyword">AS</span> `age` <span class="keyword">from</span> `stuinfo` <span class="keyword">order</span> <span class="keyword">by</span> `stuinfo`.`age`</span><br><span class="line">character_set_client: utf8</span><br><span class="line">collation_connection: utf8_general_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>3）查看状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: demo_view1</span><br><span class="line">         Engine: <span class="keyword">NULL</span></span><br><span class="line">        Version: <span class="keyword">NULL</span></span><br><span class="line">     Row_format: <span class="keyword">NULL</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="keyword">NULL</span></span><br><span class="line"> Avg_row_length: <span class="keyword">NULL</span></span><br><span class="line">    Data_length: <span class="keyword">NULL</span></span><br><span class="line">Max_data_length: <span class="keyword">NULL</span></span><br><span class="line">   Index_length: <span class="keyword">NULL</span></span><br><span class="line">      Data_free: <span class="keyword">NULL</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="keyword">NULL</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: <span class="keyword">NULL</span></span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: <span class="keyword">NULL</span></span><br><span class="line">        Comment: <span class="keyword">VIEW</span></span><br></pre></td></tr></table></figure><h4 id="font-color-gree-修改视图-font"><font color='gree'>修改视图</font></h4><p><strong><mark class="hl-label blue">修改结构</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> demo_view1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> age</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> stuinfo;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type       <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，只能从头修改视图的结构，无法仅添加列。</p><p><strong><mark class="hl-label blue">修改内容</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> customer_view</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> room_id<span class="operator">=</span><span class="string">&#x27;011&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;李华&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。</strong><br><strong><font color='orange'>某些结构会使得视图不可更新</font></strong> 。如果视图包含以下结构中的任何一种，它就是不可更新的：</p><ul><li>聚合函数 SUM()、MIN()、MAX()、COUNT() 等。</li><li>DISTINCT 关键字。</li><li>GROUP BY 子句。</li><li>HAVING 子句。</li><li>UNION 或 UNION ALL 运算符。</li><li>位于选择列表中的子查询。</li><li>FROM 子句中的不可更新视图或包含多个表。</li><li>WHERE 子句中的子查询，引用 FROM 子句中的表。</li><li>ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。</li><li><strong>若视图是由两个以上基本表导出的，则此视图不允许更新</strong></li></ul><p>使用视图的时候，还应该注意以下两点：</p><ul><li><strong>视图不能索引，也不能有关联的触发器、默认值或规则。</strong></li><li>视图不包含数据，<strong>所以每次使用视图时，都必须执行查询中所需的任何一个检索操作</strong> 。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解快速排序</title>
      <link href="/2022/09/15/%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/15/%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-荷兰国旗问题-font"><font color='red'>荷兰国旗问题</font></h3><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>拿破仑席卷欧洲大陆之后，代表自由，平等，博爱的竖色三色旗也风靡一时。荷兰国旗就是一面三色旗（只不过是横向的），自上而下为红白蓝三色。该问题本身是关于三色球排序和分类的，由荷兰科学家 Dijkstra 提出。由于问题中的三色小球有序排列后正好分为三类，Dijkstra 就想象成他母国的国旗，于是问题也就被命名为荷兰旗问题（Dutch National Flag Problem）。下面是问题的正规描述： 现有 n 个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。<strong>在算法中，更多这样描述：如何通过两两交换，将一个数组中小于 N 的数放在靠左边，等于 N 的数放在靠中间，大于 N 的数放在靠右边</strong> ；比如，数组 arr[1, 14, 5, 16, 8, 7], N=8, 则两两交换后得到[1, 7, 5, 8, 16, 14]。<strong>注意，左右两边内部不一定有序</strong> 。</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong><br>设计一个大(右)小(左)区间，通过不断扩展区间达到 <strong>分区(partition)</strong> 的效果。过程图示如下：<br><img src="/2022/img/未命名绘图-16632545470111.png" alt="" style="zoom:80%;" /></p><p>有以下几点需要注意：</p><ol><li><strong>左区间的初始位置为 L=0，右区间的初始位置为 R=size；</strong></li><li>当指针(下标为T)指向的数<ul><li>小于 N 时：交换 arr[T] 和 arr[L+1] ，T++ ，L++；</li><li>等于 N 时，T++；</li><li>大于 N 时，交换 arr[T] 与 arr[R-1]，R–；</li></ul></li><li>T &gt;= R 时，过程结束。注意，结束条件不能设置为 T==R，因为 R–，T++，可能有 T-R=1</li><li><strong><font color='orange'>区间内部不保证有序</font></strong></li></ol><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">netherLandFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> R = size;</span><br><span class="line"><span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[T] &lt; N)</span><br><span class="line"><span class="built_in">swap</span>(arr[T++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[T] = N)</span><br><span class="line">T++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[T], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-快速排序1-0-font"><font color='red'>快速排序1.0</font></h3><p><strong><font color='orange'>快速排序的核心就是递归调用荷兰国旗方法</font></strong> 。<strong>由于一旦完成 partition，中间区间(等于N的数)就不会再移动，所以就能通过不断在左右区间内部继续划分区间，直到无法划分为止(满足基线条件)，最终达到排序的效果</strong> 。在快速排序中，N 并不是上述那样人为指定的，<strong>而是固定为当前区间中最右边的那个数</strong> 。如下图：<br><img src="/2022/img/未命名绘图-16632931991463.png" alt="" style="zoom:80%;" /><br>注意：</p><ol><li><strong>不同于之前 R=size，这里 R = size-1；</strong></li><li><strong>最后需要指定交换 arr[R] 与 arr[size-1]；</strong></li></ol><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意第 21 行的 swap，容易忽略；</li><li>基线条件是 lower&gt;=upper，而不是 lower==upper；</li><li><strong>第 29 行，右边界下标为 R+1 而非 R</strong> ；</li></ul><h3 id="font-color-red-快速排序2-0——随机快排-font"><font color='red'>快速排序2.0——随机快排</font></h3><p>阅读上文后，读者也许能敏锐地发现，区间的划分情况和 N 息息相关。我们希望，N 总是可以打到数组的中间(数值, 而非位置)，这样每次划分就可以达到类似于二分的效果；而一旦数组偏有序，那么划分次数就会大大增加，如下：<br><img src="/2022/img/未命名绘图-16632988093595.png" alt="" style="zoom:80%;" /></p><p>第 K 层比较次数为 N-K 次，笼统记为 N 次( <strong>只要与 N 相关，都记为 N</strong> )；一共 N-1 层，笼统记为 N 层；所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p><p>如果每次打到中间，就可以产生二分效果，减少划分次数，如下：<br><img src="/2022/img/未命名绘图-166330129553810.png" alt="上图中比较5次更正为6次" style="zoom:80%;" /></p><p>第 K 层比较次数为 N-K 次，笼统记为 N 次；一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 层( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>7</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">log_27=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> )，笼统记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，故时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。</p><p>那么如何使 N 刚好打到数组的数值正中间呢？遗憾的是，无法做到，只能随机取值。但好消息是，将 N 随机取值(其值必须为数组中的数)后，该算法的长期期望也可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。<strong>期望归期望，实践时，可能运气很差，所以随即快排是不稳定的</strong> 。</p><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;<span class="comment">//生成随机数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">swap</span>(arr[upper], arr[<span class="built_in">rand</span>() % (upper - lower + <span class="number">1</span>) + lower]);</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 58 行，随机交换数组最后和其他某位置的数。</li></ul><h3 id="font-color-red-效率比较-font"><font color='red'>效率比较</font></h3><p><code>测试次数time=10000</code> ，<code>最大值max=1000000000</code> ，<code>最大长度size=1000000</code> ，快速排序 1.0 反而快于随机快排 <code>0.6203 ms</code> ：</p><img src="/2022/img/image-20220920231457291.png" alt="image-20220920231457291" style="zoom:67%;" /><p>这稍显离谱。。。。。原因咱不知晓，后续探究。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;<span class="comment">//生成随机数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_1</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process_1</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process_1</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort_1</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process_1</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">swap</span>(arr[upper], arr[<span class="built_in">rand</span>() % (upper - lower + <span class="number">1</span>) + lower]);</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process_2</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process_2</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort_2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process_2</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">clock_t</span> start_1, end_1,start_2,end_2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">int</span> maxSize = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> times = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> arg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">rand</span>() % maxSize + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, size);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, size);</span><br><span class="line">start_1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quickSort_1</span>(arr_1, size);</span><br><span class="line">end_1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">start_2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quickSort_2</span>(arr_2, size);</span><br><span class="line">end_2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, size) == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;排序出错!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;一般快速排序：&quot;</span> &lt;&lt; end_1 - start_1 &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;随机快速排序：&quot;</span> &lt;&lt; end_2 - start_2 &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;后者快于前者：&quot;</span> &lt;&lt; end_1 - start_1 - (end_2 - start_2) &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">arg += end_1 - start_1 - (end_2 - start_2);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;==========================================&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;平均快于&quot;</span> &lt;&lt; (<span class="type">double</span>)arg/times &lt;&lt; <span class="string">&quot; ms&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序变式-区间和计数</title>
      <link href="/2022/09/14/%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F%E5%8F%98%E5%BC%8F-%E5%8C%BA%E9%97%B4%E5%92%8C%E8%AE%A1%E6%95%B0/"/>
      <url>/2022/09/14/%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F%E5%8F%98%E5%BC%8F-%E5%8C%BA%E9%97%B4%E5%92%8C%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定一个数组 arr，两个整数 lower 和 upper，返回 arr 中有多少个子数组的累加和在 [lower, upper] (左闭右闭)范围上。<strong>注意，子数组是连续的，单独一个元素也是子数组</strong> 。</p><p><strong><mark class="hl-label blue">重要工具 — 前缀和数组</mark> </strong></p><p>当我们需要 <strong>频繁计算</strong> 数组中 [l, r] 范围中元素的累加和时，如果每次都要遍历子区间的元素，就显得十分低效，此时前缀和数组就有大用处了。前缀和数组的元素是原数组从 0 下标开始到当前位置所有元素的累加和，比如：arr[4, 8, 6, 10, 12] ，其对应的前缀和数组为：presum[4, 12, 18, 28, 40]；当需要计算 arr 的区间 [2, 4] 中的累加和时，只需要用 presum[4] - presum[2-1] 就可得到对应的累加和。原理很好理解，不再过多阐述。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>在不使用前缀和数组的情况下，此问题的复杂度将达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ：从下标 0 遍历 N 次 -&gt; 从下标 1 遍历 N-1 次 -&gt;从下标 2 遍历 N-2 次 …每次遍历时，都还需要遍历该范围内的元素以计算累加和。如果使用前缀和数组，就可以将复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。能不能进一步优化呢？且听下文分析。<br><img src="/2022/img/未命名绘图.png" alt=""  /><br>经上图分析，我们成功地将 <strong>求累加和在某区间内的子数组个数</strong> 转变为了 <strong>求前缀和在某区间内的子数组个数</strong> 。各位可能仍有疑惑：这与归并排序有什么关系呢？看过博主之前的文章《<a href="https://jyxcpp.netlify.app/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/">归并排序及其加强</a> 》的读者也许就会上图中的红色字体有一丝丝感觉。没错，<strong><font color='red'>当涉及到一个数组中某个数左(右)边的数与此数的关系时，往往就可以采用归并排序</font></strong> ，而 <strong><font color='red'>必然条件:K&lt;N</font></strong> 就提供了这样一种关系。下面我们再来剖析这个过程(目标区间[10, 30])：<br><img src="/2022/img/未命名绘图-16631419576573-16631425474895.png"  /><br>有几个点需要注意：</p><ol><li><strong><font color='red'>当左边指针指向的数字大于前缀和区间的右边界时，左指针就无需再向右移动，因为其后的数字比当前数字更大，更不可能会落入前缀和区间，所以直接归位到第一个位置。当左边指针指向的数字小于前缀和区间的左边界时，左指针就必须继续向右移动了，这点在图中并未体现，需要留心！</font></strong></li><li>此方式下，右边指针始终右移，左边指针则可能回退，所以无法边操作边 merge，只有等到操作结束后统一 merge；类似的还有《<a href="https://jyxcpp.netlify.app/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/">归并排序及其加强</a> 》中提到的二倍大问题。</li><li>由于左指针发生回退，所以此方式复杂度最好情况下才为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，而最坏情况下可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong><font color='red'>为什么能使用归并？因为此方法只关心两个前缀和的相对位置，并不关心它们的具体位置和相距距离。</font></strong></li><li><strong>上图的过程中，没有验证某个前缀和本身否落在指定范围，即不能验证 arr 数组从 0 位置到 N 的累加和，而只能验证从 K(K≠0) 到 N 的累加和(即presum[N]-presum[K])。所以还必须单独验证这些前缀和自身是否落在指定范围，此操作在下面代码的 63 行给出。</strong></li></ol><p>下面给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> upper, lower;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span>(rp&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prel = arr[rp] - upper;<span class="comment">//presum left</span></span><br><span class="line"><span class="type">int</span> prer = arr[rp] - lower;<span class="comment">//presum right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lp &gt; m)</span><br><span class="line">&#123;</span><br><span class="line">rp++;</span><br><span class="line">lp = l;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &lt; prel)</span><br><span class="line">lp++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[lp] &gt; prer)</span><br><span class="line">&#123;</span><br><span class="line">rp++;</span><br><span class="line">lp = l;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">lp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;           </span><br><span class="line">rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &gt;= lower &amp;&amp; arr[r] &lt;= upper)</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lower = <span class="number">10</span>;</span><br><span class="line">upper = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>&#125;; </span><br><span class="line"><span class="type">int</span> presum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//10 11 12 22</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">presum[i] += arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergeSort</span>(presum,<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">进一步优化</mark> </strong><br>细心观察，我们可以发现，前缀和的上限 prel 与下线 prer 一定是不断增加的，这是因为 prel = arr[rp] - upper，prer = arr[rp] - lower ，而 arr[rp] 是递增的，所以 prel 与 prer 只会增加。所以，[prel, prer] 区间是持续向右移动的，不会回退，我们只需要每次将 [prel, prer] 区间内的数字个数算入 count 即可。过程如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16631662112261.png" alt=""></p><ul><li><strong>注意，l 与 r 是 presum 数组的下标。</strong></li><li><strong>presum[l] 必须紧靠前缀和区间的左边界，presum[r] 必须紧靠前缀和区间的右边界</strong></li><li><strong>和上一种方式相同，上图并没有验证某个前缀和本身否落在指定范围，需要单独验证。</strong></li><li><strong>count = r + l - 1</strong></li><li><strong>可见，指针不回退，所以此方法复杂度稳在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</strong></li><li>仍然先操作完，再统一 merge，否则不好操作；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> upper, lower;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;            </span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="type">int</span> wl = l - <span class="number">1</span>;   <span class="comment">//window left;  wl即图中的l</span></span><br><span class="line"><span class="type">int</span> wr = l - <span class="number">1</span>;  <span class="comment">//window right; wp即图中的r</span></span><br><span class="line"><span class="keyword">while</span>(rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prel = arr[rp] - upper;<span class="comment">//presum left</span></span><br><span class="line"><span class="type">int</span> prer = arr[rp] - lower;<span class="comment">//presum right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (wl &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[wl] &lt; prel)</span><br><span class="line">wl++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wl &gt; m)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span> (wr &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[wr + <span class="number">1</span>] &lt;= prer &amp;&amp; wr!=m)</span><br><span class="line">wr++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wl != l<span class="number">-1</span> &amp;&amp; wr != l<span class="number">-1</span>)</span><br><span class="line">cnt += wr - wl + <span class="number">1</span>;</span><br><span class="line">rp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;           </span><br><span class="line">rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &gt;= lower &amp;&amp; arr[r] &lt;= upper)</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lower = <span class="number">10</span>;</span><br><span class="line">upper = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;; </span><br><span class="line"><span class="type">int</span> presum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//10 20 30 40</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">presum[i] += arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergeSort</span>(presum,<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>14、15 行为什么设置为 l-1？这是和第 36 行的 if 语句搭配使用的；因为如果 wr 与 wl 初始就指向 l 位置，那么即使 presum[l] 没有落在指定区间，最后也会直接 cnt += wr - wl + 1；这很难把握。</li><li>21，27，29，31的边界为什么如此设置，留给读者思考，博主仅写此算法就用了一整天，，筋疲力竭。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种排序算法总结</title>
      <link href="/2022/09/13/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/13/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在看算法图解的过程中，看到书中说时间复杂度同为O(nlogn)，快排比归并排序快的原因是快排查找的常量要比归并小。</p><p>看完还不是很理解，去网上查了下资料，看了几种回答，还是《数据结构与算法分析：C++描述》中说的比较清楚，主要是因为：</p><p>1.C++模板有很强的inline优化机制，比较操作相对于赋值（移动）操作要快的多（尤其是元素较大时）</p><p>2.另一方面，一般情况下，归并排序的比较次数小于快速排序的比较次数，而移动次数一般多于快速排序的移动次数，二者大约都是2~3倍的差距。</p><p>因为这样，在C++中快排要比归并排序更快，但其实在java中恰恰相反，移动（赋值）一般比较快。</p><p><a href="https://blog.csdn.net/qq_39521554/article/details/79364718">快速排序 Vs. 归并排序 Vs. 堆排序——谁才是最强的排序算法_图灵的猫i的博客-CSDN博客_快速排序和归并排序哪个好</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:Xenia and Weights</title>
      <link href="/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95-Xenia-and-Weights/"/>
      <url>/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95-Xenia-and-Weights/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定 n 种砝码,重量位于区间 [1,10] ，不同种类砖码重量互不相同,且每种砝码的数量不限。轮流在天平两侧放砖码，要求：<strong>每次所使用的砝码与前一次不同(第一次可以为任意重量)，且当前放置砝码的一侧放置砝码后比另一侧重</strong> 。问能否进行 m 次操作，如果能，输出任意一种方案，如果不能，输出NO。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>思路大致和之前回溯法章节相同，只是需要左右两边分开处理。process() 的参数较多，这是因为笔者个人偏好 <strong><font color='orange'>利用函数栈自动完成回溯法所需要的撤销操作，所以必须用参数（而且必须为值传递）；也可以用全局变量，然后再递归后手动撤销。</font></strong> 详细过程不再阐述，代码注释已经解释清楚：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">turn</span>&#123;LEFT,RIGHT&#125;;</span><br><span class="line"><span class="type">int</span> weights[<span class="number">2</span>][<span class="number">10</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125; <span class="comment">//砝码种类</span></span><br><span class="line">  ,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//1代表有此种类</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//设定的操作次数</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    lw:左盘总重 rw:右盘总重 m:当前操作的次数 temp:记录每次放下的砝码重量  t:轮到哪边放*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> lw,<span class="type">int</span> rw,<span class="type">int</span> w, <span class="type">int</span> m,std::vector&lt;<span class="type">int</span>&gt; temp,turn t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (m == count)</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">-1</span>;<span class="comment">//将count设置为1，后续不再dfs，直接返回</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : temp)</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t == turn::LEFT)<span class="comment">//本次在左盘放置砝码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lw + w &lt;= rw)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lw += w;</span><br><span class="line">m++;</span><br><span class="line">temp.<span class="built_in">push_back</span>(w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span> || w == i+<span class="number">1</span>)<span class="comment">//w==i+1代表如果本次放下的重量等于上次的重量,则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(lw, rw, weights[<span class="number">0</span>][i], m, temp, turn::RIGHT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == turn::RIGHT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rw + w &lt;= lw)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">rw += w;</span><br><span class="line">m++;</span><br><span class="line">temp.<span class="built_in">push_back</span>(w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span> || w == i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(lw, rw, weights[<span class="number">0</span>][i], m, temp, turn::LEFT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> count)</span><span class="comment">//启动子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(<span class="number">0</span>, <span class="number">0</span>, weights[<span class="number">0</span>][i], <span class="number">0</span>, temp, turn::LEFT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">put</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是采用 dfs 完成的，dp 放在后续文章了解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:超级幸运数</title>
      <link href="/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
      <url>/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>幸运数为 4 和 7，超级幸运数则是指因数只有 4 和 7 的数，比如 28，16，49 等。给出一个个数为 N 的数列，求其中幸运数的个数；数据范围：num&gt;1, N&gt;1；</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>暴力破解不难，直接给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count_2++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">7</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中，第 3、5、12 行代码是容易忽略的地方。</strong></p><p>那么，如何用回溯法解决此问题？不同于暴力破解对 num 的 <strong>拆分</strong> (除、模)，回溯法是对 num 进行 <strong>拼凑</strong> ，比如，对于数字 18，会尝试用 4*4，4*7 去拼凑，如果拼凑的结果大于 num，则回溯到上一层进行下一次尝试。图示如下：<br><img src="/2022/img/image-20220913105139956.png" style="zoom:80%;" /><br>根据图示，易得以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num是需要检验的数字，luck是当前所在节点的累积数值，即紫色框中的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lucky</span><span class="params">(<span class="type">int</span>&amp; num, <span class="type">int</span> luck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&lt;luck*<span class="number">4</span>)<span class="comment">//即图示中的比大小，如果左子树进不去(luck*4)，则右子树也不可能进(luck*7)</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//回溯</span></span><br><span class="line"><span class="keyword">if</span> (num == luck * <span class="number">4</span> || num == luck * <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;<span class="comment">//标记已成功</span></span><br><span class="line">count_1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">4</span>);<span class="comment">//先进左子树</span></span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">7</span>);<span class="comment">//如果未标记成功，则继续进入右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意第 8、13 行代码，作用如图示：<br><img src="/2022/img/image-20220913110716725.png" style="zoom:67%;" /><br>可见，如果不标记检测成功，28 就被 count++了两次，实际上 count++ 一次后就应该停止回溯。所以需要在成功后将 num 设置为 0（也可以采用其他标记方式）以标记成功，后续不再进入右子树。</p><p>附上对数器，所有代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count_1;</span><br><span class="line"><span class="type">int</span> count_2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lucky</span><span class="params">(<span class="type">int</span>&amp; num, <span class="type">int</span> luck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&lt;luck*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (num == luck * <span class="number">4</span> || num == luck * <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line">count_1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count_2++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">7</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">1000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">100000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line">count_1 = <span class="number">0</span>;</span><br><span class="line">count_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">lucky</span>(arr_1[i], <span class="number">1</span>);</span><br><span class="line"><span class="built_in">comparator</span>(arr_2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;go wrong&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">std::cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; count_1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; count_2 &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡、选择、插入排序</title>
      <link href="/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-冒泡排序-font"><font color='red'>冒泡排序</font></h3><p>冒泡排序网上有很多资料，只想强调几点：</p><ol><li>固定往哪个方向冒泡，个人喜欢从左向右冒泡，不要一会向左一会向右，思绪易乱。</li><li>泡泡到达右边后，相应位置就固定住了，所以下一次无需再经过此处，于是内层循环还要减去外层循环已进行的次数。</li><li>冒泡时是第 K 个与第 K+1 个元素相比较，所以外层循环次数为 size-1 次即可，最后一个位置无需单独比较。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)<span class="comment">//注意-1！！！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)<span class="comment">//注意-i-1！！！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(arr[k], arr[k + <span class="number">1</span>]))<span class="comment">//使用比较器</span></span><br><span class="line"><span class="built_in">swap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="font-color-red-选择排序-font"><font color='red'>选择排序</font></h3><p>选择排序也只须注意以下几个小坑：</p><ol><li>外层目标位置 K 确定后，内层从 K+1 位置开始往后遍历。</li><li>初始 mIndex 值必须等于外层目标位置。</li><li>由于第 1 点，所以外层 i&lt;size-1，内层 k &lt;size；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mIndex; <span class="comment">//最大或最小值的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i++)<span class="comment">//注意-1!</span></span><br><span class="line">&#123;</span><br><span class="line">mIndex = i; <span class="comment">//这里是最容易忽略的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i+<span class="number">1</span>; k &lt; size; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">cmp</span>(arr[mIndex], arr[k]))</span><br><span class="line">mIndex = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[i], arr[mIndex]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-插入排序-font"><font color='red'>插入排序</font></h3><p>注意以下几点：</p><ol><li>由于是 arr[k] 与 arr[k-1] 比较，所以外层从 i=1 开始。当然这只是个人偏好，也可以 arr[k] 与 arr[k+1] 比较。</li><li>内层从 i 开始。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T* arr, <span class="type">int</span> size, comparator cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cmp</span>(arr[k<span class="number">-1</span>], arr[k]))</span><br><span class="line"><span class="built_in">swap</span>(arr[k<span class="number">-1</span>], arr[k]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//break是关键,容易忽略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，插入排序是一种不稳定算法，其速度随数据状况而变，即数组越有序其速度越快，而冒泡和选择排序则是稳定的 O(N^2^) 。</p><p>这三种排序是最基础的排序算法，即使如此，我们也须额外小心其中的边界处理！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序及其三道加强习题</title>
      <link href="/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>归并排序(Merge Sort)</strong> 是利用归并的思想实现的排序方法，该算法采用经典的 <strong>分治(divide-and-conquer)</strong> 策略将问题分成一些小的问题然后递归求解，即分而治之。</p><h3 id="font-color-red-递归实现-font"><font color='red'>递归实现</font></h3><p>图解：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhYmJjYzEzMg==,size_16,color_FFFFFF,t_70.png" alt="" style="zoom: 50%;" /></p><p>先递归将数组一分为二，直到不可再分；然后=依次将两边 <strong>合并(merge)</strong> ，合并的图解如下（以最后一次合并为例）：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhYmJjYzEzMg==,size_16,color_FFFFFF,t_70-16628687498517.png" style="zoom:50%;" /></p><p><strong><font color='orange'>注意，之所以能这样合并，是因为两边的子数组都是已经排好序了的！而子数组最终也是通过该方法从单个元素排序而来</font></strong> 。从图可知，我们需要 new 一个辅助数组来存放左右两边比较后的结果；注意，当 i 移到 7 位置时，7&gt;6，将 6 放入辅助数组，然后 j++，于是 j 超出数组范围，<strong>此时就直接将左半边余下的 7、8 放入辅助数组</strong> ，结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> cmptor&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(T* vec, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, cmptor cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = vec[lp] &lt; vec[rp] ? vec[lp++] : vec[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = vec[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第10行和第12行的while只可能进入一个</span></span><br><span class="line">help[p++] = vec[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">vec[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> cmptor&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T* vec, <span class="type">int</span> l, <span class="type">int</span> r, cmptor cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)<span class="comment">//base case</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">process</span>(vec, l, m, cmp);</span><br><span class="line"><span class="built_in">process</span>(vec, m + <span class="number">1</span>, r, cmp);</span><br><span class="line"><span class="built_in">merge</span>(vec, l, m, r, cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> cmptor&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T* vec, <span class="type">int</span> size, cmptor cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(vec, <span class="number">0</span>, r, cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码作如下分析：</p><ul><li>归并排序的边界条件很巧妙：<strong><font color='red'>[L，M]，[M+1，R]</font></strong> ，分到最后只剩一个元素时，就会有 L&gt;=M，从而结束递归，比如所在区间：[0, 1]，L=0，R=1，M=(0+1)/2=0，左边进入递归 [0, 0]，右边进入递归 [1, 1]，自然就会满足基线条件(base case)，从而 return。对其他区间也同样如此。<strong><font color='orange'>未来考虑某些边界条件时，这是一个很好的参考</font></strong></li><li><strong>注意 base case 是 l&gt;=r 而非 l==r，左边界在某些情况下可能超过右边界，血的教训…</strong></li><li><strong><font color='red'>为什么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这么 low ？因为它大量浪费了比较行为，前一次比较丝毫不能为以后的比较做出贡献。归并排序为什么好？因为它将每一次的比较结果都往后进行了传递，使后续的递归能够利用之前的比较成果</font></strong></li><li><strong>归并排序的复杂度为什么是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ：因为最坏情况下，每一个数(即 N 个数)都会被比较 logN 次（递归层数）</li></ul><h3 id="font-color-red-迭代实现-font"><font color='red'>迭代实现</font></h3><p>归并排序的迭代实现也有较复杂的边界条件，笔者会用代码和示意图对应着解释这些边界。先上图：<br><img src="/2022/img/image-20220911173802954.png" alt=""><br><img src="/2022/img/image-20220911174107803.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lp = l;</span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)         <span class="comment">//第9行和第10行的while只会进入其中一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || N == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mergeSize = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (mergeSize &lt; N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (M &gt;= N<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> R = (M + mergeSize) &lt; (N - <span class="number">1</span>) ? M + mergeSize : N - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">L = R + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>)<span class="comment">//防止整形溢出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mergeSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">51</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">27</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">43</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">86</span> &#125;;</span><br><span class="line"><span class="built_in">mergeSort</span>(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代实现的 merge() 与递归实现的 merge() 相同</li><li>重点要讨论的边界处理，即第 23、26、29 行代码，其理由已经在图中详细阐述。</li><li>第 35 行代码十分容易忽略。当 N 靠近整形边界时，mergeSize×2 就可能发生溢出成为负数，然后回到第 23 行进行比较，又重新进入 while 循环！<strong><font color='orange'>所以未来在这种作了增加运算后还要和其他数进行比较时，须特别注意这类情况！</font></strong></li></ul><h3 id="font-color-red-对数器检验-font"><font color='red'>对数器检验</font></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span><span class="comment">//迭代版</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lp = l;</span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)</span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void process(int* arr, int l, int r)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (l == r)</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//int m = l + ((r - l)&gt;&gt;1);</span></span><br><span class="line"><span class="comment">//process(arr, l, m);</span></span><br><span class="line"><span class="comment">//process(arr, m + 1, r);</span></span><br><span class="line"><span class="comment">//merge(arr, l, m, r);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void mergeSort(int* arr, int size)//递归版</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (size == 1)</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//int r = size - 1;</span></span><br><span class="line"><span class="comment">//process(arr, 0, r);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || length == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (mergeSize &lt; length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (M &gt;= length<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> R = (M + mergeSize) &lt; (length - <span class="number">1</span>) ? M + mergeSize : length - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">L = R + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt; length / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mergeSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &lt; arr[k + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[k];</span><br><span class="line">arr[k] = arr[k + <span class="number">1</span>];</span><br><span class="line">arr[k + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">1000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1, arrLen);  </span><br><span class="line"><span class="built_in">mergeSort</span>(arr_2, arrLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, arrLen) == <span class="literal">false</span>) &#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fuck!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout &lt;&lt; arr_1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;success   &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-归并排序变式：三道面试题-font"><font color='red'>归并排序变式：三道面试题</font></h3><h4 id="font-color-gree-小和问题-font"><font color='gree'>小和问题</font></h4><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>在一个给定的数组中，计算出每一个数左边的所有比其小的数的和，并将这些和相加，即得这个数组的小和。距离：对于数组 <code>[6,3,8,9]</code> ，6 的左边没有比 6 小的数；3 的左边没有比 3 小的数；8 的左边，6 和 3 小于 8，其和为 6+3=9；9 的左边，6，3，8 小于 9，其和为 17；故数组的小和为 26。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>显然，本问题可以很容易地被暴力破解，对每一个数，遍历之前的所有数，算法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。在暴力破解的基础上，我们会很容易地想到一些优化的方法，比如，当前数字为 7 时，往前挨个比较，当碰上数字 6 时，我们就可以停止遍历，直接将 6 和 6 的小和相加即可，如下图：<br><img src="/2022/img/image-20220912172534459.png" style="zoom: 50%;" /><br>可见，当数字 N 左边紧挨着 N-1 时，此方式的效率就能达到最高；但如果碰上 <code>[7,6,5,4,3,2,1]</code> 这样从大到小的数列，复杂度也会回归到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。那么，如何进一步优化？从以上过程可以隐约感受到，如果在求小和的过程中能够将之前比较过的数字由小到大进行排序，也许就可以充分利用上述优化方式。进一步，我们尝试引入归并排序（别问为什么，问就是不知道，呜呜呜）。仍然拿前文例子进行说明：<br><img src="/2022/img/image-20220912181635790.png" alt="" style="zoom:67%;" /></p><p>取出中间状态，分析步骤：<br><img src="/2022/img/image-20220912182236325.png" alt="" style="zoom:80%;" /></p><ul><li>当有小和时，<strong>sum += 左边指向数 × (1 + 右边指向数的右边所有数字的个数)</strong> ，<strong><font color='red'>也即：sum += arr[lp] * (R - rp + 1)</font></strong> ；具体原因见上文的优化。<strong>这是排序的最终用处。</strong></li><li><strong><font color='orange'>此算法关键问题在于，为什么排序没有影响这些数字的小和？</font></strong> <strong>这是因为，在归并(merge)前，左组中的每一个数仍然在右组中每一个数的左边，这种状态并没有因为之前的排序而改变，直到本次merge才结束这种状态</strong> 。</li><li>此算法的代码实现，仅仅只改变了 merge() 函数（下面代码的第17-20行）</li></ul><p><strong><font color='orange'>另外需要注意，当左边指针指向的数等于右边指针指向的数时，必须先将右边的数放入辅助数组！</font></strong> 拿如下情况举例讲解：<br><img src="/2022/img/image-20220912190912493.png" alt="" style="zoom: 67%;" /></p><p>小和问题分析大致如此，如有补充，请在评论区提出，谢谢。代码如下（附带对数器）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &lt; arr[rp])</span><br><span class="line">&#123;</span><br><span class="line">count_1 += (r - rp + <span class="number">1</span>) * arr[lp];<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &lt; arr[p])</span><br><span class="line">count_2 += arr[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">100000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line">        count_1 = <span class="number">0</span>;</span><br><span class="line">count_2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">comparator</span>(arr_2, arrLen);</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;go wrong&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">std::cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">delete</span> arr_1, arr_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-gree-逆序对问题-font"><font color='gree'>逆序对问题</font></h4><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>输入: [7,5,6,4]<br>输出: 5<br>逆序对：&lt;7,5&gt;,&lt;7,6&gt;,&lt;7,4&gt;,&lt;5,4&gt;,&lt;6,4&gt;</p><p><strong><mark class="hl-label blue">分析</mark> </strong></p><p>同小和问题类似，都是左边的数比较右边的数，解决思路几乎相同，<strong><font color='orange'>唯一不同是，需要从大到小排序！</font></strong></p><img src="/2022/img/image-20220912202305683.png" alt="" style="zoom:67%;" />对 merge() 稍作修改即可：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &gt; arr[rp])</span><br><span class="line">&#123;</span><br><span class="line">count_1 += r - rp + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较器也需要稍作修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &gt; arr[p])</span><br><span class="line">count_2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-red-两倍大问题-font"><font color='red'>两倍大问题</font></h4><p>给定一个数组，计算出每个数右侧比自身要小两倍还多的数的累计个数。如数组 [9,5,4,2] ，9 -&gt; 4，9 -&gt;2，5 -&gt; 2，结果为 3。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br><strong><font color='orange'>同逆序对类似，也是关于前面数字大于后面数字的问题，所以也最好使用归并算法的降序方式。</font></strong> 不同的是，<strong>此时需要先完成全部计算，然后统一直接merge</strong> 。如果仍按之前的方式边计算边 merge，会出现如下逻辑问题：<br><img src="/2022/img/image-20220912222454570.png" style="zoom: 50%;" /><br><strong>所以应该先完成所有计算，再 merge：</strong><br><img src="/2022/img/image-20220912222911740.png" style="zoom:67%;" /><br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;           </span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r &amp;&amp; <span class="built_in">lp</span>&lt;=m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &gt; (arr[rp] * <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">count_1 += r - rp + <span class="number">1</span>;</span><br><span class="line">lp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;            <span class="comment">//left pointer</span></span><br><span class="line">rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &gt; (arr[p]*<span class="number">2</span>))</span><br><span class="line">count_2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p><strong>数组中，某个数左边或右边，有多少个数比它大，类似的或者有相似子步骤的问题，都可以往递归上靠。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-表连接</title>
      <link href="/2022/09/10/MySQL-%E8%A1%A8%E8%BF%9E%E6%8E%A5/"/>
      <url>/2022/09/10/MySQL-%E8%A1%A8%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-交叉连接-font"><font color='red'>交叉连接</font></h3><p><strong>交叉连接（CROSS JOIN）一般用来直接返回连接表的笛卡尔积。</strong><br>交叉连接的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span>子句]</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span>子句] </span><br></pre></td></tr></table></figure><p><strong>注意，</strong></p><p><strong>笛卡尔积示例：第一种方式为官方指定写法，语义更加清晰；第二种写法默认为交叉连接，如果想指定为内连接和外连接，就需要显式指定。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span> course ;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br></pre></td></tr></table></figure><p>可见，笛卡尔积中大多数条目都没有意义，所以通过交叉连接的方式进行多表查询的这种方法并不常用，我们应该尽量避免这种查询。</p><h3 id="font-color-red-内连接-font"><font color='red'>内连接</font></h3><p>内连接使用 <strong>INNER JOIN</strong> 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。<br>内连接的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ON</span>子句]</span><br></pre></td></tr></table></figure><p>INNER JOIN 也可以使用 WHERE 子句指定连接条件，但是 INNER JOIN … ON 语法是官方的标准写法，而且 WHERE 子句在某些时候可能会影响查询的性能。</p><blockquote><p>有时以不同的方式编写查询可以提高速度，但多数情况下使用 WHERE 和 ON 实现的连接在底层的查询计划是相同的，理论上没有任何性能区别。</p><p>另一种说法是：ON 子句对每次笛卡儿积的中间结果进行过滤，而 WHERE 子句对最终结果进行过滤。该说法未查证真伪，但这似乎为采取社区的语法规范提供了理由：由该说法可得在外连接时，使用 ON 而不是 WHERE 来设置连接条件将提高效率</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> stuinfo.course_id<span class="operator">=</span>course.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-外连接-font"><font color='red'>外连接</font></h3><p><strong>外连接分为左连接和右连接</strong> 。在内连接中我们发现，当 ON 子句中的连接条件不成立时，就不会输出相应结果。但有时，我们也想输出未满足条件的那些记录，比如在上表中，我们以 stuinfo 和 course 表中的 id 为连接条件，只输出了满足条件的内容；但现在我们想查看所有参加了选课的同学，同时学生和所选课程也要在同一行，怎么办呢？这时就需要用到外连接。下面我们使用 <strong>左外连接</strong> 来完成这个需求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> course</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> stuinfo.course_id<span class="operator">=</span>course.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br></pre></td></tr></table></figure><p>可见，Xuan 同学所选的课程号是不存在的。</p><p><strong>外连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN</strong> 。以上为左连接示例，右连接同理不再赘述。另外，MySQL 不支持全外连接，Oracle 支持全外连接。</p><h3 id="font-color-red-自连接-font"><font color='red'>自连接</font></h3><p>自连接是指在同一张表上的连接查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name  <span class="operator">|</span> mgn  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom   <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>现在我们有这样一个需求：打印出职员名和职员名对应的上级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> worker.name <span class="keyword">AS</span> &quot;职员名&quot;,manager.name <span class="keyword">AS</span> &quot;上级名&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> emp <span class="keyword">AS</span> worker, emp <span class="keyword">AS</span> manager</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> worker.mgr<span class="operator">=</span>manager.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 职员名     <span class="operator">|</span> 上级名     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack      <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom       <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling     <span class="operator">|</span> Jack      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black     <span class="operator">|</span> Tom       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，如上，自连接必须指定别名以区分不同实例！</font></strong><br>同时可见，Han是总裁，没有上级员工，但现在我们也想让 Han 出现在上表中，咋办？使用左连接即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> worker.name <span class="keyword">AS</span> &quot;职员名&quot;,manager.name <span class="keyword">AS</span> &quot;上级名&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> emp <span class="keyword">AS</span> worker <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp <span class="keyword">AS</span> manager</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> worker.mgr<span class="operator">=</span>manager.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 职员名     <span class="operator">|</span> 上级名     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack      <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom       <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling     <span class="operator">|</span> Jack      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black     <span class="operator">|</span> Tom       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han       <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:填数字</title>
      <link href="/2022/09/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%A1%AB%E6%95%B0%E5%AD%97/"/>
      <url>/2022/09/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%A1%AB%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述：</mark> </strong><br>有 7 对数字:两个 1 ,两个 2 ,两个 3 ,…两个 7 ,把它们排成一行。要求,两个 1 间有 1 个其它数字,两个 2 间有 2 个其它数字,以此类推,两个 7 之间有 7 个其它数字。如下就是一个符合要求的排列:<br><code>1 7 1 2 6 4 2 5 3 7 4 6 3 5</code></p><p>请列出所有满足条件的排列。</p><p><strong><mark class="hl-label blue">问题分析：</mark> </strong></p><p>稍作分析我们就可以得到以下结论：</p><ol><li><p>放数字时，不仅要在当前位置放，还需要在关联位置上放：</p><img src="/2022/img/image-20220909104732262.png" style="zoom:50%;" />在 [4] 位置放置 3 时，也必须同时在 [8] 位置放置 3；</li><li><p>每放一个数字时，都需要将此数字标记为已放置。</p></li><li><p>放置数字时，必须在没有放置(未标记)的数字中 <strong>从小到大</strong> 试每个数字，直到能够放置或试完所有数字：<br><img src="/2022/img/image-20220909104746470.png" style="zoom:50%;" /></p><p>在 [9] 位置放置时，遍历 1,2,3,4,5 发现都已标记，于是尝试 6，不可；在尝试 7，不可；于是撤销上一步操作；</p></li><li><p>当发现某个空白位不能放任何数字时，说明之前的放置方式是错误的， <strong>需要撤回上一次的放置</strong> ，并放置其他数字，再重复以上过程：<br>在上图中，执行到第 6 步(箭头6)时陷入死路，于是撤回到第 5 步(箭头5)，并在此处尝试放置数字 6，可以：<br><img src="/2022/img/image-20220909105313901.png" style="zoom:50%;" /><br>然后在箭头 6 处放置数字；先考虑放置 5，不可；再考虑放置 7，不可；于是再次撤回到箭头 5，并在此放置数字 7，仍然不可；于是撤回到箭头 4，并在此处放置 5，可以：<br><img src="/2022/img/image-20220909105659357.png" style="zoom:50%;" /><br>然后在箭头 5 处考虑放置数字 4，不可([12]被 5 占了)；考虑数字 6，可以，于是放置 6…</p></li></ol><p><strong>从以上过程可见，核心有两点：</strong></p><ol><li><strong>从小到大依次放置数字</strong></li><li><strong>撤销操作的实现</strong></li></ol><p>实际上，这个过程可以抽象成如下动态变化的树：<br><img src="/2022/img/image-20220909111056021.png" style="zoom:67%;" /><br>执行到第 7 步时，只有数字 6 未标记，但无法放置，于是回退到第 6 步，之前放置的是数字 2，回退后就应该尝试放置数字 6，也无法放置；于是回退到第五步，之前放置的是数字 5，现在应该尝试放置数字 6，可以；重复以上步骤即可。下面给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> num[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">15</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPut</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!num[i] <span class="comment">//是否被标记为已放</span></span><br><span class="line">        &amp;&amp; pos + <span class="number">1</span> + i &lt;= <span class="number">14</span> &amp;&amp; arr[pos + <span class="number">1</span> + i] == <span class="number">0</span>)<span class="comment">//该空白处是否能放</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> pos)</span><span class="comment">//放置数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[pos] = k;</span><br><span class="line">arr[pos + <span class="number">1</span> + k] = k;</span><br><span class="line">num[k] = <span class="number">1</span>;<span class="comment">//标记该数字为已放true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&gt;<span class="number">14</span>)<span class="comment">//判断所有数字是否已经put</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[pos]!=<span class="number">0</span>)<span class="comment">//如果该位置有数字了，则再往前走一步</span></span><br><span class="line"><span class="built_in">go</span>(pos + <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">7</span>; k++)<span class="comment">//从小到大依次试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">canPut</span>(k, pos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">put</span>(k, pos);</span><br><span class="line"><span class="built_in">go</span>(pos + <span class="number">1</span>, k);<span class="comment">//进入下一层</span></span><br><span class="line">                <span class="comment">//以下三行是撤销操作！</span></span><br><span class="line">arr[pos + k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">arr[pos] = <span class="number">0</span>;</span><br><span class="line">num[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">go</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据操作(二)</title>
      <link href="/2022/09/06/MySQL-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/09/06/MySQL-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基本格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">[<span class="keyword">DISTINCT</span>]</span><br><span class="line">&#123;<span class="operator">*</span> <span class="operator">|</span> <span class="operator">&lt;</span>字段列名<span class="operator">&gt;</span>&#125;</span><br><span class="line">[    </span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表 <span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表 <span class="number">2</span><span class="operator">&gt;</span>…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">group</span> <span class="keyword">by</span> definition<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span> [&#123;<span class="operator">&lt;</span>operator<span class="operator">&gt;</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span>&#125;…]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">order</span> <span class="keyword">by</span> definition<span class="operator">&gt;</span>]</span><br><span class="line">[LIMIT[<span class="operator">&lt;</span><span class="keyword">offset</span><span class="operator">&gt;</span>,] <span class="operator">&lt;</span><span class="type">row</span> count<span class="operator">&gt;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，以上指令的输入顺序不能乱！</font></strong></p><p>基础示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-去重-font"><font color='red'>去重</font></h3><p>DISTINCT 关键字的主要作用就是对数据表中一个或多个字段重复的数据进行过滤，只返回其中的一条数据给用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12398</span> <span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">21343</span> <span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。查询 student 表中对 name 和 age 字段去重之后记录的条数，SQL 语句和运行结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name,age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name,age) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span>                        <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-别名-font"><font color='red'>别名</font></h3><p><strong>给列起别名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 总分   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">397</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">388</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">436</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">352</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> 姓名 (数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line">ERROR <span class="number">1305</span> (<span class="number">42000</span>): <span class="keyword">FUNCTION</span> stuinfo.姓名 does <span class="keyword">not</span> exist</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> 姓名 ,(数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名    <span class="operator">|</span> 总分   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>    <span class="number">397</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>    <span class="number">388</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>    <span class="number">436</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>    <span class="number">352</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br></pre></td></tr></table></figure><p><strong>给表起别名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> stu.name ,stu.addr <span class="keyword">FROM</span> stu_info_table <span class="keyword">AS</span> stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han   <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：表的别名不能与该数据库的其它表同名。字段的别名不能与该表的其它字段同名。</strong><br>某些情况下必须使用别名，如自连接时需要给表取别名，详见：<a href="https://jyxcpp.netlify.app/2022/09/10/mysql-%E8%A1%A8%E8%BF%9E%E6%8E%A5/">表的连接</a></p><h3 id="font-color-red-限制查询的条数-font"><font color='red'>限制查询的条数</font></h3><p>当数据表中有上万条数据时，一次性查询出表中的全部数据会降低数据返回的速度，同时给数据库服务器造成很大的压力。这时就可以用 <code>LIMIT</code> 关键字来限制查询结果返回的条数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl LIMIT 初始位置,条数;</span><br></pre></td></tr></table></figure><p><strong>如果不加初始位置，则默认从<font color='orange'>第0条</font>开始。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info_table LIMIT <span class="number">3</span>,<span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info_table LIMIT <span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>每页显示 N 条，则公式为：<code>LIMIT (第几页-1)*N , N</code></p><h3 id="font-color-red-对查询结果排序-font"><font color='red'>对查询结果排序</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>其中， ASC 代表升序，DESC 代表降序；<strong>默认升序</strong> ；<br>单字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名   <span class="operator">|</span> 数学   <span class="operator">|</span> 语文   <span class="operator">|</span> 英语   <span class="operator">|</span> 物理   <span class="operator">|</span> 化学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">68</span> <span class="operator">|</span>     <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span>     <span class="number">97</span> <span class="operator">|</span>     <span class="number">96</span> <span class="operator">|</span>     <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">68</span> <span class="operator">|</span>     <span class="number">59</span> <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span>     <span class="number">57</span> <span class="operator">|</span>     <span class="number">86</span> <span class="operator">|</span>     <span class="number">58</span> <span class="operator">|</span>     <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br></pre></td></tr></table></figure><p>多字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese, Math <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> Chinese ,Math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span> Math <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意：在对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese, Math <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> Chinese <span class="keyword">DESC</span>,Math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span> Math <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>DESC 关键字只对前面的列进行降序排列，在这里只对 height 字段进行降序。因此，height 按降序排序，而 name 仍按升序排序。如果想在多个列上进行降序排序，<strong><font color='orange'>必须对每个列指定 DESC 关键字</font></strong> 。</p><h3 id="font-color-red-条件查询-font"><font color='red'>条件查询</font></h3><p>查询条件可以是：</p><ul><li><p>带比较运算符：&gt; ，&lt;，&gt;=，&lt;=，!= ，= 等；</p></li><li><p>逻辑运算符：AND(&amp;&amp;) , NOT , OR(||) , XOR</p><blockquote><p>XOR：记录满足其中任意一个条件，并且不满足另一个条件时，才会被查询出来。</p></blockquote></li><li><p>带 <code>BETWEEN AND</code> 关键字的查询条件：等价于 <code>&gt;=L AND &lt;= R</code></p></li><li><p>带 <code>IS NULL</code> 关键字的查询条件：判断是否为空；**不能将 <code>IS</code> 换做 <code>=</code> **</p></li><li><p>带 <code>IN</code> 关键字的查询条件：显示在 IN 列表中的值，如 IN(98,87)；</p></li><li><p>带 <code>LIKE</code> ，<code>NOT LIKE</code> 关键字的查询条件</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">####<span class="keyword">IN</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Math <span class="keyword">IN</span>(<span class="number">98</span>,<span class="number">76</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>        <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>      <span class="number">59</span> <span class="operator">|</span>        <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####<span class="keyword">BETWEEN</span> <span class="keyword">AND</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Chinese <span class="keyword">BETWEEN</span> <span class="number">87</span> <span class="keyword">AND</span> <span class="number">98</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line">####XOR</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> MATH <span class="operator">&gt;</span> <span class="number">70</span> XOR Physics <span class="operator">&lt;</span> <span class="number">70</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>      <span class="number">97</span> <span class="operator">|</span>      <span class="number">96</span> <span class="operator">|</span>        <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>      <span class="number">86</span> <span class="operator">|</span>      <span class="number">58</span> <span class="operator">|</span>        <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br></pre></td></tr></table></figure><p><code>LIKE</code> 模糊查询：<code>%</code> 代表任何长度的字符串，字符串的长度可以为 0；<code>_</code> 只能代表单个字符，字符的长度不能为 0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> &quot;%an%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> &quot;_a%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br></pre></td></tr></table></figure><p>默认情况下，<strong>LIKE 关键字匹配字符的时候是不区分大小写的</strong> 。如果需要区分大小写，可以加入 <code>BINARY</code> 关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="type">BINARY</span> &quot;han&quot;;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="type">BINARY</span> &quot;Han&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</strong><br><strong><font color='orange'>WHERE 查询条件中不可以使用字段别名</font></strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">AS</span> 姓名,Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;where clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">AS</span> 姓名,Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名   <span class="operator">|</span> 数学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-分组查询-font"><font color='red'>分组查询</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在数据统计时，GROUP BY 关键字经常和聚合函数一起使用。聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()等：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>        <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>      <span class="number">59</span> <span class="operator">|</span>        <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>      <span class="number">97</span> <span class="operator">|</span>      <span class="number">96</span> <span class="operator">|</span>        <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>      <span class="number">86</span> <span class="operator">|</span>      <span class="number">58</span> <span class="operator">|</span>        <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX ,<span class="built_in">AVG</span>(Math) <span class="keyword">AS</span> 数学平均分 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> 数学平均分       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span>         <span class="number">77.0000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span>         <span class="number">87.0000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>GROUP BY 关键字可以和 GROUP_CONCAT() 函数一起使用。GROUP_CONCAT() 函数会把每个分组的字段值都显示出来：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name`, SEX <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line">ERROR <span class="number">1055</span> (<span class="number">42000</span>): Expression <span class="number">1</span> <span class="keyword">of</span> <span class="keyword">SELECT</span> list <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">and</span> <span class="keyword">contains</span> nonaggregated <span class="keyword">column</span> <span class="string">&#x27;stuinfo.demo_2.name&#x27;</span> which <span class="keyword">is</span> <span class="keyword">not</span> functionally dependent <span class="keyword">on</span> columns <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause; this <span class="keyword">is</span> incompatible <span class="keyword">with</span> sql_mode<span class="operator">=</span>only_full_group_by</span><br><span class="line">### 直接根据SEX分组打印信息会报错</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX, GROUP_CONCAT(name) <span class="keyword">AS</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han,Xuan  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack,Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="3"><li>WITH POLLUP 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX, GROUP_CONCAT(name) <span class="keyword">AS</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han,Xuan           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack,Mike          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Han,Xuan,Jack,Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-过滤分组-font"><font color='red'>过滤分组</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。但是 WHERE 和 HAVING 关键字也存在以下几点差异：</p><ol><li><strong><font color='orange'>一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。</font></strong></li><li><strong>WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。</strong></li><li><strong>WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 ，<font color='orange'>所以 HAVING 绝大多数时候应该搭配 GROUP BY 使用！</font></strong></li><li>WHERE 针对数据库文件进行过滤，而 HAVING 针对查询结果进行过滤。也就是说，<strong>WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面<font color='orange'>已经查询出的字段</font>进行过滤。</strong></li><li><strong><font color='red'>WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。</font></strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#对于第<span class="number">4</span>点</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> Math<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;Math&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;having clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Math<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line">#对于第<span class="number">5</span>点</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;where clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 数学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12398</span> <span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">21343</span> <span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> GROUP_CONCAT(name) ,addr <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> addr</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> addr<span class="operator">!=</span>&quot;深圳&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> GROUP_CONCAT(name) <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike,XUAN,Han      <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack               <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-子查询-font"><font color='red'>子查询</font></h3><p>子查询指将一个查询语句嵌套在另一个查询语句中。<strong>在 SELECT 语句中，子查询可以被嵌套在 SELECT 语句的列、表和查询条件中，即 SELECT 子句，FROM 子句、WHERE 子句、GROUP BY 子句和 HAVING 子句，而且可以进行多层嵌套。</strong> 子查询经常出现在 WHERE 子句中。使用子查询时，常用 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。</p><p>为方便演示，先给出以下酒店数据库的三张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">##房间类型</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line">##房间信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> room_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> location <span class="operator">|</span> state <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-1</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-2</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-3</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">003</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-4</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">004</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">10</span><span class="number">-5</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">005</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">11</span><span class="number">-6</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">006</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">11</span><span class="number">-7</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">007</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">12</span><span class="number">-8</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">008</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">12</span><span class="number">-9</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">009</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">13</span><span class="number">-10</span>    <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span> <span class="number">10</span><span class="number">-11</span>    <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line">##客人信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> ID     <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">511323</span> <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">18990889826</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">511345</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> <span class="number">17390199497</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">532435</span> <span class="operator">|</span>   <span class="number">45</span> <span class="operator">|</span> <span class="number">18932981949</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">343234</span> <span class="operator">|</span>   <span class="number">34</span> <span class="operator">|</span> <span class="number">14342324323</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">343323</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> <span class="number">32232123343</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">单行子查询：</mark> </strong></p><p>1）查询和李华住在一个房间的人（单次嵌套）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> customer_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> room_id <span class="operator">=</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> room_id <span class="keyword">FROM</span> customer_info <span class="keyword">WHERE</span> `name`<span class="operator">=</span>&quot;李华&quot;)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AND</span> `name`<span class="operator">!=</span><span class="string">&#x27;李华&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure><p>2）查询李华住的房间的价格（多次嵌套，横跨三张表）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> price <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> type<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> type <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> room_id<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> room_id <span class="keyword">FROM</span> customer_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;李华&quot;));</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">多行子查询：</mark> </strong><br>1）查询状态为空的所有房间的价格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> price <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> type <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> type <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> state<span class="operator">=</span><span class="number">0</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p>2）打印出各 capacity 中的最高 price 的房型，输出列包含：type，price，capacity。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"></span><br><span class="line">#小白一般可能会这样：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type, <span class="built_in">MAX</span>(price), capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity;</span><br><span class="line">ERROR <span class="number">1055</span> (<span class="number">42000</span>): Expression #<span class="number">1</span> <span class="keyword">of</span> <span class="keyword">SELECT</span> list <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">and</span> <span class="keyword">contains</span> nonaggregated <span class="keyword">column</span> <span class="string">&#x27;custom_info.type_info.type&#x27;</span> which <span class="keyword">is</span> <span class="keyword">not</span> functionally dependent <span class="keyword">on</span> columns <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause; this <span class="keyword">is</span> incompatible <span class="keyword">with</span> sql_mode<span class="operator">=</span>only_full_group_by</span><br><span class="line">#报错是因为 “type 不依赖 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 子句中的列” </span><br></pre></td></tr></table></figure><p>如上，多行子查询常用 IN 和 NOT IN，同时也经常用到 EXISTS 关键字；<strong>EXISTS 用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回布尔值 true 或 false，EXISTS 指定一个子查询，检测行的存在</strong> 。</p><p>3）若还有空房，则打印所有房间类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> state <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> state<span class="operator">=</span><span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>子查询的功能也可以通过表连接完成，但是子查询会使 SQL 语句更容易阅读和编写</strong> 。一般来说，表连接（内连接和外连接等）都可以用子查询替换，但反过来却不一定，有的子查询不能用表连接来替换。子查询比较灵活、方便、形式多样，适合作为查询的筛选条件，而表连接更适合于查看连接表的数据。<br>习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：<strong>先执行子查询，再执行父查询</strong> 。</p><h3 id="font-color-red-子查询临时表-font"><font color='red'>子查询临时表</font></h3><p>现在有这样一个需求：打印出各 capacity 中的最高 price 的房型，输出列包含：type，price，capacity。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#显示上述表中价格第二的条目，实际无需如此复杂</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity)) temp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> temp.price <span class="keyword">DESC</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type      <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房    <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br></pre></td></tr></table></figure><p>嵌套在 SELECT 语句的 FROM 子句中的子查询语法格式如下：</p><p>SELECT  * FROM (子查询) AS 表的别名；<strong>注意：必须为表指定别名。</strong></p><h3 id="font-color-red-多列子查询-font"><font color='red'>多列子查询</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br></pre></td></tr></table></figure><p>需求：找到和 Jack 所在部门相同且上级也相同的人：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> (mgr,department)<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> mgr,department <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>&quot;Jack&quot;)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">&amp;&amp;</span> name<span class="operator">!=</span>&quot;Jack&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>子查询语句返回多列结果，分别与等号前的 mgr 和 department 匹配。</p><h3 id="font-color-red-合并查询-font"><font color='red'>合并查询</font></h3><p>通常使用 <code>UNION ALL</code> 或 <code>UNION</code> 关键字合并多张表的查询结果。前者不会去重，后者会去重。比如有这样一个需求：NO.1 中学和 NO.2 中学联考，并混合排名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO1SC.stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO2SC.stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> JayChou <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black   <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han     <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>   <span class="number">147</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO1SC.stu_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO2SC.stu_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Jack    <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han     <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>   <span class="number">147</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan    <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Dan     <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black   <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JayChou <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="http://c.biancheng.net/">C语言中文网</a> ，<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=30&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平MYSQL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的起始下标为什么为0?</title>
      <link href="/2022/09/05/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BA0/"/>
      <url>/2022/09/05/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BA0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>x数组的起始下标为什么为0?</p><p>相信每一位初学者都曾吐槽过 C 语言的数组下标为什么从 0 开始，而不是从 1 开始，这样太不人性化了:smile: 。实际上，不仅是 C 语言，其他绝大多数语言的数组下标也是从 0 开始的，既然都如此设计，就必然有它的好处。下面我们就这个问题来进行粗略的讨论。</p><ul><li><p><strong><font color='orange'>首要目标：为了方便计算出每个元素的具体内存地址：</font></strong><br>a[0] 的内存地址  =  a的地址 + 0 * 4   (第一个元素的地址计算结果跟数组的首地址一样)<br>a[1] 的内存地址  =  a的地址 + 1 * 4   (下标是1,内存地址就就是首地址偏移 4 字节)<br>a[2] 的内存地址  =  a的地址 + 2 * 4   (下标是2,内存地址就首地址偏移 8 字节)<br>…<br>a[5]的内存地址  =  a的地址 + 5 * 4  (下标是5 内存地址就是首地址 偏移 20字节)<br>如果从 1 开始，每一步都要减去1,多一步运算,效率就相对较低；而从 0 开始，就无需减 1。</p></li><li><p><strong><font color='orange'>利于边界处理：</font></strong> 下面这张图胜过千言万语<br><img src="/2022/img/2025849-20200824195059390-1250153254.png" alt=""></p><p>将一个左闭右开区间“切割”时，其子区间也能很好的符合左闭右开的形式。例如：区间[x,y)可以分割为:[x,z)和[z,y)——无缝连接，没有重叠。假如是全闭区间的话，边界情况处理起来就比较麻烦。全开区间的话会丢掉端点，边界情况就要特判。</p></li><li><p>数组[1,3,4,7,8]的中间下标为 5/2 = 2，刚好在中间，对应数字为4；如果下标从 1 开始，那么下标 2 就对应数字3，实际并不是数组的中间位置。</p></li><li><p>有点植树问题的感觉，比如你要爬到第 15 楼，而实际上只需要爬 14 层；如果将第一层定义为 0 层，那么你去第 15 楼时，实际也只需要爬 15 楼；这使得描述更加统一。</p></li></ul><p><strong>你还有其他见解吗？欢迎在评论区提出。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识复杂度与对数器</title>
      <link href="/2022/09/05/%E5%88%9D%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8/"/>
      <url>/2022/09/05/%E5%88%9D%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-时间复杂度-font"><font color='red'>时间复杂度</font></h2><ul><li>务必细分过程，区别出常数操作和与 N 有关的操作。这也要求你对调用的 API 有一定熟悉程度！</li><li>对于插入排序这样会由于数据状态而影响到算法过程的，<strong><font color='orange'>一律按最差情况统计复杂度！</font></strong></li><li>冒泡和选择排序的算法性能是固定的，不受数据状态影响；而插入会受数据状态影响。后者性能大于前两者。</li><li>当两算法的复杂度都相等时(比如，冒泡和插入都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>) ，就需要比拼各自的常数项时间。如何比拼常数项时间：<br><strong>放弃理论分析,生成随机数据直接测</strong> 。为什么不去理论分析?不是不能纯分析,而是没必要。因为不同常数时间的操作,虽然都是固定时间,但还是有快慢之分的。<strong>比如,位运算的常数时间小于算术运算的常数时间,这两个运算的常数时间又小于数组寻址的时间</strong> 。所以如果纯理论分析,往往会需要非常多的分析过程（就比如，算术运算在某些时候可转为位运算，详见<a href="https://jyxcpp.netlify.app/2022/07/08/csapp/">csapp</a>）。常数时间不考虑在最优解范畴。</li><li>算法优劣：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mi>X</mi></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>X</mi><mi>N</mi></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&gt;O(logN)&gt;O(N)&gt;O(N×logN)&gt;O(N^X)&gt;O(X^N)&gt;O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!)</span></span></span></span> ，其中 X 为常数，N 为数据量；</li></ul><h2 id="font-color-red-对数器-font"><font color='red'>对数器</font></h2><p>网页上关于对数器的介绍基本都来自于算法讲师左程云，所以这里不再赘述其他内容，只提供几个关键点：</p><ol><li><strong>有一个你想要测的方法 a；</strong></li><li><strong>实现一个绝对正确(不管复杂度)的方法 b；</strong></li><li><strong>实现一个随机样本产生器；</strong></li><li><strong>实现对比算法 a 和 b 的方法；</strong></li><li><strong>把方法 a 和方法 b 比对多次来验证方法 a 是否正确；</strong></li><li><strong>如果有一个样本使得比对出错，则打印样本进行分析；</strong></li><li><strong>当样本数量很多时比对测试依然正确，可以确定方法 a 已经正确。</strong></li></ol><p>下面以冒泡排序为例来演示利用对数器进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//sort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;len-i<span class="number">-1</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[k]&lt;arr[k+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp=arr[k];</span><br><span class="line">arr[k]=arr[k+<span class="number">1</span>];</span><br><span class="line">arr[k+<span class="number">1</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span></span>&#123; </span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des,src,len*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1,<span class="type">int</span>* arr_2,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">20</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;testTimes;i++)&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span> *arr_1 = <span class="built_in">generateRandomArr</span>(max,arrLen);</span><br><span class="line"><span class="type">int</span> *arr_2 = <span class="built_in">cpyArr</span>(arr_1,arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1,arrLen);  <span class="comment">//方法a</span></span><br><span class="line"><span class="built_in">sort</span>(arr_2,&amp;arr_2[arrLen],[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);<span class="comment">//方法b</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isEqual</span>(arr_1,arr_2,arrLen)==<span class="literal">false</span>)&#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;fuck!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrLen;i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout&lt;&lt;arr_1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrLen;i++)</span><br><span class="line">cout&lt;&lt;arr_2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;success&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据操作语言(一)</title>
      <link href="/2022/09/03/MySQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/03/MySQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>数据操作语句只适用于表，而无法作用于数据库，所以无需在操作关键词后添加 <code>TABLE</code> 关键字。</strong></p></blockquote><h2 id="font-color-red-INSERT-font"><font color='red'>INSERT</font></h2><p>INSERT 语句有三种语法形式：<br><strong><mark class="hl-label blue">INSERT...VALUES语句</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [ <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ , … <span class="operator">&lt;</span>列名n<span class="operator">&gt;</span>] ]</span><br><span class="line"><span class="keyword">VALUES</span> (&#123;expr<span class="operator">|</span><span class="keyword">DEFAULT</span>&#125;,...),(...),...</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_0(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id       <span class="type">CHAR</span>(<span class="number">12</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`   <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> age      TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> addr     <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (id, `name`, age, addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUE</span>(<span class="string">&#x27;12336&#x27;</span>, <span class="string">&#x27;QuanHa&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;四川&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li><p><strong>一次可插入多条记录：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (id, `name`, age, addr) <span class="keyword">VALUES</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="string">&#x27;13445&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;南京&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="string">&#x27;11234&#x27;</span>,<span class="string">&#x27;Mike&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>如<strong>果只向某些列插入值，那么其他未手动插入值的列被赋值为 NULL(若可以) 或 默认值。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0 (id,age,addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;成都&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure></li><li><p>当为所有列全部赋值时，可不指定列名，<strong>但 VALUES 中的列顺序必须和表定义时的列顺序相同</strong> ；如果不知道表的结构，使用 <code>DESC</code> 查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0 <span class="keyword">VALUES</span>(<span class="string">&#x27;111111&#x27;</span>,<span class="string">&#x27;XUAN&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;重庆&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">INSERT...SET语句</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="string">&#x27;12321&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;Han&#x27;</span>, age<span class="operator">=</span><span class="number">20</span>, addr<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span>  <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">INSERT...SELECT语句</mark> </strong></p><p><strong><font color='orange'>快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1(id, name, age, addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, name , age, addr</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><blockquote><p>另外，还有 INSERT…DELAYDE 语句，其用法较复杂，笔者将在后续文章中详细阐述。INSERT…SELECT 语句也有相当多注意事项，详细请参考 MySQL 手册和博主后续其他文章。</p></blockquote><p><strong><mark class="hl-label blue">蠕虫复制</mark> </strong><br>有时为了测试某条语句的效率，我们需要海量的数据，蠕虫复制就是利用少量已有的数据进行自我复制，只需几次操作就能获得百万级的数据表。操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp<span class="operator">^</span>C</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">12</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">12</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">24</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">24</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">###</span><br></pre></td></tr></table></figure><p>重复以上复制十几次就可以达到百万行记录。</p><h2 id="font-color-red-UPDATE-font"><font color='red'>UPDATE</font></h2><p>使用 UPDATE 语句修改单个表，语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span> [,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>… ] [<span class="keyword">WHERE</span>子句]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句] [LIMIT子句]</span><br></pre></td></tr></table></figure><p>示例一，修改某行的多个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span>  <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">111111</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">12213</span>, name<span class="operator">=</span><span class="keyword">NULL</span> #修改某行的多个字段</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111111</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12213</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><p>示例二，统一修改所有行的某个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span>id<span class="operator">*</span><span class="number">3</span>, id<span class="operator">=</span>id<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如第二行所示，UPDATE 从左到右执行赋值操作，id先加 1 ，再乘 3 。</p><p>示例三，使用 LIMIT 限定更改的行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">23</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> addr<span class="operator">=</span>&quot;南京&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">3</span>;  #限定修改三条</span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">3</span>  Changed: <span class="number">3</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37009</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">40336</span> <span class="operator">|</span> Jack   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37036</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 上海   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-DELETE-font"><font color='red'>DELETE</font></h2><p>使用 DELETE 语句从单个表中删除数据，语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> 子句] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37009</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">40336</span> <span class="operator">|</span> Jack   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37036</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>第 15 行中 <code>DESC</code> (descent) 指降序（从大到小），第 16 行的 LIMIT 为 3，故而本指令的含义为：依次删除 id 最大的三个条目。<br><strong><font color='orange'>注意：在不使用 WHERE 或 LIMIT 条件的时候，将删除所有数据。</font></strong></p><p><strong><mark class="hl-label blue">如何删除表中的重复数据？</mark> </strong></p><ol><li>创建一张新表，其结构和旧表相同。</li><li>在旧表中查重</li><li>将查重的内容复制到新表</li><li>删除旧表</li><li>将新表的名改为旧表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="number">48</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp <span class="keyword">LIKE</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">6</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> temp RENAME <span class="keyword">TO</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="font-color-red-TRUNCATE-font"><font color='red'>TRUNCATE</font></h2><p><strong>TRUNCATE  TABLE 用于完全清空一个表</strong> 。从逻辑上说，该语句与用于删除所有行的 DELETE 语句等同，但是在有些情况下，两者在使用上有所不同：</p><ul><li><p>对于InnoDB表，如果有需要引用表的外键限制，则 TRUNCATE  TABLE 被映射到 DELETE 上；否则使用快速删减（取消和重新创建表）。使用TRUNCATE  TABLE 重新设置 AUTO_INCREMENT 计数器，设置时不考虑是否有外键限制。</p></li><li><p>对于其它存储引擎，在 MySQL 5.1 中，TRUNCATE TABLE 与 DELETE  FROM 有以下几处不同：</p><ul><li>删减操作会取消并重新创建表，这比一行一行的删除行要快很多</li><li>删减操作不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。</li><li>被删除的行的数目没有被返回。</li><li>只要表定义文件 tbl_name.frm 是合法的，则可以使用 TRUNCATE  TABLE 把表重新创建为一个空表，即使数据或索引文件已经被破坏。</li><li>表管理程序不记得最后被使用的 AUTO_INCREMENT 值，但是会从头开始计数。即使对于 MyISAM 和 InnoDB 也是如此。MyISAM 和InnoDB通常不再次使用序列值。</li><li>当被用于带分区的表时，TRUNCATE  TABLE 会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（.par）文件不受影响。</li></ul></li></ul><p>TRUNCATE TABLE 是在 MySQL 中采用的一个 Oracle  SQL 扩展。</p><h2 id="font-color-red-SELECT-font"><font color='red'>SELECT</font></h2><p>SELECT 内容较多，参见另一篇文章：<a href="https://jyxcpp.netlify.app/2022/09/06/mysql-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/">MySQL-SELECT详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据定义语言(二)</title>
      <link href="/2022/09/02/MySQL-%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/02/MySQL-%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-表的创建-font"><font color='red'>表的创建</font></h2><p>有两种方式：1. 新创建一个表；2. 根据旧表结构创建新表；格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#################################################<span class="number">1.</span>自定义创建新表</span><br><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tbl_name</span><br><span class="line">    [(create_definition,...)]</span><br><span class="line">    [table_options] [select_statement]</span><br><span class="line">########示例<span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_0 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`   <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  age     TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  gender  <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `resume` TEXT);   #如果不指定字符集和校对规则，则采用默认对象</span><br><span class="line">########示例<span class="number">2</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`  <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  age    TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `resume` TEXT)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_bin ENGINE INNODB;</span><br><span class="line">#################################################<span class="number">2.</span>模仿旧表结构创建新表</span><br><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tbl_name</span><br><span class="line">    [(] <span class="keyword">LIKE</span> old_tbl_name [)];</span><br><span class="line">########示例<span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> demo_2 <span class="keyword">LIKE</span> demo_1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>详尽的 <code>table_options</code> ， <code>select_statement</code> 与 <code>create_definition</code> 内容请查看<a href="https://jyxcpp.netlify.app/2022/08/31/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Mysql5.1手册</a> .</p></blockquote><ul><li><p>CREATE TABLE用于创建带给定名称的表。您必须拥有表 CREATE 权限。</p></li><li><p>第 7、10 行的 name 和 resume 加上了反引号 ` ，<strong>这是因为 name 和 resume 是 Mysql 的保留字，为了避免冲突，需要加反引号</strong> 。</p></li><li><p>创建表时默认在本数据库下创建，如果要在其他数据库中创建表，除了先切换到其他数据库再创建表，还可以使用以下方式：</p></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> staffInfo.demo_0 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> USE staffInfo;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_staffinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_0              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>表名称被指定为 <code>db_name.tbl_name</code> ，以便在特定的数据库中创建表。不论是否有当前数据库，都可以通过这种方式创建表。如果您使用加引号的识别名，则应对数据库和表名称分别加引号。例如，`mydb` . `mytbl`是合法的，但是 `mydb.mytbl` 不合法。</p><ul><li><p>在创建表格时，您可以使用 <code>TEMPORARY</code> 关键词。只有在当前连接情况下，TEMPORARY 表才是可见的。<strong>当连接关闭时，TEMPORARY 表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止</strong> ）您必须拥有 CREATE  TEMPORARY TABLES 权限，才能创建临时表。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `aha`(data <span class="type">INT</span>); #在stuinfo数据库中创建临时表</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> quit; #断开当前连接并重新登入</span><br><span class="line">Bye</span><br><span class="line">C:\Windows\system32<span class="operator">&gt;</span>mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">Enter password: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Welcome <span class="keyword">to</span> the MySQL monitor.</span><br><span class="line">mysql<span class="operator">&gt;</span> use stuinfo;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> test_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_2            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_5            <span class="operator">|</span>  #之前的临时表消失</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>要求某列不能为空，且指定默认值：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> country <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;China&quot;);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo <span class="keyword">VALUES</span>(); #未插入具体值</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> China   <span class="operator">|</span> #默认值为china</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br></pre></td></tr></table></figure><p>使用 <code>NOT NULL DEFAULT</code> 为某列指定默认值。</p></li></ul><h2 id="font-color-red-表的查看-font"><font color='red'>表的查看</font></h2><p><strong><mark class="hl-label blue">查看当前数据库下的表</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> demo_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_2            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_5            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">查看表的结构</mark> </strong></p><ol><li>使用 <code>DESC</code> 或 <code>DESCRIBE</code> ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>SHOW CREATE TABLE</code> ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                               <span class="comment">----------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1 <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `demo_1` (</span><br><span class="line">  `age` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resume` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>和 DESCRIBE 相比，SHOW CREATE TABLE 展示的内容更加丰富，它可以查看表的存储引擎和字符编码；在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加 <code>\g</code> 或者 <code>\G</code> 参数可以改变展示形式。</p><p><strong>&quot;<mark class="hl-label blue">查看表的状态</mark> </strong><br>使用 <code>SHOW TABLE STATUS</code> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: customer_info</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">5</span></span><br><span class="line"> Avg_row_length: <span class="number">3276</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2022</span><span class="number">-09</span><span class="number">-09</span> <span class="number">17</span>:<span class="number">03</span>:<span class="number">51</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: fuck</span><br><span class="line">         Engine: <span class="keyword">NULL</span></span><br><span class="line">        Version: <span class="keyword">NULL</span></span><br><span class="line">     Row_format: <span class="keyword">NULL</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="keyword">NULL</span></span><br><span class="line"> Avg_row_length: <span class="keyword">NULL</span></span><br><span class="line">    Data_length: <span class="keyword">NULL</span></span><br><span class="line">Max_data_length: <span class="keyword">NULL</span></span><br><span class="line">   Index_length: <span class="keyword">NULL</span></span><br><span class="line">      Data_free: <span class="keyword">NULL</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="keyword">NULL</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: <span class="keyword">NULL</span></span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: <span class="keyword">NULL</span></span><br><span class="line">        Comment: <span class="keyword">VIEW</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-表的修改-font"><font color='red'>表的修改</font></h2><p>其语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [修改选项]</span><br></pre></td></tr></table></figure><p>修改选项的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>旧列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> &#123; <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="operator">|</span> MODIFY <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> RENAME [<span class="keyword">TO</span>] <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> #或 CHARSET</span><br><span class="line"><span class="operator">|</span> <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更详细的选项参见<a href="https://jyxcpp.netlify.app/2022/08/31/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Mysql5.1手册</a></p></blockquote><p><strong><mark class="hl-label blue">修改表名</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_2 RENAME <span class="keyword">TO</span> demo_3;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><code>TO</code> 可加可不加。</p><p><strong><mark class="hl-label blue">修改字符集</mark> </strong></p><ol><li><strong>修改表的默认字符集</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">################修改表的字符集</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHARSET utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改列的字符集</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">################修改列的字符集</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_5 CHANGE country country <span class="type">CHAR</span>(<span class="number">10</span>) CHARSET ascii;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_5 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: demo_5</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `demo_5` (</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country` <span class="type">char</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> ascii <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>修改列的字符集时，可以不改名和列类型，但必须写出更改后(未更改)的名字和类型，这是捆绑在一起的操作。</font></strong></p><p><strong><mark class="hl-label blue">添加列</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age    <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> address <span class="type">VARCHAR</span>(<span class="number">32</span>) </span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p>默认是添加到最后一行，可使用关键字 <code>AFTER</code> 和 <code>FIRST</code> 在指定位置插入新行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sex   <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_5 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> addr <span class="type">VARCHAR</span>(<span class="number">48</span>) AFTER age;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> addr  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">48</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sex   <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">修改列名</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHANGE <span class="keyword">COLUMN</span> `name` `tel` <span class="type">VARCHAR</span>(<span class="number">11</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.07</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> tel     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">11</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p>如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，<strong><font color='orange'>但数据类型不能为空</font></strong> 。</p><p><strong><mark class="hl-label blue">修改列类型</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 MODIFY <span class="keyword">COLUMN</span> tel <span class="type">VARCHAR</span>(<span class="number">32</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> tel     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>使用 MODIFY 来改变列的类型，此时不需要重命名。</strong> <strong>使用 CHANGE 修改列类型时，必须重命名(名字可相同)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHANGE <span class="keyword">COLUMN</span> `name` `name` <span class="type">VARCHAR</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">删除列</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">DROP</span> tel;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-表的删除-font"><font color='red'>表的删除</font></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> demo_0;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-其他事项-font"><font color='red'>其他事项</font></h2><ul><li><p>如果您使用 ALTER TABLE 更改列规约，但是 DESCRIBE tbl_name 提示您列规约并没有改变，则可能是因为 MySQL 忽略了您所做的更改。例如，如果您试图把VARCHAR列更改为CHAR列，此时，如果表包含其它长度可变的列，则 MySQL 可能仍会使用VARCHAR。</p></li><li><p><strong><font color='orange'>ALTER TABLE 运行时会对原表进行临时复制( 除了 RENAME )，在副本上进行更改，然后删除原表，再对新表进行重命名</font></strong> 。在执行 ALTER  TABLE 时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。</p></li><li><p><strong><font color='orange'>要使用 ALTER TABLE，您需要获得表的 ALTER,  INSERT 和 CREATE 权限。</font></strong></p></li><li><p>您可以在一个 ALTER TABLE 语句里写入多个 ADD, ALTER,  DROP 和 CHANGE 子句，中间用逗号分开。这是 MySQL 相对于标准 SQL 的扩展。在标准 SQL 中，每个 ALTER  TABLE 语句中每个子句只允许使用一次。例如，在一个语句中取消多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type       <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">char</span>(<span class="number">8</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">DROP</span> gender, <span class="keyword">DROP</span> resume;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type    <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">char</span>(<span class="number">8</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><code>COLUMN</code> 为可选关键字。<code>CHARSET</code> 与 <code>CHARACTER SET</code> 相同。</p></li><li><p><strong><font color='orange'>表中各列数据的字符集可以不同</font></strong> 。如果您在向表中添加一个新列时没有指定字符集，则此时使用表的默认字符集。注意，<strong>以下语句只改变了表的默认字符集：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHARSET utf8;</span><br></pre></td></tr></table></figure><p><strong>如果您想要把表默认的字符集和所有字符列（CHAR, VARCHAR, TEXT）改为新的字符集，应使用如下语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> CHARSET utf8;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据类型</title>
      <link href="/2022/08/31/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/08/31/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-概要-font"><font color='red'>概要</font></h2><p>MySQL 数据类型又叫 “列类型” 、“字段类型” 。数据类型定义了列中可以存储什么数据以及该数据怎样存储的规则。MySQL 数据类型大致分为 <strong><u>数值类型</u>，<u>字符串/文本类型</u>，<u>二进制类型</u>与<u>时间/日期类型</u></strong> ，如以下三张表所示：<br><strong><mark class="hl-label blue">数值类型</mark> </strong></p><table><thead><tr><th>类型</th><th>大小（字节）</th><th>范围（signed）</th><th>范围（unsigned）</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128  ~ 127</td><td>0 ~ 255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768 ~ 32767</td><td>0 ~ 65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608 ~ 8388607</td><td>0 ~ 16777215</td></tr><tr><td><font color='orange'>INT</font></td><td>4</td><td>-2147483648 ~ 2147483647</td><td>0 ~ 4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>0 ~ 18446744073709551615</td></tr><tr><td><font color='orange'>FLOAT</font></td><td>4</td><td></td><td></td></tr><tr><td><font color='orange'>DOUBLE</font></td><td>8</td><td></td><td></td></tr><tr><td><font color='orange'>DECIMAL</font></td><td>M+2</td><td>取决于M</td><td>依赖于M</td></tr></tbody></table><p><strong><mark class="hl-label blue">字符串类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td><font color='orange'>CHAR</font></td><td>固定长度非二进制字符串</td><td>取决于字符集类型和指定的字符数，最多 255 个<u>字符</u>。</td></tr><tr><td><font color='orange'>VARCHAR</font></td><td>变长非二进制字符串</td><td>取决于字符集类型和指定的字符数，最多 65532 个<u>字节</u>。</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>2^8 字节；</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>2^16 字节，约 64 KB</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>2^24 字节，约 16 MB</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>2^32 字节，约 4 GB</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><p><strong><mark class="hl-label blue">时间/日期类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td><font color='orange'>TIME</font></td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td><font color='orange'>DATE</font></td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td><font color='orange'>DATETIME</font></td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><p><strong><mark class="hl-label blue">二进制类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><p>（橙色标记为常用类型）</p><h2 id="font-color-red-数值类型-font"><font color='red'>数值类型</font></h2><ul><li><p>整形类型都支持声明：<code>Type [(M)] [UNSIGNED] [ZEROFILL]</code> ；其中 M 指输出宽度，当数据长度大于宽度时，原样输出。当 M 和 ZEROFILL 同时指定时，才能看见 M 的效果。<br>浮点类型都支持声明：<code>Type [(M,D)] [UNSIGNED] [ZEROFILL]</code> ；其中 M 指小数总位数，D 指小数点后位数。如果<em>M</em>和<em>D</em>被省略，根据硬件允许的限制来保存值。<br>DECIMAL(定点)类型：<code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code> ，M 最大为 65，D 最大为 30，且 D 不得超过 M；如果<em>D</em>被省略，  默认是0。如果<em>M</em>被省略， 默认是10。DECIMAL 是定点数，不会像浮点数那样存在误差问题，广泛用于金融相关的计算中。关于 DECIMAL 定点数的讨论，参见笔者另一篇文章<a href="https://jyxcpp.netlify.app/2022/08/31/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/">定点数与浮点数</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###################################################整形测试</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1(num <span class="type">INT</span>(<span class="number">5</span>) ZEROFILL );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1 <span class="keyword">VALUES</span>(<span class="number">34</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> num   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">00034</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1 <span class="keyword">VALUES</span>(<span class="number">1234567</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> num     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">00034</span> <span class="operator">|</span>       # 输出宽度为<span class="number">5</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1234567</span> <span class="operator">|</span>       # 超过M则原样输出</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">#####################################################浮点测试</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_3 (dig <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">3</span>) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_3 <span class="keyword">VALUES</span>(<span class="number">12345.6789</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;dig&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #不能超过(<span class="number">7</span>,<span class="number">3</span>)范围</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_3 <span class="keyword">VALUES</span>(<span class="number">1235.679</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><code>FLOAT</code> 只能精确到小数点后大约 7 位；<code>DOUBLE</code> 可用精确到小数点后大约 15 位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_08(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dig <span class="type">FLOAT</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_08 <span class="keyword">VALUES</span>(<span class="number">0.123456789</span>);#输入<span class="number">9</span>位小数</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_08;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> dig      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.123457</span> <span class="operator">|</span> #输出<span class="number">6</span>位小数</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_09(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dig <span class="keyword">DOUBLE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_09 <span class="keyword">VALUES</span>(<span class="number">0.123456789123456789</span>);#输入<span class="number">18</span>位小数</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_09;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> dig                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.12345678912345678</span> <span class="operator">|</span> #输出<span class="number">17</span>位小数</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>MySQL 使用带符号的 BIGINT 或 DOUBLE 值进行所有运算</font></strong> ，因此除了位函数，不应使用大于 63位 的无符号的大整数！如果这样做，结果中的最后几位可能出错，这是由于将 BIGINT 值转换为 DOUBLE 进行四舍五入时造成的错误（BIGINT 与 DOUBLE 混合运算时）。<br><strong><font color='orange'>当两个操作数均为整数值时，-、+和*  操作符使用 BIGINT 运算</font></strong> 。这说明如果乘两个大整数，当结果大于 9223372036854775807(63位) 时，会得到意想不到的结果。</p></li></ul><h2 id="font-color-red-字符串类型-font"><font color='red'>字符串类型</font></h2><ul><li><p>CHAR 和 VARCHAR 类型声明的长度表示你想要保存的 <strong>最大字符数</strong> ，而非字节数。需要注意，<strong><font color='orange'>CHAR 的字符最大储存为 255 个；VARCHAR 的最大储存数量为 (65535-3)/3=21844 (utf8下)</font></strong> ，除以 3 可能是因为 Mysql 为 utf8 字符集设置的<u>平均</u>字节大小为 3（说“平均”是因为utf8是变长字符集，字符所占字节数从1-5都有）；VARCHAR 的最大有效长度由最大行大小和使用的字符集确定，整体最大长度是 65,532 字节，减 3 是因为 <strong>VARCHAR 是变长的，也就是说其按照实际占用空间来分配(但不可超过你指定的长度)</strong> ，所以需要 3 个字节来记录长度；相反，<strong>CHAR 是固定长度的，当保存CHAR值时，在它们的右边填充空格以达到指定的长度</strong> 。另外，<strong><font color='red'>MySQL中的所有CHAR 和 VARCHAR 值比较时不需要考虑任何尾部空格</font>；<font color='orange'>保存 VARCHAR 时，尾部的空格会保留。</font></strong> 如果分配给 CHAR 或 VARCHAR 列的值超过列的最大长度，则对值进行裁剪以使其适合，如果被裁掉的字符是空格，则会产生一条警告。如果裁剪非空格字符，则报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo4(data <span class="type">VARCHAR</span>(<span class="number">21845</span>));</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo4(data <span class="type">VARCHAR</span>(<span class="number">21844</span>));#utf8下，<span class="type">VARCHAR</span>最大字符数为<span class="number">21844</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)           #gbk下，<span class="type">VARCHAR</span>最大字符数为(<span class="number">65535</span><span class="number">-3</span>)<span class="operator">/</span><span class="number">2</span></span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo5(data <span class="type">CHAR</span>(<span class="number">5</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo5 <span class="keyword">VALUES</span>(&quot;year&quot;); #尾部填充一个空格</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo5 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;year&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> data <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">year</span> <span class="operator">|</span>     #仍然可查询到<span class="keyword">year</span>，说明<span class="type">CHAR</span>检索时忽略了尾部的空格</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo7(data <span class="type">VARCHAR</span>(<span class="number">8</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAY       &quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo7 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;DAY&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> data     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DAY</span>      <span class="operator">|</span> #仍然可查询到<span class="keyword">DAY</span>，说明<span class="type">VARCHAR</span>检索时忽略了尾部的空格</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+ #DAY后有一串空白，说明保存时保留了尾部的空格。</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAY                &quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec) #超出长度的空格被裁剪，发出警告</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAYDAYHAPPY &quot;);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;data&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #超出长度的非空格被裁减，报错</span><br></pre></td></tr></table></figure></li><li><p>当数据是定长时，比如手机号，身份证等，推荐使用 CHAR；当数据不定长时，比如留言，文章等，推荐使用 VARCHAR。<strong>CHAR 的查询速度比 VARCHAR 快</strong> 。</p></li><li><p>与 CHAR 和 VARCHAR 不同，使用 TEXT 类型时无需指定存储长度。此外，当检索或插入文本数据时，MySQL 不会删除或填充空格。 <strong>请注意，TEXT 数据不存储在数据库服务器的内存中，因此，每当查询 TEXT 数据时，MySQL都必须从磁盘读取它，这与 CHAR 和 VARCHAR 相比要慢得多。</strong> 由于 TEXT 也是不定长类型，所以也需要记录长度：TINYTEXT 需要 1 个字节记录，TEXT 需要 2 个字节，MEDIUMTEXT 需要 3 个字节，LONGTEXT 则需要四个字节。</p></li></ul><h2 id="font-color-red-二进制类型-font"><font color='red'>二进制类型</font></h2><ul><li><p>BIT 数据类型可用来保存位字段值。BIT(<em>M</em>)类型允许存储<em>M</em>位值。<strong><em>M</em>范围为1到64</strong> 。</p></li><li><p><strong>与CHAR和VARCHAR不同，BINARY和VARBINARY的长度是字节长度而不是字符长度。</strong></p></li><li><p>BIT 以二进制方式输出，如下图：</p><p><img src="/2022/img/image-20220831213507973.png" alt=""></p><p>注意，在命令行中输出不可见：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_4 (dig BIT(<span class="number">8</span>) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_4 <span class="keyword">VALUES</span>(<span class="number">129</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_4;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> dig  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含的是 <strong>字节数组</strong> (类似于 Qt 中的 QByteArray) 。也就是说，它们包含字节字符串而不是字符字符串。<font color='orange'>这说明它们没有字符集，也不包含校对规则，并且排序和比较基于字节而非字符</font>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_5 (data <span class="type">BINARY</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_6 <span class="keyword">VALUES</span>(&quot;中国&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> data       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> 中国        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>额…翻车了…因为字节数组没有字符集，所以也不应该输出“中国”呀…暂且认为是 Mysql 太贴心了吧…在 Qt 中，输出中文的字节数组，只会显示字节数据：</p><img src="/2022/img/image-20220831223235303.png" alt="" style="zoom:67%;" /><p>当保存 <code>BINARY</code> 值时，<strong>在它们<u>右边</u>填充值以达到指定长度</strong> 。填充值是 0x00(\0)。插入值时在右侧添加 0x00 ，<u>并且选择时不删除尾部的字节</u>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_6 (data <span class="type">BINARY</span>(<span class="number">10</span>)); #大小<span class="number">10</span>个字节</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_6 <span class="keyword">VALUES</span>(&quot;hello&quot;); #前五个字节为hello，后五个字节为<span class="number">0x00</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6 <span class="keyword">WHERE</span> data <span class="operator">=</span> &quot;hello&quot;;#只有五个字节，hello</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   #匹配不到是因为匹配时后面的<span class="number">0x00</span>也要参与</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;hello\0\0\0\0\0&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> data       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> hello      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当保存 <code>VARBINARY</code> ,插入时不填充字符，选择时不裁剪字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_7 (data <span class="type">VARBINARY</span>(<span class="number">10</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_7 <span class="keyword">VALUES</span>(&quot;中国&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_7 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;中国&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> data   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 中国   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>在大多数方面，可以将 BLOB 列视为能够足够大的 VARBINARY，BLOB 列没有字符集，并且排序和比较基于列值字节的数值值。</p></li></ul><h2 id="font-color-red-时间-日期类型-font"><font color='red'>时间/日期类型</font></h2><ul><li><p>试图插入一个不合法的日期，MySQL将给出警告或错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_0(ddl <span class="type">DATE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;2022-11-31&quot;);</span><br><span class="line">ERROR <span class="number">1292</span> (<span class="number">22007</span>): Incorrect <span class="type">date</span> <span class="keyword">value</span>: <span class="string">&#x27;2022-11-31&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;ddl&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #<span class="number">11</span>月没有<span class="number">31</span>号</span><br></pre></td></tr></table></figure><p>可以使用 <code>ALLOW_INVALID_DATES</code> SQL 模式让 MySQL 接受某些日期，比如 2002-00-00，这在需要保存一个你不知道确切日期的生日时非常有用 。如果你不想在日期中出现零，可以使用 <code>NO_ZERO_IN_DATE</code> SQL模式。在严格模式，非法日期不被接受。</p></li><li><p>存储年份时，可以只输入后两位，比如 <code>2022</code> -&gt; <code>22</code> ； 但两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：</p><ul><li><p>70-99 范围的年值转换为 1970-1999</p></li><li><p>00-69 范围的年值转换为 2000-2069</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;22-10-30&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;70-10-30&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-10</span><span class="number">-30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-10</span><span class="number">-30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>MySQL 以标准输出格式 <code>YYYY-MM-DD HH:MM:SS</code> 或 <code>YY-MM-DD HH:MM:SS</code> 检索给定日期或时间类型的值，但它尽力解释你指定的各种输入值格式：</p><ul><li>允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，<code>98-12-31  11:30:45</code> 、<code>98.12.31 11+30+45</code> 、<code>98/12/31  11*30*45</code> 和 <code>98@12@31 11^30^45</code> 是等价的。</li><li><code>YYYYMMDDHHMMSS</code> 或 <code>YYMMDDHHMMSS</code> 格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，<code>19970523091528</code> 和 <code>970523091528</code> 被解释为 <code>1997-05-23  09:15:28</code> ，但 <code>971122129015</code> 是不合法的(它有一个没有意义的分钟部分)，将报错或变为 <code>0000-00-00  00:00:00</code> 。<strong>强烈建议加入分隔符！</strong></li><li>对于包括日期部分间割符的字符串值，如果日和月的值小于 10，不需要指定两位数。<code>1979-6-9</code> 与 <code>1979-06-09</code> 是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于 10，不需要指定两位数。<code>1979-10-30 1:2:3</code> 与 <code>1979-10-30 01:02:03</code> 相同。</li></ul></li><li><p>在一定程度上，可以将一个日期类型的值分配给一个不同的日期类型。但是，值可能会更改或丢失一些信息：</p><ul><li>如果你为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 <code>00:00:00</code> ，因为 DATE 值未包含时间信息。</li><li>如果你为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因为 DATE 值未包含时间信息。</li><li>TIMESTAMP 值不能早于 <code>1970</code> 或晚于 <code>2037</code> 。这说明一个日期，例如 <code>1968-01-01</code> ，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP 值却无效，如果分配给这样一个对象将被转换为 0。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#####为一个 DATETIME 或 <span class="type">TIMESTAMP</span> 对象分配一个 <span class="type">DATE</span> 值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_0(ddl <span class="type">DATE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;2021-12-29 11:30:49&quot;);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-12</span><span class="number">-29</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line">#####为一个 <span class="type">DATE</span> 对象分配一个 DATETIME 或 <span class="type">TIMESTAMP</span> 值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_1 (ddl DATETIME);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_1 <span class="keyword">VALUES</span>(&quot;2022-12-29&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> ddl                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line">#####</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_2(data <span class="type">TIMESTAMP</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_2 <span class="keyword">VALUES</span>(&quot;2022-12-29 12:43:49&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)     </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_2;  #<span class="number">1970</span><span class="operator">~</span><span class="number">2037</span>之间的日期可赋值给时间戳</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> data                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-29</span> <span class="number">12</span>:<span class="number">43</span>:<span class="number">49</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_2 <span class="keyword">VALUES</span>(&quot;2045-12-29 12:43:49&quot;);#<span class="number">1970</span><span class="operator">~</span><span class="number">2037</span>之外的日期不可赋值给时间戳</span><br><span class="line">ERROR <span class="number">1292</span> (<span class="number">22007</span>): Incorrect datetime <span class="keyword">value</span>: <span class="string">&#x27;2045-12-29 12:43:49&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;data&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>时间戳取值范围包含约 22 亿个数值，因此在 MySQL 内部使用 4 个字节 INT 类型来存放时间戳数据：</p><p>1、在存储时间戳数据时，先将本地时区时间转换为 UTC 时区时间，再将 UTC 时区时间转换为 INT 格式的毫秒值(使用UNIX_TIMESTAMP函数)，然后存放到数据库中。<br>2、在读取时间戳数据时，先将INT格式的毫秒值转换为 UTC 时区时间(使用 FROM_UNIXTIME 函数)，然后再转换为本地时区时间，最后返回给客户端。</p></li><li><p>时间戳自动将当前时间填入数据库(可用于登入时间的记录)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_5(ddl <span class="type">DATE</span>, log_time <span class="type">TIMESTAMP</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>);  #<span class="number">2</span>，<span class="number">3</span>行代码设置自动记录写入时间。</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_5(DDL) <span class="keyword">VALUES</span>(&quot;2023-11-11&quot;);#只手动写入ddl</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span> log_time            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2023</span><span class="number">-11</span><span class="number">-11</span> <span class="operator">|</span> <span class="number">2022</span><span class="number">-09</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">35</span>:<span class="number">45</span> <span class="operator">|</span> #写入时间自动被记录</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="font-color-red-其他-font"><font color='red'>其他</font></h2><p><strong><mark class="hl-label blue">ZEROFILL属性</mark> </strong></p><p><code>ZEROFILL</code> 属性只用于整形。在插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补 0 ；<strong>如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性</strong> 。<code>ZEROFILL</code> 仅仅只是显示属性，与内存无关。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_5(</span><br><span class="line">    id <span class="type">INT</span> ZEROFILL);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">7.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_5 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_5 ;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> id         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0000000001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">严格/非严格模式</mark> </strong></p><p>当要在一个数值列内保存一个超出该列允许范围的值时，MySQL 的操作取决于此时有效的 SQL 模式。如果模式未设置，MySQL 将值裁剪到范围的相应端点，并保存裁减好的值。但是，如果模式设置为 traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据 SQL 标准插入会失败。如果 INT 列是 UNSIGNED，列范围的大小相同，但其端点会变为到 0 和 4294967295。若此时你试图保存 -9999999999 和 9999999999，以非严格模式保存到列中的值是 0 和 4294967296。如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。</p><p>当MySQL没有工作在严格模式时，对于 ALTER  TABLE、LOAD DATA  INFILE、UPDATE 和多行 INSERT 语句，由于裁剪发生的转换将报告为警告。当 MySQL 工作在严格模式时，这些语句将失败，并且部分或全部值不会插入或更改，取决于是否表为事务表和其它因素。<strong>最近的 Mysql 都默认采用严格模式。</strong></p><blockquote><p>参考：<a href="https://jyxcpp.netlify.app/img/mysql5.1_zh_chm.rar">Mysql5.1手册(点此下载)</a>，<a href="https://www.yiibai.com/mysql/text.html">TEXT简介</a>，<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=17&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平Mysql</a>，<a href="http://c.biancheng.net/view/2426.html">C语言中文网</a>，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据定义语言(一)</title>
      <link href="/2022/08/30/MySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/08/30/MySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。绝大多数 DBMS(Datebase Management System) 都支持 SQL 语言，因此，学习 SQL 使你几乎能与所有数据库打交道。同时，许多 DBMS 厂商通过增加语句和指令对 SQL 进行了扩展，虽然各厂商之间的扩展并不兼容，但它们都支持标准 SQL（ANCI SQL），所以无需担心 SQL 不适用于某个 DBMS。</p></blockquote><h2 id="font-color-red-SQL组成-font"><font color='red'>SQL组成</font></h2><p>SQL 包含以下 4 部分：</p><ol><li><p><strong>数据定义语言（Data Definition Language，DDL）</strong></p><p>用来创建或删除数据库以及表等对象，<strong><font color='orange'>针对的是表的结构(列)</font></strong> 。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">DROP</mark> </strong> ：删除数据库和表等对象</li><li><strong><mark class="hl-label default">CREATE</mark> </strong> ：创建数据库和表等对象</li><li><strong><mark class="hl-label default">ALTER</mark> </strong> ：修改数据库和表等对象的结构</li></ul></li><li><p><strong>数据操作语言（Data Manipulation Language，DML）</strong></p><p>用来变更表中的记录，<strong><font color='orange'>针对的是表的内容(行)</font></strong> 。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">SELECT</mark> </strong> ：查询表中的数据</li><li><strong><mark class="hl-label default">INSERT</mark> </strong> ：向表中插入新数据</li><li><strong><mark class="hl-label default">UPDATE</mark> </strong> ：更新表中的数据</li><li><strong><mark class="hl-label default">DELETE</mark> </strong> ：删除表中的数据</li></ul></li><li><p><strong>数据查询语言（Data Query Language，DQL）</strong></p><p>用来查询表中的记录，主要包含 <strong><mark class="hl-label default">SELECT</mark> </strong>  命令，来查询表中的数据。</p></li><li><p><strong>数据控制语言（Data Control Language，DCL）</strong></p><p>用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">GRANT</mark> </strong> ：赋予用户操作权限</li><li><strong><mark class="hl-label default">REVOKE</mark> </strong> ：取消用户的操作权限</li><li><strong><mark class="hl-label default">COMMIT</mark> </strong> ：确认对数据库中的数据进行的变更</li><li><strong><mark class="hl-label default">ROLLBACK</mark> </strong> ：取消对数据库中的数据进行的变更</li></ul></li></ol><h2 id="font-color-red-SQL基本书写规则-font"><font color='red'>SQL基本书写规则</font></h2><ul><li><p><strong>SQL 语句要以分号 <code>;</code> 结尾</strong> 。一条 SQL 语句代表着数据库的一个操作。</p></li><li><p><strong>单词需要用半角空格或者换行来分隔</strong></p></li><li><p><strong>SQL 语句大小写规则：</strong></p><ul><li>SQL 关键字和函数名：一律不区分大小写。</li><li>数据库名、表名和视图名：<strong>MySQL 用服务器主机的底层文件系统所包含的目录和文件来表示数据库和表</strong> 。因此，<font color='orange'>数据库名和表名的默认大小写取决于服务器主机的操作系统在命名方面的规定</font>。比如 Windows 系统的文件名不区分大小写，所以运行在 Windows 系统上面的 MySQL 服务器也不用区分数据库名和表名的大小写。Linux 系统的文件名区分大小写，所以运行在 Linux 系统上的 MySQL 服务器需要区分数据库名和表名的大小写。</li><li>存储程序的名字：存储函数、存储过程和事件的名字都不区分大小写。触发器的名字要区分大小写，这一点与标准 SQL 的行为有所不同。</li><li>列名和索引名：一律不区分大小写。</li><li>别名：表的别名在 Linux 中区分大小写，在 Windows 中不区分；列名与列的别名一律忽略大小写；</li></ul><img src="/2022/img/image-20220830161650126.png" alt="" style="zoom:67%;" /><blockquote><p>需要注意的是，插入到表中的数据是否区分大小写由创建数据库时指定的 <strong>字符集校对规则( COLLATE )</strong> 决定，默认使用 <code>utf8_general_ci</code> (不区分大小写)，而 <code>utf8_bin</code> 则区分大小写。后面会详细阐述相关内容。</p></blockquote><p>在 Linux 服务器下创建数据库和表时，考虑到它们以后是否会迁移到 Windows 服务器上，应该认真对待大小写的问题。</p></li></ul><h2 id="font-color-red-数据库基本操作-font"><font color='red'>数据库基本操作</font></h2><h3 id="font-color-red-创建数据库-font"><font color='red'>创建数据库</font></h3><p>使用 <strong>CREATE DATABASE</strong> 语句创建数据库，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] </span><br><span class="line">[[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure><p>[ ]中的内容是可选的。语法说明如下：</p><ul><li><code>&lt;数据库名&gt;</code> ：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li><code>IF NOT EXISTS</code>：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li><code>[DEFAULT] CHARACTER SET</code> ：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集，即 <code>utf-8</code> 。</li><li><code>[DEFAULT] COLLATE</code> ：指定字符集的默认校对规则，即 <code>utf8_general_ci</code> 。</li><li>注意，不同于查看数据库的操作，<code>DATABASE</code> 后面没有 <code>S</code> ，数据库名不用加 <code>''</code> 。</li></ul><blockquote><p><strong>字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。</strong></p></blockquote><p><strong><mark class="hl-label blue">示例</mark> </strong></p><p><strong>直接创建数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test_db;</span><br><span class="line">Query OK, 1 row affected (0.12 sec);</span><br></pre></td></tr></table></figure><p>若再次输入<code>CREATE DATABASE test_db;</code> 语句，则系统会给出错误提示信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test_db;</span><br><span class="line">ERROR 1007 (HY000): Can&#x27;t create database &#x27;test_db&#x27;; database exists</span><br></pre></td></tr></table></figure><p>MySQL 不允许在同一系统下创建两个相同名称的数据库。可以加上 <code>IF NOT EXISTS</code> 从句，就可以避免类似错误，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE IF NOT EXISTS test_db;</span><br><span class="line">Query OK, 1 row affected (0.12 sec)</span><br></pre></td></tr></table></figure><p><strong>指定字符集和校对规则：</strong></p><p>使用 MySQL 命令行工具创建一个测试数据库，命名为 test_db_char，指定其默认字符集为 <code>utf8</code>，默认校对规则为 <code>utf8_chinese_ci</code>（简体中文，不区分大小写），输入的 SQL 语句与执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char</span><br><span class="line">    -&gt; DEFAULT CHARACTER SET utf8</span><br><span class="line">    -&gt; DEFAULT COLLATE utf8_chinese_ci;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>仅在最后一行末尾打上分号即可</font></strong> 。<code>DEFAULT</code> 可写可不写。<br>这时，可以使用 <code>SHOW CREATE DATABASE</code> 查看 test_db_char 数据库的定义声明，发现该数据库的指定字符集为 <code>utf8</code> ，运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE DATABASE test_db_char;</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| Database     | Create Database                                     |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| test_db_char | CREATE DATABASE `test_db_char` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-查看数据库-font"><font color='gree'>查看数据库</font></h3><p>在 MySQL 数据库中存在系统数据库和自定义数据库，系统数据库是在安装 MySQL 后系统自带的数据库，自定义数据库是由用户定义创建的数据库。在 MySQL 中，可使用 <strong><mark class="hl-label default">SHOW DATABASES</mark> </strong> 语句来查看或显示当前用户权限范围以内的数据库。查看数据库的语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES LIKE &#x27;数据库名&#x27;;</span><br></pre></td></tr></table></figure><ul><li>LIKE 从句是可选项，用于匹配指定的数据库名称；LIKE 从句可以部分匹配，也可以完全匹配。<ul><li>查看名字为 stuInfo 的数据库       ：<strong><code>SHOW DATABASES LIKE 'stuInfo';</code></strong></li><li>查看名字中包含 stuInfo 的数据库：<strong><code>SHOW DATABASES LIKE '%stuInfo%';</code></strong></li><li>查看名字以 stuInfo 开头的数据库：<strong><code>SHOW DATABASES LIKE '%stuInfo';</code></strong></li><li>查看名字以 stuInfo 结尾的数据库：<strong><code>SHOW DATABASES LIKE 'stuInfo%';</code></strong></li></ul></li><li>注意是 <code>DATABASES</code> ，可别忘了后面的 <code>S</code> 。</li><li>可用单引号也可以双引号。</li></ul><p><strong>系统数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 row in set (0.22 sec)</span><br></pre></td></tr></table></figure><p>还未创建自定义数据库时，<code>SHOW DATABASES;</code> 列出的数据库即为系统数据库：</p><ul><li>information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。</li><li>mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。</li><li>performance_schema：主要用于收集数据库服务器性能参数。</li><li>sakila：MySQL 提供的样例数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。</li><li>sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。</li><li>world：world 数据库是 MySQL 自动创建的数据库，该数据库中只包括 3 张数据表，分别保存城市，国家和国家使用的语言等内容。</li></ul><p><strong>查看数据库的定义声明：</strong></p><p>使用 <code>SHOW CREATE DATABASE</code> 查看 test_db_char 数据库的定义声明，发现该数据库的指定字符集为 <code>utf8</code> ，运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE DATABASE test_db_char;</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| Database     | Create Database                                     |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| test_db_char | CREATE DATABASE `test_db_char` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>说明：第五行第二列中<code>test_db_char</code> 两旁的反引号 ` 是为了在创建数据库时规避关键字冲突，比如我脑壳烧坏了，想创建一个名为 CREATE 的数据库，就必须在创建时输入反引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE `CREATE`;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>查看当前所在数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line">############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test    <span class="operator">|</span>#数据库名</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> push_test         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ship_order_detail <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">############################</span><br><span class="line">mysql<span class="operator">&gt;</span> status;</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.7</span><span class="number">.19</span>, <span class="keyword">for</span> Win64 (x86_64)</span><br><span class="line"></span><br><span class="line">Connection id:          <span class="number">3</span></span><br><span class="line"><span class="keyword">Current</span> database:       no1sc  #当前数据库</span><br><span class="line"><span class="keyword">Current</span> <span class="keyword">user</span>:           root<span class="variable">@localhost</span></span><br><span class="line">SSL:                    <span class="keyword">Not</span> <span class="keyword">in</span> use</span><br><span class="line"><span class="keyword">Using</span> delimiter:        ;</span><br><span class="line">Server version:         <span class="number">5.7</span><span class="number">.19</span> MySQL Community Server (GPL)</span><br><span class="line">Protocol version:       <span class="number">10</span></span><br><span class="line">Connection:             localhost via TCP<span class="operator">/</span>IP</span><br><span class="line">Server characterset:    utf8</span><br><span class="line">Db     characterset:    utf8</span><br><span class="line">Client characterset:    utf8</span><br><span class="line">Conn.  characterset:    utf8</span><br><span class="line">TCP port:               <span class="number">3306</span></span><br><span class="line">Uptime:                 <span class="number">1</span> <span class="keyword">day</span> <span class="number">4</span> hours <span class="number">20</span> min <span class="number">58</span> sec</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-修改数据库-font"><font color='gree'>修改数据库</font></h3><p>在 MySQL 数据库中<u>只能对数据库使用的字符集和校对规则进行修改</u>，数据库的这些特性都储存在 db.opt 文件中。修改数据库的语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE [数据库名] &#123; </span><br><span class="line">[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |</span><br><span class="line">[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>ALTER DATABASE 用于更改数据库的全局特性。</li><li>使用 ALTER DATABASE 需要获得数据库 ALTER 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li></ul><p><strong><mark class="hl-label blue">示例：</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER DATABASE test_db</span><br><span class="line">    -&gt; DEFAULT CHARACTER SET gb2312</span><br><span class="line">    -&gt; DEFAULT COLLATE gb2312_chinese_ci;</span><br><span class="line">mysql&gt; SHOW CREATE DATABASE test_db;</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">| Database | ALTER Database                                        |</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">| test_db  | ALTER DATABASE `test_db` /*!40100 DEFAULT CHARACTER SET gb2312 */|</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-删除数据库-font"><font color='gree'>删除数据库</font></h3><p>Mysql 数据库中储存着一个或多个数据表，而数据表的本质仍是文件，这种文件有特殊的结构，非常方便数据的操作；数据库则体现为一个目录，如下图：</p><img src="/2022/img/image-20220830121356695.png" alt="stuinfo数据库" style="zoom:67%;" /><img src="/2022/img/image-20220830121414517.png" alt="table_1数据表" style="zoom:67%;" /><p>删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><ul><li>IF EXISTS：用于防止当数据库不存在时发生错误。</li><li>DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。</li></ul><p><strong><mark class="hl-label blue">示例：</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#删除stuInfo数据库</span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| stuinfo            |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DROP DATABASE stuInfo;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>另外，使用 MySQL 命令删除数据库后不可恢复，需谨慎操作；若直接删除数据库目录(将数据库目录放入回收站)，似乎也能够完成删除操作，但不建议如此，因为其他文件中相关的配置可能没有即时更改(个人猜测)。</p><h3 id="font-color-gree-选择数据库-font"><font color='gree'>选择数据库</font></h3><p>当用 CREATE DATABASE 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。其语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><p><strong>无需加 <code>DATABASE</code> !</strong> 该语句可以通知 MySQL 把 <code>&lt;数据库名&gt;</code> 所指示的数据库作为当前默认数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| stuinfo            |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use stuinfo;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-安装配置</title>
      <link href="/2022/08/29/MySQL-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/08/29/MySQL-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-MySQL下载-font"><font color='red'>MySQL下载</font></h2><p>进入到<a href="https://downloads.mysql.com/archives/community/">MySQL官网地址</a> ，选择常用的 <code>5.7.19</code> 版本，操作系统选择 <code>Microsoft Windows</code> ，然后点击 <code>Windows (x86, 64-bit), ZIP Archive</code> 所在行的 <code>Download</code> ，如下图：</p><p><img src="/2022/img/image-20220829185625160.png" alt=""></p><p>下载后得到 <code>.zip</code> 压缩包，单击右键解压到指定的路径，笔者选择的路径是 <code>D:\MySQL</code> ，解压好后如下：</p><p><img src="/2022/img/image-20220829194816430.png" alt=""></p><p><img src="/2022/img/image-20220829195010717.png" alt=""></p><h2 id="font-color-red-MySQL配置-font"><font color='red'>MySQL配置</font></h2><h3 id="font-color-orange-配置文件-font"><font color='orange'>配置文件</font></h3><p>在 <code>D:\MySQL\mysql-5.7.19-winx64</code> 目录下新建 <code>my.ini</code> 文件，创建后写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">#  设置MySQL的安装目录</span><br><span class="line">basedir=D:\\MySQL\\mysql-5.7.19-winx64\\</span><br><span class="line">#  设置MySQL数据库的数据存放目录</span><br><span class="line">datadir=D:\\MySQL\\mysql-5.7.19-winx64\\data</span><br><span class="line">port=3306</span><br><span class="line">character-set-server=utf8</span><br><span class="line">#跳过安全检查，设置密码后才将其注释</span><br><span class="line">skip-grant-tables </span><br></pre></td></tr></table></figure><p><strong><font color='gree'>注意将代码中的路径更改为你自己设置的路径！</font></strong></p><h3 id="font-color-orange-配置环境变量-font"><font color='orange'>配置环境变量</font></h3><p>在桌面上右键单击 <code>我的电脑</code> -&gt; <code>属性</code> ，出现以下界面：</p><p><img src="/2022/img/image-20220829195720092.png" alt=""></p><p>然后单击 <code>高级系统设置</code> -&gt; <code>环境变量</code> -&gt; <code>PATH</code> -&gt; <code>编辑</code> -&gt; <code>新建</code> -&gt; 将路径 <code>D:\MySQL\mysql-5.7.19-winx64\bin</code> 粘贴进用户变量并确认保存即可。如果之前配置过其他版本的 MySQL ，则须将路径上移。过程如下：</p><img src="/2022/img/image-20220829200227747.png" alt="" style="zoom:50%;" /><img src="/2022/img/image-20220829200318095.png" alt="" style="zoom:67%;" /><img src="/2022/img/image-20220829200413903.png" alt="" style="zoom:67%;" />**注意，最好在admin用户下进行操作以获取最高权限** 。<blockquote><p>配置环境变量是为了可以在任意位置执行 MySQL 命令，否则每次登录 MySQL 服务器时就必须进入到 MySQL 的 bin 目录下，才能使用 MySQL 等其它命令工具，这样比较麻烦。</p></blockquote><h3 id="font-color-orange-命令行操作-font"><font color='orange'>命令行操作</font></h3><ol><li><strong><font color='gree'>务必以管理员身份打开命令行！不可直接cmd打开！</font></strong></li></ol><img src="/2022/img/image-20220829200909610.png" alt="" style="zoom:67%;" /><ol start="2"><li><p>切换到 <code>D:\MySQL\mysql-5.7.19-winx64\bin</code> 目录下：先输入 <code>D:</code> 并回车，再输入 <code>cd D:\MySQL\mysql-5.7.19-winx64\bin</code> 并回车：</p><p><img src="/2022/img/image-20220829201327011.png" alt=""></p></li><li><p>安装 MySQL：输入 <code>mysqld -install</code></p></li><li><p>初始化数据库：输入 <code>mysqld --initialize-insecure --user=mysql</code> 并回车。如果执行成功，会在 <code>D:\MySQL\mysql-5.7.19-winx64\</code> 目录下生成 <code>data</code> 目录。</p><img src="/2022/img/image-20220829201735873.png" style="zoom:67%;" /></li><li><p>启用 MySQL 服务：输入 <code>net start mysql</code></p><img src="/2022/img/image-20220829202122072.png" style="zoom:67%;" /><p>停止服务则输入 <code>net stop mysql</code> 即可。</p></li><li><p>连接到 MySQL 管理终端：输入 <code>mysql -u root -p</code> ，root 即为用户名，p 为 password ；回车后会要求输入密码，但目前密码为空，所以直接再次回车跳过即可。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\MySQL\mysql-5.7.19-winx64\bin&gt;mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure><p>注意：不写 <code>-h 主机IP</code> ，则默认为本机；不写 <code>-P 端口号</code> 则默认 3306 ；端口号是大写P，密码是小写p。</p></blockquote></li><li><p>修改 root 用户密码：首先输入 <code>use mysql;</code> ，<strong>勿忘分号！分号是SQL语句的终止符；</strong> 再输入 <code>update user set authentication_string=password('password') where user='root' and Host='localhost';</code> ，其中 <code>password</code> 是你要设置的密码；然后输入 <code>flush privileges</code> 刷新权限。</p></li><li><p>修改 <code>my.ini</code> 文件，将最后一行的 <code>skip-grant-tables </code> 注释掉，并保存文件。而后你可以在命令行输入 <code>quit</code> 退出 MySQL 终端并重新进入，此时就需要输入密码了。</p></li></ol><p>如果你在执行上述某一步操作时出错而导致后续无法推进，请先删除已安装好的 MySQL ，在命令行输入 <code>sc delete mysql</code> 即可。如果想删除某些文件却发现无法删除(文件已在另一处打开)，请先停止 <code>MySQL</code> 服务：输入 <code>net stop mysql</code> ，而后再进行删除。</p><blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平MySQL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器中的排队与调度</title>
      <link href="/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/"/>
      <url>/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>经过上一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/">路由器的工作原理</a>》的学习，我们应该发现当端口的处理速率与交换结构的转发速率不匹配时，就可能发生排队(Queuing)；以何种方式调离队列中的分组，称之为调度(Scheduling)。本文将详细讨论这两个问题。</p></blockquote><h3 id="font-color-red-何处出现排队-font"><font color='red'>何处出现排队</font></h3><p>排队的位置和程度取决于流量负载、端口处理速率以及交换结构的转发速率，当端口处理速率和转发速率不匹配时，就会发生排队。当队列占满整个缓冲区时，路由器将无法接收到新的分组，这时就会产生 <strong>丢包(packet loss)</strong> 。在 TCP 一章的讨论中，我们经常说到的丢包就在这里产生。</p><h4 id="font-color-orange-输入排队-font"><font color='orange'>输入排队</font></h4><p><u>如果交换结构的转发速率慢于输入端口的处理速率，就会在输入端口发生排队</u>，因为到达的分组必须加入输入端口队列中，以等待通过交换结构传输到输出端口。在输入端口的排队大致能分为两种类型：<strong>1.端口竞争；2.队头阻塞(Head-Of-The-Line, HOL)</strong> 。如下图所示：</p><img src="/2022/img/image-20220819103139081.png" alt="排队示意图" style="zoom:67%;" /><p><strong><mark class="hl-label blue">端口竞争</mark> </strong></p><p>如图，当第一排端口的队头分组和第三排的队头分组要发往同一个输出端口时，就会发生排队。即使不发往同一个端口，由于交换结构种类的限制，也可能发生排队，比如经总线交换和经内存交换每次只能交换一个分组，而 crossbar 交换也并非任何时候都能实现并行交换，详见《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/">路由器的工作原理</a>》。</p><p><strong><mark class="hl-label blue">HOL</mark> </strong></p><p>如上图，当发生端口竞争时，第一排队头先交换，第三排队头等待；由于第三排队头的阻塞，即使第三排队尾的分组的目的端口为第二排输出端口(没有端口竞争)，其也无法发送(FIFO策略)，这种阻塞就叫做队头阻塞。有研究表明，由于 HOL 阻塞，只要输入链路上的分组到达速率达到队列容量的 58%，输入队列的长度就将无限增大，导致大量丢包，所以 HOL 是输入队列面临的首要问题之一。解决 HOL 的主流方法是使用 <strong>虚拟输出队列(Virtual Output Queues)</strong> 。虚拟输出队列总体的想法十分朴素：在输入端口<u>将发送到不同端口的数据包虚拟成不同的队列</u>，并且彼此互不影响，这样一来即使队头数据包被阻塞也将不会影响发送到其他端口的数据包的发送。如下图 2 × 4 的输入输出交换结构中，每个输入端口将根据数据包输出端口的不同而加入专属“虚拟队列”（图中以不同的颜色区分），这样一来，在同一输入端口而目的端口不同的数据包的发送将彼此互不影响。除了虚拟输出队列外，还有其他许多解决排头阻塞的算法，如神经网络、<em>i</em>SLIP等等。</p><img src="/2022/img/format,f_auto.png" alt="虚拟输出队列" style="zoom:67%;" /><blockquote><p>只有在缓存式输入的交换机中才会出现队头阻塞的情况，如果交换机内部的带宽足够的话，缓存输入就是没有必要的了——所有的缓存都可以在输出处被处理，从而也避免了队头阻塞。这样的无缓存式输入架构在中小型规模的乙太网交换机中非常常见。</p></blockquote><h4 id="font-color-orange-输出排队-font"><font color='orange'>输出排队</font></h4><p>当交换速度较慢时，可能在输入端口形成排队；那么当交换速度足够快时，就能避免队列的形成吗？答案是否定的。即使 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>N</mi><mo>×</mo><msub><mi>R</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{switch}=N×R_{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，一旦当大量分组需要从不同输入端口传输到同一个输出端口时，队列也会在这个输出端口形成。当没有足够的内存来缓存分组时，要么将其丢弃(drop-tail)，要么删除队列中的某个分组来为新分组腾出空间。有时可能会在队列被填满之前就主动丢弃新分组，以此向发送方提供拥塞信号，这种策略被称为 <strong>主动队列管理(AQM)</strong> 算法。</p><p><strong><mark class="hl-label blue">多少缓存才足够？</mark> </strong></p><p>通过上述的简单讨论，不难发现似乎都是因为队列空间(缓存)不够大才造成的丢包，那么我们直接扩大路由器的缓存不就行了吗？事实上，确定合适的缓冲大小是一个复杂的问题。<strong>缓存设置过小会发生丢包，这不难理解；缓存设置过大，即使不会丢包，但也会引发高延迟并形成恶性循坏，其危害甚至比丢包更为严重</strong> ！这就是臭名昭著的 <strong>缓冲膨胀(buffer bloat)</strong> 。<strong>大多数<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a>算法都依靠测量丢包的发生来确定连接两端之间的可用带宽</strong> 。该算法会加快数据传输速度，直到数据包开始丢失，然后降低传输速率。理想情况下，他们会不断调整传输速率，直到达到链路的平衡速度为止。为了使算法能够选择合适的传输速度，必须及时收到有关丢包的反馈。使用大容量缓冲区时，数据包虽然最后会到达目的地，但延迟较高。因为数据包没有丢失，所以即使上行链路饱和，TCP 也不会减慢速度，从而进一步导致缓冲区饱和，从而进一步造成高延迟，这对实时类应用无疑是致命的。</p><p>缓冲膨胀的解决可以从两个角度切入：针对网络的解决方案和针对端点的解决方案。前者通常采用队列管理算法的形式，如 AQM 算法；后者包含 TCP 的 BBR 算法，详见笔者另一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制详解(二)</a>》。关于缓存大小的经验法则是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B=RTT×C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ，其中 C 是链路的容量，RTT 是平均往返时延。</p><h3 id="font-color-red-分组调度-font"><font color='red'>分组调度</font></h3><p>队列形成后，我们自然会考虑如何将分组调离队列并发送。就实际生活而言，一般我们排队会遵循 <strong>先到先服务(FCFS, 也称之为先进先出(FIFO))</strong> 策略；然而我们也经常在车站售票窗口看见“军人优先服务”。类似地，路由器中的队列也有不同的排队策略，这些方式叫做 <strong>分组调度(Packets Scheduling)</strong> 。</p><h4 id="font-color-orange-先进先出-FIFO-font"><font color='orange'>先进先出(FIFO)</font></h4><p>先进先出属于典型的被动队列管理的方法，它调度包的方法是：先到达路由器的分组先被传输，其它分组采用默认的排队方式。然而，路由器的缓存总是有限的，如果分组到达时缓存已满，那么路由器就不得不丢弃该分组。由于 FIFO 总是丢弃队尾的分组，所以又称它为“去尾”（drop-tail）算法。FIFO和“去尾”是最简单的分组调度和丢弃策略，两者有时可被视为一体，简单称为 FIFO 排队。<br>FIFO排队的算法简单，实施容易，是目前Internet使用最为广泛的一种方式。然而 FIFO 无法“识别”面向连接的连续 TCP 数据流，当存在占用大量带宽的对 TCP 不友好的流时，网络可能会持续拥塞，TCP 流分享不到应有的带宽。</p><h4 id="font-color-orange-优先权排队-priority-queuing-font"><font color='orange'>优先权排队(priority queuing)</font></h4><p>在此规则下，<strong>到达的分组根据既定规则被划入一个优先权类，每一个优先权类都有自己的队列，同一个队列中的分组采用 FIFO 策略</strong> 。如下图，分组 1、3、4 属于高优先权类，分组 2、5 属于低优先权类。分组 1 达到后即开始传输，在这期间分组 2、3 相继到达；分组 3 的优先权高于分组 2，所以分组 1 传输完成后轮到 3 传输；分组 4 在分组 2 传输时到达，在 <strong>非抢占式优先权排队</strong> 规则下，一旦分组开始传输，就不能被打断，所以即使分组 4 的优先权高于分组 2，也需要等到分组 2 传输完毕后才能传输分组 4 。</p><img src="/2022/img/image-20220819170315190.png" alt="image-20220819170315190" style="zoom:67%;" /><p>然而，虽然高优先级业务的带宽和时延得到了最大限度的保证，但若高优先级业务持续占据带宽，会导致低优先级业务一直得不到调度，这显然是不公平的，所以有了下面的 <strong>轮循和加权公平排队</strong> 策略。</p><h4 id="font-color-orange-轮循和加权公平排队-WFQ-font"><font color='orange'>轮循和加权公平排队(WFQ)</font></h4><p>WFQ是在发生拥塞时稳定网络运行的一种自动的方法，它能提高处理性能并减少分组的重发。WFQ主要有三个目的：</p><ol><li><p>为每个活动流提供公平的带宽分配机制，即WFQ名字中的F（fairness）的含义</p></li><li><p>为少量交互流提供更快的调度机制</p></li><li><p>为高优先级的流提供更多的带宽</p></li></ol><p>WFQ 根据流对报文进行动态分类，分类判据可为五元组和 IP 服务类型(TOS字段)，然后使用 Hash 算法映射到不同的队列中。另外，如果使用WFQ，那么 low-volume（字节数小的报文）、higher-precedence（优先级高的报文）的流会比 large-volume、lower-precedence 的流更先处理(目的二)。在出队的时候，WFQ 按流的优先级来分配每个流应占有出口的带宽。优先级的数值越小，所得的带宽越少。优先级的数值越大，所得的带宽越多。这样就保证了相同优先级业务之间的公平，体现了不同优先级业务之间的权值。详细内容参考[WFQ](<a href="https://baike.baidu.com/item/WFQ/10000942">WFQ_百度百科 (baidu.com)</a>) 。</p><blockquote><p>参考文章：《计算机网络自顶向下》，<a href="%5B%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83_%E7%9F%A5%E8%A1%8C%E6%B5%81%E6%B5%AA%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E7%BD%91%E7%BB%9C%E9%98%9F%E5%88%97%5D(https://blog.csdn.net/zengxiantao1994/article/details/53080941#:~:text=%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E5%B1%9E%E4%BA%8E%E5%85%B8%E5%9E%8B,%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8E%92%E9%98%9F%E6%96%B9%E5%BC%8F%E3%80%82)">FIFO</a>，<a href="http://lihaizhou.top/2020/08/27/%E8%87%AD%E5%90%8D%E6%98%AD%E8%91%97%E7%9A%84bufferbloat/">缓冲膨胀</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器的工作原理</title>
      <link href="/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文主要讨论网络层数据平面中的转发功能的硬件实现，即如何将分组从路由器的输入链路传输到合适的输出链路。</p></blockquote><p>下图展示了通用路由器的一般结构：</p><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3qV3nJvjh-GRCnpGI%2Fimage.png" alt="通用路由器的1一般结构" style="zoom:67%;" /><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3qgLtqu7FWWNziVrZ%2Fimage.png" alt="输入端口" style="zoom:67%;" /><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3r8ffUymOfqAgojKQ%2Fimage.png" alt="输出端口" style="zoom:67%;" /><p>我们可以从图中看到，路由器大致有 <strong>输入端口、输出端口、交换结构、路由处理器</strong> 四个主要组件，下面我们简单分析各个组件的功能：</p><h3 id="font-color-red-输入端口-font"><font color='red'>输入端口</font></h3><p>1 号部分负责物理层功能：PHY(Physical Layer Device)模块或者 MAU(Medium Attachment Unit)模块将信号转换成通用格式，并将信号发送给 MAC 模块；<br>2 号部分负责链路层功能：MAC 模块收到 PHY 模块发来的信号后，将信号转换为数字信息，到达信号末尾时检查 FCS，<strong>如果 FCS 出错则直接丢弃此分组</strong> ，若无错则 <strong>再检查分组 MAC 头部中的接收方 MAC 地址是否与自己一致</strong> ，若不一致则直接丢弃，若一致则去掉 MAC 报头并将数据部分移交给网络层；<br>3 号部分负责网络层功能：<strong>查询转发表</strong> ，决定此分组的输出端口；</p><blockquote><p>为了更清楚地了解 PHY 和 MAC 模块在输入与输出端口中的作用，我们来看看电脑的网卡是如何将信息发送到网络中的：</p><p>首先，MAC 模块从报头开始将数字信息按每个比特转换为电信号(通用信号)，这里注意，<strong><font color='orange'>将数字信号转换为电信号的时间就是我们所说的传输时延</font></strong> ；然后 PHY(MAU) 模块将电信号转为转换为可在网线上传输的格式，并通过网线发送出去。不同链路有着不同的信号格式，<strong><font color='red'>但 MAC 模块不关心这些区别，它只负责将数字信号转换为通用信号并转发给 PHY 模块，然后 PHY(MAU) 再将其转换为可在网线上传输的格式</font></strong> 。接收网络中的信号是上述过程的逆过程，不再过多阐述。</p></blockquote><p>下面我们详细了解路由表的查询：</p><img src="/2022/img/417F6E2A7DA886977A88FF9C0AE6F9AC.png" alt="转发表示例" style="zoom:50%;" /><p><u>转发表由路由处理器计算生成和更新</u>。<strong>转发表从路由处理器经过独立的总线复制到<u>线路卡</u>(Line Card)，通过使用在每个输入端口的副本，转发决策就能在每个输入端口本地做出，无须每个分组都调用路由处理器来进行决策，从而避免了集中式处理的瓶颈</strong> 。<strong><font color='red'>查询转发表时，会忽略主机号，只根据子网掩码匹配 IP 地址的网络号</font></strong> ，且采用 <strong><font color=#3b8dfe>最长前缀匹配规则</font> (longest prefix matching rule)</strong> 。拿上图来说，目标地址为 <code>192.168.1.10</code> 的分组到达了路由器，然后将 <code>192.168.1.10</code> 和表中各 IP 地址分别与相应子网掩码进行与运算，若所得结果相同，则匹配。而计算后发现，图中 3、4、5 排记录都能匹配，<strong>根据最长前缀匹配规则，路由器最终匹配到网络号比特数最长的一条记录</strong> (图中第4条)。<u>网络号比特越长，说明子网中主机越少，从而减小了后续的寻找范围</u>。需要注意的是，即使根据最长前缀匹配规则，我们仍然可能匹配到多条候选记录(例如考虑到路由器或网线故障而设置的备用路由)，<strong>这时需要根据跃点数进行判断，跃点数越小则表明该路由越近。因此应该选择跃点数较小的记录</strong> 。<font color='orange'>若找不到匹配记录且不存在默认路由，路由器就会丢弃此分组，并通过 ICMP 消息告知发送方；若存在默认路由，则不匹配项都会被发送的默认路由</font> ；<code>0.0.0.0</code> 即为默认路由。</p><p>提高转发表查找速率是路由的核心问题之一。考虑具有 10 Gbps带宽的输入链路和 64 字节的 IP 数据报，其输入端口在另一个 IP 数据报到达之前仅有 51.2 纳秒的时间来处理数据报！所以实际网络对输入端口处理数据的速度要求极高，可以通过以下几个方面来提高速度：</p><ol><li>采用硬件执行查找。硬件执行速率往往比软件执行速率高几个数量级。</li><li>提高查找算法的效率。</li><li>缩小转发表的规模。路由器会使用 CIDR 来减小转发表的条目数量，从而提高查询效率，详见笔者另一篇文章 [<a href="https://jyxcpp.netlify.app/2022/08/16/ip%E7%BC%96%E5%9D%80/">IP编址</a>]。</li><li>提高内存访问速度。</li></ol><p>除了上述的处理，输入端口还需要进行其他操作，比如检查 IP 首部的版本号、CheckSum 和 TTL ，<u>并重写后两个字段</u>：每经过一个路由，TTL 就需要自减一次，这是为了防止发生路由循环，TTL 初始值通常设为 64 或 128 ；<strong><font color='orange'>由于 CheckSum 作用域包含了 TTL ，所以随着 TTL 的更新，CheckSum 也需要重新计算</font></strong> 。</p><h3 id="font-color-red-交换结构-Switching-Fbric-font"><font color='red'>交换结构(Switching Fbric)</font></h3><p>确定好分组的输出端口后，就可以进入到路由器的交换结构。通过交换结构，分组才能由输入端口被转发到正确的输出端口。交换结构有如下三种方式：</p><img src="/2022/img/IMG_0447(20220818-180045).PNG" alt="三种交换技术" style="zoom: 50%;" /><ol><li><strong>内存交换：</strong> 最早的的路由器就是传统的计算机，交换直接由 CPU 控制。分组从输入端口被复制到内存中，然后 CPU 提取出目的 IP 地址并在表中进行查找合适的输出端口，然后再将该分组复制到相应的输出端口缓存中。这种方式效率较低，原因在于：（1）查找表都由 CPU 进行；（2）由于总线一次只能进行内存读/写操作，所以不能同时进行多个分组交换。许多现代路由器也采用经内存交换，但与早期路由器的一个主要差别是：转发表查找和将分组写入相应端口的内存是由线路卡来处理的。</li><li><strong>总线交换：</strong> 输入端口经一根共享总线将分组直接传送到输出端口，其工作方式为：在输入端口为每个分组加上标签，然后经交换结构发送该分组至所有输出端口，但只有与该标签匹配的输出端口才会接收该分组；然后分组在输出端口去除标签并发送。相比于经内存交换，经总线交换无需路由处理器的干预，效率上有所提升；但由于每次只有一个分组能够跨越总线，所以交换带宽受总线速率限制，但对于网络边缘的路由器，总线速率通常够用。</li><li><strong>crossbar交换：</strong> 纵横式交换结构由 2N 条总线构成，它连接 N 个输入端口和 N 个输出端口。交叉点通过交换结构控制器(交换结构的一部分)进行开闭操作，当分组从 A 交换到 Y 时(A×Y交换)，只需要开启总线 A 和 Y 之间的交叉点即可。通过这样的设计，<strong>crossbar 交换结构就能并行地转发多个分组</strong> ，但并非任何时候都能执行并行转发，如下情况除外：（1）来自不同端口的多个分组有相同的目的端口。（2）(N×N)交换严格无阻塞，(M×N)交换可能发生阻塞；比如(A×X)与(B×Y)同时进行就会发生阻塞(交换路线交叉)。</li></ol><blockquote><p>设计交换网的时候一般要大于 1.2 倍的端口速率，这样才能保证在路由器内部交换网无阻塞的传输数据，这个 1.2 叫做加速比（speed up ratio）,比如华为的NE5000E路由器的加速比是 2，所以可以实现交换网无阻塞的传输数据。</p></blockquote><h3 id="font-color-red-输出端口-font"><font color='red'>输出端口</font></h3><p>输出端口取出其内存中的分组并将其发送到输出链路上。输出分组前可能面临排队和调度，相关内容见笔者另一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/">路由器中的排队与调度</a>》。另外，在全双工模式下每个端口既是入端口也是出端口。其他操作相当于输入端口的逆操作，不再赘述。</p><h3 id="font-color-red-路由处理器-font"><font color='red'>路由处理器</font></h3><img src="/2022/img/IMG_0445(20220818-115058)-166082484083011.PNG" alt="路由选择处理器" style="zoom:50%;" /><p>路由处理器执行控制平面的功能，包括：执行路由选择协议、计算并下发路由表、网络管理等。路由处理器可以集成在路由器中，每个路由器独立地执行各自的路由算法和其他操作；也可以只负责与远程控制器进行通信，远程控制器收集整个网络的信息，并通过一根总线(上图虚线)下发转发表至各个路由器。这种集中式管理，控制平面与数据平面分开的方式称为 <strong>SDN(Software Defined Network)</strong> ，详细内容参见《<a href="https://jyxcpp.netlify.app/2022/08/17/%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E4%B8%8Esdn/">通用转发与SDN</a>》。</p><blockquote><p>限笔者水平，文章难免有错误之处，如读者发现错误，敬请指出。<br>文章参考：《计算机网络自顶向下》，《网络是如何连接的》，<a href="https://www.zhihu.com/question/48343492">CLOS架构</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP编址</title>
      <link href="/2022/08/16/IP%E7%BC%96%E5%9D%80/"/>
      <url>/2022/08/16/IP%E7%BC%96%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-IP地址的定义-font"><font color='red'>IP地址的定义</font></h3><p>IP 地址(IPv4)由 32 位 bit 储存，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，即允许最多 43 亿台设备连入网络。为方便人为识别 IP 地址，我们采用 <strong>点分十进制</strong> 来表示 IP 地址，如下：<br><img src="/2022/img/IMG_0441(20220817-104106).PNG" alt="点分十进制" style="zoom:50%;" /></p><p>需要注意的是，<strong>IP 地址并非根据主机台数来配置，而是根据主机的网卡(NIC)来配置</strong> 。由于每一台主机一般都有多张网卡，而每张网卡又必须分配一个 IP 地址，所以 IPv4 的 IP 地址数目(约43亿)根本不够用，为了在 IPv4 的基础上容纳更多的主机， <a href="">NAT技术</a>应运而生。IPv6 也能很好的解决此问题，但由于网络规模巨大，全面替代 IPv4 还需要假以时日。</p><p>同时，为了方便网络管理和路由控制，<strong>IP 地址分为网络号和主机号</strong> 。网络号(网段)用来表示相邻的一片主机(如公司内的主机采用一个网络号)，主机号则表示网络段中的某一台主机。IP 地址的主机标识不能在同一网段中重复出现。网络号和主机号如何方便网络管理和路由控制呢？举例来说，对于网络管理，广播利用网络号直接将数据报发送到具有同一网络号的所有主机中，而无需一台主机一台主机地发送；对于路由控制，<strong>进行路由时，路由器只看网络号而忽视主机号</strong> 。那么，究竟从第几位开始是网络号，第几位开始又是主机号呢？最初二者使用 IP 地址的分类进行区分，而现在基本使用 <strong>子网掩码(subnet mask)</strong> 区分。<u>需要注意，在有些情况下依据部分功能、系统和协议的需求，前一种方法依然存在。</u></p><h3 id="font-color-red-IP-地址的分类-font"><font color='red'>IP 地址的分类</font></h3><p>IP 地址被分为 A，B，C，D，E五类。它根据 IP 地址中从第 1 位到第 4 位的比特序对网络号和主机号进行区分，如下图：</p><img src="/2022/img/IMG_0442(20220817-112008).PNG" alt="IP分类" style="zoom:50%;" /><p><strong>A类地址</strong> ：首位以 <code>0</code> 开头，第 2 位到第 8 位是其网络标识，即 0.0.0.0 ~ 127.0.0.0 是 A 类的网络号，后面的 24 位为主机地址。因此 A 类地址的一个网段可容纳最多 16,777,214 个主机。<br><strong>B类地址</strong> ：首位以 <code>10</code> 开头，第 2 位到第 16 位是其网络标识，即 128.0.0.1 ~ 191.255.0.0 是 B 类的网络号，后面的 16 位为主机地址。因此 A 类地址的一个网段可容纳最多 65,534 个主机。<br><strong>C类地址</strong> ：首位以 <code>110</code> 开头，第 2 位到第 24 位是其网络标识，即 192.168.0.0 ~ 239.255.255.0 是 C 类的网络号，后面的 8 位为主机地址。因此 A 类地址的一个网段可容纳最多 254 个主机。<br><strong>D类地址</strong> ：首位以 <code>1110</code> 开头，第 2 位到第 32 位是其网络标识，即 224.0.0.0 ~ 239.255.255.255 是 D 类的网络号。D 类地址没有主机号，常被用于多播。关于多播，参考<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/">此处</a> 。</p><p>另外，A 类地址保留给政府，B 类给中等以上的公司，C 类分配给个人，D 类用于多播，E 类尚未使用。</p><blockquote><p>注意，观察到主机数目都减去了 2，这是因为主机号全为 0 时表示整个子网，全为 1 时表示向子网所有设备发送报文，即广播；关于广播，参见<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/">此处</a>；<code>0.0.0.0</code> 地址对应于未知地址，指在本机的路由表里没有特定条目指明如何到达；一般用户主机为了获得一个可用的 IP 地址，就给 DHCP 服务器发送 IP 分组，并用这样的地址作为源地址。</p></blockquote><p>我们发现，架构 A、B 类网络时，一个网段中将存在数万乃至数十万的主机，这类情况在实际架构时通常是不存在的。因此，IP 地址的分类显得浪费资源，我们需要一种更好的划分方式。</p><h3 id="font-color-red-CIDR与VLSM-font"><font color='red'>CIDR与VLSM</font></h3><p>由于 IP 地址的分类造成的严重浪费，人们放弃了这种 IP 分配策略，开始采用任意长度分割 IP 的网络号和主机号。这种方式叫做 <strong>CIDR(无类型域间路由)</strong> 。通过使用 CIDR ，我们就可以将多个 C 类地址合并为一个网络地址范围，如下：</p><img src="/2022/img/IMG_0444(20220818-102905).PNG" alt="CIDR" style="zoom:50%;" /><p>在 CIDR 之前，如果很多个 C 类网络在一起，经过路由器的时候就被宣告成很多条子网掩码为 <code>255.255.255.0</code> 的路由条目(一个C类地址是 24 位网络号)，其数目是巨大的，非常消耗路由器的资源。CIDR 的基本思想是取消 IP 地址的分类结构，将多个地址块聚合在一起生成一个更大的网络( <strong>路由聚合</strong> )，<strong>以减少路由表中的路由条目，从而降低路由的性能损耗</strong> 。而在 CIDR 之前，多个 C 类网络是无法被聚合在一起的。</p><p>在 CIDR 应用初期，<u>网络内部</u>(一段连续分配的IP地址,比如公司内部) 采用固定长度的子网掩码机制，也就是说，当子网掩码的长度被设置为 /24 以后，域内所有的子网掩码都必须使用同样的长度。然而，一个公司内有些部门可能有 100 台主机，另一些部门可能只有 25 台，两个部门的子网掩码却都相同(即分配的主机IP数目也相同)，这就导致了 IP 地址的浪费。如果采用统一的标准，就难以架构一个高效的网络。为此人们提出了组织内部(即子网)要使用可变长度的、高效的 IP 地址分配方式。</p><p>于是，<strong>VLSM(Variable Length Subnet Mask)</strong> 应运而生。<strong>VLSM 通过对 IP 地址的主机号进行再划分，把其一部分划入网络号，就能划分各种类型大小的子网了</strong> 。 比如一个公司内部的子网掩码被设为 /24 (可容纳254个主机)，那么对于只有 100 台主机的部门，我们可以把部分主机号归入网络号，将此部门的子网掩码设置为 /25 (可容纳127个主机)，这样就有效提高了 IP 地址的利用率。</p><p>通过以上描述，我们可以发现，<strong>CIDR 更多是一个 ISP/Provider 级别的概念，常用于网络核心；而 VLSM 是地址块的接收者用来更有效地使用分配的地址块的一种机制，多用于网络边缘</strong> 。</p><p>CIDR 与 VLSM 的关系简单总结为：<strong><font color='orange'>CIDR 和 VLSM 在某程度上可以看做是逆过程，CIDR 是把几个小网络汇聚成一个大网络来做表示，而 VLSM 则是把一个大网络继续细分为几个小网络进行 IP 地址分配。前者能让路由器的路由条目得到有效的减少，而后者可以充分利用 IP 进行地址分配而解决 IP 地址不被浪费的问题。</font></strong></p><blockquote><p>文章参考：<a href="https://community.cisco.com/t5/switching/what-is-the-difference-between-cidr-and-vlsm/td-p/1172242">思科</a>，<a href="https://blog.csdn.net/qq_43207781/article/details/105059613">CIDR与VSLM的区别</a>，《计算机网络自顶向下》，《图解TCP/IP》，《网络是如何连接的》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
          <category> IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差错检测和纠正技术</title>
      <link href="/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>虽然将本节放入链路层专栏，但需要知道，差错检测和纠正技术不单单出现在链路层，传输层也有此技术的应用，比如 TCP/UDP 中的校验和。校验和主要用于传输层，奇偶校验和循环冗余检测(CRC)则主要用于链路层。</p></blockquote><h3 id="font-color-red-校验和-font"><font color='red'>校验和</font></h3><p><strong>校验和(Checksum)</strong> 是一个端到端的校验方式，<u>由发送端计算，然后由接收端验证，如果接收方检测到校验和有差错，则报文会被直接丢弃</u> 。其目的是为了发现首部和数据在发送端到接收端之间发生的任何改动。<strong>UDP 可选择使用校验和，而 TCP 则强制使用校验和</strong> 。CheckSum 不同领域可能采用不同算法，算法存在细微差别，且覆盖区域也不同：</p><ul><li><p>IP校验和：IP 首部</p></li><li><p>ICMP校验和：ICMP 首部 + ICMP 数据</p></li><li><p>UDP、TCP校验和：首部 + 数据 + 伪首部</p></li></ul><blockquote><p><u>伪首部并非 TCP&amp;UDP 数据报中实际的有效成分，它是一个虚拟的数据结构，其中的信息是从数据报所在 IP 分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和</u> 。伪头部 = 源 IP 地址 + 目的 IP 地址 + 8 位协议 + 16 位 UDP 长度，通过 伪头部+UDP头部+应用层数据，就可以检测出网络层(被递交到错误主机)，传输层(被递交到错误进程)，应用层(应用数据错误)的比特错误。</p></blockquote><p>下面以 UDP 校验和举例(TCP类似)。</p><p><strong><mark class="hl-label blue">一.计算校验和：</mark> </strong></p><ol><li><p>把校验和字段设置为 0 (下一步计算时，会包含此部分，所以必须设置为零)</p></li><li><p>把需要校验的数据看成以 16 位为单位的数字组成，依次进行 <strong><font color='orange'>二进制反码求和</font></strong></p></li><li><p>把得到的结果存入校验和字段中</p></li></ol><p>另外注意：</p><ul><li>UDP、TCP 数据报的长度可以为奇数字节，因为计算时是 16 位为单位，所以此时计算校验和时需要在最后增加一个填充字节 0 (<u>只是计算校验和用，不发送出去</u>)。</li><li><strong>二进制反码求和，就是先把这两个数取反，然后求和，如果最高位有进位，则向低位进 1</strong> 。<strong>先取反后相加与先相加后取反，得到的结果是一样的，因此实现代码都是先相加，最后再取反。</strong></li></ul><p><img src="/2022/img/image-20220816104346070.png" alt="示意图"></p><p><strong><mark class="hl-label blue">二.检验校验和：</mark> </strong></p><p>把需要校验的内容(包括校验和字段)看成以 16 位为单位的数字，依次进行二进制反码求和，<strong>如果结果是0表示正确，否则表示错误</strong> 。</p><p><strong><mark class="hl-label blue">三.实现代码：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title">check_sum</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *buffer, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cksum = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//16位为单位数字相加</span></span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cksum += *buffer++;</span><br><span class="line">        size -= <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//长度奇数情况</span></span><br><span class="line">    <span class="keyword">if</span>(size)</span><br><span class="line">        cksum += *((<span class="type">unsigned</span> <span class="type">char</span> *)buffer);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//高位有进位，进位到低位，下面两行代码保证了高16位为0。</span></span><br><span class="line">    cksum = (cksum&gt;&gt;<span class="number">16</span>) + (cksum&amp;<span class="number">0xffff</span>);</span><br><span class="line">    cksum += (cksum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//最后取反</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(~cksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><mark class="hl-label blue">为什么要用反码计算校验和？</mark> </strong></p><p><strong>因为使用反码计算就可以避免依赖系统的字节序(大小端)</strong> 。即无论你是发送方计算机或者接收方检查校验和时，都不要调用htons或者ntohs，直接通过上面的算法就可以得到正确的结果。用反码求和时，交换16位数的字节顺序，得到的结果相同，只是字节顺序相应地也交换了；而如果使用原码或者补码求和，得到的结果可能就不同。举例如下：</p><p><img src="/2022/img/20160929173826754.png" alt="反码计算校验和"></p><p>可见，使用反码进行校验和计算，不同字节序所得结果相同。</p><p><strong><mark class="hl-label blue">UDP可选校验和：</mark> </strong></p><p>UDP 协议可以不选择使用校验和。在这种情况下，发送前 CheckSum 字段全部填充 0 ；如果在 UDP 发送方决定使用 CheckSum 的情况下计算出其值全为0，则在发送前将其全改为 1；注意，这这并不会产生混淆，因为 CheckSum 有可能被计算为全 0 ，但不可能被计算为全 1 (这意味着 CheckSum 覆盖的数据全为 0 ，这是不可能的)。</p></blockquote><h3 id="font-color-red-奇偶校验-font"><font color='red'>奇偶校验</font></h3><p>奇偶校验用来检测数据传输过程中是否发生比特错误，是众多校验码中最为简单的一种。<strong>采用何种校验是事先规定好的</strong> 。<u>通常专门设置一个奇偶校验位</u> ，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性，偶校验同理。</p><img src="/2022/img/v2-ed494a01b2527927febaac2845b51d9c_1440w.jpg" alt="奇偶校验" style="zoom:67%;" /><blockquote><p>上图中直接将校验位放在了原始字节流的末尾，但实际上通常专门设置一个奇偶校验位。</p></blockquote><p><strong><mark class="hl-label blue">计算原理：</mark> </strong></p><p>如果事先规定了采用奇校验，则发送方利用校验位将 <u>数据+校验位</u>  中的 1 的个数调整为奇数个（如上图），接收方收到分组后检验 <u>数据+校验位</u> 的 1 的个数，如果为奇数个，则 <strong>基本</strong> 能够说明数据没有发生错误，反之 <strong>一定</strong> 出错。偶校验同理。</p><p><strong><mark class="hl-label blue">万一校验位本身出错呢？</mark> </strong></p><p>目前笔者没有了解到此问题的解决方案，但需要知道的是，相对于数据而言校验位本身占的位数极少，本来一个分组发生比特错误的概率就极少，而错误发生在校验位而非数据位的概率就更加少了，所以并不用很担心此问题。即使发生错误，链路层和传输层也提供 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">ARQ 协议</a>来保障数据的正确性。</p><p><strong><mark class="hl-label blue">当出错比特数为偶数，此方法不就失效了吗？</mark> </strong></p><p>是的，奇偶校验只能检测到出错比特数为奇数的情况，一旦为偶数，就无法检测出错误。但需要知道的是，在某些可靠性较高的链路上(如,以太网)发生比特错误的概率是很小的，而同一个分组中发生多个比特错误的概率则是极小的，在这种情况下，单个奇偶校验位应该是足够的。然而即使如此，测量已经表明差错经常以“突发”的方式聚集在一起，而不是独立的发生，使用单比特奇偶校验保护的一帧中，未检测差错的概率达到了 50%，所以显然我们需要更健壮的差错保护方式。下面我们提供三种方式来提高其健壮性：</p><ol><li><p>为每 N 个字节设置一个校验位。比如有 1000 字节的数据，每 100 字节设置一个校验位，则需要总共 10 个校验位。只有在连续的 100 个字节中同时出现多个比特错误才可能导致校验失败，这再次大大减少了失误发生的概率。（此方法为笔者推测，仅供参考）</p></li><li><p><strong><font color='orange'>二维奇偶校验：</font></strong> 将数据的 N 个比特划分为 D 行 D 列，对每行和每列都计算校验位。一旦某处发生错误，那么其行/列校验位都会发生变动，<strong>因此接收方不仅可以检测的错误的发生，还能定位错误并将其纠正！</strong></p><img src="/2022/img/IMG_0440(20220816-154217).PNG" alt="IMG_0440(20220816-154217)" style="zoom: 50%;" /><p>需要注意的是，并非任何差错情况都能够纠正(但都可检测到)，只要一个分组中出现多个比特差错，就无法纠正。原因是，假设发生两个比特错误，则再上图中就会有三条或四条线，对应三个或四个交点，而只发生了两处错误，所以无法准确定位。</p></li><li><p><strong><font color='orange'>汉明码：</font></strong> 汉明码(海明码)在上世纪 40 年代早早地就诞生了，不过直到今天的 ECC 内存里面，我们还在使用这个技术方案，而海明也因为海明码获得了图灵奖。汉明码与二维奇偶校验类似，也属于多重奇偶校验。汉明码不仅可以验证数据是否有效，还能在数据出错的情况下指明错误位置(仅发生一处错误时)。下面我们详细了解其计算方法。</p></li></ol><p><strong><mark class="hl-label blue">汉明码计算方法</mark> </strong></p><p><strong>冗余位：</strong> “冗余位”是一种二进制位，它被用来添加到需要传输的数据信息中，以侦测数据在传输过程中发生的丢失或者改变。汉明码需要多少个冗余位？答案如图：</p><img src="/2022/img/image-20220816170748013.png" alt="image-20220816170748013" style="zoom:50%;" /><p>对于 7 位有效数据，汉明码需要 4 位冗余码进行纠错，所以最早的汉明码又叫 <u>7-4 汉明码</u> 。<u>下面的讨论采用 7-4 方式且使用 <strong>奇校验</strong> 进行举例说明</u> 。</p><p><strong>编码方式：</strong></p><ol><li><p>为方便讨论，对比特位进行编号。7个有效位，4个冗余位，一共11位。<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom: 33%;" /></p></li><li><p><u>汉明码对于奇偶校验位的位置有特殊要求</u> ：<strong>所有2的幂次位（2^0=1,2^1=2,2^2=4,2^3=8……）作为“奇偶校验位”</strong> ，因此，第1位，第2位，第4位，第8位为奇偶校验位，其他的7位为数据位。<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064187407110.png" alt="示意图" style="zoom:33%;" /></p></li><li><p>表示出索引的二进制：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064194823213.png" alt="示意图" style="zoom: 50%;" /><br>并对索引进行分类：<u>从右往左（低位往高位）数</u> ，第一位是“1”的索引有：1011, 1001, 0111, 0101, 0011, 0001；于是这些位置由第一个校验码管理：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064212510716.png" alt="示意图" style="zoom: 50%;" /><br>第二位是“1”的索引有：1011, 1010, 0111, 0110, 0011, 0010；于是这些位置由第二个校验码管理：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064216439519.png" alt="示意图" style="zoom: 50%;" /><br>其他两组同理。</p></li><li><p>填充数据位：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064231040322.png" alt="示意图" style="zoom: 50%;" /><br>填充冗余位：第一组(1,3,5,7,9,11位)：1 的个数为 4 个，偶数个，因此①号应该为 1(采用的是奇校验)；类似的，得出其他冗余位：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064258132625.png" alt="示意图" style="zoom:50%;" /></p><p>构造完毕。</p></li></ol><p><strong>汉明码的纠错机制：</strong><br>汉明码通过检查每一小组的“奇校验”，来确定是否发生了错误。<br>首先第一组（1,3,5,7,9,11位）：1 的个数为 6 位，不再是奇数个了，因此，我们可以断定，这一组中肯定有某个数据发生了错误，但不能确定是哪一位上发生了错误。为了达到“奇校验”，我们必须补 1 个 1 来达到奇数个 1。<br>接下来，我们检查第二组（2,3,6,7,10,11） ，1的个数为3位，仍然满足“奇校验”，因此我们也可以断定这一组中没有任何一位数据发生了改变。所以，我们只需要补 0。<br>我们继续检查第三组（4,5,6,7），1 的个数为 2，不在满足“奇校验”，因此，我们可以断定，这一组中也有数据发生改变。为了达到“奇校验”，我们必须补 1 个 1 来达到奇数个1。<br>我们检查第四组（8,9,10,11位），1 的个数为 3 位，满足“奇校验”，因此没有发生改变。所以我们只需要补0。<br>如下图所示：</p><p><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064303859628.png" alt="示意图"></p><p>我们发现，最后得出来的二进制数是：<code>0101</code> ，我们会神奇地发现，<code>0101</code> 就是十进制 5 的二进制表现，因此，我们可以准确的知道，5号位上发生了数据的改变，我们只要对 5 号位进行置反操作即可。最后，接收方就可以修改成为正确的数据。</p><blockquote><p>二维奇偶校验与汉明码谁略胜一筹？<br>笔者提供一个思路(仅供参考)：对于 10000 字节的数据而言，二维奇偶校验需要 200 个冗余字节(行100，列100)；而汉明码则最少只需要约 14 个字节(通过上面的公式计算得出)，所以在有效利用率上，汉明码更胜一筹。但显然二维奇偶校验的思路更加简单。</p></blockquote><h3 id="font-color-red-循环冗余校验-CRC-font"><font color='red'>循环冗余校验(CRC)</font></h3><p>CRC 循环冗余校验属于检错码，只能检测出现了错误，但<u>无法纠正错误</u> 。与 CRC 循环冗余校验类似的，还有奇偶校验，<u>但是 CRC 漏检率更低</u> ，因此在实际应用中更为重要。CRC 常用于数据链路层的错误检测，通常在帧尾添加 CRC 校验码。<br><strong>CRC 校验流程概述</strong> ：发送方在原始数据的基础上，加上 CRC 校验码，组成新的发送数据；然后接收方对收到的 <code>原始数据 + 校验码</code> 进行校验，判断数据在传输过程中是否出现错误，若出错则丢弃，并反馈相应信息。</p><p><strong><mark class="hl-label blue">CRC校验步骤：</mark> </strong></p><p><strong><font color=#3b8dfe>发送方追加校验码：</font></strong></p><ol><li>假设原始数据是：<code>101001</code></li><li><strong>生成待追加的校验码，需要使用一个生成多项式G(x)(收发双方事先约定)</strong> ，例如 G(x) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3 + x^2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>构造被除数：原始数据 + 生成多项式最高次项个0，即：<code>101001000</code></li><li>除数：除数实际上就是生成多项式的系数，G(x) <strong>展开得到</strong> : G(x) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>0</mn></msup><mtext>，</mtext></mrow><annotation encoding="application/x-tex">1 × x^3 + 1 × x^2 + 0 × x^1 + 1 × x^0，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span></span></span></span>即 <code>1101</code></li><li>两数相除得余数，<u>并进行补位(补到与生成多项式最高次项一致)</u> ，即得到校验码。但是，这里的除法跟常规除法并不相同，本处使用的是<strong>模2除法</strong> ；常规除法在上下两行数进行运算时，使用的是减法运算，而这里使用的是异或运算。通过上述运算，得到校验码 <code>001</code>，添加到原始数据之后，得到最终发送数据为   <code>101001001</code></li></ol><p><img src="/2022/img/2021021213262352.png" alt="示意图"></p><p><strong><font color=#3b8dfe>接收方进行校验：</font></strong></p><ol><li>继续接前文，假设收到的数据为 <code>101001001</code></li><li>接收方对该数据做除法，除数仍然是之前使用的多项式的系数 <code>1101</code> ，过程如下：</li></ol><p><img src="/2022/img/20210212134841902.png" alt="示意图"></p><p><strong>若余数不为0，则表明发生比特错误</strong> 。</p><blockquote><p>另外，在实际使用 CRC 时，采用的生成多项式更为复杂，从而确保较低的漏检率：<br><img src="/2022/img/20210212140304184.png" alt="常见多项式"></p></blockquote><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p>接收方检测和纠正差错的能力被称为 <strong>前向纠错(Forward Error Correction, FEC)</strong> 。在网络环境中，FEC 可以单独应用，也可以与链路层的 ARQ 技术一起应用。FEC 技术具有很高应用价值，因为它们可以减少重发次数，避免了潜在的往返时延，这对于实时网络应用尤其重要。</p><blockquote><p>参考资料：<a href="https://blog.csdn.net/jiangqin115/article/details/39315085">伪首部</a>，<a href="http://www.metools.info/code/c128.html">校验和计算器</a>，<a href="https://www.cnblogs.com/iamwho/p/11510160.html">校验和计算方法</a>，<a href="https://blog.csdn.net/axiqia/article/details/52704061?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-52704061-blog-103358272.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-52704061-blog-103358272.pc_relevant_vip_default&amp;utm_relevant_index=1">校验和计算原理</a>，<a href="https://blog.csdn.net/qq_19782019/article/details/87452394">汉明码通俗讲解</a>，<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E7%A0%81/3226749">汉明码-百度</a>，<a href="https://blog.csdn.net/TL18382950497/article/details/113794438">CRC计算流程详解</a>，<a href="https://zhuanlan.zhihu.com/p/61636624">CRC代码实现</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 链路层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP存活检测机制</title>
      <link href="/2022/08/08/TCP%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/"/>
      <url>/2022/08/08/TCP%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">TCP存活检测的背景</mark> </strong></p><p>由于 TCP 位于传输层，两端的连接为逻辑信道(由五元组控制)而非物理连接，所以当两端处于连接状态但未发送数据时，理论上即使中间的路由器崩溃重启、或者中间的网络线路拔掉在插上等等，只要客户端和服务器端的主机没有发生异常，这个TCP连接仍然是处于连接状态的。这会引发以下问题：</p><ol><li>服务器资源被持续占用（需要保存连接的状态信息）</li><li>防火墙和NAT设备可能会保存一个连接超时的定时器，如果这个 TCP 连接长时间没有数据传输，定时器超时后，服务器端和客户端实际上已经不能在进行通信。</li></ol><p>为了解决上面的两个问题，TCP连接需要一个存活检测机制，定时检测当前的 TCP 连接是否可用，以刷新防火墙和 NAT 信息，或者当检测到连接失败的时候释放相关资源。TCP 存活检测机制主要为 <strong>长连接</strong> 服务。</p><p><strong><mark class="hl-label blue">存活检测实现方式</mark> </strong></p><ol><li><strong>应用层心跳机制</strong></li><li><strong>TCP保活机制</strong></li></ol><p>相比传输层的存活检测，应用层的检测更灵活且不依赖传输层的协议，但需要应用自定义心跳消息头。心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉对方自己还活着。事实上这是为了保持<a href="https://baike.baidu.com/item/%E9%95%BF%E8%BF%9E%E6%8E%A5">长连接</a>，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。</p><p><strong><mark class="hl-label default">应用层心跳机制</mark> </strong></p><p>应用层的心跳包其实就是一个预先规定好格式的数据包，在程序中启动一个定时器，定时发送即可，这是最简单的实现思路。通常，当双端正常通信时，各端接收到数据包本身也能说明连接是“有心跳的”，故此时无需心跳包。所以，对于用于保活的心跳包，我们仅在没有数据来往达到一定时间间隔时才发送一次心跳包。一般是客户端主动给服务器端发送心跳包，服务器端做心跳检测决定是否断开连接。</p><p><strong><mark class="hl-label default">TCP保活机制</mark> </strong></p><p>在TCP存活检测中有一个 <strong>存活定时器</strong> ，当 TCP 连接的任何一个方向有业务数据传输时，就会把这个存活定时器重置为 <code>keepalive time</code> ，当固定时间内没有数据传输导致本端这个定时器超时的时候，TCP就会发送一个探测包(keepalive probe )，若对端接收到这个探测包后响应一个 ACK，本端接收到这个 ACK 时就会重置这个存活定时器为 <code>keepalive time</code> 。如果本端没有收到这个 ACK 响应，会以 <code>keepalive interval</code> 为间隔时间重复发送探测包，如果一直发送了<code>keepalive probes</code> 次都没有收到 ACK 响应，则认为这个连接已经失活。如果中间的某次收到 ACK 响应则会重置存活定时器为 <code>keepalive time</code> ，并且停止 <code>keepalive interval</code> 为间隔的探测包重复发送。</p><p><code>keepalive time</code> 一般为 7200 ms，即两个小时(时间太长，没有实际意义)；<code>keepalive interval</code> 一般为 75 ms；<code>keepalive probs</code> 一般为 9 次。所以如果连接一直未响应，最晚两个小时十多分钟就会自动断开连接。<u>keepalive功能必须默认关闭</u> 。</p><p><strong><mark class="hl-label blue">为什么有了TCP保活机制，还需要应用层心跳检测？</mark> </strong></p><p>因为 TCP 的保活机制并不能准确体现应用层的可用性。应用层心跳除了说明进程还活着，更重要的是说明进程还能正常工作。一旦客户端发生死锁， 其心跳机制也会锁住，这样服务端就能感知到不正常，从而及时断开连接。而 TCP 的保活机制依然正常，所以无法向外界反馈正确信息。</p><blockquote><p>文章参考：<a href="https://www.zhihu.com/question/40602902">TCP37</a>，<a href="https://www.zhihu.com/question/40602902">知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP计时器详解</title>
      <link href="/2022/08/08/TCP%E4%B8%83%E7%A7%8D%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/08/TCP%E4%B8%83%E7%A7%8D%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>建立连接定时器 (connection-establishment timer)<br>重传定时器 (retransmission timer)<br>延迟应答定时器 (delayed ACK timer)<br>坚持定时器 (persist timer)<br>保活定时器 (keepalive timer)<br>FIN_WAIT_2 定时器 (FIN_WAIT_2 timer)<br>TIME_WAIT 定时器 (TIME_WAIT timer, 也叫2MSL timer)</p></blockquote><p><strong><mark class="hl-label blue">建立连接定时器</mark> </strong></p><p>建立连接的过程中，在发送 SYN 时， 会启动一个定时器(1秒或3秒，取决于实现)，如果 SYN 包丢失了， 那么 1 秒以后会重新发送 SYN 包，若再次超时，则会将 RTO 设为 2，再超时则设为 4，每次翻倍（指数回退）。在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5，所以一般等待 60 秒后再无回应就会关闭连接。</p><p><strong><mark class="hl-label blue">重传定时器</mark> </strong></p><p>重传定时器在 TCP 发送<u>普通报文</u>时设定，具体大小(一般为1秒)参见<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">RTT的测量</a>，在计时器超时后没有收到返回的确认 ACK，发送端就会重新发送队列中需要重传的报文段。使用 RTO 重传计时器一般有如下规则：</p><ol><li>当TCP发送了位于发送队列最前端的报文段后就启动这个RTO计时器；</li><li>收到 ACK 报文后，若所有已发送分组都被确认，则停止计时，若只是部分确认，则重开计时器。</li><li>若超时，则重传所有未完成报文（有待考证）。</li></ol><p>对于普通报文的重传定时器，最大重传次数由 <code>tcp_retries2</code> 决定，详细参考<a href="https://www.cnblogs.com/lshs/p/6038527.html">此处</a> 。</p><p><strong><mark class="hl-label blue">延迟应答定时器</mark> </strong></p><p>延迟确认也被称为捎带ACK， 这个定时器在延迟应答的时候使用（最大时间为 0.5 秒）。收到第一个 ACK 报文后，等待一段时间，若最长 0.5 秒内未收到第二个报文，则直接发送 ACK。TCP 最多只能延迟确认一次，即 ACK 报文最多只能累积确认两个报文。</p><p><strong><mark class="hl-label blue">坚持定时器</mark> </strong></p><p>当 TCP 的一端一直接收数据，但是应用层没有及时读取的话，会导致缓存区不断减小，<code>window size</code> 会变为 0，此时我们称呼这个接收窗口为零窗(zero window)，对端也不能在发送更多的数据。如果随后本端应用层从 TCP 接收缓存中读取了足够数据，TCP 模块有了足够的新的接收缓存的时候，就会发送一个TCP报文，并带有一个有效非零的 <code>Window size</code> 来指示对端自己已经可以接收新数据了。这个带有有效<code> Window size</code> 的报文我们称为窗口更新(window update)报文。<strong>窗口更新报文一般为 pure ACK 报文，不消耗系列号，所以发生丢失并不会进行重传</strong> 。如果窗口更新报文发生丢失，那么接收端会等待发送端发送新的数据，而发送端会等待窗口更新报文，这种场景下，两端互相等待对方，就会产生 <strong>死锁</strong> （Nagle算法和延迟ACK同时生效的时候也会产生类似的死锁）。为了避免死锁，发送方会设置一个 <strong>坚持计时器</strong> ，每当这个定时器超时的时候，发送端就会发送 <strong>零窗口探测报文</strong> 。RFC1122 建议初始坚持定时器时间为RTO，随后每次超时重传进行指数回退，最大指数回退次数为 <code>tcp_retries2</code> 。达到 <code>tcp_retries2</code> 后不再进行指数回退，且继续以当前 RTO 进行重传。<strong>可以看到这里没有释放 TCP 连接，而在 RTO 重传指数回退过程中，当超过根据 <code>tcp_retries2</code> 计算的最大重传时间的时候就会释放TCP连接。</strong></p><p><strong><mark class="hl-label blue">保活计时器</mark> </strong></p><p><strong>在 TCP 连接建立的时候指定了 <code>SO_KEEPALIVE</code> ，保活定时器才会生效</strong> 。如果客户端和服务端长时间没有数据交互，那么需要保活定时器来判断是否对端还活着，但是这个其实很不实用，因为默认是 2 小时没有数据交互才探测，时间实在是太长了。如果你真的要确认对端是否活着， 那么应该自己实现心跳包，而不是依赖于这个保活定时器。详细参见<a href="https://jyxcpp.netlify.app/2022/08/08/tcp%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/">此处</a> 。</p><p><strong><mark class="hl-label blue">FIN_WAIT_2定时器</mark> </strong></p><p>主动关闭方收到第二次挥手的 FIN 报文后进入 <code>FIN_WAIT_2</code> 状态。由于可能因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的 FIN，所以需要 <code>FIN_WAIT_2</code> 定时器进行计时， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的 FIN 那么直接释放这个连接。对于 close() 函数关闭的连接，由于无法再发送和接收数据，所以 <code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒；对于 shutdown() 函数，主动关闭方无法再发送数据，但还可以接收数据，所以可能不会计时，待讨论。</p><p><strong><mark class="hl-label blue">TIME_WAIT定时器</mark> </strong></p><p>第四次握手后，主动关闭方进入 <code>TIME_WAIT</code> 状态，并等待 <code>2MSL</code> 后关闭。关于为什么需要等待 <code>2MSL</code> ，参见<a href="https://jyxcpp.netlify.app/2022/08/03/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">此处</a> 。<code>MSL</code> 是数据包在网络中的最大生存时间，其值应大于 ip 协议中 <code>TTL</code> 换算的时间，rfc793 建议 <code>MSL</code> 设置为 2 分钟，linux 遵循伯克利习惯设置为 30 s。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP“粘包”</title>
      <link href="/2022/08/08/TCP%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D/"/>
      <url>/2022/08/08/TCP%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>首先需要明白，“TCP 粘包”这个称呼本身是有问题的，因为 <strong>TCP 是面向字节流的协议</strong> ，不存在数据边界，所以 TCP 本身就不会有什么“粘包”的问题。要说“粘包”，这个词更适合形容 UDP 这类 <strong>面向数据报</strong> 的协议。所以说，“粘包”并不是 TCP 的范畴，而是程序员基于错误的理解来实现上层逻辑，从而导致的问题，和 TCP 本身无关。再具体而言，“TCP粘包问题”应该阐述为——<u>在TCP传输协议下，应用层数据拼装发送和接收解析的问题</u> 。不过为了方便描述，下文就采用“TCP粘包”一词。</p></blockquote><p><strong><mark class="hl-label blue">粘包如何产生？</mark> </strong></p><p>“粘包”的首要原因就是 <strong>基于字节流</strong> 这个特点。字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串，而这些 01 串之间 <strong>没有任何边界</strong> 。应用层传到 TCP 协议的数据以字节流的方式发送到下游，这些数据可能被切割（过大）和组装（过小）成段，接收端收到这些段后没有正确还原原来的消息，因此出现粘包现象。粘包可以发生在发送端和接收端。</p><p><strong>发送端：</strong></p><p>在 Nagle 算法（参考<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">此处</a>）开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到 <code>MSS</code> （或含有 <code>Fin</code> 包），立刻发送，否则等待下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为200ms），第一个包没到 <code>MSS</code> 长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><img src="/2022/img/1460000039691668.png" alt="negle引起发送端粘包" style="zoom: 80%;" /><p>如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就像是两个包粘在一起，就会导致粘包问题。</p><p><strong>接收端：</strong></p><p>如果接收端一直较忙，没来得及取出缓冲区的数据，导致缓冲区挤压，最后一次性取出大量数据，也可能产生粘包。</p><img src="/2022/img/1460000039691676.png" alt="关闭Negle也可能粘包" style="zoom:67%;" /><p><strong><mark class="hl-label blue">如何解决粘包？</mark> </strong></p><p>粘包出现的根本原因是不确定 <strong><u>消息</u>的边界</strong> 。接收端在面对&quot;无边无际&quot;的二进制流的时候，根本不知道收了多少 01 才算一个<u>消息</u> 。一不小心拿多了就说是粘包。所以说粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><blockquote><p>应用层的数据包称为“消息”，TCP 的数据包称为“段”，UDP 的数据包称为“数据报”，链路层则称为“帧”。所以，“粘包”也许应该叫“粘消息”，哈哈哈。</p></blockquote><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong> ，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。一般有两种分包方法：</p><ol><li><p><strong>以指定字符（串）为包的结束标志</strong> ：这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如， FTP协议， SMTP 协议，一个命令或者一段数据后面加上&quot;\r\n&quot;（即所谓的 <strong>CRLF</strong> ）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。这种协议一般用于一些包含各种命令控制的应用中。如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。</p><img src="/2022/img/1460000039691673.png" alt="消息边界头尾标志" style="zoom: 50%;" /></li><li><p><strong>包头 + 包体格式</strong> ：这种格式的包一般分为两部分，即包头和包体，<strong>包头是固定大小的</strong> ，且包头中必须含有一个字段来说明接下来的包体有多大。当收到数据时，首先提取包头大小的数据量，解析包头得到包体长度，根据此长度继续提取后面的包体即可。可见，此方法要求接收方从一开始就必须采用约定方式提取数据，而不能中途使用。</p></li></ol><p>下面给出 <mark class="hl-label default">包体+包头</mark>  方式的代码示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制1字节对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">//协议头</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg_header</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int32_t</span>  bodysize;         <span class="comment">//包体大小  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包最大字节数限制为10M</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PACKAGE_SIZE    10 * 1024 * 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatSession::OnRead</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//while连续读取数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不够一个包头大小</span></span><br><span class="line">        <span class="keyword">if</span> (pBuffer-&gt;<span class="built_in">readableBytes</span>() &lt; (<span class="type">size_t</span>)<span class="built_in">sizeof</span>(msg_header))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LOGI &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg_header)=&quot; &lt;&lt; sizeof(msg_header);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取包头信息</span></span><br><span class="line">        msg_header header;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;header, pBuffer-&gt;<span class="built_in">peek</span>(), <span class="built_in">sizeof</span>(msg_header));<span class="comment">//注意只能peek，不能提取，因为倘若接下来根据包头中的字段得到包体大小时，如果剩余数据不够一个包体大小，你又得把这个包头数据放回缓冲区。</span></span><br><span class="line">        <span class="comment">//包头有错误，立即关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> (header.bodysize &lt;= <span class="number">0</span> || header.bodysize &gt; MAX_PACKAGE_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//务必判断bodysize的合法性，有可能是非法客户端发来攻击，也可能数据错误。</span></span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;Illegal package, bodysize: %lld, close TcpConnection, client: %s&quot;</span>, header.bodysize, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            conn-&gt;forceClose();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到的数据不够一个完整的包</span></span><br><span class="line">        <span class="keyword">if</span> (pBuffer-&gt;<span class="built_in">readableBytes</span>() &lt; (<span class="type">size_t</span>)header.bodysize + <span class="built_in">sizeof</span>(msg_header))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        pBuffer-&gt;<span class="built_in">retrieve</span>(<span class="built_in">sizeof</span>(msg_header));</span><br><span class="line">        <span class="comment">//inbuf用来存放当前要处理的包</span></span><br><span class="line">        std::string inbuf;</span><br><span class="line">        inbuf.<span class="built_in">append</span>(pBuffer-&gt;<span class="built_in">peek</span>(), header.bodysize);</span><br><span class="line">        pBuffer-&gt;<span class="built_in">retrieve</span>(header.bodysize);</span><br><span class="line">        <span class="comment">//解包和业务处理</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Process</span>(conn, inbuf.<span class="built_in">c_str</span>(), inbuf.<span class="built_in">length</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//客户端发非法数据包，服务器主动关闭之</span></span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;Process package error, close TcpConnection, client: %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            conn-&gt;forceClose();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// end while-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">UDP会粘包吗？</mark> </strong></p><p>不会，UDP 面向报文，其报头中有本报文的长度信息，可以区分数据包，所以不会粘包。</p><blockquote><p>参考文章：<a href="https://segmentfault.com/a/1190000039691657">详解粘包</a>，<a href="https://www.zhihu.com/question/20210025">知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拥塞控制详解(一)</title>
      <link href="/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">什么是网络拥塞？</mark> </strong></p><p>当 TCP 数据包经由网络中的路由器传输的时候，如果路由器的收包速度大于处理速度，路由器一般会先把收到的数据包缓存起来等待后续处理。但是当网络传输速度过大时，则会导致路由器的缓存空间全部被占用从而只能丢弃一部分数据包，如果一个路由器或者交换机等网络节点由于性能或者带宽等因素的限制而不能及时处理这些业务数据的时候，就会强制丢包，这种场景就叫做 <strong>拥塞(congestion)</strong> 。</p><p><img src="/2022/img/282120371196460.png" alt="当负载超过Cliff之后，吞吐量就急剧下降，延迟相应急剧上升。Cliff点也就是网络的最大负载，一旦超过网络的整体性能就大打折扣"></p><p><strong><mark class="hl-label blue">拥塞控制和流量控制的关系？</mark> </strong></p><ol><li>流量控制是点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收；拥塞控制是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，关注到传输链路上所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制是以显式的方式在TCP头中通过 Window size 字段通告发送方，流量控制关注的是接收端和发送端；<u>拥塞控制大多是通过隐式的方式控制发送端速率，接收端依据特定的收发包情况来推测网络拥塞状况</u> 。</li></ol><p>简单而言，<strong>流量控制考虑的是接收方的接收能力，拥塞控制考虑的是网络的传输能力</strong> 。网络拥塞本来应该由 IP 协议负责，但因为 IP 是一个不可靠且简单的协议，所以此责任不得不落于 TCP 身上。</p><blockquote><p>具体而言，如果网络上的延时突然增加，那么，TCP 流量控制只重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大，最终导致整个网络的崩溃。</p></blockquote><p>对应流量控制中的 <code>rwnd</code> ，TCP 会维护一个 <code>cwnd</code> 变量来控制拥塞窗口的大小。<strong><font color='orange'>发送端实际可用的窗口大小 <code>W = min(rwnd, cwnd)</code></font></strong> （不过为了方便描述，cwnd 通常指 MSS 大小的包的个数）</p><p>。已经发送但还没有被 ACK 确认的数据量叫做 <strong>flight size</strong> ，<strong>拥塞控制限制发送速率的方式就是让 <code>flight size&lt;=W</code></strong> ，另外有两点需要注意：</p><ol><li><p>在没有使用 SACK 时，flight size 就是当前已经发送数据包的最大 seq 减去当前接收到的最大 ACK Number。</p></li><li><p>在使用 SACK 时，flight size 还需要扣除被 SACK 反馈的数据包。</p></li></ol><blockquote><p>W 的合理值应该接近网络的 <strong>带宽延迟积</strong> 。</p><p><strong>数据包守恒原则：</strong> 在一个运行平稳的 TCP 连接中流动的数据包应该是守恒的，意思是当只有旧的数据包被成功传输到对端后，新的数据包才能加入到连接中。传输中的包称为 in_flight ，进行拥塞控制的时候，如果 <code>in_flight&gt;=cwnd</code> 的，就表示拥塞窗口不允许在额外发送数据包了。</p></blockquote><p>TCP 拥塞控制主要包含下面四个算法：<strong>慢启动，拥塞避免，快速恢复，快速重传</strong> 。</p><h3 id="font-color-red-慢启动-font"><font color='red'>慢启动</font></h3><p>一个 TCP 连接启动的时候并不知道 cwnd 应该取多大的值适合当前的网络状况，因此 TCP 发送方会从一个较小的初始值指数抬升 cwnd 到某一个值，这个 cwnd抬升的过程就叫做慢启动。慢启动算法如下：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><img src="/2022/img/271.jpg" alt="慢启动算法" style="zoom:50%;" /><blockquote><ul><li>注意，是 <strong>每个 ACK</strong> 都会使 <code>cwnd</code> 翻倍，而不是每一批 ACK（拥塞避免采用）。可见，慢启动会进行指数增长，<code>cwnd</code> 短时间内迅速增大，为防止其过大，还需要引入 <strong>慢启动阈值(ssthresh)</strong> ，一旦达到阈值，便进入 <strong>拥塞避免</strong> 。</li><li>如果延迟确认，则也会进行指数增长，不过是 1.5 的幂。</li><li>Linux 3.0后把 <code>cwnd</code> 初始化成了 10个 MSS。</li></ul></blockquote><h3 id="font-color-red-拥塞避免-font"><font color='red'>拥塞避免</font></h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd，即每收完同一批数据包的ACK，cwnd++</strong> 。</p><img src="/2022/img/281.jpg" alt="拥塞避免" style="zoom:67%;" /> <p>显然，慢启动是指数增加算法，而拥塞避免是线性增加算法，两种方法合起来常称为 <strong>AIMD算法</strong>（加法增大乘法减少）。这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><h3 id="font-color-red-拥塞处理-font"><font color='red'>拥塞处理</font></h3><p>拥塞窗口增大的过程中，也随时有可能发生拥塞。TCP 中，一般使用两种事件作为拥塞发生的标志：1）<strong>超时重传</strong> ；2）<strong>收到三次重复 ACK</strong> ；收到三次重复 ACK 情况下的拥塞程度低于超时重传，因为当发送方收到三次重复 ACK 时，说明一个段发生了丢失或延迟，但三个段已经被接收，说明网络拥堵有所恢复。</p><p>TCP 如下处理这两种拥塞情况：</p><ol><li><strong>RTO超时：</strong><ul><li>sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ul></li><li><strong>收到三次重复 ACK（TCP Reno）：</strong><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li><li>进入快速恢复算法</li></ul></li></ol><h3 id="font-color-red-快速恢复-font"><font color='red'>快速恢复</font></h3><p>快速恢复和快速重传一般同时使用。快速恢复算法如下：</p><ul><li>cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）</li><li>重传 Duplicated ACK 指定的数据包</li><li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li><li>如果收到了新的 ACK，那么，cwnd = sshthresh ，然后就进入拥塞避免的算法。</li></ul><img src="/2022/img/拥塞发生-快速重传.drawio.png" alt="Reno 快速恢复" style="zoom:67%;" /><p><strong><mark class="hl-label blue">cwnd=ssthresh+3，为什么加3？</mark> </strong></p><p>因为既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大些。后续收到冗余 ACK 仍增加的原因同理。</p><blockquote><p>然而上面这个算法也存在问题，那就是——它依赖于 3 个重复的 ACK 。注意，3 个重复的 ACK 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。SACK 或 D-SACK 的方法虽然可以让 Fast Recovery 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。New Reno 对此做出了改进。</p></blockquote><p><strong>New Reno下的快速恢复：</strong></p><ul><li>当发送方这边收到了3个 Duplicated ACK，进入快速重传模式，重传冗余 ACK 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 ACK 可以确认所有已经被发送方传输出去的数据。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li><li>一旦发送方这边发现了 Partial ACK 出现，那么，发送方就可以推理出来有多个包被丢了，于是乎继续重传窗口内未被确认的第一个包。直到再也收不到 Partial Ack，才真正结束快速恢复这个过程。</li></ul><p>另一种带有 SACK 的快速恢复是 <strong>FACK</strong> 算法，自行了解，我也不懂。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/lshs/p/6038757.html">拥塞算法</a>，<a href="http://www.52im.net/thread-515-1-1.html">TCP概述</a>，<a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D">小林coding</a>，<a href="https://blog.csdn.net/dl962454/article/details/115796513">拥塞简介</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP流量控制详解</title>
      <link href="/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-滑动窗口-font"><font color='red'>滑动窗口</font></h3><p>TCP 流量控制基于 <strong>滑动窗口</strong> (连续 ARQ 协议) 实现。滑动窗口既保证了分组无差错、有序接收，也实现了流量控制。</p><p><img src="/2022/img/101120ihanzfsth0hhcllk.png" alt="发送方滑动窗口示意图"></p><p>发送方的滑动窗口由接收方控制，实现方法为：在接收方传递给发送方的报文中加入 Window Size 信息，从而告知发送方自己的窗口大小，<strong>且发送方必须服从接收方的管理</strong> 。在 TCP 实现中，<strong>两端的窗口大小相同</strong> 。另外需要注意的是，发送方不一定会一次性发送整个窗口的数据，这根据网络情况而定。</p><blockquote><p><strong><font color='orange'>窗口本身是一种抽象</font></strong> ，发送窗口有三个变量实现，分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> （第一个未完成分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Sn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span></span></span></span> （下一个待发送分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mrow><annotation encoding="application/x-tex">S{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span> （窗口大小）。</p><img src="/2022/img/IMG_0427(20220802-163852).PNG" alt="窗口的抽象" style="zoom:50%;" /></blockquote><p><img src="/2022/img/104946z1skgjjxx8g0txbx.png" alt="滑动窗口示意图"></p><p>一般而言，流量控制分为两种：1）发送方输出的流量过多，接收方来不及接收。2）发送方发得太少，导致浪费带宽（数据只有一两个字节，而报头就占了几十个字节）。对于第一种则很好控制，只要发送方将每次输出的流量控制在接收方告知的窗口大小内即可；对于第二种情况(被称之为 <strong>糊涂窗口综合征</strong> )，则相对复杂。</p><blockquote><p><strong>糊涂窗口综合征</strong> ：当发送端进程产生数据缓慢或接收端进程数据拉取缓慢时，会导致发送方以很小的段发送，这会降低信道的利用率。这个问题称之为糊涂窗口综合征。此问题可以从发送方和接收方解决：</p><ul><li><strong><font color='orange'>发送方： Nagle 算法，Cork 算法</font></strong></li><li><strong><font color='orange'>接收方：Clark Solution，延迟确认</font></strong></li></ul></blockquote><h3 id="font-color-red-延迟确认-font"><font color='red'>延迟确认</font></h3><p><strong>延迟确认（Delayed Acknowledgements）用于接收方</strong> ，其工作原理：当包到达接收方时，不立即确认，而是等待一定时间再发送确认。等待一段时间有两个好处：</p><ol><li>此时间内接收方进程可以拉取数据，清空部分缓冲区以提供更大窗口（这样就可以使发送方一次发送更多的字节）。</li><li>接收方不必确认每一个段，减少了 pure ACK ，提高了通信效率。这基于发送方的 <strong>累积确认</strong> 。</li></ol><p>需要注意，<strong><font color='orange'>延迟确认最多延迟一次，即每两个报文就必须发送 ACK 报文；最多延迟 0.5 秒，若未等到下一个包，则直接发送 ACK</font></strong> 。同时，<u>延迟确认必须同时满足以下几点才可使用</u> ：</p><ol><li><p><strong>当前已经收到的但是还没有回复 ACK 的报文长度小于接收 MSS。</strong></p><blockquote><p>这很好理解，<u>TCP 是基于字节流的协议</u> ，数据没有边界，所以发送方填充数据时应该会将每个段填充到最大长度（ MSS ）时才会继续填充下一个。若数据长度未达 MSS，我们就可以合理猜测对方数据已经发送完（也可能是因为对方进程产生数据太慢）。</p></blockquote></li><li><p><strong>当前没有处于 quick ACK模式</strong></p></li><li><p><strong>当前接收窗口中没有先前接收的乱序报文</strong></p></li></ol><p>仅有延迟确认机制，不会导致请求延迟(初以为是必须等到 ACK 包发出去，recv系统调用才会返回)。一般来说，只有当该机制与Nagle算法或拥塞控制(慢启动或拥塞避免)混合作用时，才可能会导致时耗增长。</p><blockquote><p><strong>quick ACK：</strong></p><p>与延迟 ACK 对应，Linux 还有一个 quick ACK 模式，这种 quick ack 模式下就会对每个数据包都回复一个 ACK。在<u>连接初始建立时候</u> 、<u>收包间隔大于 RTO 时</u> 、<u>收到不在接收窗内的报文的时候</u>  等场景下就会进入 quck ack 模式，进入 quick ac k模式的时候，会把 quick ack 计数器初始化为 16 (也有可能是小于16的某个值)，这就是说随后的 16 个数据包都不采用延迟 ACK。</p></blockquote><h3 id="font-color-red-Nagle-算法-font"><font color='red'>Nagle 算法</font></h3><blockquote><p>如果发送方 TCP 正在为一个创建数据很缓慢的进程服务，则可能引起糊涂窗口综合征。解决方法是防止发送方一个一个字节地发送数据。发送方被迫等待到将数据集成较大的数据块时再发送。那么需要等待多久？太长，延误进程；太短，数据不够长，效率低。Nagle 提供了一个简单的方法解决此问题。</p></blockquote><p><strong>Nagle 算法用于发送方</strong> ，其方法非常简单：</p><ol><li>即使从发送方进程接收来的数据只有 1 字节，也直接将其封装并发送。</li><li>发送第一个段后，发送方在缓冲区积累数据并等待，<strong><font color='orange'>直到发送方接收到 ACK 或数据积累到 MMS 或包中有 FIN 再发送。</font></strong></li></ol><p><strong><mark class="hl-label blue">Nagle与延迟ACK引发死锁</mark> </strong></p><p>当 Nagle 算法和延迟 ACK 同时使能的时候，可能会造成如下情况：</p><ol><li>客户端发送第一个小包，并被服务端接收。</li><li>客户端等待 ACK 或数据长度达到 MMS。</li><li>服务端延迟确认等待下一个包直到超时（0.5s）。</li></ol><p>这使得两端相互等待，引发 <strong>死锁(deadlock)</strong> 。这种情况下就会提升平均时延，降低网络性能，因此可能需要禁用Nagle算法或者延迟ACK算法。另外，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序</strong> ，你需要关闭这个算法。在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法</p><h3 id="font-color-red-Cork-算法-font"><font color='red'>Cork 算法</font></h3><p><strong>Nagle 算法用于发送方</strong> 。Cork 算法与 Nagle 算法类似，但 Cork 算法则更为激进，一旦打开 Cork 算法，TCP 不关注是否有收到 ACK 报文，只要当前缓存中累积的数据量不满 MMS 时，就不会将数据包发出，直到一个 RTO 超时后才会把不满 MMS 的数据包发出去。</p><p>linux 中可以通过 <code>TCP_CORK</code> 选项来设置 Socket 打开 Cork 算法。<code>TCP_NODELAY</code> 选项和 <code>TCP_CORK</code> 选项在 Linux 早期版本是互斥的，但目前最新的 linux版本已经可以同时打开这两个选项了，但是 <code>TCP_CORK</code> 选项的优先级要比 <code>TCP_NODELAY</code> 选项的优先级要高。</p><blockquote><p>CORK 与 Nagle 的区别是，Nagle 算法是尽量避免大量的小包发送，而 CORK 算法是期望完全避免发送小包（无论是大量还是少量的小包）。</p></blockquote><h3 id="font-color-red-Clark-Solution-font"><font color='red'>Clark Solution</font></h3><p><strong>Clark Solution 用于接收方</strong> 。要避免接收方的糊涂窗口综合征，简单的办法就是不让接收方窗口每次只更新少量可用缓冲区，直到有较大空间时，才通知发送方窗口大小。Clark 解决方法是 <strong><font color='orange'>只要有数据到达就发送确认，但宣布的窗口大小为零，直到窗口足够放入具有最大长度的报文段，或者至少半个缓存空间是空的</font></strong> 。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/lshs/p/6038647.html">Cork</a>，<a href="https://www.cnblogs.com/lshs/p/6038641.html">Nagle</a>，<a href="https://www.cnblogs.com/lshs/p/6038635.html">延迟ACK</a>，<a href="http://www.52im.net/thread-515-1-1.html">TCP简介</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP重传机制详解</title>
      <link href="/2022/08/07/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/07/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-超时重传-font"><font color='red'>超时重传</font></h3><p><strong><font color='orange'>超时重传基于定时器，以时间驱动重传</font></strong> 。当发送端发送数据包后会启动相应计时器，如果在一定时间内未收到接收端发来的 ACK 报文导致计时器超时，则会重传相应报文。</p><blockquote><p>需要注意的是，是仅重发相应超时报文还是重发所有未完成（已发出但未收到 ACK）的报文，在各个机制中有所不同（这取决于定时器的数量）。比如在【停等协议】中， 仅有一个定时器，一旦超时，重发所有未完成包；而在【选择重传协议】中，每个报文都有一个定时器，超时后仅重传对应报文。详细内容见：<a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">详解ARQ协议</a></p></blockquote><p>超时重传面临三个主要问题：</p><ol><li><p><strong>RTO(重传时间) 如何确定？</strong></p></li><li><p><strong>超时才发生重传，延迟较高。</strong></p></li><li><p><strong>发生超时后，重传哪些包？</strong></p><blockquote><p>比如，发送端按序发送 1，2，3，4，5 个包，发送端只接收到第 1，2，4，5个包，那么接收端只能发送 ACK = 3 的 ACK 报文（表明 3 之前的都已收到），发送端收到 ACK 报文后，定时器超时， 由于此时第 3，4，5 的 ACK 报文都没有收到，那么发送端该重发哪些报文呢？只发 3 的报文还是发送 3，4，5 的报文？前者会节省带宽，但是若 4，5 真的也丢失了，又会等待重传；后者会快一点，但是会浪费带宽，也可能会有无用功。</p></blockquote></li></ol><p>对于第一个问题，笔者写了另一篇文章详尽阐述，参见<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">此处</a> ；对于第二个问题，<strong>快速重传</strong> 机制会很好地解决；对于第三个问题，<strong>SACK</strong> 机制派上用场。另外需要知道的是，<strong><font color='orange'>若连续超时重传，则会进行 <a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">指数回退</a> ，超过一定次数则会终止连接，务必参见<a href="https://www.cnblogs.com/lshs/p/6038527.html">重传示例</a></font></strong> 。</p><h3 id="font-color-red-快速重传-font"><font color='red'>快速重传</font></h3><p><strong><font color='orange'>快速重传不以时间为驱动，而以数据驱动重传。</font></strong> 【快速重传】机制如下图：</p><p><img src="/2022/img/140607dww7fwawwfft7a1j.png" alt="快速重传示意图"></p><p>如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ACK 回2，结果 2 因为某些原因没收到，3 到达了，于是还是 ACK 回2；后面的 4 和 5 都到了，但是还是 ACK 回 2，因为 2 还是没有收到，于是发送端收到了四个 <code>ACK = 2</code> 的确认，知道了 2还 没有到，于是就马上重传 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是回复 <code>ACK = 6</code> 。</p><blockquote><p><strong>注意！大多数书上和博客对【重复】描述并不清晰，个人认为应该如此描述：1. 收到三个 <u>冗余</u> 的ACK，重传；2. 收到四个 <u>重复</u> 的ACK，重传；</strong></p></blockquote><p><strong><mark class="hl-label blue">为什么要重复三次才发送？</mark> </strong><br>那是因为 dup ACK 即可能是丢包造成的，也可能是网络乱序造成的。基于实验，定值为 3 ，参见 <a href="zhihu.com/question/21789252">此处</a>。</p><p>然而，【快速重传】机制只解决了【超时重传】的时间延迟较长的问题，但还是没有解决第三个问题。对于上面的示例来说，是重传 2 呢还是重传 2，3，4，5呢？因为发送端并不清楚这连续的 3 个 <code>ACK = 2</code> 是谁传回来的。也许发送端发了 20 份数据，是 6，10，20 传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些 TCP 的实际的实现）。为此，引入【SACK方法】。</p><h3 id="font-color-red-SACK-font"><font color='red'>SACK</font></h3><p>【SACK】即 Selective Acknowledgment ，这种方式需要在 TCP 头部里加一个 SACK 选项，选项格式如下：</p><img src="/2022/img/image-20220807120644997.png" alt="image-20220807120644997" style="zoom:67%;" /><img src="/2022/img/140643mooa22groefuggoh.jpg" alt="SACK示意图" style="zoom: 67%;" /><p><code>SACK</code> 汇报的是接收方当前 ACK 号之后的已经收到的字节数。通过 <code>SACK</code> ，发送方就可以判断接收方还有哪些包没有收到，进而就可以只重传特定的分组，大大提高了效率。同时注意：</p><ol><li>如果要支持 <code>SACK</code>，必须双方都要支持，在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）；</li><li><strong>TCP的选项不能超过40个字节，所以 SACK 段不能超过4组</strong>。</li><li>接收方可能 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，<strong>发送方也不能完全依赖 SACK</strong> ，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传。</li><li>SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</li></ol><blockquote><p>需要注意，【SACK】是【选择性确认】，不同于 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">ARQ</a> 协议中的【选择重传】，二者有相似之处，但前者并不代替 ACK，只是在 ACK 报文中添加额外的信息来帮助发送方进行确认。</p></blockquote><h3 id="font-color-red-DSACK-font"><font color='red'>DSACK</font></h3><p>Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。采用如下方法判断是 SACK 还是 DSACK：</p><ul><li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 DSACK</li><li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 DSACK</li></ul><p>DSACK 用法举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一.ACK丢包</span><br><span class="line"></span><br><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line">  </span><br><span class="line">3000-3499    3000-3499   3500 (ACK dropped)</span><br><span class="line">3500-3999    3500-3999   4000 (ACK dropped)</span><br><span class="line">3000-3499    3000-3499   4000, SACK=3000-3500</span><br><span class="line">----------------------------------------------</span><br><span class="line">二.网络延迟</span><br><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line">  </span><br><span class="line">500-999        500-999     1000</span><br><span class="line">1000-1499      (delayed)                         -&gt;| SACK</span><br><span class="line">1500-1999      1500-1999   1000, SACK=1500-2000    | SACK</span><br><span class="line">2000-2499      2000-2499   1000, SACK=1500-2500    | SACK</span><br><span class="line">2500-2999      2500-2999   1000, SACK=1500-3000    | SACK</span><br><span class="line">1000-1499      1000-1499   3000                    |</span><br><span class="line">               1000-1499   3000, SACK=1000-1500  &lt;-| DSACK</span><br></pre></td></tr></table></figure><p><strong>可见，引入了D-SACK，有这么几个好处：</strong></p><ul><li>可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</li><li>是不是自己的 timeout 太小了，导致重传。</li><li>网络上出现了先发的包后到的情况</li><li>网络上是不是把我的数据包给复制了。</li></ul><p>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控。Linux下的 <code>tcp_dsack</code> 参数用于开启这个功能（Linux 2.4后默认打开）。</p><blockquote><p>从纠错层面上而言，DSACK 和 SACK 完全相同，只是 DSACK 在收到包且重复的情况下也会反馈信息给发送方，使发送方更全面地了解网络情况。</p></blockquote><h3 id="font-color-red-早期重传（ER）-font"><font color='red'>早期重传（ER）</font></h3><blockquote><p>学习【快速重传】时，你可能会想到，万一经常出现发送方只收到两次或者一次冗余的 ACK 报文而无法快速重传报文时，咋办？只有等定时器超时吗？那这样效率是不是又会降下来？是对，为了解决此类情况，谷歌提出了【早期重传】。</p></blockquote><p>按照 RFC5827，ER 有两种形式一种是基于字节的，一种是基于包的，基于包的ER精度要高于基于字节的ER，linux 实现的是基于 TCP 包的 ER，因此我们这里只介绍基于包的ER。</p><p><strong>ER 是在没有新数据可以发送的场景下降低快速重传 dup ACK的门限</strong> ，dup ACK 是由乱序 TCP 报文触发的，但是发出的总数据包的个数少于 4 个的时候，就会因为没有足够的 dup ACK 而不能触发快速重传(假设默认 dup ACK 门限是 3)。<strong>当同时出现下面两个条件时，启用ER：</strong></p><ol><li>发出去的但是还没有收到ACK确认的TCP报文个数 (oseg) 小于 4。</li><li><u>缓存中没有未发送数据或者发送窗口受限不能发送新数据</u> （如果允许发送新数据的话就可以进一步触发 dup ACK 来达到门限了。）</li></ol><p>当满足上面两个条件时候，如果这个 TCP 未使能 SACK 的时候，用来触发 ER 的 dup ACK 门限必须降低为 <code>ER_thresh = oseg - 1</code> ；当这个 TCP 连接 SACK 的时候，触发 ER 的条件则变为，<code>(oseg-1) 个TCP包已经被 SACK 确认</code> 。</p><blockquote><p><strong>最好启用 SACK ，原因如下：</strong></p><p>假设发送 1，2，3 个包，第 1，3 个包顺利到达，第 2 个包丢失，此时可能有以下两种情况：</p><ol><li>第 1 个包被接收到时延迟确认，当收到第 3 个包时，必须发送 ACK=2  包（延迟确认机制最多只能延迟一个包）。那么此时如果未开启 SACK ，发送发就会收到一个正常的 ACK，而不是 dup ACK 。这样一个 dup ACK 都没有收到过，所以也就不会触发ER机制，而只能靠RTO超时来进行重传(而且S2和S3都要重传)；如果开启了 SACK，则发送方知道第 1，3 个包已经被收到，于是确认（SACKED）这两个包，并启用 ER 发送第 2 个包。</li><li>第 1 个包被收到时直接返回确认，则都会开启 ER 。</li></ol></blockquote><blockquote><p>参考文章：<a href="https://www.cnblogs.com/lshs/p/6038527.html">重传次数到底怎么定？</a> ，<a href="https://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/">早期重传</a> ，<a href="http://www.52im.net/thread-513-1-1.html">TCP详解</a> ，<a href="https://www.cnblogs.com/lshs/p/6038575.html">TCP 20</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP握手优化:T/TCP与TFO</title>
      <link href="/2022/08/05/TCP-Fast-Open-TFO/"/>
      <url>/2022/08/05/TCP-Fast-Open-TFO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>当前 web 和 web-like 应用中一般都是在三次握手后开始数据传输，相比于 UDP，多了一个 RTT 的时延，即使当前很多应用使用 <strong>长连接</strong> 来处理这种情况，但是仍然有一定比例的 <strong><u>短连接</u></strong> ，这额外多出的一个 RTT 仍然对应用的时延有非常大的影响。T/TCP 和 TFO 就是在这种背景下面提出来的。<br>点击此处：<a href="https://cloud.tencent.com/developer/article/1640430">什么是短链接与长连接？</a></p></blockquote><h3 id="font-color-red-什么是-T-TCP？-font"><font color='red'>什么是 T/TCP？</font></h3><p>T/TCP 是基于事务的 TCP，“事务” 是指类似与 http 和 DNS 这类连接持续很短的请求-回复型应用。对于这类应用，往往客户端只会发送一次数据请求，然后服务器回复一次请求，然后连接就结束了。而建立连接的过程就需要三次握手，由此看来，一般 TCP 对于这类事务的数据传送效率是很低的。T/TCP 就是为了解决这个问题而被提出——直接在 SYN 报文中传递数据。T/TCP 能够把 SYN 、FIN、SYN 合并到一个报文中（前提是数据量必须小于 MSS），从而完成一次对话只需要三次传递：<br><img src="/2022/img/IMG_0578(20230406-153450).PNG" alt=""><br>不过，由于将 SYN 和数据合并发送存在极大的安全隐患，所以这种方式并未得到推广，大多数操作系统也并不支持。因此本文就不对 T/TCP 进行展开了，详细内容可参考《UNP》P321 。</p><h3 id="font-color-red-什么是-TFO？-font"><font color='red'>什么是 TFO？</font></h3><p>TFO 的 cookie 机制修补了 T/TCP 的安全漏洞，<strong><u><font color='gree'>但必须先进行一次完整的 TCP 三次握手</font></u></strong> ，<u><strong>后续一定时间内的握手则能够合并 SYN 和数据</strong></u> ，如下：</p><img src="/2022/img/e8b8def71ea7471dac12535fe1068790tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="对比图" style="zoom:67%;" /><p>说明：TCP 第三次握手发送的 ACK 报文可以携带数据，所以当客户端收到 HTTP Response 前需要两个来回（RTT），而在 TFP 第二次及以后的请求中，只需要一个来回（RTT）就可收到数据。</p><p>尽管 <a href="https://switch-router.gitee.io/blog/tcp-fastopen/(https://tools.ietf.org/html/rfc793)">RFC793</a> 并没有禁止 SYN 报文携带数据，<u>但所有的 TCP 实现默认都不会使用</u> 。原因是这不太安全，站在 Server 的角度，收到这样一个 SYN 报文，但这个时候 TCP 握手还没完成呢，对端真的可信吗？说不定是一个伪造源端的 TCP 报文，稳妥起见，这个数据报文还是等握手完成之后再上送给应用吧。<u><strong>这就是 TCP Fast Open 的来源，它允许在第一个握手的 SYN 报文中携带数据，如此以来，短连接便可以节省一次来回的 RTT。</strong></u> 即使 Web 浏览器之类的应用程序尝试使用HTTP 长连接来缓解此问题，即浏览器保持与 Web 服务器的连接，并将该连接重用于以后的 HTTP 请求。但是，这种技术的有效性会降低，因为空闲连接可能会在它们被重用之前关闭。<u>例如，为了限制资源使用，繁忙的 Web 服务器通常会主动关闭空闲的 HTTP 连接。</u></p><h3 id="font-color-red-TFO过程-font"><font color='red'>TFO过程</font></h3><ol><li><strong>在使用 TFO 之前，client 首先需要通过一个普通的三次握手连接获取</strong> <strong>FOC</strong> (Fast Open Cookie)<ul><li>1.client 发送一个带有 Fast Open 选项的SYN包，同时携带一个空的 cookie 域来请求一个 cookie</li><li>2.server 产生一个 cookie，然后通过 SYN-ACK 包的 Fast Open 选项来返回给 client</li><li>3.client 缓存这个 cookie 以备将来使用 TFO 连接的时候使用</li></ul></li><li>执行 TFO<ul><li>1.client 发送一个带有数据的 SYN 包，同时在 Fast Open 选项中携带之前通过正常连接获取的 cookie</li><li>2.server 验证这个 cookie。如果这个 cookie 是有效的，server 会返回 SYN-ACK 报文，然后这个 server 把接收到的数据传递给应用层。如果这个 cookie是无效的，server 会丢掉 SYN 包中的数据，同时返回一个 SYN-ACK 包来确认 SYN 包中的系列号。</li><li>4.client 发送ACK包来确认 server 的 SYN 和数据，如果 client 端 SYN 包中的数据没有被服务器确认，client 会在这个 ACK 包中重传对应的数据。</li><li>4.剩下的连接处理就类似正常的 TCP 连接了，client 一旦获取到 FOC，可以重复 Fast Open 直到 cookie 过期。</li></ul></li></ol><h3 id="font-color-red-代码示范-font"><font color='red'>代码示范</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock_listen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> qlen = <span class="number">0</span>;</span><br><span class="line">    setsockopt(sock_listen, SOL_TCP, TCP_FASTOPEN, &amp;qlen, <span class="keyword">sizeof</span>(qlen));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    bind(sock_listen, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    listen(sock_listen, <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> sock_conn = accept(sock_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//处理数据</span></span><br><span class="line">    close(sock_conn);</span><br><span class="line">    close(sock_listen);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span></span><br><span class="line">    bzero(&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.248.128&quot;</span>);</span><br><span class="line">    addr_serv.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    addr_serv.sin_family = AF_INET;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    sendto(sock, buf, <span class="keyword">sizeof</span>(buf), MSG_FASTOPEN, (<span class="keyword">struct</span> sockaddr*)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv));</span><br><span class="line">    <span class="comment">//other things</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意包含的头文件 &lt;netinet/tcp.h&gt;</p></li><li><p>第 6 行的 qlen 用来指定 TFO 的半连接队列大小，这是为了避免 TFO 请求过多而资源耗尽，原因和普通三次握手的半连接队列相同。</p></li><li><p>第 7 行，设置 qlen 和 TCP_FASTOPEN。</p></li><li><p>第 33 行，如果客户端想将数据和 SYN 合并，就必须使用 sendto 函数，且指定 MSG_FASTOPEN。</p><blockquote><p>sendto() 一般用于 UDP。</p></blockquote></li></ul><p>注意，<strong><u>TFO 功能需要在 TCP 通信的双方都启用时才会生效</u></strong> ，除了上面代码层面上实现 TFO，<strong>还需要在操作系统层面上开启此功能</strong> ，方法如下：</p><p>修改系统变量：<code>/proc/sys/net/ipv4/tcp_fastopen</code> ，该变量有三个值：</p><ul><li><p>tcp_fastopen = 1</p><p>允许客户请求 cookie</p></li><li><p>tcp_fastopen = 2</p><p>允许服务器生成 cookie</p></li><li><p>tcp_fastopen = 3</p><p>运行本机请求和生成 cookie</p></li></ul><blockquote><p>如果服务器和客户不在一台主机，那么对于服务器主机而言，开启 2 即可；对于客户端，开启 1 即可。下面的实验中，服务器和客户在一台主机，所以需要开启 3 。</p></blockquote><h3 id="font-color-red-wireshark抓包实验-font"><font color='red'>wireshark抓包实验</font></h3><p><img src="/2022/img/image-20230406171933277.png" alt=""></p><p>看，第一次连接时是正常的 TCP 三次握手；然后客户断开连接（红色），重连，可看到第二次连接时，SYN 报文中携带有 1000 字节的数据。</p><p>另外在 TFO 场景下，关闭连接时第三次挥手直接发送 RST，读者可以试试。</p><h3 id="font-color-red-注意事项：-font"><font color='red'>注意事项：</font></h3><p><strong><mark class="hl-label blue">Cookie 的格式：</mark> </strong></p><p>Cookie 通过 TCP 的选项(Kind = 34)在 TCP 双方之间交互，其格式如下。它的值由 Server 根据 &lt;ClinetIP、ServerIP&gt; 生成。注意，<strong>Cookie 与 TCP 端口号无关</strong> ，即使应用程序不同，<strong><font color='gree'>只要 Client 和 Server 使用的 IP 不变，两台主机上的 TCP 程序就可以复用一个 Cookie</font></strong> ，换句话说，这个 Cookie 是主机粒度的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">                                |      Kind     |    Length     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">~                            Cookie                             ~</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">Kind            1 byte: value = 34</span><br><span class="line">Length          1 byte: range 6 to 18 (bytes); limited by</span><br><span class="line">                        remaining space in the options field.</span><br><span class="line">                        The number MUST be even.</span><br><span class="line">Cookie          0, or 4 to 16 bytes (Length - 2)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label default">TFO 不保证幂等性</mark> </strong></p><blockquote><p><strong>什么是幂等性？</strong></p><p><strong>幂等</strong> 是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。在 TCP 中，幂等性可以指对重复包的丢弃。</p></blockquote><p>虽然 TCP 保证重复数据包(重复经常发生)会被接受者忽略，但是 <strong>这个保证并不适用于连接的握手过程</strong> 。在 TFO 下随着 SYN 发送的数据有可能重复递交到应用层。例如在 IP 层不可靠传输的情况下，发送端的一个 SYN 包被传输成了两个 SYN 包，而在接收端，接收到第一个SYN包后，接收端把随SYN的数据传递到应用层，然后继续收到第二个重复包则可能再次将随 SYN 传输的数据再次传向应用层。<u><strong>因此如果应用层不能忍受这种包重复，则不能开启TFO特性。</strong></u></p><blockquote><p>换句话说，如果开启了 TFO，应用层就必须自己处理重复 SYN 带来重复数据。</p></blockquote><blockquote><p>参考文章：<a href="https://lwn.net/Articles/508865/">TCP Fast Open</a> ，<a href="https://toutiao.io/posts/1580/app_preview">移动网络性能解密</a> ，<a href="https://lwn.net/Articles/508865/">TFO详解</a> ，<a href="https://switch-router.gitee.io/blog/tcp-fastopen/">TFO</a>，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTT的测量（RTTM）</title>
      <link href="/2022/08/05/RTT%E7%9A%84%E6%B5%8B%E9%87%8F/"/>
      <url>/2022/08/05/RTT%E7%9A%84%E6%B5%8B%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>我们直到，重传机制是 TCP 协议中一种重要的通信保障手段。在超时重传下，当重传计时器超过 RTO (Retransmission Time Out) 时就会终止计时器并重发。而其中 RTO 是基于 RTT （Round-Trip Time）得到的，那么 RTT 又是如何得到的呢？似乎看起来很简单，好像就是在发送端发包时记下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，接收到 ACK 报时再记一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，于是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mtext>–</mtext><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">RTT = T_1 – T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  。没那么简单，这只是一个采样，不能代表普遍情况。</p></blockquote><h4 id="font-color-red-Jacobson-Karels-算法-font"><font color='red'>Jacobson / Karels 算法</font></h4><ol><li><p>我们需要采样一些 RTT，称为 <strong>SampleRTT</strong> 。需要注意， SampleRTT 与单个分组没有一一对应的关系，由于 <strong>延迟确认</strong> 的存在，两个确认可能合并为一个 ACK 包。SampleRTT 可能随网络情况而波动，任何值都可能是不典型的，所以直接使用 SampleRTT 是不可靠的。</p></li><li><p>为了估计一个典型的 RTT，自然想到对 SampleRTT 求平均（加权平均），得到<strong>平滑RTT（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">RTT_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</strong> ，计算方法如下：<br><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mi>α</mi><mo>×</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_S = (1 - α)RTT_S+α×SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></strong></p><p>其中 α 取决于实现，一般为 0.125</p></li><li><p>另外，还需要引入 RTT偏差（DeviationRTT），即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTT_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，其计算依赖于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">RTT_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 SampleRTT：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>β</mi><mo>×</mo><mi mathvariant="normal">∣</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>−</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">RTT_D=(1-β)×RTT_D+β×|RTT_S-SampleRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mord">∣</span></span></span></span></p><p>其中 β 取决于实现，一般为 0.25</p></li><li><p>最后根据 RTT 计算 RTO：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mn>4</mn><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTO=RTT_S+4×RTT_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RTO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li></ol><p>上面的叙述为了流畅性省略了一些内容，下面是全过程：</p><img src="/2022/img/IMG_0439(20220805-181810).PNG" alt="RTO计算过程" style="zoom: 50%;" /><p>下面给出一个例子：当 <code>SNY+ACK</code> 段传来时，SampleRTT 被测量为 1.5 秒，计算 RTO：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">SampleRTT=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">RTT_S=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mn>1.5</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>0.75</mn></mrow><annotation encoding="application/x-tex">RTT_D=1.5/2=0.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1.5/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mn>1.5</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>0.75</mn></mrow><annotation encoding="application/x-tex">RTO=1.5+4×0.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RTO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span></span></span></span></li></ol><blockquote><p>平均 RTT 一般定为 0.25 秒；同时需要注意，<strong>RTT 指的是传播时延而非传输时延</strong> ；<code>RFC 6298</code> 推荐的初始 RTO 为 1 秒。</p></blockquote><h4 id="font-color-red-Karn算法-font"><font color='red'>Karn算法</font></h4><p>重传计时器超时会重发报文。而上面的这个算法对于重传会遇到这样一个问题：当发送方收到来自接收方的 ACK 段时，如何判别这个段是第一次发的还是重传的？即使知道，也会面临如下问题：你是用第一次发数据的时间和 ACK 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？</p><img src="/2022/img/101017ipbtj3eijbtmj2j2.jpg" alt="示意图" style="zoom:67%;" /><ul><li>情况（a）是 ACK 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li><li>情况（b）是 ACK 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li></ul><p>而 <strong>Karn</strong> 算法简单粗暴地解决了此问题——<u>当需要重传时，则不采用此报文来测量 RTT，等到发送方不需要重发某个段时，再进行采样</u> 。但是，这样一来，又会引发一个新问题——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重传所有的包。由于重转的不采样，RTO 就不会被更新，这导致网络实时状况被发送端忽略（发送方就无法合理调整后续发送行为），可能加重网络拥塞。<strong>Karn</strong> 算法据此提出 <strong><font color='orange'>指数回退</font></strong> ，当发生重传时，则 RTO 翻倍。例如重传一次后 RTO = 2 s，还未收到，再重传一次，RTO = 4 s …<br><strong>即，Karn 算法规定两点：1）碰上重传则不采样；2）碰上重传则 RTO 翻倍。</strong></p><h4 id="font-color-red-时间戳测量RTT-font"><font color='red'>时间戳测量RTT</font></h4><p>详解笔者的另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/04/tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">时间戳RTTM</a></p><blockquote><p>文章参考：《计算机网络自顶向下第六版》 ，《计算机自顶向下第七版》 ，<a href="https://www.cnblogs.com/lshs/p/6038536.html">TCP 14</a> ，<a href="http://www.52im.net/thread-515-1-1.html">即时通讯网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间戳——RTTM与序列号回绕</title>
      <link href="/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="font-color-red-时间戳格式-font"><font color='red'>时间戳格式</font></h4><p>时间戳（TimeStamp—TSOPT）选项格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           Kind: 8</span></span><br><span class="line"><span class="comment">//         Length: 10 bytes</span></span><br><span class="line"><span class="comment">//          +-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="comment">//          |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|</span></span><br><span class="line"><span class="comment">//          +-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="comment">//              1       1              4                     4</span></span><br></pre></td></tr></table></figure><p><code>TSval</code> 表示发送端发出该报文时的本地时间戳， 而 <code>TSecr</code> 则负责回放 (Echo) 最近一次收到的对端报文中的 <code>TSval</code> 的值。下面是一组典型的时间戳交互过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                   TCP  A                               TCP B</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;A,TSval=1,TSecr=120&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(A),TSval=127,TSecr=1&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;B,TSval=5,TSecr=127&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(B),TSval=131,TSecr=5&gt;</span></span><br></pre></td></tr></table></figure><p>启用 Timestamp 选项需要经过双方的协商，<u>协商在三次握手时完成</u> ，<font color='orange'>如果协商成功,则在后续的报文中， 除了 RST 之外的所有报文均必须包含 Timestamp 选项，若未协商成功，即使后续报文有 Timestamp 选项也一并忽略。</font></p><h4 id="font-color-red-时间戳作用-font"><font color='red'>时间戳作用</font></h4><p>在RFC1323中，TSOPT主要有两个用途一个是 <strong>RTTM</strong>  (round-trip time measurement)即根据 ACK 报文中的这个选项测量往返时延，另外一个用途是 <strong>PAWS</strong>  (protect against wrapped sequence numbers)，即防止同一个连接的系列号重叠。另外还有一些其他的用途，如 SYN-cookie、 Eifel Detection Algorithm 等等。下面详述前两个用途。</p><h5 id="font-color-orange-RTTM-font"><font color='orange'>RTTM</font></h5><blockquote><p>对此，时间戳不能走得太慢，这是为了能更准确地测量报文的 RTT。假设这个时钟 10s 才 tick 一下，那么对于 往返时间为 1s 的 TCP 连接，一端发送报文之后，很有可能会发现收到对端的 ACK 报文中的 TSecr 和当前时钟 的值是一样的，这说明 RTT 为 0 ! 显然，这是十分荒谬的。需要说明的是，RTT 的测量不需要时间戳也能进行，只是使用时间戳可以解决 RTTM 中某些棘手的问题（区分重传报），参见另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">RTT的测量</a></p></blockquote><p><strong><mark class="hl-label blue">TSOPT如何测量RTT？</mark> </strong></p><p>一般而言，客户端和服务端会互发数据和确认，但此处为了更清楚地说明问题，我们只考虑客户端发送数据，服务端回应 ACK 报文。于是有以下过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           客户端 A                               服务端 B</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;A,TSval=1&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(A),TSecr=1&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;B,TSval=5&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(B),TSecr=5&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端如此测量 RTT</strong> ：将本端此刻时间戳填入 TSOPT 选项中的 TSval 部分，并发送报文 A ；服务端接收到报文 A 后，将 TSval 部分的值放入 ACK 报中的 TSecr 部分并发送；客户端接收到 ACK 报文后取出 TSecr ，并将此刻时间戳减去 TSecr ，即得到 RTT 。通常情况下，发送 ACK 报文时只需要无脑填入对端上一个报文的 TSval 就行了，但有几种特殊场景需要注意：</p><ol><li><p><strong>Delay ACK（延迟确认）：</strong></p><blockquote><p>延迟确认有两大好处：1.减少网络中 ACK 包的数量（<u>最多延迟一个包</u> ），以减小网络拥塞；2.如果接收端刚好也有数据发送，则可以将数据和 ACK一起发送（数据捎带确认），减少了 pure ACK 的数量。</p></blockquote><p>如果启用了 Delay ACK, 并且接收端收到了多个报文，这些报文的 TSval 不同，那么应该 Echo 哪一个报文的 TSval 呢?答案是：<strong>需要 Echo 最早收到的那个报文的 TSval</strong>  , 因为只有这样，发送端测量的 RTT 才更加准确（更保守）。<u>本地会维护一个 TS.recent 变量，其用来保存下一个填入 TSecr 的时间戳,当需要发送报文时，报文的 TSecr 始终从当前 TS.Recent 获得。</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟确认下：                                       TS.Recent   </span></span><br><span class="line"><span class="comment">//              &lt;A, TSval=1&gt; -------------------&gt;     1      </span></span><br><span class="line"><span class="comment">//                                                    </span></span><br><span class="line"><span class="comment">//              &lt;B, TSval=2&gt; -------------------&gt;     1      </span></span><br><span class="line"><span class="comment">//                                                     </span></span><br><span class="line"><span class="comment">//                       &lt;---- &lt;ACK(B), TSecr=1&gt;      1      </span></span><br><span class="line"><span class="comment">//可见，echo的是最早发送的报文</span></span><br></pre></td></tr></table></figure></li><li><p><strong>乱序或丢失：</strong></p><p>发送端发送了多个报文，但中间有报文出现了丢失或者乱序，这会使得接收端的窗口产生<strong>空洞</strong> (即在未收到序号较小的报文时，先收到序号较大的报文)。这种情况可能预示着链路发生了拥塞，因此，此时也会让接收方 Echo 稍早时候的 TSval ，而不是序号最大报文的 TSval , 这样使得发送端估算的 RTT 能偏大，也就是发送报文更保守，有利于减小拥塞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送顺序：A-&gt;B-&gt;C-&gt;D-&gt;E</span></span><br><span class="line"><span class="comment">接受顺序：</span></span><br><span class="line"><span class="comment">                                         TS.Recent   </span></span><br><span class="line"><span class="comment">       &lt;A, TSval=1&gt; -------------------&gt;    1       </span></span><br><span class="line"><span class="comment">                                                     </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(A), TSecr=1&gt;1       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;C, TSval=3&gt; -------------------&gt;1       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(A), TSecr=1&gt;1    </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;B, TSval=2&gt; -------------------&gt;1-&gt;2    </span></span><br><span class="line"><span class="comment">                                                   </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(C), TSecr=2&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;E, TSval=5&gt; -------------------&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(C), TSecr=2&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;D, TSval=4&gt; -------------------&gt;2-&gt;4    </span></span><br><span class="line"><span class="comment">                                                   </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(E), TSecr=4&gt;4                                                       </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意第 11 行，ACK 报文中的 TSecr = 1 而不是 3 ，原因是：1.使 RTT 偏大，保守计算；2.如果发送 3 ，则 TS.Recent 改为 3 ，那么接收到 B 包时，会计算<code>TSecr = 2 &lt; TS.Recent = 3</code> ，从而判断 B 是历史报文而导致错误丢弃。</p></li></ol><h5 id="font-color-orange-PAWS-font"><font color='orange'>PAWS</font></h5><blockquote><p>由于序号占 32 位，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，即最大 4 个 GB 。在一般网络下（假定 1 MB /S），那么循环一圈序列号所花费的时间约为 1.19 小时，而 <code>MSL</code> （报文最大生存时间）为 30 秒（Linux），所以一般情况下即使是发生序列号回绕也不会接收到历史报文。但在高速网络（千兆网）下，可能循环一圈只需要十几秒甚至几秒，此时网络中的历史报文就有较大概率落入新连接的窗口（窗口最大 1 GB），从而造成数据错乱。由此，还需要引入 <strong>时间戳</strong> 来解决此问题。</p></blockquote><p>举个例子，假设发送端的序号从 1 开始计数，此时已经发送了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>+</mo><mn>4999</mn></mrow><annotation encoding="application/x-tex">2^{32}+4999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4999</span></span></span></span> 字节的数据，当前接收端的 <code>RCV.NXT = 5000</code>, <code>TS.Recent = 100</code> , 如果收到一个报文 <code>Seq = 5000</code> , <code>LEN = 1000</code> , <code>TSval=70</code>  如果不看时间戳，那么接收端会认为这个报文正好是预期的报文，但是这个报文实际上却是第 5000 ~ 5999 字节的报文；而有了时间戳，之间根据 <code>TSval &lt; TS.Resent</code> 就可判断此报文已过期。</p><p><strong><mark class="hl-label blue">时间戳的时间部分占32位，不也会用完并回绕吗？</mark> </strong></p><p>是的，时间戳也会回绕，不过需要时间戳是以时间为驱动进行增长（1ms，实现不同），而序列号是以字节为驱动进行增长。按照 1ms 的时间戳时钟计算，32-bit 的时间戳回绕一次的周期是 24.8 天， 而实际上连接实际不会这么长，所以远不用担心时间戳回绕。</p><p><strong><mark class="hl-label blue">时间戳还有什么作用？</mark> </strong></p><ol><li>当开启时间戳后，即使在 <code>TIME-WAIT</code> 状态下也允许建立连接。参考 <a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html">此处</a></li><li>时间戳可以用于 SYN Cookie 中。参考 <a href="https://jyxcpp.netlify.app/2022/08/04/syn%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">此处</a></li><li>RACK 重传</li><li>Eifel 探测算法</li></ol><blockquote><p>文章参考：<a href="https://www.cnblogs.com/lshs/p/6038494.html">TCP 08</a> ，<a href="https://switch-router.gitee.io/blog/tcp-timestamp/">时间戳那点事</a> ，<a href="https://switch-router.gitee.io/blog/TCP-SYN-Cookies/">SYN Cookie</a> ，<a href="https://blog.51cto.com/u_9164120/3289669">RTT</a>  ，<a href="https://www.gingerdoc.com/tcp-seq-and-loop">序列号回环</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYN泛洪攻击</title>
      <link href="/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">什么是 SYN 泛洪攻击？</mark> </strong></p><p>SYN 洪水（半开连接攻击）是一种<u>拒绝服务 (DDoS) 攻击</u> ，旨在耗尽可用服务器资源，致使服务器无法传输合法流量。通过 TCP 三次握手时，重复发送初始连接请求 (SYN) 数据包，攻击者将占满目标服务器上的所有 <strong>半连接队列</strong> ，导致服务器在响应合法流量时表现迟钝乃至全无响应。</p><p><strong><mark class="hl-label blue">SYN 泛洪攻击原理？</mark> </strong></p><ol><li>攻击者通常使用伪造的不同的 IP 地址向目标服务器发送大量 <code>SYN</code> 数据包。</li><li>然后，服务器分别对每一项连接请求做出响应（发送 <code>ACK+SYN</code> 包），并确保打开的端口做好接收响应的准备。</li><li>在服务器等待最后一个 <code>ACK</code> 数据包（永远不会到达）的过程中，攻击者将继续发送更多 <code>SYN</code> 数据包，久而久之就会占满服务端各个端口的 <strong>半连接队列</strong> ，使得服务器不能为正常用户服务。</li></ol><p><strong><mark class="hl-label blue">半连接队列与全连接队列</mark> </strong></p><p>正常流程：</p><ul><li>当服务端接收到客户端的 <code>SYN</code> 报文时，会将其加入到内核的 <strong>SYN 队列（半连接队列）</strong> ；</li><li>接着发送 <code>SYN + ACK</code> 给客户端，等待客户端回应 <code>ACK</code> 报文；</li><li>服务端接收到 <code>ACK</code> 报文后，从 SYN 队列移除放入到 <strong>Accept 队列（全连接队列）</strong> ；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从 Accept 队列取出连接。</li></ul><img src="/2022/img/3d05f574867b70d1134e685e5f5ac137.jpg" alt="示意图" style="zoom:50%;" /><p>而在 SYN 泛洪攻击下，SYN 队列将不断接收攻击者发送的 SYN 包直到队列溢出，这种情况下，正常用户发送的连接请求也会被延迟或者拒绝。</p><p><strong><mark class="hl-label blue">SYN-Cookie原理</mark> </strong></p><p><strong><font color='orange'><code>Syn-Flood</code> 攻击成立的关键在于服务器资源是有限的，而服务器收到请求会分配资源</font></strong> 。通常来说，服务器用这些资源保存此次请求的关键信息，包括请求五元组，以及 TCP 选项，如 <code>MSS</code> 、<code>timestamp</code> 、<code>Sack</code>、<code>Wscale</code> 等等。当后续的 <code>ACK</code> 报文到达，三次握手完成，新的连接创建，这些信息才会被复制到连接结构中，用来指导后续的报文收发。</p><p>那么现在的问题就是服务器 <strong><font color='orange'>如何在不分配资源的情况下</font></strong></p><ul><li><p><strong>验证之后可能到达的 <code>ACK</code> 的有效性，保证这是一次完整的握手</strong></p></li><li><p><strong>保存 <code>SYN</code> 报文中携带的 TCP 选项信息</strong></p></li></ul><blockquote><p><strong>前两次握手本质上就是双方协商 TCP 状态的过程，有些状态的协商只会出现在前两次握手，比如 <code>MSS</code> 和 <code>WSOPT</code> ，且此后都不会再改变。因此，本端必须解析对端发来的 SYN 报文才能知道对方的 TCP 状态。</strong></p></blockquote><p><strong>下面来看 SYN-cookie 是如何在不分配资源的前提下做到以上两点的。</strong></p><p><strong><font color='orange'>TCP 连接建立时，双方的起始报文序号是可以任意的，既然是任意的，那么为什么不利用它来保存对端的 TCP 信息呢？</font></strong> 这是 <code>SYN cookies</code> 最核心的一点，因此<u>服务器端</u>按照以下规则构造初始序列号：</p><ul><li>设 <code>t</code> 为一个缓慢增长的时间戳(典型实现是每64s递增一次)</li><li>设 <code>m</code> 为客户端发送的 <code>SYN</code> 报文中的 <code>MSS</code> 选项值</li><li>设 <code>s</code> 是连接的四元组信息和 <code>t</code> 经过密码学运算后的 <code>Hash</code> 值，即 <code>s = hash(sip,dip,sport,dport,t)</code> ，<code>s</code> 的结果取低 <strong>24</strong> 位。</li></ul><p>则初始序列号 <code>n</code> 为：</p><ul><li>高 <strong>5</strong> 位为 <code>t mod 32</code></li><li>接下来<strong>3</strong>位为 <code>m</code> 的编码值</li><li>低 <strong>24</strong> 位为 <code>s</code></li></ul><blockquote><p>这样就将本次连接的状态信息保存到了 SYN+ACK 报文中，而不是另外在服务器内部开辟资源来保存。</p></blockquote><p><strong>当客户端收到此 <code>SYN+ACK</code> 报文后，它会回复 <code>ACK</code> 报文，且报文中 <code>ack = n + 1</code> ，那么在服务器收到它时，将<code>ack - 1</code> 就可以拿回当初发送的 <code>SYN+ACK</code> 报文中的序号了！</strong> 服务器通过这种方式巧妙、间接地保存了一部分客户端 <code>SYN</code> 报文的信息。接下来，服务器需要对 <code>ack - 1</code> 这个序号进行检查：</p><ul><li>将高 <strong>5</strong> 位表示的 <code>t</code> 与当前之间比较，看其到达的时间是否能接受。</li><li>根据 <code>t</code> 和连接元组重新计算 <code>s</code> ，看是否和低 <strong>24</strong> 一致，若不一致，说明这个报文是被伪造的。</li><li>解码序号中隐藏的 <code>mss</code> 信息</li></ul><p>到此，连接就可以顺利建立了。</p><p>所以，<strong><font color='gree'>SYN Cookies 的核心在于：可以在不使用 SYN 半连接队列的情况下成功建立连接</font></strong>  ：<br><img src="/2022/img/39-1679303729834-1.jpg" alt=""></p><blockquote><p>如果服务器和客户端 <strong>都</strong> 打开了时间戳选项，那么服务器可以将客户端在 <code>SYN</code> 报文中携带的 TCP 选项的信息暂时保存在时间戳中。</p></blockquote><p><strong><mark class="hl-label blue">如何预防 SYN 泛洪</mark> </strong></p><p><strong><font color='orange'>修改 Linux 内核参数</font></strong></p><ul><li><p><strong>增大半连接队列</strong><br>内容较多，不在此阐述，详细方法请移步本系列另一篇文章-<a href="https://jyx-fyh.github.io/2023/03/20/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/">全连接与半连接队列</a></p></li><li><p><strong>开启 SYN-Cookie</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><blockquote><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul></blockquote></li><li><p><strong>减少 SYN+ACK 重传次数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将重传次数设为1次</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>笔者操作系统上默认为 5 次。<br><img src="/2022/img/image-20230320172721725.png" alt=""></p></li></ul><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000019292140">深入浅出TCP中的SYN-Cookies</a> ，<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">小林coding</a> ，<a href="https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/">cloudflare</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析TCP三握四挥</title>
      <link href="/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>TCP 协议是 <strong>面向连接</strong> 的协议，通信前需要先在双端建立 <strong>逻辑信道</strong> ，即使是断开连接也不能说断就断，还需双方同意。所以下面我们详细说明 TCP 的连接管理。</p></blockquote><p>在TCP的连接建立过程中一般需要处理下面三个问题</p><ol><li>要使每一方能够确知对方的存在。</li><li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</li><li>能够对传输实体资源（如缓存大小等）进行分配</li></ol><p>TCP建立连接最常见的方式就是通过<strong>三次握手(three-way handshake)</strong> ，连接释放最常见的方式则是 <strong>四次挥手(four-way handshake)</strong> ，下面我们先介绍这两种最常见的连接管理机制。</p><h3 id="font-color-red-三次握手-font"><font color='red'>三次握手</font></h3><p><img src="/2022/img/image-20230408100933808.png" alt=""></p><ol><li>客户端会随机初始化序号（client_ISN），将此序号置于 TCP 首部的 <code>序号</code> 字段中，同时把 <code>SYN</code> 标志位置为 1 ，表示 <code>SYN</code> 报文。接着把第一个 <code>SYN</code> 报文发送给服务端，表示向服务端发起连接，<strong><u><font color='orange'>该报文不包含应用层数据</font></u></strong> ，之后客户端处于 <mark class="hl-label default">SYN-SENT</mark>  状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的 <code>序号</code> 字段中，其次把 TCP 首部的 <code>确认应答号</code> 字段填入 client_isn + 1 , 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为  1 ，同时写入 <code>rwnd</code> ，以告知对方自己的窗口大小。最后把该报文发给客户端，<strong><u><font color='orange'>该报文也不包含应用层数据</font></u></strong> ，之后服务端处于 <mark class="hl-label default">SYN-RCVD</mark>  状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 1 ，其次 <code>确认应答号</code> 字段填入 server_isn + 1 ，最后把报文发送给服务端。<strong><u><font color='orange'>这次报文可以携带客户到服务器的数据</font></u></strong> ，之后客户端处于 <mark class="hl-label default">ESTABLISHED</mark>  状态。</li><li>服务器收到客户端的应答报文后，也进入 <mark class="hl-label default">ESTABLISHED</mark>  状态。之后双方便可进行通信。</li></ol><blockquote><p><strong><font color=#FF00FF> <code>SYN</code> 和 <code>SYN+ACK</code> 段不携带数据，所以不消耗序列，<code>ACK</code> 段可携带数据，若携带数据，则消耗序列</font></strong> ，而 <strong>TFO</strong> 可以在前两次交换数据，参考<a href="">此处</a></p><p>三次握手之前的连接都称之为 <strong>半连接</strong> 。</p></blockquote><blockquote><p><strong><font color=#3b8dfe>ISN 为什么要随机？</font></strong></p><ol><li><p><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong></p><p>四元组唯一标识一个 TCP 连接，当一个 TCP 连接在经历四次挥手关闭时，假如有一个数据包延迟特别大，而这个连接在关闭后又马上以相同的四元组建立起来，那么先前这个连接的 TCP 数据包到达的时候，大概率系列号还落在接收窗内，那么这个数据包就可能会被错误接收。因此 RFC0793 指出 ISN 应该每 4μs 自增 1，从而防止同一个连接的不同实例的数据包混淆。<br><code>ISN = M + F(localhost, localport, remotehost, remoteport)</code></p><ul><li><p><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</p></li><li><p><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。若四元组相同，则随机数相同。<a href="!%5Bimg%5D(https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png)">示意图点这里</a></p></li></ul></li><li><p><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong></p><p>TCP 系列号欺骗如下图所示：</p><p><img src="/2022/img/image-20220803170133160.png" alt="示意图"></p><p>假设 A 是服务器，B 是拥有特殊权限的客户端，C 是攻击者。</p><ol><li>第一条消息 C 冒充 B 来向服务器 A 请求建立连接，此时 C 发出的数据包的 IP 地址会填写成 B 的；</li></ol></li><li><p>第二条消息假设 A 没有其他手段来验证 B，而仅仅根据 IP 地址判断 C 发过来的建立连接的请求是 B 发过来的，因此向 B 发送 <code>SYN+ACK</code> ，此时假设 B 被 C 进行了 DOS 攻击或者处于其他异常状态而不能响应第二条消息(如果 B 处于正常状态会响应一个 <code>RST</code> 包来重启 TCP 连接)；</p></li><li><p>第三条消息假如 C 能正确的猜测出 A 在第二条消息中的 ISN，就可以冒充 B 和 A 完成三次握手的过程，让 A 误以为和 B 建立了连接。接下来 C 就可以冒充 B 给 A 发送一些危险数据或者指令而实现攻击。</p></li></ol><p>另外提一句，一些朋友做实验用 wireshark 抓包时会发现 SYN 报文的 ISN 为 0，如下：<br><img src="/2022/img/image-20230409173536342.png" alt=""></p><p>打开条目后就可以看到，这其实是相对序列号，wireshark 为了方便而帮我们生成的：<br><img src="/2022/img/image-20230409173616067.png" alt=""></p></blockquote><p><strong><mark class="hl-label blue">为什么是三次握手？不是两次、四次？</mark> </strong></p><ol><li><p><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></p><p>我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文。</p><img src="/2022/img/image-20220803170152579.png" alt="示意图" style="zoom:67%;" /><p>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接，那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li><li>收到新 SYN 报文后，才重新建立起新连接。</li></ul><p>而两次握手则会直接建立历史连接，服务器可能直接发送数据，造成资源的浪费：</p><img src="/2022/img/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接" style="zoom: 67%;" /></li><li><p><strong>三次握手才可以同步双方的初始序列号</strong></p><p><u>本质而言，TCP 握手握的是通信双方数据原点的序列号</u> ，通过同步双方初始序列号来实现 <strong>双向可靠传输</strong> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  A  --SYN=9        --&gt;  B</span></span><br><span class="line"><span class="comment">//  A  &lt;-SYN=4 ACK=10 --   B</span></span><br><span class="line"><span class="comment">//  A  --      ACK=5  --&gt;  B</span></span><br></pre></td></tr></table></figure><p>两次握手只能实现 A 方和 B 方就 A 方的同步，也就是说，两次握手只能保证 A 到 B 的数据传输是可靠的，反向则无法保证。这就相当于，A -&gt; B是 TCP，而B -&gt; A是 UDP（类比不是很准确）。如果要保证 B 到 A 的数据传输也可靠，则还需要第三次握手。</p></li><li><p><strong>防止资源浪费</strong></p><p>在 SYN 泛洪攻击下，两次握手就建立了连接，而后服务器便向对端发送数据，然而对方压根不会回应，白白造成资源的浪费。</p></li></ol><blockquote><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul></blockquote><h3 id="font-color-red-四次挥手-font"><font color='red'>四次挥手</font></h3><blockquote><p>四次握手是在半关闭场景下进行的断连接操作，还有另一种断开操作只需要三次挥手。</p></blockquote><p><img src="/2022/img/740952-20161107133341092-1088495812.png" alt="半关连接-四次挥手"></p><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong> <u>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</u></li></ol><blockquote><p><strong>半关连接</strong> ：TCP 的半关连接是指 TCP 连接只有一方发送了 <code>FIN</code> ，另一方没有发出 <code>FIN</code> 包，<u><font color='orange'>仍然可以在一个方向上正常发送数据</font></u> 。这种场景并不常见，一般来说调用 shutdown() 接口时候就会进入半关闭状态，调用常规的 close() 一般是期待完整的双向关闭这个 TCP 连接。shutdown() 接口相当指示程序，本端已经没有数据待发送，所以发送一个 <code>FIN</code> 到对端，但是仍然可以从对端接收数据，直到对端发送一个 <code>FIN</code> 指示关闭连接为止，详见后文。<a href="https://www.cnblogs.com/lshs/p/6038468.html">同时关闭参考此处</a></p></blockquote><p><strong><mark class="hl-label blue">断开连接为什么需要四次挥手？</mark> </strong></p><p><u>因为 TCP 是 <strong>全双工协议</strong> ，双方都可以接收和发送数据，所以断开连接时，也需要服务端和客服端都确定对方将不再发送数据。</u></p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，<u>而服务端可能还有数据需要处理和发送</u> ，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p><strong><mark class="hl-label blue">四次挥手可以变成三次吗？</mark> </strong></p><p><font color='pink'>可以。实际上，三次挥手比四次挥手更为常见</font>。 以下情形会转为三次挥手：</p><ul><li><p><font color=#3b8dfe>当接收端收到 <code>FIN</code> 报文时没有需要发送的数据，且开启了延迟确认</font>，则会将 <code>ACK</code> （第二次）和 <code>FIN</code> （第三次）合并发送。</p></li><li><p><font color=#3b8dfe>当接收端收到 <code>FIN</code> 报文时只有少于 MMS 的少量数据，且开启了延迟确认</font>，则会将 <code>ACK</code> 、<code>FIN</code> 报文和数据合并发送。</p></li><li><p>当发送方调用 close() 时，表明自己不再接收和发送数据，之后接收方如果还发送数据，发送方内核会发送 RST 报文强制释放连接，所以此方式比较粗暴，勉强算得上三次挥手。</p><img src="/2022/img/640-16615889860813.png" alt="图片" style="zoom:67%;" /></li></ul><p><strong><mark class="hl-label blue">FIN 报文一定得调用关闭连接的函数，才会发送吗？</mark> </strong></p><p>不一定。如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p><p><strong><mark class="hl-label blue">为什么需要设置 TIME_WAIT ？</mark> </strong></p><ol><li><p><strong><font color='orange'>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</font></strong></p><p>当序列号发生回绕时，就没法直接通过序列号来判断新老报文了。这时，一个历史报文可能刚好落在在同一四元组的新连接下的窗口中，此时窗口就会接收历史报文，从而引起数据错乱。于是，最直接的办法就是 <strong><u>等待网络中的所有包消失</u></strong> ，所以需要设置 <code>TIME_WAIT</code> 。</p><blockquote><p>可以通过 <strong>时间戳</strong> 的方式判断新老报文。详细内容会在其他文章中讲解。</p></blockquote></li><li><p><strong><font color='orange'>保证被动关闭连接的一方，能被正确的关闭；</font></strong></p><p>假设客户端收到服务器的 FIN 后不等待 TIME_WAIT 而直接关闭连接，那么如果最后客户回复的 ACK 丢失，则服务器会超时重发 FIN，此时由于客户端的客户状态已经丢失（因为连接已关闭），所以它将直接回复 RST，从而被服务器解释为异常终止。</p></li></ol><p><strong><mark class="hl-label blue">为什么 TIME_WAIT 等待的时间是 2MSL？</mark> </strong></p><p><strong><u><font color=#FF00FF>因为 2MSL 可以保证网络上所有的历史报文全部消失</font></u></strong> ，参见下图：</p><img src="/2022/img/14f8dc84f7d660ffa06e18a4877707ae.png" alt="示意图" style="zoom: 67%;" /><p>假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失。附带也能够保证上条问题第二点。详细参见：<a href="https://www.zhihu.com/people/noo-40/answers">知乎文章</a> 。</p><blockquote><p><code>MSL</code> 应大于 IP 协议 <code>TTL</code> 换算的时间，RFC793 建议 <code>MSL</code> 设置为 2 分钟，Linux 遵循伯克利习惯设置为 30 s。</p></blockquote><h3 id="font-color-red-握手和挥手的异常处理-font"><font color='red'>握手和挥手的异常处理</font></h3><p>参考本系列另一篇文章：<a href="https://jyx-fyh.github.io/2023/04/15/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/">三握四挥的异常处理</a></p><blockquote><p>文章参考：<br>《计算机网络自顶向下》，《UNP》，<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">小林coding</a> ，<a href="https://www.cnblogs.com/lshs/p/6038477.html">TCP系列五</a> ，<a href="https://www.zhihu.com/people/noo-40/answers">知乎文章</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP概述及报头解析</title>
      <link href="/2022/08/02/TCP%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%8A%A5%E5%A4%B4%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/08/02/TCP%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%8A%A5%E5%A4%B4%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-TCP-特征概述-font"><font color='red'>TCP 特征概述</font></h3><p>TCP 协议在网络 OSI 参考模型中的第四层——传输层，是一个 <strong><font color='red'>面向连接的（connection-oriented）、可靠的（reliable）、字节流式的（byte stream）</font></strong> 传输协议。</p><blockquote><ul><li><strong>面向连接</strong> ：在应用 TCP 协议进行通信之前，双方通常需要通过三次握手来建立 TCP 连接，连接建立后才能进行正常的数据传输。但是同时面向连接的特性给 TCP 带来了复杂的 <strong>连接管理</strong> 以及用于检测连接状态的 <strong>存活检测机制</strong> 。同时，TCP 提供全双工通信。</li><li><strong>可靠性</strong> ：TCP 层需要解决来自 IP 层的四种常见传输错误问题，分别是 <strong>比特错误</strong> (packet bit errors)、<strong>包乱序</strong> (packet reordering)、<strong>包重复</strong> (packet duplication)、<strong>丢包</strong> (packet drops)，TCP要提供可靠的传输，就需要有额外的机制处理这几种错误。TCP 通过使用 <strong>确认</strong> ，<strong>重传</strong> ，<strong>校验和</strong> 这三种基本机制来实现可靠传输。因此TCP协议具有<u>超时与重传管理、窗口管理、流量控制、拥塞控制</u>等功能。</li><li><strong>字节流式</strong> ：应用层发送的数据会在 TCP 的发送端缓存起来，统一分段(例如一个应用层的数据包分成两个TCP包)或者打包(例如多个应用层的数据包打包成一个TCP数据包)发送，到接收端的时候接收端也是直接按照字节流将数据传递给应用层。也就是说，<strong>TCP 的数据流是没有边界的</strong> ，这可能导致粘包。作为对比，同样是传输层的协议，UDP 并不会对应用层的数据包进行打包和分片的操作，一般一个应用层的数据包就对应一个 UDP 包。</li></ul></blockquote><h3 id="font-color-red-报头解析-font"><font color='red'>报头解析</font></h3><img src="/2022/img/IMG_0433(20220803-094417).PNG" alt="报头格式" style="zoom:67%;" /><p>报头大小为 <strong>20 ~ 60 字节</strong> ，若没有 option ，则为 20 字节。下面对图中各部分进行解析。</p><ul><li><p><strong>源端口和目的端口：</strong> 分别用来唯一标识主机和服务器的进程。</p><blockquote><p>源端口、目的端口、以及源 IP 地址、目的 IP 地址统称为 <strong>四元组</strong> ，它唯一的标识了一个 TCP 连接。一个 IP 地址和一个端口号组成 <strong>套接字地址</strong> 。接收端的 TCP 层根据不同的端口号来将数据包传送给应用层的不同程序，这个过程叫做 <strong>解复用</strong> (demultiplex)。相应的发送端会把应用层不同程序的数据映射到不同的端口号，这个过程叫做 <strong>复用</strong> (multiplex)。</p></blockquote></li><li><p><strong>序列号(SN)：</strong>  TCP 为待发送缓冲区中的数据编号，与 ARQ 协议不同，此处<u>是为每个字节进行编号，而不是为段进行编号</u> 。序列号范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</p><blockquote><p>连接时，TCP 在范围内生成一个 <u>随机数</u> 作为 <strong>初始序号（ISN）</strong> ，那么第一个字节的序号应为 ISN + 1 。例如，ISN = 23 ，第一个分组大小为 500，则其序号为 24 ~ 500 ，那么下一个分组就需要从 501 开始编号。当 SYN =1 时，该序列号有效。TCP 通过序列号来判断丢包，重复和失序。</p></blockquote></li><li><p><strong>确认号(ACK)：</strong> 当 ACK 位为 1 时，该确认号有效。接收方通过使用确认号来告知发送方已收到的字节数（或下一次想收到的字节），比如，接收方收到 <code>SN = 54</code> 的分组，然后回复 <code>ACK = 55</code> 的分组来告知发送方我已收到 55 之前的字节（或下一次我想收到 55 开头的字节流）。与 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">GBN</a> 相同，<u>确认号时累积的。</u></p></li><li><p><strong>头部长度：</strong> 表示报头总大小。注意，头部长度仅占 4 bit ，范围为 0 ~ 15 ，而报头大小为 20 ~ 60 bytes，所以头部长度的单位是 4 bytes，也就是说，若头部长度为 11，则报头总大小为 <code>11 × 4 = 44</code> bytes 。</p></li><li><p><strong>保留：</strong> 占 6 位，这些位必须是0。为了将来定义新的用途所保留，其中 RFC3540 将保留字段中的最后一位定义为 Nonce 标志，用于处理拥塞。</p></li><li><p><strong>窗口大小：</strong> 16 位，表明接收端窗口的空闲空间大小，<u>最大的窗口大小为64Kb</u> 。这个值通常被称为 <strong>rwnd</strong> 。注意，它也可以表示为<u>对方必须维持的窗口大小</u> ，因为发送方必须服从接收方的支配。用于流量控制。</p></li><li><p><strong>校验和：</strong> 发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端 checksum 校验失败的时候会直接丢掉这个数据包。CheckSum 是根据 <u>伪头部+TCP头+TCP数据</u> 三部分进行计算的。</p><blockquote><p><u>伪首部只参与校验，不占空间，不参与传输</u> 。UDP 伪头部 = 源 IP 地址 + 目的 IP 地址 + 8位协议 + 16位UDP长度 。<br><strong>UDP 发送方可以选择不计算校验和，而 TCP 必须计算校验和</strong> 。UDP 伪首部目的是让UDP两次检查数据是否已经正确到达目的地：第一次，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的；第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP。相较于链路层的 CRC 校验，TCP/UDP 校验和提供相对较弱的差错保护。</p></blockquote></li><li><p><strong>紧急指针：</strong> 16位，指向优先数据的字节，在URG标志设置了时才有效。<u>如果URG标志没有被设置，紧急域作为填充</u> 。</p></li><li><p><strong>标志位：</strong></p><ul><li><strong>CWR(Congestion Window Reduce)</strong> ：拥塞窗口减少标志被发送主机设置，用来表明它接收到了设置ECE标志的TCP包，发送端通过降低发送窗口的大小来降低发送速率</li><li><strong>ECE(ECN Echo)</strong> ：ECN 响应标志被用来在 TCP 3次握手时表明一个 TCP 端是具备 ECN 功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11。ECN(Explicit Congestion Notification)是一种由网络层辅助的拥塞控制方法，用于显式通知终端拥塞的发生。参考<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">此处</a></li><li><strong>URG(Urgent)</strong> ：该标志位置位表示紧急(The urgent pointer) 标志有效。该标志位目前已经很少使用。</li><li><strong>ACK(Acknowledgment)</strong>：取值 1 代表 ACK 字段有效，这是一个确认包，取值0则不是确认包。</li><li><strong>PSH(Push)</strong> ：该标志置位时，一般是表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。<u>在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。</u></li><li><strong>RST(Reset)</strong> ：用于复位相应的TCP连接。通常在发生异常或者错误的时候会触发复位 TCP 连接，这可能导致数据丢失。作用如下：<ol><li>向一个未打开的端口发送连接请求</li><li>应用程序主动终止一个连接</li><li>应用程序还没有接收缓存中的数据，连接被提前关闭</li><li>TWA(TIME-WAIT Assassination)</li><li>半开连接的情况下发送数据。参考 <a href="https://www.cnblogs.com/lshs/p/6038500.html">此处</a></li></ol></li><li><strong>SYN(Synchronize</strong>) ：该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号.</li><li><strong>FIN(Finish)</strong> ：带有该标志置位的数据包用来结束一个TCP会话，<u>但对应端口仍处于开放状态</u> ，准备接收后续数据。</li></ul></li><li><p><strong>选项(Option)</strong> ：长度不定，但长度必须以是32bits的整数倍。常见的选项包括 MSS、SACK、Timestamp 等。<u>可用于填充</u> 。</p><blockquote><img src="/2022/img/20191026141216154.png" alt="可选字段的格式" style="zoom:67%;" /><p><img src="/2022/img/740952-20161107134032077-307444296.png" alt="选项含义"></p><p>常用选项为：</p><ul><li><p><strong>最大报文传输段(Maximum Segment Size — MSS )</strong> ：<strong><font color='red'>MSS只出现在前两次握手中</font></strong> 。</p><blockquote><p>MSS 是传输层 TCP 协议范畴内的概念，顾名思义，其标识TCP能够承载的最大的 <strong><u>应用数据</u></strong> 长度，因此，MSS = MTU - 20 字节TCP报头 - 20字节IP报头，那么 <strong>在以太网环境下，MSS值一般就是1500-20-20=1460字节</strong></p></blockquote></li><li><p><strong>窗口扩大选项(window scaling – WSOPT  )</strong> ：<strong><font color='red'>该选项只出现在前两次握手中</font></strong> ，因此当TCP连接建立起来后，window scale就固定了。</p><blockquote><p><code>window size</code> 占 16 位，最大 64 kb，在网络情况很好的状态下，这么小的窗口无法满足较高的网络性能，所以需要用 WSOPT 选项扩大窗口。该选项格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//         +---------+---------+---------+</span></span><br><span class="line"><span class="comment">//         | Kind=3  |Length=3 |shift.cnt|</span></span><br><span class="line"><span class="comment">//         +---------+---------+---------+</span></span><br></pre></td></tr></table></figure><p>当使用 WSOPT 选项的时候，接收窗口的实际大小则为 <code>Window Size &lt;&lt; shift.cnt</code>，其中 <u><strong>shift.cnt 按照协议最大只能为14</strong></u> ，当接收端接收到的 shift.cnt 大于 14 的时候，则按照 14 来处理 <strong>Window Size</strong> 。WSOPT 选项最大可将原有的 16 位 <strong>Window Size</strong> 扩展到近 30 位大小(大约1GB)，可以有效提升TCP允许使用的接收缓存。</p></blockquote></li><li><p><strong>选择确认选项(Selective Acknowledgements —SACK )</strong> ：用于重传和拥塞控制，笔者其他文章会详述。</p></li><li><p><strong>时间戳选项(timestamps )</strong> ：用于 <u>测量往返时延</u> （RTTM，利于掌握网络拥塞信息），<u>防止序列号回绕</u> （PAWS）（参见：<a href="https://jyxcpp.netlify.app/2022/08/04/tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">序列号回绕</a> ）</p></li><li><p><strong>NOP</strong> ：<u>选项部分的每种选项长度必须是4字节的倍数，不足时用NOP补充</u> 。注意，是用来填充选项之间的空隙。</p></li><li><p><strong>EOL</strong> ：用来填充整个选项部分的末尾。</p><blockquote><p>举例：假如 <strong>Header Length</strong> 指定的 TCP 头长为 40 bytes，其中第 29-38 bytes 为 TSOPT 选项，则可以在第 39 byte 处添加一个 EOL 选项指示选项列表结束，可以看到 EOL 并没有位于 TCP 头的结束位置的第 40 byte。对于最后一个 byte RFC793 协议规定需要以 0 来填充。这个EOL后面填充的 0 已经不属于 TCP 选项的一部分了。然而，linux 本身发送 TCP 数据包的时候并不会添加 EOL 选项，而是通过添加一个或者多个 NOP 选项来实现整个 TCP 头长的四字节对齐。</p></blockquote></li><li><p><strong>FOC</strong> ：用于 <strong>TFO</strong> 的 Cookie 选项，参见<a href="https://jyxcpp.netlify.app/2022/08/05/tcp-fast-open-tfo/">此处</a></p></li></ul></blockquote></li></ul><blockquote><p>文章参考：</p><p><a href="https://www.cnblogs.com/lshs/p/6038458.html">TCP协议01</a> ,<a href="https://www.gingerdoc.com/tcp-intro">姜知笔记</a> ,<a href="https://coolshell.cn/articles/11564.html">TCP那些事</a> , <a href="https://www.cnblogs.com/lshs/p/6038494.html">TCP 8</a> , 《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识端口</title>
      <link href="/2022/08/02/%E5%88%9D%E8%AF%86%E7%AB%AF%E5%8F%A3/"/>
      <url>/2022/08/02/%E5%88%9D%E8%AF%86%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-什么是端口？-font"><font color='red'>什么是端口？</font></h3><p>我们知道，<strong>网络层提供主机到主机的通信，而传输层提供进程到进程的通信</strong> 。在网络层中，IP 地址是识别主机的标识符，网络包通过 IP 地址来寻找主机；相对地，在传输层中，端口是主机上进程的标识符，网络包通过 IP 地址到达主机后，又通过端口号来寻找对应进程。即，<strong><font color=#3b8dfe>端口号用来唯一标识主机进程</font></strong> 。</p><blockquote><p>一个 IP 地址和一个端口号组成了 <strong>套接字地址</strong> ，套接字地址唯一标识了网络中的进程。而客户端和服务器端的 IP 地址与端口，以及传输层协议，共同组成了 <strong>五元组</strong> ，用来标识唯一通信。</p></blockquote><p>客户端程序使用 <strong>临时端口号</strong> 定义自己，之所以叫“临时端口号”，是因为其生命周期较短，本次使用完该端口，下一次就不一定再使用。临时端口号通常选择 49152 ~ 65535之间的数。</p><p>服务器端也需要使用端口号定义自身，但此端口号不能随机选择，否则客户端访问服务器端时，将不知道其端口号。所以服务器必须使用 <strong>公用端口号（well-know port）</strong></p><div class="note info flat"><p><strong><font color='gree'>ICANN范围</font></strong></p><p><strong>公用端口：</strong> <strong>0 ~ 1023</strong></p><p><strong>注册端口：</strong> <strong>1024 ~ 49151</strong></p><p><strong>动态端口：</strong> <strong>49152 ~ 65535</strong></p><p><strong><font color=#3b8dfe>端口号在计算机中占 16 位 bit ，故总范围是 0 ~ 65535</font>。</strong>  公用端口号由 ICANN 预留给 TCP 和 UDP 协议使用的端口号（如 http - 80，DNS - 53）；注册端口号由公司和其他用户向 ICANN 登记注册；动态端口号供进程任意挑选。</p><p><strong><font color='orange'>在 Linux 下，服务和端口的映射关系通常保存在 <code>/etc/services</code></font></strong></p></div><div class="note warning flat"><p>需要注意的是，在网络术语中，端口有两种含义，一种是物理上的端口，如路由器，交换机和集线器上的端口，此端口用于连接其他网络设备；一种是逻辑上的端口，一般是指 TCP/IP 协议中的端口 ，即我们上面所述的端口。</p></div><p><strong>一个端口号是否可以被多个进程绑定？</strong></p><ul><li><p><strong>对于 TCP 而言，可以，只要绑定的 IP 不同，参见<a href="https://jyx-fyh.github.io/2023/04/02/%E5%B8%B8%E7%94%A8socket%E9%80%89%E9%A1%B9/">Socket常用选项</a></strong></p></li><li><p><strong><font color='red'>UDP 和 TCP 可以绑定同一个端口</font></strong> 。TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 http 对应的 80 号端口，TCP 和 UDP 能在同一时刻绑定 80 号端口，二者并不冲突。</p><blockquote><p>就如 HTTP，支持多个协议（TCP、UDP）的服务往往使用相同的 TCP 端口号和 UDP 端口号，不过反过来说就不一定了——有些端口号在 UDP 上用于一种服务，而在 TCP 上却使用另一种服务，比如端口 512~514 ，自行查看 <code>etc/services</code></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解ARQ协议</title>
      <link href="/2022/07/31/%E8%AF%A6%E8%A7%A3ARQ%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/31/%E8%AF%A6%E8%A7%A3ARQ%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><font color='gree'>自动重传请求</font></strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中 <u>数据链路层</u> 和 <u>传输层</u> 的错误纠正协议之一。它通过使用 <strong>确认</strong> ， <strong>超时</strong> ，<strong>校验和</strong> 这三个机制，<strong>在不可靠服务的基础上实现可靠的信息传输，且是一种面向连接的协议。</strong></p><blockquote><p><font color='orange'>ARQ 协议到底属于数据链路层的协议还是传输层的协议?</font></p><p>ARQ 是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了 ARQ ，并不专属某一层。例如，数据包到达数据链路层的网卡和交换机后会进行 FCS 校验，如果错误则直接丢弃；又如在 TCP（传输层）中，数据包的 TCP 报头有 seq 序列号，用于检测失序和丢失。</p></blockquote><p><strong><font color=#FF00FF>ARQ 包含三个协议：停止 - 等待协议（SW），回退N帧协议（GBN），选择重传协议（SR）</font></strong> 。下面对各个协议进行详细分析。</p><h3 id="font-color-red-停止-等待协议（SW）-font"><font color='red'>停止 - 等待协议（SW）</font></h3><ul><li><p><strong>发送方和接收方都只有大小为 1 的滑动窗口</strong> 。每当发送方发送一个分组时，就会开启一个计时器，一旦超时，就重发分组，这意味着，<strong>当收到接收方发来的 ACK 前，发送方都必须将已发送的分组留在窗口中而不可删除。</strong></p></li><li><p>ARQ 协议通过 <strong>序号（seq）</strong> 和 <strong>确认号（ACK）</strong> 来判断失序和重复分组。由于信道中只可能同时存在一个分组或 ACK ，<strong>所以 seq 只需要 1 位，即 0 和 1</strong>  。ACK 号表明的是自己 <strong>预期收到的序号</strong> （比如发送方发送了 seq = 1 的分组，接收方收到后，应发送 ACK = 0 的报文，表明自己下一次想要收到 seq = 0 的报文。</p><blockquote><p>在<mark class="hl-label default">停止 - 等待协议</mark>  中，确认号总是以模 2 运算的方式声明预期收到的下一个分组。</p></blockquote></li><li><p>为了发现破坏分组，我们需要在分组中加入一种被称之为 <strong>校验和</strong> 的检测数据，当发送方收到分组后，会利用校验和进行检测，如果校验和不正确，则说明包发生错误，将其丢弃。</p><blockquote><p>关于校验和，请移步博主另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/">差错检测与纠正技术</a></p></blockquote></li><li><p><strong>对于发送方</strong> ：</p><ul><li>若收到进程传来的数据，发送方创建分组 ，保留分组的副本，并将其发送，同时开启计时器。</li><li>若收到无错（校验和正确）ACK 且与其值等于待发送分组序号，则进入第一步。</li><li>若收到被破坏的 ACK 或 无关 ACK ，则直接丢弃。</li><li>若发生超时，则重发分组，并重开计时。</li></ul><p><strong>对于接收方</strong> ：</p><ul><li><p>若预期无错分组 Seq  = R 到达，则分组被传递到进程，然后窗口滑动，ACK = （R + 1）% 2 被发送。</p></li><li><p>若失序无错分组 Seq != R到达，则分组被丢弃，且发送 ACK = R 。</p></li><li><p>若有错分组到达，直接将其丢弃。注意，不发送 ACK！</p><img src="/2022/img/IMG_0426(20220802-152553).PNG" alt="停止等待协议" style="zoom: 50%;" /></li></ul></li><li><p><strong>效率分析：</strong> 如果我们的信道带宽较大，那么此方式将非常低效，信道中永远只有一个分组，利用率极低。</p><blockquote><p><strong><font color=#3b8dfe>带宽时延积</font>：</strong> 传播时延 × 带宽<br>注意，<strong>传播时延 ≠ 传输时延</strong></p><p>假设在 停止 - 等待 系统中，线路带宽为 1Mbps，1 bit 发送需要 20 毫秒完成往返。求其带宽时延积和信道利用率。</p><p>带宽时延积 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>20</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mn>20000</mn></mrow><annotation encoding="application/x-tex">(1 × 10^6) × (20 × 10^{-3}) = 20000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20000</span></span></span></span> ，即信道容量可达 20000 位，而系统只发送了 1000 位，所以信道利用率为 5%。</p><p>如果系统在往返时间内发送 15 个分组（15000位），则信道利用率达 75%（信道利用率不是越高越好），由此我们引出 <strong>回退N帧协议</strong> 。</p></blockquote></li></ul><h3 id="font-color-red-回退N帧协议（GBN）-font"><font color='red'>回退N帧协议（GBN）</font></h3><blockquote><p>在网络或其他领域中，在之前的任务结束前，经常会开始另外一个新任务。这称之为 <strong>流水线（pipeline）</strong> 。流水线往往可以提高传输效率。</p></blockquote><ul><li><p>发送方收到 ACK 前可以同时连续发送多个分组且<strong>窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{m}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong> （原因见下文），<strong>但接收方只能缓冲一个分组（窗口大小为 1）</strong> 。</p><blockquote><p><strong><font color='orange'>窗口本身是一种抽象</font></strong> ，发送窗口有三个变量，分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> （第一个未完成分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Sn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span></span></span></span> （下一个待发送分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mrow><annotation encoding="application/x-tex">S{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span> （窗口大小），接收窗口仅<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><img src="/2022/img/IMG_0427(20220802-163852).PNG" alt="窗口的抽象" style="zoom:50%;" /></blockquote></li><li><p><strong>序号是模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 的</strong> ，其中 m 为序号字段的位大小，如 TCP 的 Seq 段为 16 ，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>    。</p></li><li><p>在本协议中，<strong>确认号 ACK 是累积的</strong> 。例如，接收方发送 ACK = 4 ，则说明 <strong>Seq = 4 之前的分组</strong> 都已收到，这对于 ACK 报文的丢失尤其有用（见后文图示）。</p></li><li><p><strong>仅有一个计时器</strong> 。因为第一个未完成分组的计时器总是最先停止，且计时器超时直接重发所有分组，所以只需要一个。</p></li><li><p><strong>对于发送方</strong> ：</p><ul><li><p>当发送窗口内第一个分组时开始计时，<strong>一旦超时，全发所有未完成（已发送但未收到 ACK）分组</strong> 。</p><blockquote><p>如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">S_f = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">S_n = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> ，且计时器（发送分组 4 时开始计时）超时，则重发分组 4，5，6。</p></blockquote></li><li><p>如果无错且相关 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi><mo>=</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ACK = S_f+m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> （显然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>&lt;</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_f&lt;S_f+m&lt;=S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ）到达，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>=</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">S_f=S_f+m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 。并且，<strong>若所有未完成分组都被确认，则计时器停止并进行下一轮发送；若不是所有未完成分组都被确认（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi><mo mathvariant="normal">≠</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">ACK ≠ S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ），则计时器重新开始</strong> 。</p></li><li><p>若被破坏或无关的 ACK 报文到达，直接丢弃。注意，不会重发。</p></li><li><p>若发生超时，直接重发所有未完成分组，并重新计时。</p></li></ul><p><strong>对于接收方</strong> ：</p><ul><li>若对应无错分组到达，报文被解开并传入进程，随后窗口滑动，接着发送 ACK。</li><li>若无错但无关分组到达，将其丢弃，<strong>且发送 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的 ACK 报文</strong> （表明自己需要的是 Seq = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的分组）。</li><li>若被破坏分组到达，则直接丢弃。注意，不发送 ACK 。</li></ul></li></ul><div class="note info flat"><p><strong><font color=#3b8dfe>为什么发送窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{m}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ？</font></strong></p><p><strong>新接收窗口可能将历史延迟报文当作新报文接收，如下：</strong></p><img src="/2022/img/IMG_0428(20220802-173239).PNG" alt="示意图" style="zoom:50%;" /></div><blockquote><p><strong>累积确认如何起作用</strong> ：</p><img src="/2022/img/IMG_0429(20220802-173821).PNG" alt="示意图" style="zoom:50%;" /><p>可见，ACK = 3 到达后，同时完成了对 Seq = 1，2 的确认。</p></blockquote><p>总览图：</p><img src="/2022/img/IMG_0430(20220802-174823).PNG" alt="总览图" style="zoom: 67%;" /><h3 id="font-color-red-选择重传（SR）协议-font"><font color='red'>选择重传（SR）协议</font></h3><blockquote><p>显然，GBN 协议在网络拥塞时，效率会很低，因为只要一个包丢失或错误或乱序，都会导致重发所有未完成分组，从而进一步加剧网络拥塞，形成恶循环。为了解决此问题，选择性重传协议应运而生。</p></blockquote><ul><li><p><strong>发送窗口相对于 GBN 更小，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></strong> ， 且发送窗口和接收窗口大小一致。</p></li><li><p><strong>接收窗口允许储存失序分组</strong> ，直到成为连续分组。</p></li><li><p>与 GBN 不同，<strong>SR 的确认号不是累积的</strong> ，仅定义为本次收到的报文，对其他分组没有反馈。</p></li><li><p>理论上需要需要为每一个未完成分组分配单独计时器，但这样会给系统造成很大开销，所以只使用一个计时器。原因同 GBN 。</p><blockquote><p>《计算机网络第七版》中表示 SR 协议中，每个分组都会分配单独计时器，这样可以做到超时只重发指定的未完成报文。可以用单个硬件定时器来模拟多个逻辑定时器的操作。GBN 仍只使用一个计时器。</p></blockquote></li><li><p><strong>对发送方：</strong></p><ul><li>若收到进程数据，则创建分组，然后发送分组并保留副本，同时开启计时器（如果未开启）。</li><li>若无错且相关 ACK 到达，则将对应分组标记为已确认；若 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，那么窗口向右滑动，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 指向第一个未完成分组；此时若还存在未完成分组，则重启计时器，否则停止计时。</li><li>若出错或无关 ACK 到达，则丢弃。</li><li>若超时，则发送所有未完成分组。</li></ul><p><strong>对接收方：</strong></p><ul><li>若 Seq 在接收方窗口内的无错分组到达，则储存分组，且发送 ACK = Seq ；此外，若 Seq = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则分组以及之前连续到达的分组被传递到应用层，并滑动窗口。</li><li>若 Seq 不在接收窗口内的无错分组到达，则丢弃，且发送 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li><li>若出错分组到达，直接丢弃。</li></ul></li></ul><div class="note info flat"><p><strong><font color=#3b8dfe>为什么窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>？</font></strong></p><img src="/2022/img/IMG_0431(20220802-201744).PNG" alt="示意图" style="zoom: 50%;" /></div><p>总览图：</p><img src="/2022/img/IMG_0432(20220802-202103).PNG" alt="总览图" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP</title>
      <link href="/2022/07/08/CSAPP/"/>
      <url>/2022/07/08/CSAPP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-计算机系统漫游-font"><font color='red'>计算机系统漫游</font></h2><h3 id="font-color-orange-生成可执行文件的过程-font"><font color='orange'>生成可执行文件的过程</font></h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRhello.c--&gt; B{预处理器}--&gt;hello.i--&gt;L{编译器}--&gt;hello.s--&gt;G{汇编器}--&gt;K(&quot;hello.o&quot;)--&gt;A{链接器}--&gt;可执行目标文件Z(&quot;printf.o&quot;)--&gt;A  </pre></div><blockquote><ul><li><code>hello.i</code> 文件是在 <code>hello.c</code> 的基础上进行了宏替换，头文件展开等操作。</li><li>编译器将C代码转变为汇编语言程序，而汇编器将汇编语言程序转变为机器语言，而不是汇编器将C代码转变为汇编语言。</li><li><strong>汇编语言为不同的高级语言提供了相同的输出语言。任何高级语言都需要先转为汇编语言，因为汇编语言才是和机器语言一一对应的。</strong> 汇编语言的种类取决于电脑使用的 CPU 指令架构。所以机器代码和汇编代码的移植性比高级语言差许多。</li><li><code>printf</code> 函数在单独预编译好的 <code>printf.o</code> 的文件中，这个文件需要以某种方式合并到 <code>hello.c</code> 文件中，链接器就负责此过程。</li></ul></blockquote><h3 id="font-color-orange-系统的硬件组成-font"><font color='orange'>系统的硬件组成</font></h3><ol><li><p><strong>总线</strong></p><blockquote><p>总线在各个部件中传输信息字节。总线被设计成传送定长的字节块，即 <strong>字（word）</strong> ，目前大多数计算机要么是4个字节（32位），要么8字节（63位）。<font color='gree'>由于每次只能传送定长的字节块，所以C语言中的整型提升意义就在于此。</font></p></blockquote></li><li><p>I/O设备</p><blockquote><p>最基本的I/O设备：键盘，鼠标，显示器，磁盘。</p></blockquote></li><li><p>主存</p><blockquote><p>主存又一组 <strong>动态随机存取储存（DRAM）</strong> 芯片组成。</p></blockquote></li><li><p>处理器</p><blockquote><p>处理器看上去是指令集架构的简单实现，大多数离不开下面几个操作：</p><ul><li>加载：从主存复制数据到寄存器。</li><li>存储：从寄存器复制数据到主存。</li><li>操作：把两个寄存器的内容复制到ALU（算术/逻辑单元），ALU对其进行算术运算，并将结果放在一个寄存器中保存结果。</li><li>跳转：指向下一条指令。</li></ul></blockquote></li></ol><h3 id="font-color-orange-高速缓存-font"><font color='orange'>高速缓存</font></h3><p>运行程序时，需要先将磁盘中的代码复制到主存中，再由主存复制到 CPU 并运行程序，这些复制便是额外开销，减慢了程序真正工作的效率。</p><blockquote><p>所以目前已经有了 CPU 和内存结合的技术，以解决数据运输的巨大开销。</p><p>当下，存取速度远慢于 CPU 计算速度，未来想要进一步提高计算机运行速度，存取技术才是突破口。</p></blockquote><p>为了缓解这样巨大的复制和运输开销，<strong>高速缓存储存器</strong> 应运而生。</p><img src="/2022/img/20220709092100.png" alt="缓存分级" style="zoom:50%;" /><div class="note info flat"><p>L1，L2，L3高速缓存由 <strong>静态随机访问储存器（SRAM）</strong> 实现。</p></div><p><strong><font color='greew'>储存器的层次结构的主要思想：上一级储存器作为低一层存储器的高速缓存。</font></strong></p><h3 id="font-color-orange-操作系统管理硬件-font"><font color='orange'>操作系统管理硬件</font></h3><p><strong>操作系统是应用程序和硬件直接的一层软件，所有应用对硬件的操作都必须通过操作系统来进行，即 系统调用 。</strong></p><p>操作系统的两大功能：</p><ol><li>防止硬件被失控的应用滥用。</li><li>向应用程序提供简单一致的机制来控制复杂而大不相同的低级硬件设备。</li></ol><p><strong><font color=#00FFFF>简单而言，操作系统给应用提供硬件的一种抽象。</font></strong></p><p>操作系统通过几个基本的抽象概念（<u>进程</u>，<u>虚拟内存</u>，<u>文件</u>）来实现这两个功能：</p><ul><li>文件是对 I/O 设备的抽象。</li><li>虚拟内存是对主存和磁盘 I/O 设备的抽象。</li><li>进程是对处理器，主存和 I/O 设备的抽象。</li></ul><h3 id="font-color-orange-进程-font"><font color='orange'>进程</font></h3><p><strong><font color=#00FFFF>进程是操作系统对一个正在运行的程序的一种抽象。</font></strong> 一个 CPU 看上去像是在并发地执行多个进程，这是通过处理器在进程间来回切换实现的。操作系统实现这种交错执行的机制称作 <strong>上下文切换</strong> 。操作系统保持跟踪进程运行所需的所有状态信息，这种状态也就是上下文，包含许多信息，如：PC和寄存器的值，主存的内容等。<strong>任何时刻，单处理器只能执行一个进程的代码。</strong> 操作系统从当前进程转到其他进程时，就会保存当前的上下文，并恢复新进程的上下文，新进程就会从之前停止的地方开始。</p><p><strong>进程间的切换由操作系统内核（kernel）管理。内核不是单独的进程，而是系统管理全部进程所用代码和数据结构的集合。</strong></p><h3 id="font-color-orange-文件-font"><font color='orange'>文件</font></h3><blockquote><p>Linux哲学：<strong>一切皆文件</strong></p></blockquote><p><strong>文件就是字节序列，仅此而已。</strong> 在 Linux/Unix 中，每个 I/O 设备，包括磁盘，键盘，显示器甚至网络，都可以看作为文件。所有输入输出操作都是由 Unix I/O 的系统函数调用读写文件来实现的。文件向应用程序提供了统一的视角来看待各种 I/O 设备，大大简化了程序员的工作量。</p><h3 id="font-color-orange-Amdahl定律-font"><font color='orange'>Amdahl定律</font></h3><p><strong><font color='pink'>想要显著加速整个系统，必须要提升全系统中相当大部分的速度</font></strong> 。</p><blockquote><p>如果系统中 60% 的部分加速到无需时间，那么整个系统最终的加速比也只有 2.5X</p></blockquote><hr><h2 id="font-color-red-信息的处理和表示-font"><font color='red'>信息的处理和表示</font></h2><p><strong><font color='greew'>信息 = 位 + 解释</font></strong></p><blockquote><p>由于不同数据类型有不同的底层实现原理，导致它们的行为也大不相同，比如整形能够进行结合律和交换律，而浮点数却不行。整形是精确的，而浮点是近似的。对相同的位进行不同的解释，得到的结果也大不相同。</p></blockquote><h3 id="font-color-orange-信息存储-font"><font color='orange'>信息存储</font></h3><p><strong>字节（byte）是最小的可寻址单位（操作单位），而不是内存中单独的位。</strong> 每个字节由唯一的数字表示，表示其地址，所有字节的地址集合构成了 <strong>虚拟地址空间</strong> 。程序数据，指令和控制信息完全在虚拟内存空间中管理。</p><blockquote><p>C编译器将指针和类型信息联系起来，如此便可以根据指针值的类型来生成不同的机器级代码。</p><p><strong><font color='gree'>实际上，机器代码中并不包含关于数据类型的信息</font></strong> 。问题：那么运行时，CPU 怎么知道用什么方式来解释位？</p></blockquote><h4 id="font-color-00FFFF-十六进制-font"><font color=#00FFFF>十六进制</font></h4><p><strong>一个十六进制数 = 4个位</strong> ，<strong>两个十六进制数 = 2个位 = 1个字节</strong></p><blockquote><p>比如：0x173A4</p><img src="/2022/img/20220709110111.png" alt="image-20220709110110979" style="zoom:67%;" /></blockquote><h4 id="font-color-00FFFF-字数据大小-font"><font color=#00FFFF>字数据大小</font></h4><p><strong>字长（word size）指明了指针的大小，决定了虚拟地址空间的最大大小</strong> 。</p><p>64 位机器大多可以运行 32 位程序，而 32 位机器无法运行 64 位程序。”32位程序“ 或 “64位程序” 区别在于该程序是如何编译的，而不是其运行的机器类型。</p><p>同时，C数据类型的大小也受字数据大小的影响。</p><blockquote><p>char 常用于储存单个字符，但它也可以用来储存整数值，因为其本质仍是整数。然而并不值得这样做，编译器有可能生成额外代码将 char 变为 int，造成不必要的开销。</p></blockquote><p>为了数据类型大小对机器的依赖，ISO C99 引入了大小固定的数据类型，如：int32_t，int64_t 。</p><p><strong>C标准仅规定 char 的大小必须为 1 字节，其他类型仅规定了下限，而没有规定上限。</strong></p><blockquote><p>大部分数据类型都默认编码为有符号类型，但 char 是个例外，C标准不保证这一点，尽管大多编译器视其为有符号数。</p></blockquote><h4 id="font-color-00FFFF-寻址和字节顺序-font"><font color=#00FFFF>寻址和字节顺序</font></h4><p><strong>小端（little endian）：</strong> 高位在高地址（违背直觉）</p><p><strong>大端（big   endian）：</strong> 高位在低地址（符合直觉）</p><p>如表示：0x01234567</p><img src="https://jyxcpp.netlify.app/img/20220709113101.PNG" alt="IMG_0381(20220709-113043)" style="zoom:67%;" /><p><strong>一旦选定了特定操作系统，字节顺序也就确定了。</strong></p><blockquote><p>如何确定大小端？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">char</span> *b = (<span class="type">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*b == <span class="number">0x78</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line">&#125;demo;</span><br><span class="line"> </span><br><span class="line">demo.sh = <span class="number">0x0001</span>;<span class="comment">//小端：0x0100    大端:0x0001</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(demo.ch == <span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-00FFFF-移位运算-font"><font color=#00FFFF>移位运算</font></h4><p><strong>左移 k 位时，丢弃最高的 k 位，并在右边补上 k 个 0 。</strong> 右移时，分为 <strong>算术右移</strong> 和 <strong>逻辑右移</strong> ：</p><p>算术右移：左端补上 k 个 <strong>有效位</strong> 的值。</p><p>逻辑右移：左端补上 k 个 0</p><blockquote><ul><li><p>C语言标准没有明确定义有符号数的右移采用哪种方式，但几乎所有编译器和机器都对有符号数采用算术右移。无符号数只能采用逻辑右移。</p></li><li><p>在许多机器上， <strong><font color=#FF00FF>实际的位移量 = k % w</font></strong> （w是数据类型所占位数），比如 <code>int a = 0x12345678 &lt;&lt; 36</code> ，实际上的的位移量应该是 <code>36%32=4</code> 。不过此行为对于C程序而言是未定义的（java特别要求采用上述方式），应保证位移量小于数据所占位数。</p></li></ul></blockquote><h4 id="font-color-00FFFF-补码编码-font"><font color=#00FFFF>补码编码</font></h4><blockquote><p>C/C++ 支持有符号数（默认）和无符号数，java 只支持有符号数。</p><p><strong>C语言标准并没有要求有符号数的表示需用补码，但基本上所有实现都采用的补码。相反，Java标准要求必须用补码。</strong></p></blockquote><p>补码编码用于有符号整数，不同于无符号数编码，补码编码将最高有效位解释为负权，如下：</p><img src="https://jyxcpp.netlify.app/img/20220710093132.png" alt="image-20220710093132790" style="zoom:67%;" /><p><strong><font color='greew'>即：当符号位为1时，为负数；符号位为0时，为负数。</font></strong></p><div class="note info flat"><p>补码如此设计是为了让计算机用加法来实现减法，因为计算机只有加法器。而减法的实现正是通过最高位截断来实现的，如下图：</p><img src="https://jyxcpp.netlify.app/img/20220710103319.png" alt="减法实现" style="zoom:50%;" /></div><blockquote><p>至于原码和反码，只是为了帮助我们快速地计算相反数而引入的概念，个人认为学习时最好不要自动引入这两者，否则很容易混乱。</p><p>A - B = A + (-B)，<strong>减一个正数B，等于加上B的相反数，即B的补码</strong> 。对计算机而言，A 和 B 本来就是采用的补码，所以 B 本来就是负数，不存在 -B 这一说。只是对人而言，当补码为负数时不太好计算，所以引入原码和反码来辅助计算(具体见后文) ，就可以很方便的把减 B 变为加上 B 的相反数。</p><p><strong>浮点数中会使用的原码的概念。</strong></p></blockquote><p><strong>补码的属性：</strong></p><ul><li><p>|MIN| = |MAX| + 1</p><blockquote><p>这会造成细微的计算错误： <strong>-MIN = MIN</strong></p><p>所以：<font color='red'>X &gt; Y != (-X) &lt; (-Y)</font></p></blockquote></li><li><p>最大的无符号数比最大的有符号数的两倍还大1。</p></li></ul><div class="note info flat"><p>简单了解一下原码，反码和补码的关系，以应对计算：</p><p>真值：带符号位的机器数对应的真正数值称为机器数的真值。</p><ul><li><p>原码：符号位加上真值的 <strong>绝对值</strong> , 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 = 0000 0001</p><p>[- 1]原 = 1000 0001</p></li><li><p>反码：正数的反码是其本身，负数的反码是在其原码的基础上, <strong><font color='greew'>符号位不变</font></strong> ，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[- 1] = [10000001]原 = [11111110]反</p></li><li><p>补码：正数的补码就是其本身，负数的补码是在其原码的基础上, <strong><font color='greew'>符号位不变</font></strong> ， 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1 ] = [10000001]原 = [11111110]反  = [11111111]补</p></li></ul><p><strong>一般情况下不要引入这几个概念，极易混。对于整形的储存方式，就只分为无符号编码和补码。</strong></p><p><strong><font color='red'>将二进制数（无论补码还是无符号编码）取反加1（补码）的结果和原二进制数相加，其和为0</font></strong> 。</p><p>对补码而言：<strong>-X = ~X + 1</strong></p><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解</a></p></div><h4 id="font-color-00FFFF-有符号数和无符号数的转换-font"><font color=#00FFFF>有符号数和无符号数的转换</font></h4><ul><li><p><strong>当强制地转换在有符号类型和无符号类型间转换时，结果的位值不变，只改变解释这些位的方式</strong></p></li><li><p><strong>当隐式地发生转换时，有如下几个规则：</strong></p><blockquote><ul><li><p><strong><font color='red'>整形提升：</font></strong> signed 符号扩展，unsigned 零扩展。</p><blockquote><p>符号扩展：高位补充符号位的值</p><p>零扩展：高位补零</p><p>这样做可以在保持值不变的情况下将位数少的二进制数（如8位）转为位数多的二进制数（如32位）。</p><p>从直观上理解为什么高位补符号位其值不变：</p><p>a = 1110           -&gt; 取反加一 -&gt; 0010</p><p>b = 11111110    -&gt; 取反加一 -&gt; 00000010</p><p>a和b的相反数相同，故 a = b</p></blockquote></li><li><p><strong><font color='red'>值保护规则：</font></strong> <font color='red'>仅针对无符号数！ </font> <strong>如果 signed int 可以装下扩展前 unsigned 类型的所有值</strong> ，则提升（零扩展）后将其视为 signed int，反之视作 unsigned int 。</p></li><li><p><strong><font color='red'>无符号数和有符号数混合运算时，有符号数会默认转变为无符号数。</font></strong> <font color='red'>此规则发生在前两个规则之后，具体看后文</font></p><div class="note danger flat"><blockquote><p><strong><font color='red'>应极力避免有符号数和无符号数的混合运算，其差错难以发现！</font></strong></p></blockquote></div></li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aha&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dada&quot;</span>;   <span class="comment">//结果输出dada</span></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aha&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dada&quot;</span>;  <span class="comment">//结果输出aha</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>第一种情况：<ol><li><code>unsigned char</code> 和 <code>signed int</code> 比较，首先 <code>unsigned char</code> 采用值保护规则，进行提升，由于 <code>signed int</code> 可以装下 <code>unsigned char</code> 的所有值，所以提升后，a 的类型为 <code>signed int</code></li><li>a 和 b 都为 <code>signed int</code> ，直接进行比较，a &gt; b，输出 dada</li></ol></li><li>第二种情况：<ol><li><code>unsigned int</code> 和 <code>signed int</code> 混合运算，后者变为无符号数，-1 变为 INT_MAX</li><li>进行比较，b &gt; a ，输出aha</li></ol></li></ul><p><strong><font color=#FF00FF>补码转为无符号数：</font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220710160958.png" alt="关系式"></p><p><strong><font color=#FF00FF>无符号数转换为补码：</font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220710161025.png" alt="关系式"></p><hr><h4 id="font-color-00FFFF-截断-font"><font color=#00FFFF>截断</font></h4><p><strong>截断无符号数为k位：X’ = X % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span></strong></p><p><strong>截断有符号数为k位：X’ = X % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> ，且最高位作符号位</strong></p><blockquote><p><strong><font color='orange'>取模是丢高位，除法是丢低位：</font></strong></p><p>10101 ➗2   = 1110</p><p>10101 %  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> = 1110</p></blockquote><p>不论大端还是小段，截断丢弃的都是高位数据！所以下面方法来判断大端还是小端是无效的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">char</span> c = a;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0x78</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong><font color='red'>整数运算实际上就是一种模运算形式！</font></strong></p><hr><h4 id="font-color-00FFFF-无符号加法-font"><font color=#00FFFF>无符号加法</font></h4><p><strong><font color=#FF00FF>X + Y = ( X + Y ) % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220713083030.png" alt="image-20220713083023388"></p><p>模数加法形成了一种数学结构，即 <strong>阿贝尔群</strong> 。也就是说，模数加法是 <strong>可交换</strong> 和 <strong>可结合的</strong> 。</p><blockquote><p>这说明对于 ( X + Y ) - Y ，无论 ( X + Y ) 是否溢出，始终有 ( X + Y ) - Y = X</p><p><strong><font color=#FF00FF>这也是整形运算可使用交换律和结合律的原因，而浮点数运算则不可。</font></strong></p></blockquote><hr><h4 id="font-color-00FFFF-补码加法-font"><font color=#00FFFF>补码加法</font></h4><img src="https://jyxcpp.netlify.app/img/20220713083826.PNG" alt="公式" style="zoom:67%;" /><img src="https://jyxcpp.netlify.app/img/20220713083902.PNG" alt="示意图" style="zoom:67%;" /><p><strong>加正数则顺时针，减正数则逆时针</strong>。</p><div class="note danger flat"><p><strong><font color='red'>所以 X&lt;1 不等价于 X-1&lt;0</font></strong> ，当 X = INT_MIN 时，X - 1 = INT_MAX</p><p>此类细节错误经常出现，需要注意！</p></div><hr><h4 id="font-color-00FFFF-乘以常数-font"><font color=#00FFFF>乘以常数</font></h4><blockquote><p>在大多数机器上，整数乘法往往需要较多的时钟周期，而其他整数运算（加减，位级运算，移位）只需要 1 个时钟周期。因此编译器会试着用移位和加法的组合运算来代替常数的乘法</p></blockquote><p><strong><font color=#FF00FF>对无符号和补码值都有： X&lt;&lt; K = X * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span></font></strong></p><p>技巧：考虑一组从位位置 n 到位位置 m （n&gt;m）的连续的 1 ，如对于 14 而言有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0000 0000 0000 1110</span></span><br><span class="line"><span class="comment">//                ⬆⬆⬆⬆</span></span><br><span class="line"><span class="comment">//                3210</span></span><br></pre></td></tr></table></figure><p><strong>则可以有下面两种形式表示此计算：</strong></p><ol><li>x &lt;&lt; n + x&lt;&lt;(n-1) + … + x&lt;&lt;m</li><li>x&lt;&lt;(n + 1) - (x &lt;&lt; m)</li></ol><p>显然，第二种方法更好。</p><blockquote><p>例如：</p><ul><li>X * 14 = X * ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> +<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> ) = (X&lt;&lt;3) + (X&lt;&lt;2)+ (X&lt;&lt;1) = (X&lt;&lt;4) - (X&lt;&lt;1)</li><li>3*A = A&lt;&lt;1 + A</li></ul></blockquote><hr><h4 id="font-color-00FFFF-除以常数-font"><font color=#00FFFF>除以常数</font></h4><blockquote><p>整数除法比整数乘法需要更多的时钟周期（30乃至更多），所以编译器也会 <strong>尝试</strong> 用左移来代替除法。</p></blockquote><p><strong>无符号数和补码数分别使用逻辑右移和算术右移来实现除法。</strong></p><p>对于无符号数和补码数，<strong><font color='greew'>除以 2 的幂的除法</font></strong> ，都有：<strong><font color='greew'>X &gt;&gt;k = [X / <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>]</font></strong></p><blockquote><p>[ a ] 代表不超过 a 的最大整数，如 [14.5] = 14 ，[-3.5] = -4，即向下舍入。</p></blockquote><div class="note info flat"><p>如果想要变为向上舍入，即令 [ a ] = 超过 a 的最小整数，则需要使用以下 “偏置技术”：</p><p><strong>(x+(1&lt;&lt;k)-1)&gt;&gt;1 = [x/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>]</strong></p><p><strong><font color='greew'>而对于大多数补码机器而言，一般策略是：对正数向下舍入，对负数向上舍入（以0为参考点）。所以一般使用如下方法：</font></strong></p><p><mark class="hl-label default">(x &lt; 0?x+(1 &lt;&lt; k ) - 1 : x) &gt;&gt; k</mark></p></div><div class="note danger flat"><p><strong><font color='red'>这种方法不能推广到任意常数的除法！因为除法没有分配律。</font></strong></p></div><hr><h4 id="font-color-00FFFF-浮点数-font"><font color=#00FFFF>浮点数</font></h4><blockquote><p>在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。Intel 在研发 8087 浮点数协处理器时，聘请到加州大学伯克利分校的 William Kahan 教授以及他的两个伙伴，来为 8087 协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于 1985 年正式发布，这就是 IEEE 754 标准。IEEE 754完成了对浮点数的统一，所有计算机都支持此标准。</p></blockquote><p>了解浮点数之前，我们先来认识一下 <strong>定点数</strong> ：</p><img src="https://jyxcpp.netlify.app/img/20220713113938.png" alt="定点数" style="zoom:50%;" /><p><img src="https://jyxcpp.netlify.app/img/20220713114053.png" alt="定点数"></p><p><strong>特点</strong></p><p>如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。</p><p><strong>精度</strong></p><p>小数部分的 <strong>最后一位可能是精确数字，也可能是近似数字</strong>（由四舍五入、向零舍入等不同方式得到）；除此以外，<strong>剩余的31位都是精确数字</strong> 。从二进制的角度看，这种定点格式的小数，<strong>最多有 32 位有效数字，但是能保证的是 31 位；也就是说，整体的精度为 31~32 位</strong> 。</p><p><strong>范围</strong></p><p>将内存中的所有位（Bit）都置为 1，小数的值最大，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>，极其接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>，换算成十进制为 65536。将内存中最后一位（第32位）置 1，其它位都置0，小数的值最小，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p><strong>综述</strong></p><p>用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。</p><p><strong><font color=#FF00FF>浮点数</font></strong></p><blockquote><p>浮点数使用指数的形式来存储小数，当指数变化时，其小数点的位置也发生变化，故而称之为浮点数。</p></blockquote><p><strong>C语言标准规定</strong> ，小数在内存中以科学计数法的形式来存储，具体形式为：</p><mark class="hl-label default">flt = sign × mantissa × base^exponent</mark> <p>说明：</p><ul><li><mark class="hl-label default">flt</mark>  是要表示的小数。</li><li><mark class="hl-label default">sign</mark>  用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。</li><li><mark class="hl-label default">base</mark>  是基数（进制），它的取值大于等于 2。</li><li><mark class="hl-label default">mantissa</mark>  为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，**小数点前面只能有一位数字**  <div class="note danger flat"><p>注意，10.101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，10.101 不是尾数，尾数必须要满足 1 ≤ mantissa ＜ base 。</p></div></li><li><mark class="hl-label default">exponent</mark>  为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。</li></ul><p>例如：1.0101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> ，其中 1.0101 是尾数，10 是基数，3 是指数。</p><p><strong><font color=#FF00FF>将小数转换为浮点格式</font></strong></p><p>当 base 取值为 10 时，19.625 的浮点形式为：</p><p>19.625 = 1.9625 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">10^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></p><p>当 base 取值为 2 时，将 19.625 转换成二进制为 10011.101，用浮点形式来表示为：</p><p>19.625 = 10011.101 = 1.0011101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>19.625 整数部分的二进制形式为：<br>19 = 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span> = 10011<br>小数部分的二进制形式为：<br>0.625 = 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> = 101<br>将整数部分和小数部分合并在一起：<br>19.625 = 10011.101</p></blockquote><p>可以看出，当基数（进制）base 确定以后，<strong><font color=#00FFFF>指数 exponent 实际上就成了小数点的移动位数</font></strong> ：</p><ul><li>exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值；</li><li>exponent 小于零，mantissa 中的小数点左移 exponent 位即可还原小数的值。</li></ul><p><strong><font color=#FF00FF>储存</font></strong></p><p><strong>32 位整形（float）：</strong> <mark class="hl-label default">符号位 1 bit</mark>  + <mark class="hl-label default">指数位 8 bit</mark>  + <mark class="hl-label default">尾数位 23 bit</mark> </p><p><strong>64 位整形（double）：</strong> <mark class="hl-label default">符号位 1 bit</mark>  + <mark class="hl-label default">指数位 11 bit</mark>  + <mark class="hl-label default">尾数位 52 bit</mark> </p><ul><li><p><strong>符号位：</strong> 用 0 表示正数，用 1 表示负数。</p></li><li><p><strong>尾数位：</strong> 当采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：<strong><font color='red'>尾数的整数部分一定为 1（规格化）</font></strong> ，是一个恒定的值，<strong>这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可</strong> 。对于 1.0011101，就是把 0011101 放入内存。</p></li><li><p><strong>指数位：</strong> 指数必须要有正负，但指数的存储并没有像整形那样采用补码编码的形式，而是采用的是 <strong>取中间值</strong> 的方式：</p><blockquote><p><strong><font color=#00FFFF>在规格化的情况下，</font></strong> float 的指数部分占用 8 Bits，能表示从 0-255 的值，取其中间值 127 （偏置值，bias），指数在写入内存前 <strong>先加</strong> 上127，读取时 <strong>再减</strong> 去 127 ，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。</p><p>对于 double ，bias = 1023 ，</p><p>其中，<strong>bias = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong></p></blockquote></li></ul><p><strong>根据 <mark class="hl-label default">exponent</mark>  的不同，编码的值可以分为三种情况：</strong></p><ul><li><p>规格化的</p><p><img src="https://jyxcpp.netlify.app/img/20220713160938.png" alt="规格化"></p></li><li><p>非规格化值</p><p><img src="https://jyxcpp.netlify.app/img/20220713183224.png" alt="非规格化"></p><p><strong><font color=#00FFFF>非规格化值的尾数不包含隐含的开头的 1，而是 0</font></strong></p></li><li><p>无穷大</p><p><img src="https://jyxcpp.netlify.app/img/20220713161208.png" alt="无穷大"></p></li><li><p>NaN（Not a Number）</p><p><img src="https://jyxcpp.netlify.app/img/20220713161445.png" alt="NaN"></p></li></ul><div class="note info flat"><p><strong>了解规范化数</strong></p><p><strong><font color=#00FFFF>规格化数的 E = e - bias ，非规格化数的 E = 1 - bias</font></strong> ，其中 <strong>E 为实际值，e 为内存值</strong> 。非规格化数采用此方式，可以极其巧妙使非规格化值平滑过度到规格化值，如下：</p><p><img src="https://jyxcpp.netlify.app/img/20220713173041.png" alt="假定的8位浮点格式"></p><p>可以看见，最大非规格化数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>7</mn><mn>512</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {7} {512}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">512</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 到最小规格化数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>8</mn><mn>512</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {8} {512}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">512</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的平滑转换。这种转换归功于对非规格化数的 E 的定义，其可以弥补非规格化数的尾数没有隐含的开头的 1 。</p><p><strong>同时还可以发现，当把上图中的位表达式解释为无符号数时，其就是升序排列的！</strong> 这并非偶然，IEEE 格式如此设计就是为了使浮点数能够使用整数排序函数来进行排序。</p><p><strong>规格化数的用途：</strong></p><ul><li><font color=#00FFFF>提供了表示浮点 0 的方法。因为使用规格化数，mantissa 必须的整数部分一定为 1，所以无法表示 0 </font>。当所有域都为 0 时，表示 +0.0 ；当符号位为 1 ，其他域为 0 时，表示 -0.0 。</li><li><font color=#00FFFF>表示那些很接近 0 的数</font></li></ul></div><div class="note info flat"><p>一些运算的结果不能是实数或无穷，就会返回 NaN，比如计算 根号下-1 或 ∞ - ∞ ，有时也可以用来表示某些未初始化的数据。</p></div><p><strong><font color='red'>精度</font></strong></p><p>计算机浮点误差主要来源于：一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才 <strong>有可能</strong> 转换成有限位数的二进制，其它的小数都不行。 float 和 double 的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。<strong>也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。</strong><br>对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24 位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的 23 位都是精确数字。也就是说，整体的精度为 23~24 位。如果转换成十进制，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16777216</mn></mrow><annotation encoding="application/x-tex">2^{24}= 16 777 216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16777216</span></span></span></span> ，一共8位；也就是说，<strong>最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。</strong></p><blockquote><p>比如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.5=1×2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.75</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.75 = 1×2^{-1}+1×2^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ；而 0.55 与 0.755 就无法用有限的二进制位表示。</p></blockquote><p><strong><font color='red'>过程示范：</font></strong></p><p>将 12345 转为浮点格式：</p><ol><li><p>12345 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.100000011100</mn><msub><mn>1</mn><mn>2</mn></msub><mo>×</mo><mn>1</mn><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">1.1000000111001_2 × 12^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">1.100000011100</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>丢弃尾数开头的 1 ，并在 <strong>末尾</strong> 增加 10 个 0 ，来构造尾数字段，得到 <code>10000001110010000000000</code></p><blockquote><p><font color='red'>注意，小数是在末尾添 0 ，整数是在 开头添 0</font></p></blockquote></li><li><p>13 + 127 = 140 ，其二进制为：<code>10001100</code></p></li><li><p>符号位为 0</p></li><li><p>得到 <code>01000110010000001110010000000000</code></p></li></ol><p>同时可以发现，整形 12345 和 浮点 12345 有如下对应关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形 00000000000000000011000000111001</span></span><br><span class="line"><span class="comment">// 箭头                    ⬇···········⬇</span></span><br><span class="line"><span class="comment">// 浮点           01000110010000001110010000000000</span></span><br></pre></td></tr></table></figure><p>浮点的尾数部分与整形第一位后的所有位相对应。</p>]]></content>
      
      
      <categories>
          
          <category> 技术书籍笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转专业失败总结</title>
      <link href="/2022/06/24/%E8%BD%AC%E4%B8%93%E4%B8%9A%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/24/%E8%BD%AC%E4%B8%93%E4%B8%9A%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>失败不是结果，它发生在每一个瞬间。</p></blockquote><p>​由于笔试失误，我转计算机专业失败了，一年的期待落空，一年的努力化为泡影。迷茫和矛盾充斥内心，一方面，我难以接受这样的结果，计算机是我的兴趣，其他学科的学习可以说是煎熬，我难以想象未来的学习该怎么继续；另一方面，我接受这次失败，因为它是必然的，过去一年的许多瞬间都加固了它的必然性。痛定思痛，与其虚假的彷徨，不如反思自己的失败。</p><blockquote><p>​为什么说失败发生在每一个瞬间？</p><ol><li>明知转专业看重绩点，却依然忽视本专业课程的学习，过度看重转专业面试和所谓的计算机“项目”经验，耗费了许多经历在小项目的制作上。</li><li>笔试考的是基础的算法题，为什么依然“失误”——无他，手不熟尔。编程学而不精，没有注重编程基础能力，总是以自己的“项目”为傲，不愿走出舒适区。</li><li>浪费了大量时间和精力在无关的事情上。我总是以自己不打游戏为傲，以为自己因此赢得了不少宝贵的时间。去他妈的，都是自我安慰。。。即使没打游戏，我还是浪费了一大把时间，关键是我还说不出来这些时间浪费在哪了。</li><li>不专注，没有沉下心来做事。总认为本土木专业的课程耗费我的“宝贵时间”，但却没见自己把这些“宝贵时间”用在计算机上，一年下来，计算机学习的进度也就如此。最后导致土木绩点不高，计算机专业也没能转成。</li><li>找借口，拖延。总想着等我转成了（哪来的信心？），我就全身心投入计算机的学习。实际上，如果我从一开始就投入（哪怕算上土木的学习），现在都能去实习了，结果呢？</li></ol></blockquote><p>​</p><p>​要善于总结教训，更要善于吸收教训！过去的一年中，我很多次想过要改变自己，想过晨跑，想过学精英语，想过学好计算机… 最后都不了了之。而这次失败对我而言是深刻的，所以它也许是一次契机，能让我真正地改变自己。坦然地面对失败吧，它对整个人生而言，不值一提（就像小学的一次数学不及格让我当时感觉天都塌了）。如果我还不知悔改，还旧错重犯，这篇文章，就是用来打我自己的脸！</p><p>​重新规划好未来一年，改正错误，调整心态，继续前进！</p>]]></content>
      
      
      <categories>
          
          <category> 成长记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shared_ptr与虚析构</title>
      <link href="/2022/06/20/shared-ptr%E4%B8%8E%E8%99%9A%E6%9E%90%E6%9E%84/"/>
      <url>/2022/06/20/shared-ptr%E4%B8%8E%E8%99%9A%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  ~<span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Data* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AX</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">AX</span>();</span><br><span class="line">  ~<span class="built_in">AX</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AXData* ax_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下不会存在内存泄漏的写法是？</p><p>A. <code>AX* p = new AX(); delete p;</code></p><p>B. <code>A* p = new AX(); delete p;</code></p><p>C. <code>shared_ptr&lt;A&gt; p = shared_ptr&lt;A&gt;(make_shared&lt;AX&gt;()); delete p; </code></p><p>D. <code>shared_ptr&lt;A&gt; p = shared_ptr&lt;A&gt;(make_shared&lt;A&gt;());  delete p; </code></p><blockquote><p>正确答案： <font color='gree'>A,C,D</font></p><p>解析：</p><p>B：基类析构函数没有声明为 <code>virtual</code> ，所以 p 所指的对象析构时，不会调用基类的析构函数。</p><p>D：正常情况，显然不会内存泄漏。</p><p>C：<strong><font color=#00FFFF>shared_ptr创建时会记住原来的类型的析构函数，基类指针析构时仍会调用派生类的析构函数。</font></strong></p><hr><p><strong><font color='orange'>shared_ptr 创建时即捕获析构动作，何解？</font></strong></p><p>本人也不懂。。。待笔者读完《STL源码剖析》后再回来解释。</p><p><a href="https://zhuanlan.zhihu.com/p/56865771">你不一定知道的智能指针细节 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载，覆盖与隐藏</title>
      <link href="/2022/06/20/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/"/>
      <url>/2022/06/20/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/img/20220620174905.png" alt="image-20220620174904944"></p><blockquote><p>此三者的区别是针对继承关系下的成员函数而言。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解assert与if</title>
      <link href="/2022/06/20/assert-%E4%B8%8Eif/"/>
      <url>/2022/06/20/assert-%E4%B8%8Eif/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-一-assert的作用-font"><font color='red'>一. assert的作用</font></h2><p>和 <code>if</code> 的作用基本无异，都用来检测一些边界条件和进行安全性检查，如：</p><ol><li>指针是否为空？</li><li>被除数是否为 0？</li><li>函数调用的返回结果是否有效？</li><li>打开一个文件是否成功？</li></ol><p>使用格式：<code>assert(exp);</code></p><p><code>assert</code>  会计算表达式 <code>expression</code>  ，如果其值为假（即为0），那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 <code>abort</code> 来<strong>终止程序运行</strong> 。</p><p>从功能上而言，下面的两种写法等效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="number">0</span> != b);</span><br><span class="line"><span class="comment">//上下两者在功能上等价</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b is zero...&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>同时需要注意，<code>assert</code> 是宏，而非函数：</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(condition) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(condition) <span class="comment">/*implementation defined*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>从上面assert的宏可看出：</p><ol><li>如果定义了宏 <code>NDEBUG</code>，那么 <code>assert()</code> 宏将不做什么动作，也就是相当于一条空语句： <code>(void)0;</code>，<strong>当在 release 阶段编译代码的时候，都会在编译选项中(Makefile)定义这个宏</strong> 。</li><li>如果没有定义宏 <code>NDEBUG</code>，那么 <code>assert()</code> 宏将会把一些检查代码进行替换，我们在<strong>开发阶段执行 debug 模式编译时，一般都会屏蔽掉这 <code>NDEBUG</code> 这个宏</strong> 。一般来说断言 assert() 是仅在 Debug 版本起作用的宏。在发布版本时，我们不应该再依赖 assert() 宏，因为程序一旦出错，assert() 会抛出一段用户看不懂的提示信息，并毫无预警地终止程序执行，这样会严重影响软件的用户体验，所以在发布模式下应该让assert()失效。另外在程序中频繁的调用 assert() 会影响程序的性能，增加额外的开销。</li></ol></blockquote><h2 id="font-color-red-二-assert与if的区别-font"><font color='red'>二. assert与if的区别</font></h2><p><strong><font color=#FF00FF>在功能上没有明显区别。</font></strong> 二者在工程代码中都很常见，没有对错之分，更多只是编程风格和习惯上的差异。</p><blockquote><p><font color='orange'>（1） assert 支持者</font></p><p>我作为 <code>my_concat()</code> 函数的实现者，目的是拼接字符串，那么传入的参数必须是合法有效的，<strong>调用者需要负责这件事</strong> 。如果传入的参数无效，我会表示十分的惊讶！怎么办：崩溃给你看！</p><p><font color='orange'>（2）if 支持者</font></p><p>我写的 <code>my_concat()</code> 函数十分的健壮，我就预料到调用者会乱搞，故意的传入一些无效参数，来测试我的编码水平。没事，来吧，我可以处理任何情况！</p></blockquote><p>从上文我们得知，<code>assert</code> 仅在 debug 模式下有效， release 模式下不会作用。而 debug 模式是用来排除 bug 的，即排除 <strong><font color=#FF00FF>非法情况</font></strong> ，将 <strong>所有可能存在</strong> 的非法情况全部排除后，才能发行（release）。而如果试图用 <code>if</code> 来判断非法情况并处理错误（以此提高所谓的程序 “健壮性” ），则很可能会隐藏本来就需要排查的非法情况。而这样的程序发行之后，随时会因为某些极端情况而崩溃。</p><blockquote><p><strong><font color=#00FFFF>非法情况：</font></strong> 即逻辑层面的 bug 。非法情况是完全不应该出现的情况，逻辑上不允许它的存在。如传入的参数为空指针（<strong>在不同的场景下有不同的要求</strong>）。</p><p><strong><font color=#00FFFF>错误情况：</font></strong> 是可以存在，且无法完全避免的情况，在逻辑允许之内。如 <code>malloc()</code> 未申请到内存，返回 <code>NULL</code> 。</p><p><code>assert</code> 便是用来处理非法情况（验证有效性）它最大作用就是：<strong>在开发阶段，让我们的程序尽可能地 crash。每一次的 crash，都意味着代码中存在着 bug，需要去修正。当我们写下一个 assert 断言的时候，就说明：断言失败的这种情况是是不被允许存在的。必须保证断言成功，程序才能继续往下执行。</strong></p><p><code>if</code> 则是用来处理逻辑上各种可能出现的情况，包括错误情况。每一个分支都是合理的，是允许出现的，我们都要对这些分支进行处理。</p></blockquote><h2 id="font-color-red-三-使用注意事项-font"><font color='red'>三. 使用注意事项</font></h2><ol><li><p><strong>在函数开始处检验传入参数的合法性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">resetBufferSize</span><span class="params">(<span class="type">int</span> nNewSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">assert</span>(nNewSize &gt;= <span class="number">0</span>);     <span class="comment">//nNewSize&lt;0是非法情况</span></span><br><span class="line"><span class="built_in">assert</span>(nNewSize &lt;= MAX_BUFFER_SIZE); </span><br><span class="line"><span class="keyword">if</span>(nNewSize == <span class="number">0</span>)&#123;...&#125;     <span class="comment">//nNewSize=0是可能的情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(nOffset&gt;=<span class="number">0</span> &amp;&amp; nOffset+nSize&lt;=m_nInfomationSize);  <span class="comment">//不好</span></span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line"><span class="built_in">assert</span>(nOffset &gt;= <span class="number">0</span>); </span><br><span class="line"><span class="built_in">assert</span>(nOffset+nSize &lt;= m_nInfomationSize);  <span class="comment">//好</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在发行后遇到问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(i++ &lt; <span class="number">100</span>); <span class="comment">//错误</span></span><br><span class="line"><span class="comment">//========================</span></span><br><span class="line"><span class="built_in">assert</span>(i &lt; <span class="number">100</span>)</span><br><span class="line">i++;               <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p><strong>assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</strong></p></li><li><p><strong>有的地方,assert不能代替条件过滤</strong></p><p>这需要分清 <strong><font color=#00FFFF>非法情况</font></strong> 与 <strong><font color=#00FFFF>错误情况</font></strong> 。</p></li></ol><hr><p>如有错误，烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高质量编写strcpy()</title>
      <link href="/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E5%86%99strcpy/"/>
      <url>/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E5%86%99strcpy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>《高质量C++编程指南》的作者林锐博士，曾去微软中国研究院面试，而面试官让他写一个简单的strcpy()函数。林博士很惊讶，心想这有什么难的。而半小时后，林博士大汗淋漓地走出了”考场“。</p><p>这样一个小不点函数，面试官从三个方面考察：</p><ul><li>代码风格</li><li>出错处理</li><li>算法复杂度分析</li></ul><p>由此可见，编写出合格的strcpy()是不容易的，它尤其考验程序员的基本功和思维的严密性。</p></blockquote><p>下面直接给出最终代码，再逐步剖析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(des == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="built_in">assert</span>(des != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* temp = des;</span><br><span class="line">    <span class="keyword">while</span>((*des++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><font color='orange'>参数类型：</font></strong> 将<code>src</code>的内容拷贝到<code>des</code>中，并不会修改<code>src</code>。所以为了防止误操作改变<code>src</code> ，需要声明为<code>const char*</code>。</li><li><strong><font color='orange'>自赋值：</font></strong> 当<code>des</code>与<code>src</code>相同时，直接返回任意一者。此处的自赋值并不是像实现<code>string</code>类的赋值函数中的那样必要，但无疑，当两者相同时这样处理更高效。</li><li><strong><font color='orange'>检查空指针：</font></strong> 这是绝对必要的一步，不检查会引起崩溃。为什么使用 <code>assert</code> 而不是 <code>if</code>  ，可见<a href="https://jyxcpp.github.io/2022/06/20/assert-yu-if/">详解if与assert</a>。那么为什么要用两行<code>assert</code> 而不直接 <code>assert((dest!=NULL) &amp;&amp; (src !=NULL))</code>?因为前者能定位出错的位置，而后者并不能定位到两个指针中哪个为NULL。</li><li><strong><font color='orange'>保存原始des值：</font></strong> des的指向已经更改，不能直接返回。</li><li><strong><font color='orange'>返回值为什么是<code>char*</code> ：</font></strong> 为了支持链式赋值：<code>int len = strlen(strcpy(des,src))；</code></li></ul></blockquote><p>很多人疑惑为什么不考虑内存重叠（src低于des）的情况，下面是我的猜测：</p><blockquote><ol><li>strcpy()不同于memcpy()，后者能应对内存重叠是因为它有第三个参数n（开辟的字节数），如果发生内存重叠，则可以从高位往低位拷贝，这个过程必须要用n来计数。而前者没有参数n，只能依靠字符串结束符<code>'\n'</code> 来判别终点，所以无法从高位往低位拷贝。</li><li>也许某些时候不要考虑太高的容错性，这样会隐藏人为过失，导致最后bug难以溯源。灵活性 != 容错性。</li></ol></blockquote><hr><p>有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高质量C++编程指南</title>
      <link href="/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8FCpp%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8FCpp%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/img/20220619190951.png" alt="高质量C编程指南"></p><blockquote><p>图片不是很清楚，附上导图pdf和本书pdf：<a href="https://pan.baidu.com/s/1VPet6-2dVqXjLW2gN2fXMQ?pwd=gzwb">高质量C++编程pdf</a>，提取码：gzwb</p></blockquote><p>本书由林锐博士撰写，他的个人经历便可以映射出本书的价值：</p><blockquote><p>我从读大学到博士毕业十年来一直勤奋好学，累计编写了数十万行 C++/C 代码。有 这样的苦劳和疲劳，我应该称得上是编程老手了吧?<br>我开发的软件都与科研相关(集成电路 CAD 和 3D 图形学领域)，动辄数万行程序， 技术复杂，难度颇高。这些软件频频获奖，有一个软件获得首届中国大学生电脑大赛软件展示一等奖。在 1995 年开发的一套图形软件库到 2000 年还有人买。罗列出这些“业绩”，可以说明我算得上是编程高手了吧?<br>可惜这种个人感觉不等于事实。<br>读博期间我曾用一年时间开发了一个近 10 万行 C++代码的 3D 图形软件产品，我内心得意表面谦虚地向一位真正的软件高手请教。他虽然从未涉足过 3D 图形领域，却在 几十分钟内指出该软件多处重大设计错误。让人感觉那套软件是用纸糊的华丽衣服，扯 一下掉一块，戳一下破个洞。我目瞪口呆地意识到这套软件毫无实用价值，一年的心血白化了，并且害死了自己的软件公司。<br>人的顿悟通常发生在最心痛的时刻，在沮丧和心痛之后，我作了深刻反省，“面壁” 半年，重新温习软件设计的基础知识。补修“内功”之后，又觉得腰板硬了起来。博士毕业前半年，我曾到微软中国研究院找工作，接受微软公司一位资深软件工程师的面试。 他让我写函数 strcpy 的代码。<br>太容易了吧?<br>错! 这么一个小不点的函数，他从三个方面考查:<br>(1)编程风格;<br>(2)出错处理;</p><p>(3)算法复杂度分析(用于提高性能)。<br>在大学里从来没有人如此严格地考查过我的程序。我花了半个小时，修改了数次， 他还不尽满意，让我回家好好琢磨。我精神抖擞地进“考场”，大汗淋漓地出“考场”。 这“高手”当得也太窝囊了。我又好好地反省了一次。<br>我把反省后的心得体会写成文章放在网上传阅，引起了不少软件开发人员的共鸣。 我因此有幸和国产大型 IT 企业如华为、上海贝尔、中兴等公司的同志们广泛交流。大 家认为提高质量与生产率是软件工程要解决的核心问题。高质量程序设计是非常重要的环节，毕竟软件是靠编程来实现的。<br>我们心目中的老手们和高手们能否编写出高质量的程序来? 不见得都能!<br>就我的经历与阅历来看，国内大学的计算机教育压根就没有灌输高质量程序设计的观念，教师们和学生们也很少自觉关心软件的质量。勤奋好学的程序员长期在低质量的程序堆中滚爬，吃尽苦头之后才有一些心得体会，长进极慢，我就是一例。<br>现在国内 IT 企业拥有学士、硕士、博士文凭的软件开发人员比比皆是，但他们 接受大学教育时就“先天不足”，岂能一到企业就突然实现质的飞跃。试问有多少软件开发人员对正确性、健壮性、可靠性、效率、易用性、可读性(可理解性)、可扩展性、 可复用性、兼容性、可移植性等质量属性了如指掌?并且能在实践中运用自如?。“高质量”可不是干活小心点就能实现的!</p></blockquote><p>而本书重在给我们灌输高质量编程的观念，弥补大学教育的不足。同时作者给出了许多实用的建议，值得好好阅读。</p><p>本书最后给出了一套C++题目，作者表示如果你能在没有任何提示的情况下，第一次就全对，请你收他为徒。哈哈，试一试吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术书籍笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="/2022/06/19/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/06/19/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-explicit关键字-font"><strong><font color='red'>explicit关键字</font></strong></h3><p>C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, <strong>它的作用是表明该构造函数只能显式调用, 而不能充当转换构造函数</strong>（当构造函数只有一个参数或其他参数都有缺省值时）。 跟它相对应的另一个关键字是implicit,。类构造函数默认情况下即声明为implicit。</p><blockquote><p><strong><font color=#FF00FF>为何尽量对单参数构造函数使用explicit？</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;我被用了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);<span class="comment">// 被隐式转换为func(A(1)) ，本来是1却被自动调用了A(1)这就是拷贝初始化</span></span><br><span class="line">        <span class="comment">//输出：&quot;我被调用了&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上，func(1)可能只是操作失误。</p><p><strong><font color=#FF00FF>什么时候下，构造函数可以充当转换构造函数？</font></strong></p><ul><li>当构造函数只有一个参数且没有<code>explict</code>关键字修饰时。</li><li>当构造函数有多个参数且除第一个参数外其他参数都有默认值（第一个参数也可以有）时。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类内存布局与虚函数表</title>
      <link href="/2022/06/19/%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
      <url>/2022/06/19/%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-类内存布局-虚函数表-font"><strong><font color='red'>类内存布局 + 虚函数表</font></strong></h3><p>sizeof（C）的数值是（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> b;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> *c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color=#FF00FF>类的内存布局：</font></strong></p><ul><li><p><strong><font color='orange'>类中static修饰的变量不占用类大小,因为修饰后存储在静态区域。</font></strong></p></li><li><p><strong><font color='orange'>sizeof是用来计算栈大小，不涉及全局区，故类的静态成员大小sizeof不涉及。</font></strong></p><blockquote><p>对于new或malloc开辟的区域，sizeof计算的也只能是其指针的大小，无法得到开辟的内存大小！</p></blockquote></li><li><p><strong><font color='orange'>类与结构一样,都有字节对齐的问题。</font></strong></p></li><li><p><strong><font color='orange'>含有虚函数的类中，类起始地址会放置一个指向<font color='red'>虚函数表的指针</font>，也占类的内存。</font></strong></p></li><li><p><strong><font color='orange'>类中的枚举也不会占用内存。</font></strong></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体对齐</title>
      <link href="/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-结构体对齐-font"><strong><font color='red'>结构体对齐</font></strong></h3><p>在上下文及头文件均正常的情况下，以下代码打印的结果是（假设运行在 64 位计算机上）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">short</span> *pdata;</span><br><span class="line">    <span class="type">char</span> errstr[<span class="number">32</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">st_t</span> st[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)(st[<span class="number">2</span>].errstr + <span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (p - (<span class="type">char</span> *)(st)));</span><br></pre></td></tr></table></figure><p>A.  32B. 120 C. 114<font color='gree'>D. 144 </font></p><blockquote><p><strong><font color=#FF00FF>结构体对齐：</font></strong></p><ul><li>内部对齐：结构体成员之间会留有空隙。</li><li>外部对齐：在结构体数组中，结构体之间也可能留有空隙。</li></ul><p><strong><font color=#FF00FF>对齐规则：</font></strong></p><p><strong>1.第一个成员在与结构体变量偏移量为0的地址</strong></p><p><strong>2.其他成员变量要对齐到对齐数的整数倍的地址处</strong>(<font color='orange'>对齐数 = 编译器默认的对齐数（VS中为8） 与 成员变量大小的较小值</font>)，即 <strong><font color='gree'>内部对齐</font></strong> 。</p><p><strong>3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数，取所以成员变量中对齐数最大的)的整数倍</strong>，<strong>即<font color='gree'>外部对齐</font></strong></p><p><strong>4. 如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍，如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S3</span> &#123;</span><br><span class="line"><span class="type">double</span> d;  <span class="comment">//▣</span></span><br><span class="line"><span class="type">char</span> c;    <span class="comment">//▤</span></span><br><span class="line"><span class="type">int</span> i;     <span class="comment">//▦</span></span><br><span class="line">&#125;;</span><br><span class="line">               <span class="comment">//s3内存布局：▣▣▣▣▣▣▣▣▤▢▢▢▦▦▦▦  最大对齐数为8</span></span><br><span class="line">                            ↑          ↑     ↑</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S4</span> &#123;                 <span class="number">0</span>          <span class="number">8</span>     <span class="number">12</span></span><br><span class="line"><span class="type">int</span> f;     <span class="comment">//▦</span></span><br><span class="line"><span class="type">char</span> c;    <span class="comment">//▤</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S3</span> s3;  </span><br><span class="line">&#125;;             <span class="comment">//s4内存布局：▦▦▦▦▤▢▢▢▣▣▣▣▣▣▣▣▤▢▢▢▦▦▦▦</span></span><br><span class="line">                            ↑     ↑    ↑    </span><br><span class="line">                            <span class="number">0</span>     <span class="number">4</span>    <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong><font color=#FF00FF>为什么要结构体对齐？</font></strong></p><ul><li><strong>平台原因(移植原因)</strong>： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li><li><strong>性能原因</strong>： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</li></ul><p><strong><font color=#FF00FF>如何使结构体内存尽可能小？</font></strong></p><p>​    <strong>根据成员的大小按从大到小的顺序依次声明即可，如double声明在int前，而int声明在char前</strong> 。</p><p><strong><font color=#FF00FF>修改默认对齐数：</font></strong></p><p>​    <code>#pragma pack(x)//设置默认对齐数为x</code><br>如果不想对齐，直接声明 <code>#pragma pack(1)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板的继承</title>
      <link href="/2022/06/19/%E6%A8%A1%E6%9D%BF-%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/06/19/%E6%A8%A1%E6%9D%BF-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-模板的继承-font"><strong><font color='red'>模板的继承</font></strong></h3><p>下面有关函数模板和类模板的说法正确的有？</p><p><font color='gree'>A. 函数模板的实例化是由编译程序在处理函数调用时自动完成的</font></p><p><font color='gree'>B. 类模板的实例化必须由程序员在程序中显式地指定</font></p><p>C. 函数模板的模板参数仅针对参数类型</p><p>D. 类模板的模板参数仅针对数据成员和成员函数类型</p><blockquote><p>C: 函数模版还可以将 <code>函数返回值类型</code> 作为模版参数。</p><p>D: 类模板还可以针对 <code>继承的基类类型</code> 作为模板参数</p><hr><p><strong><font color=#FF00FF>类模板和类模板之间、类模板和类之间可以互相继承</font></strong>。它们之间的派生关系有以下四种情况：</p><ul><li>类模板继承类模板</li><li>类模板继承模板类</li><li>类模板继承普通类</li><li>普通类继承模板类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==============================================1、类模板继承类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T1 x;</span><br><span class="line">    T2 y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&lt;T2, T1&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T1 x1;</span><br><span class="line">    T2 y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1，T2, T3&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B&lt;T1, T3&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T2 x3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================2、类模板继承模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> A&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="comment">//具体化的模板类</span></span><br><span class="line">&#123;</span><br><span class="line">    T x4;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================3、类模板继承普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x4;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line">    T X5;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================4、普通类继承模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> : <span class="keyword">public</span> F&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数+内联</title>
      <link href="/2022/06/19/%E8%99%9A%E5%87%BD%E6%95%B0-inline/"/>
      <url>/2022/06/19/%E8%99%9A%E5%87%BD%E6%95%B0-inline/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-虚函数-inline-font"><font color='red'>虚函数 inline</font></h3><p>关于虚函数的说法,哪些是正确的( )</p><p>A. 构造函数中调用该类的虚函数，动态绑定机制会生效</p><p><font color='gree'>B. 静态函数不可以是虚函数</font></p><p><font color='gree'>C. 虚函数可以声明为inline</font></p><p>D. 构造函数和析构函数都可以声明为虚函数</p><blockquote><p><strong><font color='orange'>函数绑定：</font></strong> 找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。</p><ul><li><strong><font color='orange'>静态绑定：</font></strong> 在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。</li><li><strong><font color='orange'>动态绑定：</font></strong> 编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。</li></ul><hr><p><strong><font color='orange'>构造函数中调用虚函数问题：</font></strong></p><p><strong><font color=#00FFFF>在构造或析构函数中调用虚函数会执行与之所属类型相对应的虚函数版本。</font></strong></p><p>所以当构造函数中有虚函数时，编译期间就可以确定此虚函数为本类中的函数，不需要再动态绑定。</p><hr><p><strong><font color='orange'>虚函数内联问题：</font></strong></p><p><strong><font color=#00FFFF>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联</font></strong><br>理由如下：内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 <code>inline virtual</code>唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在<strong>编译器具有实际对象而不是对象的指针或引用</strong>时才会发生，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  </span>&#123;  <span class="comment">// 不写inline时隐式内联</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，</span></span><br><span class="line">   <span class="comment">// 编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">   Base b;</span><br><span class="line">   b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，</span></span><br><span class="line">   <span class="comment">// 所以不能为内联。  </span></span><br><span class="line">   Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p><strong><font color=#00FFFF>静态函数不能是虚函数！</font></strong></p><p><em><strong>虚函数是与类对象捆绑的</strong></em>。而类的普通成员函数（包括虚函数）在编译时加入this指针，通过这种方式可以与对象捆绑，而<em><strong>静态函数编译时不加this</strong></em>，因为静态函数是给所有类对象公用的，所以没有在编译时加this，所以无法与对象捆绑，<font color=#FF00FF>而虚函数就是靠着与对象捆绑加上虚函数列表才实现了动态绑定</font>。所以没有this指针虚函数无从谈起。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转型+继承链</title>
      <link href="/2022/06/19/%E8%BD%AC%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E9%93%BE/"/>
      <url>/2022/06/19/%E8%BD%AC%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-2-转型-继承链-font"><em><strong><font color='red'>2. 转型 + 继承链</font></strong></em></h3><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> A* p1 = <span class="keyword">new</span> C;</span><br><span class="line"> B* p2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(p1);  <span class="comment">//L1</span></span><br><span class="line"> A* p3 = <span class="keyword">new</span> A;</span><br><span class="line"> B* p2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(p3);  <span class="comment">//L2</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. L 1语句编译失败，L 2语句编译通过   <font color='gree'> B. L1语句编译通过，L2语句编译失败 </font>    C. L 1，L 2都编译失败       D. L 1，L 2都编译通过</p><blockquote><p><strong><font color='orange'>四种类型转换符：</font></strong></p><ol><li><strong><font color='cornflowerblue'>static_cast</font></strong>：用于良性转换，一般不会导致意外发生，风险很低。</li><li><strong><font color='cornflowerblue'>const_cast</font></strong>：用于 const 与非 const、volatile 与非 volatile 之间的转换。</li><li><strong><font color='cornflowerblue'>reinterpret_cast</font></strong>：高度危险的转换，仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但可实现最灵活的 C++ 类型转换。</li><li><strong><font color='cornflowerblue'>dynamic_cast</font></strong>：<em><strong>借助 RTTI，用于类型安全的向下转型（Downcasting）。</strong></em></li></ol><hr><p><strong><font color='orange'>向下转型</font>：</strong></p><p>当使用 <code>dynamic_cast</code> 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到<em><strong>当前类</strong></em><font color='red'>（指针指向的对象所属的类）</font>的类型信息(type_info)，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p><img src="/2022/img/20220619132309.png" alt="image-20220619132309381" style="zoom:50%;" /><p>故而L1编译能够通过，而L2无法通过编译。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数&amp;虚函数</title>
      <link href="/2022/06/19/%E7%BB%A7%E6%89%BF%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/19/%E7%BB%A7%E6%89%BF%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下程序输出结果是____</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span> ():<span class="built_in">m_iVal</span>(<span class="number">0</span>)&#123;<span class="built_in">test</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout&lt;&lt;m_iVal&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="built_in">func</span>();&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">int</span> m_iVal;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;<span class="built_in">test</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ++m_iVal;</span><br><span class="line">      std::cout &lt;&lt; m_iVal &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  A*p = <span class="keyword">new</span> B;</span><br><span class="line">  p-&gt;<span class="built_in">test</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 1 0   <font color='red'> B. 0 1 </font> <font color='gree'>   C. 0 1 2  </font>  D. 不可预期</p><blockquote><p>本问题涉及到两个方面：</p><ol><li><p><font color='red'>C++继承体系中构造函数的调用顺序：</font></p><p><strong>(1)任何虚拟基类的构造函数按照他们被继承的顺序构造</strong></p><p><strong>(2)任何非虚拟基类的构造函数按照他们被继承的顺序构造</strong></p><p><strong>(3)任何成员对象的函数按照他们声明的顺序构造</strong></p><p><strong>(4)类自己的构造函数</strong></p><blockquote><p>需要注意，<strong><font color=#FF00FF>成员对象在进入类构造函数的函数体前就已经完成了初始化</font></strong> （初始化列表中），函数体内的所有参数都只算赋值。</p></blockquote></li><li><p><font color='red'>构造函数中调用虚函数问题：</font></p><p><strong>在构造或析构函数中调用虚函数会执行与之所属类型相对应的虚函数版本。</strong></p><blockquote><p>原因如下：</p><p>假设构造函数中调用虚函数，其会表现为相应的子类函数行为，并且假设子类存在一个成员变量int a；子类定义的虚函数的新的行为会操作a变量，在子类初始化时根据构造函数调用顺序会首先调用父类构造函数，那么虚函数回去操作a，而因为a是子类成员变量，这时a尚未初始化，这是一种危险的行为，作为一种明智的选择应该禁止这种行为。</p></blockquote></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变长参数列表</title>
      <link href="/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
      <url>/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-可变长参数列表-font"><font color='red'> 可变长参数列表</font></h3><p>该段代码输出（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='gree'>A. 3,3</font>B. 2,2C. 2,3D. 3,2</p><blockquote><p><strong><font color=#FF00FF>参数入栈顺序：</font></strong></p><p>通常情况下c/c++默认入栈方式为<code>__cdecl</code>。</p><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">堆栈清理</th><th style="text-align:left">参数传递</th></tr></thead><tbody><tr><td style="text-align:left">__cdecl</td><td style="text-align:left">Caller</td><td style="text-align:left">以相反的顺序（从右到左）将参数压入堆栈</td></tr><tr><td style="text-align:left">__clrcall</td><td style="text-align:left">n/a</td><td style="text-align:left">按顺序（从左到右）将参数加载到 CLR 表达式堆栈</td></tr><tr><td style="text-align:left">__stdcall</td><td style="text-align:left">Callee</td><td style="text-align:left">以相反的顺序（从右到左）将参数压入堆栈</td></tr><tr><td style="text-align:left">__fastcall</td><td style="text-align:left">Callee</td><td style="text-align:left">存储在寄存器中，然后压入堆栈</td></tr><tr><td style="text-align:left">__thiscall</td><td style="text-align:left">Callee</td><td style="text-align:left">压入堆栈；此指针存储在 ECX 中</td></tr><tr><td style="text-align:left">__vectorcall</td><td style="text-align:left">Callee</td><td style="text-align:left">存储在寄存器中，然后以相反的顺序（从右到左）压入堆栈</td></tr></tbody></table><p>为什么要从右往左入栈？ <strong><font color='gree'>因为要支持可变长参数，如果从左向右，编译器就不知道用户传入了多少实参。 </font></strong> 参数的信息是由第一个参数<code>fmt...</code>确定的（如printf(“%s %s”,str1 ,str2)的参数信息是通过检测两个<code>%s</code>来获取的）。若从左向右压栈，<code>fmt...</code>就被放入了栈底，而栈顶指针由于不清楚各个参数信息，就无法确定偏移量来指向<code>fmt...</code>，所以也无法指向各个参数。相反，若从右向左压栈，<code>fmt...</code>就存放在栈顶，可以直接通过它读取各参数的信息从而确定偏移量。</p><p>所以上题，是先处理<code>*(++p)</code>，再处理<code>*p</code>，故而选A。</p><p><strong><font color=#FF00FF>类型检查与默认参数提升：</font></strong></p><ul><li><p><strong>可变参数部分不会执行类型检查</strong>，因为其原型不能提供可变参数的数目和类型。同时，调用可变参数函数之前必须有其函数原型（这像废话，但在C语言中，函数声明不是必须的，引入头文件(其中的原型)主要作用是用于参数提示和类型检查，而C++中，调用之前必须有原型，否则会报错。</p></li><li><p><strong>可变参数会进行默认参数提升：</strong> <code>char</code>与<code>short</code>总是被提升为<code>int</code>，<code>float</code>总是被提升为<code>double</code>，所以<code>%f</code>可以同时表示<code>float</code>和<code>double</code>。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy与memmove的区别</title>
      <link href="/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-memcpy与memmove的区别-font"><font color='red'> memcpy与memmove的区别</font></h3><p>这两个函数都是将s2指向位置的n字节数据拷贝到s1指向的位置。<font color=#FF00FF>memcpy 假定两块内存区域没有数据重叠，而 memmove 没有这个前提条件</font>。如果复制的两个区域存在重叠时使用memcpy，其结果是不可预知的（ <strong>未定义的</strong> ），有可能成功也有可能失败。原因如下：</p><ul><li><p>当src地址大于dest地址时，即使有重叠，也可以正常复制。<br><img src="/2022/img/20220619095616.webp" alt=""></p></li><li><p>当src地址小于dest地址时，若重叠，则复制发生异常。</p><img src="/2022/img/20220619095613.webp" alt="" style="zoom:80%;" /><blockquote><p>这种情况下，src的地址小于dest的地址，拷贝前3个字节没问题，但是拷贝第4，5个字节时，原有的内容已经被src拷贝过来的字符覆盖了，所以已经丢失原来src的内容。</p><p>然而，vs2019下进行试验，发现即使是在第二种情况下，memcpy与memmove的结果相同，都正确，原因可能是 memcpy 目前也采用了 memmove 的方式。</p></blockquote></li></ul><p><strong>memmove的实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pd = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ps = src;</span><br><span class="line">    <span class="keyword">if</span>((ps + n &gt; pd)&amp;&amp; ps &lt; pd)</span><br><span class="line">        <span class="keyword">for</span> (pd += n, ps += n; n--;)</span><br><span class="line">            *--pd = *--ps;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">            *pd++ = *ps++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>memmove会对拷贝的数据作检查，确保内存没有覆盖，<strong><font color=#FF00FF>如果发现会覆盖数据，简单的实现是调转开始拷贝的位置，从尾部开始拷贝</font></strong> 。<strong><font color='pink'>但是实际在 C99 实现中，是将内容拷贝到临时空间，再拷贝到目标地址中</font></strong> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> tmp[n];</span><br><span class="line"> <span class="built_in">memcpy</span>(tmp,src,n);</span><br><span class="line"> <span class="built_in">memcpy</span>(dest,tmp,n);</span><br><span class="line"> <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>memcpy的实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *dp = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *sp = src;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *dp++ = *sp++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前memcpy已做改进，以下为源码：</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dst &lt;= src || (<span class="type">char</span> *)dst &gt;= (<span class="type">char</span> *)src + len)&#123;</span><br><span class="line"><span class="comment">//没有内存重叠，从低地址开始复制</span></span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//有内存重叠，从高地址开始复制</span></span><br><span class="line">src = (<span class="type">char</span> *)src + len - <span class="number">1</span>;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树的操作</title>
      <link href="/2022/06/19/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/19/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最详细的二叉排序树讲解视频，没有之一：<a href="https://www.bilibili.com/video/BV1EK4y1e7UY/?spm_id_from=333.788">懒猫老师二叉排序树</a></p><p>直接上代码，有简单注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DataType int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BST_node</span></span><br><span class="line">&#123;</span><br><span class="line">DataType data;</span><br><span class="line">BST_node *left;</span><br><span class="line">BST_node *right;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BST_node* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BST</span>(DataType arr[], <span class="type">size_t</span> arr_size);</span><br><span class="line">~<span class="built_in">BST</span>() &#123; <span class="built_in">release</span>(root); &#125;;   <span class="comment">//可以琢磨一下为何要把release放入析构，而不直接用析构来释放内存。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_traverse</span><span class="params">()</span> </span>&#123; <span class="built_in">traverse</span>(root); &#125;<span class="comment">//中序遍历（即按从小到大遍历），同上，思考一下（提示：递归与root）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(DataType key)</span> </span>&#123; <span class="built_in">bi_insert</span>(root, key); &#125;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(DataType key)</span> </span>&#123; root = <span class="built_in">bi_delete</span>(root, key); &#125;<span class="comment">//删除</span></span><br><span class="line"><span class="function">BST_node* <span class="title">search</span><span class="params">(DataType key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">bi_search</span>(root, key); &#125;<span class="comment">//寻找某个指定节点，并返回其地址</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(BST_node*)</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(BST_node* node)</span></span>;<span class="comment">//用于析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bi_insert</span><span class="params">(BST_node*&amp; nood, DataType key)</span></span>;<span class="comment">//注意引用</span></span><br><span class="line"><span class="function">BST_node* <span class="title">bi_delete</span><span class="params">(BST_node* node, DataType key)</span></span>;</span><br><span class="line"><span class="function">BST_node* <span class="title">bi_search</span><span class="params">(BST_node* node, DataType key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::bi_insert</span><span class="params">(BST_node* &amp;Root, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">BST_node* new_node = <span class="keyword">new</span> BST_node;</span><br><span class="line">new_node-&gt;data = data;</span><br><span class="line">new_node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">new_node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">Root = new_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Root-&gt;data &gt; data)</span><br><span class="line"><span class="built_in">bi_insert</span>(Root-&gt;left, data);</span><br><span class="line"><span class="keyword">if</span>(Root-&gt;data&lt;data)</span><br><span class="line"><span class="built_in">bi_insert</span>(Root-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::release</span><span class="params">(BST_node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">release</span>(node-&gt;left);</span><br><span class="line"><span class="built_in">release</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> node;       <span class="comment">//注意！后序遍历删除！！</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">BST::<span class="built_in">BST</span>(DataType arr[], <span class="type">size_t</span> arr_size)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">bi_insert</span>(root, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::traverse</span><span class="params">(BST_node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">traverse</span>(node-&gt;left);</span><br><span class="line">cout &lt;&lt; node-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//只有中序遍历，才能从小到大打印</span></span><br><span class="line"><span class="built_in">traverse</span>(node-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BST_node* <span class="title">BST::bi_search</span><span class="params">(BST_node* node, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;data &gt; key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bi_search</span>(node-&gt;left, key);<span class="comment">//return函数返回值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;data &lt; key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bi_search</span>(node-&gt;right, key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BST_node* <span class="title">BST::bi_delete</span><span class="params">(BST_node* root, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BST_node* target = <span class="built_in">bi_search</span>(root, key);</span><br><span class="line">BST_node* copy_root = root;</span><br><span class="line">BST_node* temp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (root-&gt;data == key)<span class="comment">//情况一：根节点即为被删除的节点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = root-&gt;left;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">root-&gt;left = temp;</span><br><span class="line"><span class="keyword">return</span> copy_root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                </span><br><span class="line">&#123;</span><br><span class="line">BST_node* temp1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> ((root-&gt;left==<span class="literal">NULL</span> || root-&gt;left-&gt;data != key) &amp;&amp;(root-&gt;right==<span class="literal">NULL</span> || root-&gt;right-&gt;data != key)) <span class="comment">//4种可能的情况，最里面的括号中的顺序不可反！！！</span></span><br><span class="line">key &lt; root-&gt;data ? root = root-&gt;left : root = root-&gt;right;</span><br><span class="line">key &lt; root-&gt;data ? temp = root-&gt;left : temp = root-&gt;right;</span><br><span class="line">temp1 = temp-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (temp1 == <span class="literal">NULL</span>)  <span class="comment">//情况二：被删节点没有右子树，则直接将被删节点的左子树连到被删节点的父节点（作为父节点的右子树还是左子树需要判断，见下if-else）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data &gt; root-&gt;data)</span><br><span class="line">root-&gt;right = temp-&gt;left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">root-&gt;left = temp-&gt;left;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                <span class="comment">//被删节点有右子树，则将被删节点的左子树连到右子树的最左叶子节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp1-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">temp1 = temp1-&gt;left;</span><br><span class="line">temp1-&gt;left = temp-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data &lt; root-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">root-&gt;left = temp-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">root-&gt;right = temp-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;arr&#123; <span class="number">12</span>,<span class="number">32</span>,<span class="number">43</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">15</span>,<span class="number">76</span>,<span class="number">48</span>,<span class="number">98</span>,<span class="number">56</span> &#125;;<span class="comment">//刚学习STL，所以采用STL的数组，也可用普通数组</span></span><br><span class="line"><span class="function">BST <span class="title">bi_ser_tre</span><span class="params">(arr.data(), arr.size())</span></span>;</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入9:&quot;</span> &lt;&lt; endl;</span><br><span class="line">bi_ser_tre.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除76:&quot;</span> &lt;&lt; endl;</span><br><span class="line">bi_ser_tre.<span class="built_in">del</span>(<span class="number">76</span>);</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyx坦克大战</title>
      <link href="/2022/06/19/easyx%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
      <url>/2022/06/19/easyx%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>效果图如下：</p><img src="/2022/img/image-20220731195930223.png" alt="image-20220731195930223" style="zoom:50%;" /><p>特色：</p><ul><li>基于像素移动，自由度更高。对地图的破坏基于单元格进行。</li><li>地图编辑器：使玩家能够进行再创作，游戏更加灵活。</li><li>酷酷的音效。实话，这游戏很无聊，最吸引我的是它的bgm。</li></ul><blockquote><p>这个项目是本人在 <strong>01星球</strong> 与小伙伴们合作写的小游戏，也是我的第一个有图形界面的程序（之前都是黑压压的控制台小游戏）。可玩性不高，没有参考意义，仅留做纪念。有兴趣的读者可下载源码：</p><p>链接：<a href="https://pan.baidu.com/s/17PI4mMjW-RfygXp1yS5IjQ?pwd=gzwb">https://pan.baidu.com/s/17PI4mMjW-RfygXp1yS5IjQ?pwd=gzwb</a><br>提取码：gzwb</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树与哈夫曼编码</title>
      <link href="/2022/06/19/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2022/06/19/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈夫曼树的作用：<a href="https://zhidao.baidu.com/question/747308677055660332.html">哈夫曼树是为解决哪种问题发明的</a></p><p>哈夫曼树的构建原理：<a href="http://c.biancheng.net/view/3398.html">哈夫曼树详解</a></p><p>下面浅谈我个人对哈夫曼树的理解及其实现：</p><blockquote><p>阅读网上的哈夫曼树构造方法后，可以发现这是一个重复的过程：提取森林中权值最小的两棵树，并将它们组成新树，再将这个新树再次放入森林，然后重复以上步骤。既然是重复步骤，那么就可以递归实现（实际上，递归也是最易懂，最优雅的方法）。图解如下：</p></blockquote><img src="/2022/img/20220619003149.png" alt="img" style="zoom:67%;" /><ol start="3"><li>把链表第一个（b）和第二个节点©分别作为新根节点new_root的左右孩子，new_root的权值等于左右孩子权值之和，然后将new_root的权值和第三个(d)及其后面的节点权值依次比较，直到找到一个比new_root权值大的节点（找不到则放最后），并把new_root节点插入到此节点之前；重复上述步骤，图解如下：</li></ol><img src="/2022/img/20220619003141.png" alt="img" style="zoom:67%;" /><ol start="4"><li>最后把左孩子的权值改为0，右孩子权值改为1，然后遍历树，对各个字母进行编码代码实现如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">huf_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> data;<span class="comment">//字母或数字</span></span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//权重</span></span><br><span class="line">huf_tree* left;<span class="comment">//左孩子</span></span><br><span class="line">huf_tree* right;<span class="comment">//右孩子</span></span><br><span class="line">huf_tree* rlink;<span class="comment">//右节点</span></span><br><span class="line">string code;<span class="comment">//哈夫曼编码，注意用string更方便！易于递归直接string相加</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">words</span><span class="comment">//临时的结构体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> letters;</span><br><span class="line"><span class="type">int</span> counts;<span class="comment">//字母or数字的出现次数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_huf_tree</span><span class="params">(huf_tree*, <span class="type">int</span>)</span></span>;<span class="comment">//建立哈夫曼树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_lett_arr</span><span class="params">(words**)</span></span>;<span class="comment">//初始化字符的结构体指针数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">essay_data</span><span class="params">(words**)</span></span>;<span class="comment">//提取文章中的字母出现次数,并存入各个字母对应的结构体</span></span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_link_list</span><span class="params">(words**)</span></span>;<span class="comment">//创建哈夫曼树（递归创建）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huf_coding</span><span class="params">(huf_tree* root,string)</span></span>;<span class="comment">//编码（递归）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_code</span><span class="params">(huf_tree* root)</span></span>;<span class="comment">//展示各个字母的码值（递归遍历）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">36</span>;<span class="comment">//26个字母+10个数字</span></span><br><span class="line">words* letter_arr[<span class="number">36</span>]; <span class="comment">//开一个指针数组</span></span><br><span class="line"><span class="built_in">ini_lett_arr</span>(letter_arr);<span class="comment">//初始化字母数组（临时，用以排序）</span></span><br><span class="line"><span class="built_in">essay_data</span>(letter_arr);</span><br><span class="line">huf_tree* head = <span class="built_in">cre_link_list</span>(letter_arr);</span><br><span class="line">huf_tree* root = <span class="built_in">cre_huf_tree</span>(head, n);</span><br><span class="line">root-&gt;code = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">dis_code</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_lett_arr</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">97</span>; i &lt;=<span class="number">122</span>; i++)<span class="comment">//将arr数组0-25设置为存放a-z的小写字母的words结构体</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i<span class="number">-97</span>] = <span class="keyword">new</span> words;<span class="comment">//分配实体空间</span></span><br><span class="line">arr[i - <span class="number">97</span>]-&gt;letters = i;</span><br><span class="line">arr[i - <span class="number">97</span>]-&gt;counts = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">48</span>; i &lt;=<span class="number">57</span> ; i++)<span class="comment">//ASCII码48-57对应字符0-9,分别存入arr[26]-arr[35]</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i - <span class="number">22</span>] = <span class="keyword">new</span> words;</span><br><span class="line">arr[i - <span class="number">22</span>]-&gt;letters = i;</span><br><span class="line">arr[i - <span class="number">22</span>]-&gt;counts = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_huf_tree</span><span class="params">(huf_tree* head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">huf_tree* new_root = <span class="keyword">new</span> huf_tree; <span class="comment">//开辟实体空间</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)<span class="comment">//递归结束的条件：当link_list中只有两个节点，则进行以下操作后返回</span></span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;right = head-&gt;rlink;</span><br><span class="line">new_root-&gt;left = head;</span><br><span class="line">new_root-&gt;data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">new_root-&gt;weight = new_root-&gt;right-&gt;weight + new_root-&gt;left-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br><span class="line">huf_tree* new_head = head-&gt;rlink-&gt;rlink;</span><br><span class="line">huf_tree* temp = new_head;</span><br><span class="line">new_root-&gt;right = head-&gt;rlink;</span><br><span class="line">new_root-&gt;left = head;</span><br><span class="line">new_root-&gt;data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">new_root-&gt;weight = new_root-&gt;right-&gt;weight + new_root-&gt;left-&gt;weight;</span><br><span class="line">head-&gt;rlink-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> step = <span class="number">-1</span>;<span class="comment">//注意，step设置为-1而不是0！由于没有前驱指针（只有后驱指针rlink）,故把A插入BCD中C和D之间，需要把temp停在B而不可停在D！</span></span><br><span class="line"><span class="keyword">if</span> (new_root-&gt;weight &lt; new_head-&gt;weight)</span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;rlink = new_head;</span><br><span class="line">new_head = new_root;   <span class="comment">//如果新产生的根节点权重小于新的头节点，那么此根节点仍然作为链表的头节点；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_root-&gt;weight == new_head-&gt;weight)</span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;rlink = new_head-&gt;rlink;</span><br><span class="line">new_head-&gt;rlink = new_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//否则将产生的根节点插入到链表合适的位置（权值仍从小到达排列）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (new_root-&gt;weight &gt; temp-&gt;weight))<span class="comment">//第一个条件temp!=NULL很重要</span></span><br><span class="line">&#123;</span><br><span class="line">step++;</span><br><span class="line">temp = temp-&gt;rlink;</span><br><span class="line">&#125;</span><br><span class="line">temp = new_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;rlink;      <span class="comment">//将temp移动到要插入位置的前一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">new_root-&gt;rlink = temp-&gt;rlink;</span><br><span class="line">temp-&gt;rlink = new_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cre_huf_tree</span>(new_head, n - <span class="number">1</span>);<span class="comment">//此处是最关键也是最难想到的：将最终生成的根节点一路向上传回给主函数！这招很帅</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">essay_data</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入文段(以&#x27;#&#x27;结尾):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> letter = <span class="built_in">getchar</span>();                      <span class="comment">//这里将所有的字符存入缓冲区，下面的while依次读取</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( letter &gt;= <span class="number">97</span> &amp;&amp; letter &lt;= <span class="number">122</span>)<span class="comment">//小写字母</span></span><br><span class="line">&#123;</span><br><span class="line">arr[letter - <span class="number">97</span>]-&gt;counts++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (letter &gt;= <span class="number">48</span> &amp;&amp; letter &lt;= <span class="number">57</span>)<span class="comment">//数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[letter - <span class="number">22</span>]-&gt;counts++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (letter &gt;= <span class="number">65</span> &amp;&amp; letter &lt;= <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[letter + <span class="number">32</span> - <span class="number">97</span>]-&gt;counts++;<span class="comment">//把大写字母转为小写并存入</span></span><br><span class="line">&#125;</span><br><span class="line">letter = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">if</span> (letter == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_link_list</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)          <span class="comment">//冒泡排序，从小到大；36个字母，排35次即可</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">35</span> - i; k++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k]-&gt;counts &gt; arr[k + <span class="number">1</span>]-&gt;counts)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[k], arr[k + <span class="number">1</span>]);<span class="comment">//用库中的swap()交换指针的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">huf_tree* head = <span class="keyword">new</span> huf_tree;<span class="comment">//为树节点开辟实体空间</span></span><br><span class="line">head-&gt;weight = arr[<span class="number">0</span>]-&gt;counts;</span><br><span class="line">head-&gt;data = arr[<span class="number">0</span>]-&gt;letters;</span><br><span class="line">head-&gt;right = head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">huf_tree* temp_head = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">36</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">huf_tree* huf_node = <span class="keyword">new</span> huf_tree;</span><br><span class="line">huf_node-&gt;weight = arr[i]-&gt;counts;</span><br><span class="line">huf_node-&gt;data = arr[i]-&gt;letters;</span><br><span class="line">huf_node-&gt;left = huf_node-&gt;right = huf_node-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line">temp_head-&gt;rlink = huf_node;</span><br><span class="line">temp_head = temp_head-&gt;rlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huf_coding</span><span class="params">(huf_tree* root,string code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span> || root-&gt;left==<span class="literal">NULL</span>)<span class="comment">//实际上，如果right=NULL，则left必定也为NULL</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left-&gt;code = code + <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root-&gt;left,root-&gt;left-&gt;code);      <span class="comment">//递归需要注意顺序</span></span><br><span class="line"> </span><br><span class="line">root-&gt;right-&gt;code = code + <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root-&gt;right,root-&gt;right-&gt;code);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_code</span><span class="params">(huf_tree* root)</span><span class="comment">//递归遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;data &gt;= <span class="number">97</span> &amp;&amp; root-&gt;data &lt;= <span class="number">122</span>&amp;&amp;root-&gt;weight!=<span class="number">0</span>)<span class="comment">//数字出现很少，所以这里没有加数字，可以自己加上去</span></span><br><span class="line">&#123;                                                         <span class="comment">//只显示有权重的字符，没出现过的不显示</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;%c&#x27; 出现次数：%-4d   哈夫曼码：&quot;</span>, root-&gt;data, root-&gt;weight);</span><br><span class="line">cout &lt;&lt; root-&gt;code &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dis_code</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">dis_code</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/img/20220619003137.png" alt="img" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法一:八皇后回溯</title>
      <link href="/2022/06/19/%E5%85%AB%E7%9A%87%E5%90%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/19/%E5%85%AB%E7%9A%87%E5%90%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>思路来源：<a href="https://www.bilibili.com/video/BV1ZK411K7A8?spm_id_from=333.999.0.0">动画演示八皇后回溯算法</a></p><p>视频演示的非常清楚，也有详细代码，所以此处不再过多剖析，仅展示代码。</p><p>视频中使用vector来储存每次尝试的结果；需要注意的是，vector本质是new开辟的，而下面代码的实现并未使用new开辟空间，而是采用的栈数组，所以撤销操作时，需要<code>深度拷贝</code>，否则函数返回后，数组将失效！</p></blockquote><p><strong><mark class="hl-label blue">方案一：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir_x[<span class="number">8</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;<span class="comment">//创建两个方向数组</span></span><br><span class="line"><span class="type">int</span> dir_y[<span class="number">8</span>] = &#123;  <span class="number">0</span> , <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">              <span class="comment">//  L  LU  LD  R RU RD  U  D      L左，R右，D下,U上 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">int</span>(*temp)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">int</span> i, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_att_que</span><span class="params">(<span class="type">int</span> (*attack)[<span class="number">8</span>], <span class="type">char</span> (*queen)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">char</span>(*queen)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="type">int</span> counts;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> attack[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">char</span> queen[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="built_in">ini_att_que</span>(attack, queen);</span><br><span class="line"><span class="built_in">backtrack</span>(<span class="number">0</span>, attack, queen);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;八皇后问题一共有&quot;</span> &lt;&lt; counts &lt;&lt; <span class="string">&quot;种解法。&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_att_que</span><span class="params">(<span class="type">int</span> (*attack)[<span class="number">8</span>], <span class="type">char</span> (*queen)[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">*(*attack + i) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">*(*queen + i) = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">char</span>(*queen)[<span class="number">8</span>])</span><span class="comment">//n为行数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%  c  &quot;</span>, queen[i][k]);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====================================\n&quot;</span>);</span><br><span class="line">counts++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">8</span>; col++)<span class="comment">//col即column，列数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (attack[n][col] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="built_in">copy_attack</span>(attack,temp);<span class="comment">//备份attack数组</span></span><br><span class="line">queen[n][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//放置皇后；</span></span><br><span class="line"><span class="built_in">update_attack</span>(attack, n, col);</span><br><span class="line"><span class="built_in">backtrack</span>(n + <span class="number">1</span>, attack, queen);<span class="comment">//检测下一行</span></span><br><span class="line"><span class="built_in">copy_attack</span>(temp, attack);<span class="comment">//这里不是备份了！而是撤销之前的update_attack！此处不能直接attack=temp！因为temp是局部变量！函数结束后会被销毁(即需要深拷贝而不是浅拷贝)</span></span><br><span class="line">queen[n][col] = <span class="string">&#x27;#&#x27;</span>;     <span class="comment">//撤销之前放置的皇后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>],<span class="type">int</span>(*temp)[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">temp[i][k] = attack[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> k)</span><span class="comment">//i为行，k为列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt; <span class="number">8</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; <span class="number">8</span>; g++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nx = i + m * dir_x[g];<span class="comment">//nx和ny是被攻击的地方，利用方向数组直接向八个方向辐射！</span></span><br><span class="line"><span class="type">int</span> ny = k + m * dir_y[g];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; <span class="number">8</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">attack[nx][ny] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">方案二：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,  x[N], ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPut</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++) <span class="comment">//这里的j是指m层的上方所有层</span></span><br><span class="line"><span class="keyword">if</span>(x[m]==x[j]  <span class="comment">//检测[m][i]正上方的[m][j]有没有棋子</span></span><br><span class="line">|| <span class="built_in">abs</span>(j-m)==<span class="built_in">abs</span>(x[j]-x[m]))<span class="comment">//检测[m][i]的左右斜上方有没有棋子：j-m=行距; x[j]-x[m]=列距</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n<span class="number">-1</span>)&#123; <span class="comment">//n-1：我们定义的是8皇后，但数组下标从0开始，也就是说m&gt;7时，就已经满足了条件</span></span><br><span class="line">ret++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;    &quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//横向扫描</span></span><br><span class="line"></span><br><span class="line">x[m]=i;      <span class="comment">//此步非常抽象！八皇后棋盘本应是二维，x数组却是一维，这一步便是用一维数组实现二维效果的关键所在！</span></span><br><span class="line"> <span class="comment">//m是指层数，而x[m]，即x[m]中的数，是指所在列数！即x[m]=i表示棋盘位置[m][i]；且一旦对x[m]赋值，就代表在[m][i]处放棋</span></span><br><span class="line"> <span class="comment">//当x[m]重新被赋值为f，则表示在第m行f列重新放棋，之前的x[m]=i所放的棋自然而然的被移到了[m][f]处，所以就避免了上一种方法的撤销操作！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">canPut</span>(m))<span class="comment">//剪枝</span></span><br><span class="line"><span class="built_in">go</span>(m+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">n=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">go</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ret;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案一和方案二的差别在于：方案一利用二维数组，具象地模拟了放棋和撤棋的过程（比如使用*号代表棋子）；而方案而则使用一维数组，利用下标+下标中的数据来模拟放棋。第二种更加巧妙，没有额外空间复杂度，但相比方案一更抽象。</strong></p><hr><p>若有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const与constexpr的区别</title>
      <link href="/2022/06/18/const%E4%B8%8Econstexpr/"/>
      <url>/2022/06/18/const%E4%B8%8Econstexpr/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>constexpr是C++11的内容，其功能是 ==使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段== 。</p><p>提出它的目的主要是为了解决const双重语义的问题。</p><p><strong><font color=#FF00FF> &quot;双重语义&quot;是指”常量“与”只读“。</font></strong></p><p>要搞清楚const与constexpr的关系，首先应该从”常量“与”只读“的区别入手。</p></blockquote><p><strong>只读</strong> ：侧重对变量或对象本身的属性或者权力。即某个变量没有权利(通过自身)更改其内存。如下：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = b;</span><br></pre></td></tr></table></figure><p>不可通过a变量来修改a内存中的内容。</p><p>值得一提的是，这只是强调不可通过a来修改其内存，即不能继续以下操作:</p><p><code>a = 20;//a为只读，不可修改</code></p><p>但是却可以通过其他办法来改变其内存，很简单，使用指针修改即可：</p><p><code>int* pa = (int*)&amp;a;</code></p><p><code>*pa = 30;//a的值就被修改成了30.</code></p><p>需要强调的是，C++中通过引用或指针修改const的值，只适用于赋的值为左值(变量)的情况！(即const int a = b;) 当被赋的值为右值(即字面量)时（const int a = 10;）便不可被修改。至于为什么，请看下文。</p></blockquote><p><strong>常量</strong> ：侧重内存本身是常量，任何方式都无法修改此部分内存，如下：</p><blockquote><p><code>constexpr int a = 10;</code></p><p><strong><font color=#FF00FF>a此时就与一个常量绑定了，在编译期间，a就会被10替换(类似于宏替换)，以达到优化</font></strong></p><p>注意：使用constexpr时，= 右边必须是右值(即字面常量)，而不可为变量！</p></blockquote><p><strong><font color=#00FFFF>为了区分这两者，C++将“常量”交给了constexpr，将“只读”交给了const</font></strong>。</p><p>还需要注意的是，C++与C不同，后者访问const 变量的值是通过其内存获取的，而前者是通过 <strong><font color='orange'>常量折叠</font></strong> （指const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化）来获取其值的。所以当如下定义时，const与constexpr效果完全相同：</p><blockquote><p>const int a = 10;//与下等价：</p><p>constexpr int a = 10;//这两种情况,a的值无论如何也无法改变</p><p>值得一提的是，下面两种情况是不等价的：</p><p>int b = 10;</p><p>const int a = b;//第一种</p><p>const int a = 10//第二种</p><p>第一种情况虽然在语义上和第二种相同，但编译器对二者的处理是不一样的。前者是 <strong><font color='gree'>运行期常量</font></strong> ，后者是 <strong><font color='gree'>编译期常量</font></strong> 。可参考<a href="http://www.bubuko.com/infodetail-3446312.html">此链接</a></p><p>运行期常量不会进行常量折叠，编译器常量才会进行。为什么？因为运行期常量需要等到代码运行时才能确定，我们完全可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="built_in">max</span>(k,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>很显然，a的值需要等到我们输入k后才能确定。</p><p>此时，a就不可进行常量折叠了(因为常量折叠是在编译期进行的，而这时我们还没输入k)，而是通过C语言的方式，在内存的常量区域开辟空间存放常量a的值，且此后获取a的值都需要访问其内存，而不是直接从符号表中获取。下面用一个最简单的例子进行对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[size] = &#123;<span class="number">0</span>&#125;; <span class="comment">//没有问题</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = a;</span><br><span class="line"><span class="type">int</span> arr[size] = &#123;<span class="number">0</span>&#125;; <span class="comment">//报错，因为完全可用在第一行与第二行直接再对a进行运行时修改。</span></span><br></pre></td></tr></table></figure></blockquote><p>最后再简单总结<code>const</code>，<code>constexpr</code>与<code>#define</code>的区别：</p><ul><li><p>const：</p><p>1.const强调为&quot;只读&quot;，本质仍是变量，可以被间接修改(通过引用方式)。</p><p>2.const有可能为编译期常量，也可能为运行期常量。</p><p>3.定义时会在内存中分配，后面调用只是给出对应的内存地址，不再分配，节省内存空间。</p></li><li><p>constexpr：</p><ol><li><p>constexpr强调&quot;不可修改&quot;，是真正的常量。</p></li><li><p><strong>constexpr限定在了编译期常量 。</strong></p></li></ol></li><li><p>宏定义：</p><p>1.在预处理阶段展开；</p><p>2.没有类型，不做类型检查，仅仅是展开；</p><p>3.define宏定义时不分配内存，但是每次调用均会分配一次内存，会造成内存浪费；</p></li></ul><hr><p>有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kruskal算法剖析</title>
      <link href="/2022/06/18/kruskal%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90/"/>
      <url>/2022/06/18/kruskal%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-一-问题引入-font"><font color='red'>一.问题引入</font></h3><img src="/2022/img/20220618230130.png" alt="img" style="zoom: 33%;" /><p>图中的6个顶点分别代表6个村庄，线段的权值代表村庄之间的距离。请问如何找到最短的路径来访问每一个村庄，且每个村庄只访问一次。</p><h3 id="font-color-red-二-解决-font"><font color='red'>二.解决</font></h3><ol><li>提取图的边，并将边按权值大小从小到大排列，并放入edge数组。如下：</li></ol><p><img src="/2022/img/20220618230116.png" alt="img" style="zoom:33%;" /> <img src="/2022/img/20220618230124.png" alt="img" style="zoom:33%;" /></p><ol start="2"><li><p>创建根数组（辅助数组），数组下标代表顶点节点本身，其元素代表顶点的根节点，如下：</p><blockquote><p>提示：这里的“根”并不是树结构中真正的根，一棵树中只有一个根，而这里的“根”泛指长辈，可能是父节点，也可能是“爷”节点。<font color=#FF00FF>初始化根数组为-1，代表初始状态下每个顶点都各自代表一个集合。</font></p></blockquote></li><li><p>将edge数组中的边从小到大依次放回图中，如果后续加入的边与图中已放入的边形成了环，那么将此边丢弃，继续将下一条边放入，规则同前。</p><blockquote><p><font color=#00FFFF>形成环，即说明加入的这条边的起点和终点已经属于一个集合，有共同的根。加入边的过程就是多个子集不断合并的过程，同一集合中的顶点不可相连。前面的辅助数组就是用来判断起点与终点是否属于一个集合</font>。具体实现看代码注释。</p></blockquote></li><li><p>放入（顶点数-1）条边后，最小生成树（Minimum Spanning Tree）构建完成，即可结束循环。</p><blockquote><p>一棵树有n个节点，则有n-1条边</p></blockquote></li></ol><h3 id="font-color-red-三-细节-font"><font color='red'>三.细节 </font></h3><p>上述算法主要有两点需要考虑：</p><ul><li>树的储存</li><li>集合的表示</li></ul><blockquote><p>树的储存：常见的图储存结构有：邻接矩阵,邻接边表,十字链表,邻接多重表,边集数组。显然，上述算法中频繁涉及到对边的操作，所以边集数组是最佳选择。</p><p>集合的表示：使用辅助数组，存放各顶点的根顶点，如果两个顶点的根相同，则属于同一集合，另则相反。初始化辅助数组元素为-1，代表每个顶点本身就是根节点。</p></blockquote><h3 id="font-color-red-四-实现-font"><font color='red'>四.实现 </font></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VEX  10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EDGE 100  <span class="comment">//10个顶点组成的无向图最多有100条边</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>  <span class="comment">//边的属性结构体</span></span><br><span class="line">&#123;</span><br><span class="line">TYPE start;</span><br><span class="line">TYPE end;</span><br><span class="line">TYPE weight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_gragh</span><span class="params">(<span class="type">int</span>&amp; vex, <span class="type">int</span>&amp; edge, Edge* gragh)</span></span>;<span class="comment">//采用边集数组储存图</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_edge</span><span class="params">(Edge* edges,<span class="type">int</span> edge)</span></span>;<span class="comment">//使用冒泡排序，根据权值大小将边从小到大排序</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> n)</span></span>;<span class="comment">//寻找根节点以判断是否在一个集合中</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> vex; <span class="comment">//顶点个数</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> edge; <span class="comment">//边个数</span></span><br><span class="line"> </span><br><span class="line">Edge gragh[MAX_EDGE];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ini_gragh</span>(vex, edge, gragh);<span class="comment">//边集数组初始化图</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">sort_edge</span>(gragh, edge);<span class="comment">//依据权值大小给边从小到大排序</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> roots[MAX_VEX];  <span class="comment">//根数组，存放各顶点的根节点，以区别是否属于同一个集合</span></span><br><span class="line"> </span><br><span class="line">Edge MST[MAX_EDGE];   <span class="comment">//存放最小生成树（minimum spanning tree）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vex; i++)</span><br><span class="line">roots[i] = <span class="number">-1</span>;  <span class="comment">//初始化root数组，-1代表自己就是根节点；初始状态下每个顶点都是独立的根</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_EDGE; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> vex_m = <span class="built_in">find_root</span>(roots, gragh[i].start);<span class="comment">//寻找起点的根节点</span></span><br><span class="line"><span class="type">int</span> vex_n = <span class="built_in">find_root</span>(roots, gragh[i].end);<span class="comment">//寻找终点的根节点</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (vex_m != vex_n)<span class="comment">//如果两者的根节点不同，说明他们属于不同的集合，可以相连</span></span><br><span class="line">&#123;</span><br><span class="line">MST[count] = gragh[i];<span class="comment">//将此边放入MST数组</span></span><br><span class="line">count++;</span><br><span class="line">roots[vex_m] = vex_n;<span class="comment">//将两个树合并，即将顶点vex_n作为vex_m的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == vex<span class="number">-1</span>)<span class="comment">//当count达到顶点数-1，说明最小树已经生成，退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vex - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)%d\n&quot;</span>, MST[i].start, MST[i].end, MST[i].weight);   <span class="comment">//打印最小生成树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_gragh</span><span class="params">(<span class="type">int</span>&amp; vex, <span class="type">int</span>&amp; edge, Edge* gragh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入连通网顶点数：&quot;</span>;</span><br><span class="line">cin &gt;&gt; vex;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入连通网边数： &quot;</span>;</span><br><span class="line">cin &gt;&gt; edge;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;依次输入各边的起点，终点和权重(空格隔开)：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; gragh[i].start &gt;&gt; gragh[i].end &gt;&gt; gragh[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_edge</span><span class="params">(Edge* edges_arr,<span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Edge temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; edge - i - <span class="number">1</span>; k++)<span class="comment">//冒泡排序，注意这里要减1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (edges_arr[k].weight &gt; edges_arr[k + <span class="number">1</span>].weight)</span><br><span class="line">&#123;</span><br><span class="line">temp = edges_arr[k];</span><br><span class="line">edges_arr[k] = edges_arr[k + <span class="number">1</span>];</span><br><span class="line">edges_arr[k + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> roots[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (roots[n] &gt; <span class="number">-1</span>)  <span class="comment">//迭代寻找根节点</span></span><br><span class="line">n = roots[n];</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2022/img/20220618230100.png" alt="img" style="zoom: 50%;" /><hr><p>以上便是关于克鲁斯卡尔算法的剖析，有不对之处烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 图结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11模板可变参数扩展包</title>
      <link href="/2022/06/18/%E6%A8%A1%E6%9D%BF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E5%8C%85/"/>
      <url>/2022/06/18/%E6%A8%A1%E6%9D%BF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文不详细讲解如何在模板中使用可变参数，只浅谈对其中扩展包的理解。<br>看本文前建议先学习如何使用可变参数，推荐链接：<br><a href="http://c.biancheng.net/view/vip_8692.html">C++11在函数模板和类模板中使用可变参数 </a></p></blockquote><h2 id="一-对代码格式的理解">一.对代码格式的理解</h2><ul><li><p>为方便起见，直接把理解写在注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...args&gt;<span class="comment">// ... 旨在说明args是个参数包类型（模板参数包）。  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(T args, args... argv)</span><span class="comment">//... 也旨在说明argv是参数包。</span></span></span><br><span class="line"><span class="function"></span>&#123;                                 <span class="comment">//也就是说，上面两个 ... 相当于类型说明符，告诉编译器这是参数包。</span></span><br><span class="line">    cout&lt;&lt;argc&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">vir_fun</span>(argv...);<span class="comment">//而此处的...与上面的...作用不一样了！此处的...是在扩展参数包（即把包拆开），再依次传参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何理解args与argv？<br>args的作用和T一样，是一种类型，由此可推出 <strong><font color='red'>args是指(模板)参数包类型</font></strong> 。那么就可以顺利推出：第9行的 <strong><font color='red'>1argv就是(函数)参数包类型</font></strong> 。</p></li><li><p>有人可能会问，第二行的函数原型要求至少需要向函数传两个参数，而第12行却只传入了一个参数,似乎有问题？<br>==这就是理解参数包的关键之处==，见下。</p></li></ul><h2 id="二-对参数包的理解">二.对参数包的理解</h2><ul><li><p>参数包实际上是元素+参数包递归组成的，类似于俄罗斯套娃。比如我们向vir_fun()传入这几个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">12</span>, <span class="string">&quot;aha&quot;</span>, <span class="number">12.34</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的函数模板定义，12 应该是argc，后面的三个参数整体则是参数包argv 。<br>而参数包argv是由如下方式组成的：</p><img src="https://img-blog.csdnimg.cn/7793cc15e78d4efabe526fb2001f09df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55So5pe26Ze05Y675rKJ5reA,size_17,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" /></li><li><p>由上图知,第一次递归调用vir_fun()函数时,传入的argv…(见第12行)应该为&quot;haa&quot;+(12.34+10)<br>注意！(12.34+10)仍为参数包！如此，每次递归调用都拆成一个元素+一个参数包</p></li><li><p>读者可能会因为忘记加 … 而出现这样的报错：</p><p><img src="/2022/img/20220618215511.png" alt="img" style="zoom:50%;" />(第13行argv后未加…)</p><p>那么什么叫做<code>扩展参数包</code>？由我们之前的分析，很容易知道扩展参数包就是把参数包拆解为 <strong><font color=#FF00FF>元素+参数包</font></strong> 的形式，拿图1解释，扩展argv参数包就是将其拆为<code>&quot;haa&quot;+argv1</code>参数包的形式！</p></li><li><p>可以用sizeof求参数包个数来验证以上解释：</p><img src="/2022/img/20220618215702.png" alt="img" style="zoom:50%;" /><p>结果为：</p><img src="/2022/img/20220618215815.png" alt="img" style="zoom:80%;" /><p>恰好符合我们图1中的推断。</p></li></ul><hr><p>以上便是笔者个人对参数包的理解，且仅代表个人理解，如有不足或错误，烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
