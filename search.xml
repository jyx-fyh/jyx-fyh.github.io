<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TIME_WAIT与SO_REUSEADDR实操</title>
      <link href="/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/03/16/TIME-WAIT%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>运行环境：Ubuntu 16.0.4</p></blockquote><p>先说结论：</p><ul><li><p>无论是否开启 SO_REUSEADDR ，客户端主动断开连接后，无需等待 TIME_WAIT 即可重连，因为客户端每次 bind 的端口都不一样。由此可见， <strong>TIME_WAIT 是对端口而言</strong> 。</p><blockquote><p>不管是服务器还是客户端，只要是主动断开连接的，都会有 TIME_WAIT 。</p></blockquote></li><li><p>如不开启 SO_REUSEADDR，服务器端主动断开连接，则必须等待 TIME_WAIT 后才可重新 bind 该端口，原因见下文。</p></li><li><p><strong><font color='red'>注意，必须是要在 accept 或 connect 成功返回后（即连接成功后）断连或终止程序，才会有 TIME_WAIT ；仅仅 bind 但未连接成功，终止程序后是不会 TIME_WAIT 的</font></strong> 。</p></li><li><p><strong><font color='red'>注意，如果 bind 指定端口不成功，则会自动 bind 其他任意端口；</font></strong> 。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_server = socket(AF_INET, SOCK_STREAM , IPPROTO_TCP);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>; <span class="comment">//SO_REUSEADDR默认也是0</span></span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span>(opt);</span><br><span class="line">    setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR, &amp;opt, optlen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server failed to bind\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    listen(sock_server, <span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sock_clnt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> != (sock_clnt = accept(sock_server,<span class="literal">NULL</span>,<span class="literal">NULL</span>)))&#123;</span><br><span class="line">        <span class="type">ssize_t</span> size = read(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %ld bytes\n&quot;</span>,size);</span><br><span class="line">        size = write(sock_clnt, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server sent %ld bytes\n=====================&quot;</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sleep(3);  //stop 3s so that client could send FIN first</span></span><br><span class="line">    close(sock_server);</span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="type">int</span> sock_clnt = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    connect(sock_clnt, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="type">char</span> in_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> out_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">99</span>;i++)</span><br><span class="line">        out_buf[i]=<span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> size = write(sock_clnt, out_buf, <span class="keyword">sizeof</span>(out_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sent %ld bytes\n&quot;</span>,size);</span><br><span class="line">    size = read(sock_clnt, in_buf, <span class="keyword">sizeof</span>(in_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client received %ld bytes\n&quot;</span>,size);</span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">//stop 3s so that server could send FIN first</span></span><br><span class="line">    close(sock_clnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编译上述代码，先运行 server 端，再运行 client 端（注意，最好运行可执行文件，不要直接在编译器中运行），结果如下：<br><img src="/2022/img/image-20230316190258629.png" alt="server"><br><img src="/2022/img/image-20230316190325197.png" alt="client"><br>由于客户端 close 前调用了 sleep，所以可以判断一定是 server 主动断开连接，如下图：<br><img src="/2022/img/image-20230316190534357.png" alt=""><br><code>localhost:12345</code> 是本端地址信息，<code>localhost:53188</code> 是对端地址信息，后面的状态是描述本端状态的，因此可知 server 主动发送 FIN 并断开连接后，进入了 TIME_WAIT 状态。此时我们马上重启服务器，则输出以下内容：<br><img src="/2022/img/image-20230316191622035.png" alt=""><br>在 TIME_WAIT 内重启服务器，则报错绑定失败。注意，绑定指定端口失败后，会随机绑定其他端口，如下：<br><img src="/2022/img/image-20230316191842098.png" alt=""><br>第三行的 <code>46937</code> 便是服务器端随机绑定的端口。不过这已经失去意义，因为服务器是通过知名端口来被客户端认识的，客户端根本不认识这些随机端口，所以 server 会一直处于监听状态，不会有 client 来连接。因此，对于服务端，如果 bind 失败，应该直接终止程序或等待 TIME_WAIT 后重新 bind。</p><p>下面我们让 client 主动关闭连接——加上 server 的 sleep ，去掉 client 的 sleep 即可。结果如下：<br><img src="/2022/img/image-20230316193318143.png" alt="server"><br><img src="/2022/img/image-20230316193335972.png" alt="client"><br><img src="/2022/img/image-20230316193425965.png" alt=""><br>本端为 <code>localhost:53200</code> ，可见确实是 client 发起的 FIN 。因为 client 无需 bind 特定端口，即 client 每次运行绑定的端口都不同，所以不用担心会因为 TIME_WAIT 而连接失败。</p><p>接下来我们使用 SO_REUSEADDR 选项来修改 TIME_WAIT 的限制——将 server 代码第 7 行的 opt 赋值为 1 即可，这样就可以无视 TIME_WAIT 直接复用端口。下面是连续两次运行 server 和 client 的结果：<br><img src="/2022/img/image-20230316204302114.png" alt=""><br><img src="/2022/img/image-20230316204349584.png" alt="">你看，即使服务器处于处于 TIME_WAIT 状态，还是可以直接绑定端口并进行通信。</p><p><strong><font color='red'>注意，即使将 SO_REUSEADDR 置 1，TIME_WAIT 状态也依旧存在，只是可以无视该状态直接 bind 而已。</font></strong></p><p>另外，TIME_WAIT 理论相关内容请参见<a href=""></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket网络编程入门笔记</title>
      <link href="/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>初学Socket网络编程的过程中，发现此部分学习有大量细节需要掌握，因此笔记不可忽略！</li><li>Socket编程需要基础网络知识作为前置内容，该部分内容可参见<a href="https://jyx-fyh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础知识笔记</a></li><li>主要参考文章：《UNIX网络编程卷一》《TCP/IP网络编程》</li></ul></blockquote><h3 id="font-color-red-轮廓-font"><font color='red'>轮廓</font></h3><h4 id="font-color-gree-Linux-font"><font color='gree'>Linux</font></h4><h5 id="服务器端">服务器端</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> servSock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    sockaddr_in servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servAddr)); <span class="comment">//&lt;string.h&gt;</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bind</span>(servSock,(sockaddr*)&amp;servAddr,<span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listen</span>(servSock,<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    sockaddr_in clntAddr;</span><br><span class="line">    <span class="type">socklen_t</span> clntAddrSize = <span class="built_in">sizeof</span>(clntAddr);</span><br><span class="line">    <span class="type">int</span> clntSock = <span class="built_in">accept</span>(servSock,(sockaddr*)&amp;clntAddr,&amp;clntAddrSize);</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clntSock,msg,<span class="built_in">sizeof</span>(msg)); <span class="comment">//&lt;unistd.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(clntSock);</span><br><span class="line">    <span class="built_in">close</span>(servSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>过程概述：</font></strong></p><ol><li><strong>调用 socket 来创建一个<font color='gree'>“门卫”</font>套接字，注意，此时仅指定了该套接字的类型（TCP/UDP）</strong></li><li><strong>创建 socket 的身份证（servAddr），指明 IP 地址和端口</strong></li><li><strong>将身份证（servAddr）绑定（bind）到实体（servSock），这样这个套接字被指定了地址和端口</strong></li><li><strong>监听该套接字，时刻准备接受客户端发来的 连接请求</strong></li><li><strong>接受（accept）客户端发来的连接请求，<u>并返回一个新的套接字（clntSock）用来和客户端收发消息</u>。</strong></li><li><strong>消息互动（write 或 read）</strong></li><li><strong>关闭套接字（close）</strong></li></ol><blockquote><p><strong><font color='purple'>“门卫”套接字，即监听套接字，该套接字只用来接收客户端发来的连接请求，并不用来通信！</font></strong> <strong>用来通信的是 accept 返回的套接字（<u>已连接套接字</u>），即 clntSock，其信息被保存在 clntAddr 中</strong> 。<strong>注意，区分监听套接字和已连接套接字非常重要！</strong> 一个服务器程序通常只创建一个监听套接字，而当服务器完成客户端的服务时，相应已连接套接字就会关闭。下图可看到监听套接字和已连接套接字的描述符是不同的，以说明这两个套接字的差异：<br><img src="../../public/2022/img/image-20230309084228825.png" style="zoom:80%;" /></p></blockquote><p><strong><font color='orange'>相关函数和结构体详解：</font></strong></p><p><strong><mark class="hl-label blue">socket</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE38-1678261426526-2.png" alt=""></p><ul><li>family 参数指定协议族，一般我们只用到 IPv4 协议族，即指定 AF_INET 或 PF_INET，两者完全等效。<br><img src="../../public/2022/img/image-20230308155928020.png" style="zoom:67%;" /></li><li>type 指定套接字类型，一般为字节流类型（SOCK_STREAM）或数据报类型（SOCK_DGRAM）<br><img src="../../public/2022/img/image-20230308160015615.png" alt="" style="zoom: 80%;" /></li><li>protocol 敲定最终协议。一般通过前两个参数的组合就能自动推断出最后的协议类型， 但如果前两个参数无法组合出有效协议，则由该参数决定使用何种协议； <strong>如果组合有效，则该参数可直接为 0</strong> ；<br><img src="../../public/2022/img/image-20230308160546219.png" alt="空白表示无效组合"><br>有个小问题，TCP 和 SCTP 重合了，那么如果 protocol 指定为 0，最终协议是 TCP 还是 SCTP 呢？经过实验证明，是 TCP 。</li></ul><p><strong><mark class="hl-label blue">bind</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE42-1678287450215-8.png" alt=""></p><ul><li><p>该函数将 addr 地址结构所包含的信息绑定到 sockfd 套接字上，相当于为套接字办理身份证。</p></li><li><p><strong>bind 可以手动指定 IP 地址或端口，可以两者都指定，也能两者都不指定，如果不手动指定，则按以下方式处理：</strong></p>  <img src="../../public/2022/img/image-20230308162549530.png" style="zoom:80%;" />  **对于 IPv4，通配地址为宏 INADDR_ANY；对于 IPv6，为 in6addr_any** ：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servSock.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br></pre></td></tr></table></figure></li><li><p><strong><u>注意，对于 TCP 而言，如果不手动指定端口，<font color='orange'>则在调用 listen (server) 或 connect (client) 时</font>，内核会选择一个临时端口</u></strong> 。对于客户端而言，我们一般让内核来绑定套接字的端口（除非需要预留端口）；<strong><u>对于服务器端，很少让内核自行决定端口，因为服务器是通过它们的总所周知端口而被外界认识的</u></strong> 。</p></li><li><p><strong><u>对于 TCP 客户端，由内核绑定 IP 地址；对于 TCP 服务器端，如果没有手动绑定，则内核就把客户发送的 SYN 报文中的目的IP地址作为绑定的 IP 地址。</u></strong></p></li></ul><p><strong><mark class="hl-label blue">listen</mark> </strong><br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE40.png" alt=""></p><ul><li>调用 socket 后，默认为主动套接字，调用 listen 后，则转变为监听套接字。</li><li>该函数只用于服务器端。<strong>调用 listen 函数使套接字从 CLOSED 状态转变为 LISTEN 状态</strong> ，参见<a href="https://jyx-fyh.github.io/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">TCP三次握手</a></li><li>bocklog 参数用来指定套接字队列的最大容纳个数。backlog 一直没有正式的定义，不同的操作系统的实现也有所不同，可参见<a href="https://blog.csdn.net/yangbodong22011/article/details/60399728">深入探索 Linux listen() 函数 backlog 的含义</a> ；另外，<strong><u>内核为每个监听套接字维护两个队列：未完成连接队列和已完成连接队列</u></strong> ，详见<a href="">socket等待队列</a> 。</li></ul><p><strong><mark class="hl-label blue">accept</mark> </strong></p><p><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE41.png" alt=""></p><ul><li>注意和 bind 原型的差别！该函数有三个返回值，<strong>一个是新建立的已连接套接字</strong> ，一个是客户端套接字 clntAddr，另一个则是 clntAddr 的长度。<strong>如果对客户端不感兴趣，则后面两个参数可以直接传入 NULL</strong> 。</li><li></li></ul><p><strong><font color='orange'>要点陈列：</font></strong></p><ul><li><code>&lt;sys/socket.h&gt;</code> 和 <code>&lt;arpa/inet.h&gt;</code> 是网络核心头文件！</li><li>Linux 万物皆文件，Socket 套接字也是如此，所以 socket 函数创建一个套接字，并返回该套接字的文件描述符，即一个整型。</li><li></li></ul><h5 id="客户端">客户端</h5><p><strong><font color='orange'>常错点总结：</font></strong></p><ul><li><p>将 sockaddr_in 敲成 sockaddr</p></li><li><p>忘记 memset</p></li><li><p>accept 的第三个参数不同于 bind，须要对 size 取地址</p></li><li><p>别忘了 close</p></li><li><p>对于Linux，socket函数都是<code>&lt;sys/socket.h&gt;</code> ，某些宏，如<code>IPPROTO_XXX</code> 则是<code>&lt;apar/inet.h&gt;</code> 。</p></li><li><p>通过getsockname()获取套接字的信息。</p></li><li><p><strong>猜想：似乎每次回收套接字都需要一定时间？因为如果不调用close，一定时间内重启程序，客户端并不能再次直接连接。</strong><br>似乎和 TIME_WAIT 有关</p></li><li><p>memset 清零的目的是将 sockaddr_in 的成员 sin_zero 字段清零；该字段没有用，只是为了占位，以便和通用</p></li><li><p>一个socket能同时进行多个连接吗？</p></li><li><p>为什么要sockaddr_in --&gt; sockaddr</p></li></ul><h3 id="font-color-red-网络序-font"><font color='red'>网络序</font></h3><ul><li><strong>端口号就是在同一操作系统下为区分不同套接字而设置的，所以不能将一个端口号分配给不同套接字。但注意，tcp和udp不会共用端口号，所以允许重复，比如。。。</strong></li><li><a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_cookies">SYN cookie</a>是一种用于对抗<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/SYN_flood">SYN flood</a>攻击的技术，可以避免在incomplete connection queue被填满时无法建立新的TCP连接。对于使用SYN Cookie的服务来说， 当incomplete connection queue被填满时，<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>会表现得像SYN队列扩大了一样。对于队列填满后的新TCP连接，服务器会返回适当的SYN+ACK响应包，但会丢弃对应的SYN队列条目（因为队列已经满了）。如果服务器收到客户端随后的ACK响应，<strong>服务器能够使用编码在 TCP 序号内的信息重构 SYN 队列条目</strong>。</li><li>等待队列详解博客</li><li>阻塞模式</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英语外刊超精读笔记</title>
      <link href="/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/04/%E8%8B%B1%E8%AF%AD%E5%A4%96%E5%88%8A%E8%B6%85%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="font-color-3b8dfe-词汇-font"><font color=#3b8dfe>词汇</font></h4><p><strong><mark class="hl-label blue">思考</mark> </strong></p><ul><li>contemplate 沉思</li><li>meditate 冥想</li><li>muse</li><li>ponder （powder-粉末）</li><li>chew over</li><li>think over</li></ul><p><strong><mark class="hl-label blue">支出、花费</mark> </strong></p><ul><li>outlay</li><li>expenditure 一般指政府\机构等支出</li><li>spending</li><li>expense</li></ul><p><strong><mark class="hl-label blue">检查、探究、调查</mark> </strong></p><ul><li>examine</li><li>explore</li><li>investigate</li><li>research</li></ul><p><strong><mark class="hl-label blue">匹敌、媲美</mark> </strong></p><ul><li>rival<br>——Nobody could rival him in this respect.</li><li>match</li></ul><p><strong><mark class="hl-label blue">闲逛</mark> </strong></p><ul><li>wander</li><li>roam</li><li>ramble</li><li>stroll</li><li>hang out</li></ul><p><strong><mark class="hl-label blue">描述、描绘</mark> </strong></p><ul><li>describe</li><li>depict</li><li>portray</li><li>present</li></ul><h4 id="font-color-gree-搭配-font"><font color='gree'>搭配</font></h4><ul><li><p>long since 很久以前，早就</p></li><li><p>banish fears 驱除恐惧</p></li><li><p>be afraid of / have fears about sth 对某事有恐惧</p></li><li><p>in one’s image 以…形象</p></li><li><p>dependence on/upon，be dependent on/upon，independence from，be independent of</p></li><li><p>constitute/pose/present a threat to sb 对…构成威胁<br>considerable/major/great/significant/grave/serious threat 巨大/严重的威胁</p></li><li><p>sb is <strong><u>in charge of</u></strong> sth，sth is <strong><u>in the charge of</u></strong> sb</p></li><li><p>pick up an ailment 得病</p></li><li><p>soap opera 肥皂剧，pulp magazine 低俗杂志，mass tastes 大众品味</p></li><li><p>for the good of sb，for sb’s good 为了某人利益</p></li><li><p>uncritical acceptance （盲目地）全盘接受</p></li><li><p><strong>denfend/guard/secure A against B</strong><br><strong>protect/keep/shield A from B</strong></p></li><li><p><strong>be conscious/aware of sth</strong><br><strong>be alert/alive/awake to sth</strong> 意识到、警觉、了解</p></li><li><table><thead><tr><th>除…外（且包含）</th><th>除了（不包含）</th><th>除了（通用，看语境）</th></tr></thead><tbody><tr><td>in addition to</td><td>except (for)</td><td>apart from</td></tr><tr><td>besides</td><td>not counting</td><td>aside from</td></tr><tr><td></td><td>excluding</td><td></td></tr><tr><td></td><td>other than</td><td></td></tr></tbody></table></li><li><p>a densely/thickly/heavily/highly populated area 人口稠密的地区<br>a sparsely/thinly populated area 人口稀少的地区</p></li><li><p>a(n) element/trace/hint/tinge of ，a wee bit 一点、一丝、少量的</p></li><li><p>at a session on sth 在关于…的会议上</p></li><li><p>annual meeting 年会</p></li><li><p>next to 仅次于</p></li><li><p>be responsible for 对…负责</p></li><li><p>associate A with B 将A和B联系</p></li><li><p>up to speed …的最新消息<br>——Jack will bring you up to speed. 杰克将告诉你最新消息。</p></li><li><p>fit the bill/checklist 满足要求，符合条件</p></li><li><p>come by 顺道拜访，得到</p></li><li><p>let alone 更不用说</p></li><li><p>scientific case 科学论据</p></li><li><p>go too far、take sth too far 把某事做得太过<br>——Have child protection measures gone too far?</p></li><li><p>an expert on sth 某方面的专家</p></li><li><p>be concerned with 关心某事</p></li><li><p>out of a hat 随意、随机；像变魔术般<br>——I will pick up a number out of a hat.</p></li><li><p>like rabbits out of a hat 轻易的，不费吹灰之力</p></li><li><p>before long 不久后；long before 很久以前；</p></li><li><p>for one’s amusement 为了让某人取乐</p></li><li><p>sth is less A than B 与其说某物是A，不如说是B</p></li><li><p><strong>bother with 为…花功夫、费神</strong><br>——It’s so facile that you need not to bother with it at all.</p></li><li><p>translate A as B 将A解释成B</p></li><li><p>at the dawn of 在…初期</p></li><li><p>shape the perception 形成观念</p></li><li><p><strong>years to come 后来（的岁月）</strong></p></li><li><p><strong>ascribe/owe/attribute/credit A to B 将A归因于B</strong></p></li><li><p>play down 贬低</p></li><li><p>national consciousness 民族觉醒</p></li><li><p>pull out 撤离</p></li><li><p>pride onesel on (doning) sth、take pride in、be proud of</p></li><li><p>brand sb as 给某人贴上…的标签<br>——The world has branded the entire Chechen nation as terrists.</p></li><li><p><strong>count on 指望</strong></p></li><li><p>mobilize resources 调动资源</p></li><li><p>bring sth to life 使…变得生动有趣</p></li><li><p>touch the nerve points of 触及…的神经</p></li><li><p>power politics 强权政治</p></li><li><p>warn the reports 报告如此警告到<br>says the girl 女孩这样说<br>concludes a study 一份研究得到这样的结论</p></li><li><p>split from = separate from 从…分离出来</p></li><li><p>put a date to 确定…的日期</p></li><li><p>part ways 分道扬镳</p></li><li><p>in response to 作为对…的反应</p></li><li><p>over time 随着时间的推移</p></li><li><p>zone in on 将精力集中到…</p></li><li><p>now that 既然</p></li><li><p>associate professor 副教授</p></li><li><p>account for 解释，是…的原因</p></li><li><p>market cap 市值</p></li><li><p>market capitalization 市值</p></li><li><p>account for / constitude / make up / represent 占比</p></li><li><p>balance sheet 资产负债表</p></li><li><p>seal of approval 正式认可</p></li><li><p>take over 接管，收购</p></li><li><p>in the long term/run 从长远来看</p></li><li><p>put sth in place 将…落实</p></li><li><p>tune out 不理睬</p></li><li><p>rank among 位列</p></li><li><p>in terms of 在…方面</p></li></ul><h4 id="font-color-yellow-句型-font"><font color='yellow'>句型</font></h4><ul><li><strong>The question is whether … 问题在于是否…</strong><br>——The question is whether you are happy to do it.</li><li><strong>But it’s not just sth that matters. 但并非只有…重要</strong></li><li><strong>sb argue that、sb make the argument that. 某人认为、提出论点</strong></li><li><strong>As might be expected 正如所料的那样</strong></li><li><strong>The finding/discovery reinforce the conclusion that 这个发现强化了…的结论</strong></li></ul><h4 id="font-color-orange-长句-font"><font color='orange'>长句</font></h4><ul><li><strong>A sparsely populated country <u>adjoining</u> a densely populated country and <u>sharing</u> with it the same speech and largely the same cutural origins must <u>expect</u> to be dominated for a time.</strong></li><li><strong>Those were the topics of discussion at a session on the ethical and policy implications of dolphin intelligence here today at the annual meeting of the American Association for Advancement of Science.</strong></li><li><strong>That would allow researchers to account for the different human fossil that fall between the divergence and the appearance of more modern-looking people in Africa around 50000 years ago.</strong></li></ul><h3 id="熟词生意">熟词生意</h3><ul><li>see  陪…一起度过<br><strong>My friends saw me through my depression.</strong></li><li>see  经历，遭受<br>Napoleon’s campaigns saw such voracious plundering.</li><li>fall   分布于（区间），属于</li><li>fare 进展，表现</li><li>level 使平整，平坦的</li><li>craft 精心制作，工艺，手艺</li><li>deliberate 仔细考虑，认真商讨</li><li>otherwise 在另一方面</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于CHATGPT的一些想法</title>
      <link href="/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
      <url>/2023/02/10/%E5%85%B3%E4%BA%8ECHAT-GPT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近一个月以来，国内乃至全世界的焦点都汇聚到了chatgpt之上。被chatgpt刷屏后，我个人也不禁产生了一些思考。</p><p><strong><mark class="hl-label blue">chatgpt对我们的生活将造成哪些影响？</mark> </strong><br>很难说。《未来世界的幸存者》中有这样一个观点：未来几十年内，人工智能将使许多传统岗位消失，如客服、信用评估员、市场分析师等；但有些职业是人工智能暂时很难取代的，如画家或律师等艺术性或人文性较强的工作，原因很容易知道，一言以蔽之，机器始终无法替代人类的灵光一闪。之前我也对此观点深信不疑，直到看见了下面这些新闻：<br><img src="/2022/img/b&bo=NwQzBjcEMwYWECA!&rf=viewer_311.jpeg" alt="AI画作：太空歌剧院" style="zoom:80%;" /><br><img src="/2022/img/b&ek=1&kp=1&pt=0&bo=OARgCTgEYAkWECA!&tl=1&vuin=1572676601&tm=1676037600&dis_t=1676037625&dis_k=f9474985ff1e09ce64e0efcb968d67df&sce=50-1-1&rf=viewer_311.jpeg" alt="AI律师" style="zoom:67%;" /></p><p>要知道，该书出版于2018年，至今仅过了短短五年…所以，你很难想象科技的发展速度，谁知道下一个五年将会是什么样呢？就chatgpt而言，虽然目前它的回答尚有较大的瑕疵，但风口已经打开，如周鸿伟所说——“搭不上ChatGPT的企业可能将被淘汰”，大量资本的注入势必会大大增强其性能，所以它的潜力仍然无法预估。不过，有一点我们必须清楚：如果想要避免未来被人工智能取代，就必须从事技术含量高、重复性低、可量化性低的工作。当然，公务员也许不错。</p><p>话说回来，也许不用对未来AI是否会造成失业潮而过度担心呢：<br><img src="/2022/img/image-20230210223238238.png" alt=""><br>本人浅薄地认为，AI过度地取代人工，将生成大量无业游民，进而引发社会动荡，这无疑是政府所不愿看到的。因此，政府可能会进行宏观上的调控。但，即使在调控下AI只会代替少部分人，你又如何保证你不是那倒霉的小部分呢？</p><p><strong><mark class="hl-label blue">由此看到的中外差距</mark> </strong><br>在<a href="https://www.huxiu.com/article/787988.html">《万字拆解：ChatGPT为什么这么强？》</a>论文中，作者向国内同胞们发出了真切的呼吁，此诚危急存亡之秋！包括但不限于人工智能领域，国内外的差距正在不断拉大，而极多数国人却在某些公知不怀好意的误导下，认为我国已经全方位赶英超美，天朝上国无所不能…如此下去，未来中国只有两个方面能够战胜国外——浓香型科技和酱香型科技。</p><p>再来看看我们的企业在干什么：<br><img src="/2022/img/image-20230210231638974.png" style="zoom:50%;" /><br><img src="/2022/img/image-20230210231800724.png" style="zoom:50%;" /><br>国外科技巨头在马不停蹄地创新，国内巨头却在你追我赶地和菜市场的小商贩抢生意。chatgpt爆火后，国内巨头们也争先恐后地计划推出类gpt产品：<br><img src="/2022/img/image-20230210232254477.png" style="zoom:67%;" /><br>个人不认为国内的这场chatgpt争夺战能够分出胜负，反而可能是全军覆没。原因很简单：2022年，OpenAI的算力支出约为4亿美元，人工支出约为9千万美元，光是这两样就达到了惊人的35亿人民币！中国有哪家企业能够下这样的血本？更不要说它的时间成本与技术成本了。在国内浮躁的学术环境和企业环境下，我们很难持续地取得技术创新。下一个5G还有多久？</p><p><strong><mark class="hl-label default">AI可能取代人类吗？</mark> </strong><br><img src="/2022/img/image-20230210222435996.png" alt=""><br>想起了流浪地球2的开头旁白——“起初，没人认为这是一场灾难，直到它和每一个人都息息相关。”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度思维-读书总结</title>
      <link href="/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/27/%E6%B7%B1%E5%BA%A6%E6%80%9D%E7%BB%B4-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几日，我父亲醉酒后拉着我谈心，不知道是酒后起兴还是愁绪积压太久，向我倾诉了他对前半生的无尽悔恨，悔恨学生时代没有自制力（初中名列前茅，中考前被朋友带着打牌，三个月不眠，因此失利；高中仍名列前茅，又被朋友拉着打乒乓，没下课就跑去占台，耗费大量时间）；悔恨早年赚到钱时，没能听朋友劝告进入房地产；悔恨后来发家时，没能及时在深圳买房…父亲微仰着头，泪光不停地闪烁着，“在那个疯狂的、满地是钱的年代，无数个机会从我们面前闪过，然而我一个也没曾抓住。”</p><p>父亲的这些话，令我感触颇多。那个撒钱的年代，为什么机会遍地，却不曾抓住过？当然，任何一件事都有其时代的局限性，马后炮总是容易的。但话说回来，不依旧有很多人脱颖而出，改变了自己的命运吗？有人说他们靠的是胆量，或说凭的是运气。不可否认，这两者差一个都不行，但笔者认为，更重要的是——认知。与认知同义的，还有我们常说的眼界、格局等。最近有句话在网上传得很火——凭运气赚到的钱，总会凭实力亏掉，这句话的背后也许就体现了认知的重要性。如著名畅销书籍《穷爸爸富爸爸》中提到的，为什么一些运动员、演员等红极一时，短时间内赚到了普通人几辈子都赚不到的钱，而十几年甚至几年后就传出破产消息（拳王泰森、影帝尼古拉斯·凯奇都是例证）？个人认为，其背后深层次的原因都是认知（眼界）的不足。打一场拳或拍一部戏就能拿到一笔难以想象的巨款，相信绝大部分人此时都难以压抑自己的消费欲望，对于出身普通的人而言，更是会出现报复性消费，于是买豪车、置豪宅…不出多久，现金流就为负数了。而对于极少数的另一部分人，他们有更高的认知、更远的眼界，则可能用这些巨款继续创造正现金流（买房买车多数时候都属于负债，即负现金流），进而持有更多的资产。</p><p>那么，作为普通人的我们，怎样才能提升自己的眼界呢？又怎么才能把握时代的机遇呢？《深度思维》这本书也许就给出了答案。这本书给出了几种思维技术和思维格局，配以普通人的事例，让我深刻体会到了思维能力的重要性。下面简单谈谈我读完本书的感受。</p><p><strong>文章首先提到了思维链</strong> 。思维链的形式很简单，就是通过对一个问题进行连续追问，从而推测事物的未来走向（5so思考法），或探究问题的本质根源（5why思考法）。别看其思想和步骤极其简单，但结果往往令人吃惊！比如书中的例子，<strong>如何解决墙被腐蚀的问题——只需关上博物馆的窗帘！</strong> 这便是 5why思考法的威力，而普通的思考往往很难达到如此大的跨度。5so思考法同样令我震惊，书中有个精彩的真实案例：上海自贸区要成立了，so？——上海本地的贸易公司业务会繁荣，相应公司的股票一定上涨，so？——物流业务肯定也会被带动，物流公司的股票也值得购买，so？——物流繁荣，港口也一定繁荣，so？——集装箱租赁业务也肯定火爆…最后事实证明这一逻辑链完全正确，少量窥探先机的人则赚得盆满钵满。<br>既然这种简单到人人都会的思想方法能展现出如此巨大的威力，那为什么实际中，受益的人少之又少呢？个人认为，是因为没有刻意训练。方法再厉害也没有用，<strong>只有形成本能，当任何问题发生时，第一时间用这些方法思考问题，才能发挥作用</strong> 。而想要形成本能，就需要我们刻意训练，每当遇到问题，都先问自己，可以用什么样的方法或角度来解决，久而久之就可形成本能。</p><p><strong>接着提到了换位思维</strong> 。额，这还需要说？俺小学就学会了换位思考！小时候，一个小姐姐护士给我扎针，扎错了好几次，紧张得从脖子红到了耳朵，但我没怪她，因为我换位思考，如果我作为一个实习生护士，连续扎错了针，心里该多么紧张和难受啊！所以需要体谅和理解，想到这，我还安慰了这位护士，果然，一下就扎对了…呵呵，首先，这篇读后感不是小学课文；第二，换位思考不仅用于感受和体谅他人，在营销或其他领域也常有应用。还是书中的例子，一旅行社针对高压力的白领群体推出了一款旅游路线，广告语有以下两个：</p><ol><li><strong>风光无限，畅想人生</strong></li><li><strong>你是愿意待在沉闷的办公室里勉强安慰自己小点压力，还是愿意躺在大理洱海边畅快地呼吸新鲜空气？</strong></li></ol><p>高下立判。显然，第一个广告语是从你自己的角度来描述的，这并不能和白领们产生共鸣。而第二个广告语则是站在白领的角度来考虑的。想想，将自己放置于沉闷、阴暗的办公司，耳边嘈杂声不绝，满屋缭绕着对面男同事呼出的二手烟，桌面上堆满了待处理的文件…此时，你不经意抬头，看见了电脑上的第二则广告语，一幅蓝天白云，海边沙滩的画面立刻出现在你的眼前——OMG！去他妈的工作，这洱海我去定了！</p><p><strong>当我们面向的对象是人时，换位思考几乎是不能避免的</strong> 。<strong>记住，谁能引起共鸣，谁就能赢得了客户的心</strong> 。任何时候，问自己一句：如果我是他，我会想什么？我会做什么？每一份直击人心的文案策划，每一次打开局面的商业谈判，每一个引爆用户的产品设计，背后都对应着成功的换位思维。<br>另外，换位思考的一个精彩应用是爱德华·德·博诺博士提出的六顶思考帽，有专门的一本书——《六顶思考帽》详细介绍了该思想。六顶思考帽是利用换位思考，站在六种极端的角度来分析问题，最终得到一份最优的答案。后面有时间再阅读此书并另写读后感，这里就不多说了。</p><p><strong>在可视化思维一章中，文章提到了一种重要的时间管理原则——容易的事先做，重要的事先做</strong> ，经过大量实践，该原则被认为是解决拖延症的不二良方。嗯？就这么个小原则就能解决我多年的拖延症？这也太小看我了吧！再容易的事我也能拖…当然，这并不能解决你的拖延症，因为作者犀利地指出，<strong>这种时间管理原则最大的问题，在于如何评价事情的容易或重要程度</strong> ，就这点，我深有同感！很多时候，我在评价一件事情的重要性或可能性时，总会直接脱口而出：这件事有 80%~70% 的重要（可能）性！喔？70%~80% ，这些确切的数字是怎么得到的？计算得到的？还是调研得到的？又或者是随口一说？很显然，只是随口说说。通过这种模糊不定的评价标准来决策事情的先后，自己本身也会对其产生怀疑，所以当然就不会严格遵守。因此，作者就提出了一套评价标准：<br><img src="/2022/img/未命名绘图37.png" style="zoom:150%;" /><br>有了这样的确切的评价体系，我们就能够更客观地估计事件的优先级。你甚至可以对以上某一角度加权。注意，一旦决定实施这一评价体系，就必须时刻遵守它的结果。比如，算出 A 事件的优先级大于 B 事件，但你自己更喜欢 B 事件，所以你就违背了这一结果，直接先做 B 事件。长期这样违背只会降低这一方式的权威性，直到最后形同虚设。当然，你完全可以将喜爱程度也加入到这一体系中，并对喜爱度加权。</p><p><strong>令我同样印象深刻的还有秘籍型思维</strong> 。秘籍型思维是指，当我们探寻一个人是怎么成功的，或怎么才能做成一件事，最终会将原因归结到某种秘籍——职场能力、个人背景、贵人相助、思维方式…实际上，这种秘籍型思维已经深入我们的骨髓，我们将原因归结为一点，却忽视了别人在其他方面所作的努力。拿我自己举例，高中时，我一直对数学的奇技淫巧很感兴趣，花费大量时间去追求所谓的秒杀方法，基础却没能重视，最后的结果显而易见——基础不牢，地动山摇，高考数学成绩给了我一记耳光。更重要的是，直到大学，我都没有再提起过对数学的兴趣，甚至对其反感和厌恶，我想，这可能会成为我的一生之痛。<br><strong>秘籍型思维将复杂的东西过于简单化，企图用一个相对简单的秘籍去代替复杂的成功规律，而对其他方面的因素视而不见。</strong> 所有成功都是多方面因素促成的结果，单一考虑某一个方面，则有可能使得我们将鸡蛋全部放入一个篮子，增大了事件的风险性。</p><p>与秘籍型思维相反的是思维方法是全流程优化。全流程优化的最诱人的地方在于它的复利性。爱因斯坦曾说，复利是世界的第八大奇迹。全流程优化是指，将一件事情拆分为多个步骤，如果你每个步骤都做得比别人好那么一点，则成效则可能是别人的几倍！这是真正的在平凡中创造伟大！还是拿书中广告软文的例子来说明：<br>文章标题 --&gt; 正文内容 --&gt; 商品软文 --&gt; 链接跳转 --&gt; 店铺页面 --&gt; 支付界面 --&gt; 收获评价<br>富有吸引力的标题能够带来更多流量，这是第一步；正文内容不会直接谈到商品，而是做一些铺垫，这里必须保证足够吸引读者，或者和读者引发共鸣，这是第二步；接着是商品软文，这里需要承上启下，展现商品用途，需要足够打动读者；然后，读者可能成功被你的软文打动！ta尝试点入链接…<br>在以上步骤中，其他几个步骤你可以很容易地优化，比如将店铺页面装饰得漂亮些、评价反馈服务再做得到位一些…那么，链接跳转和支付页面该怎么优化呢？实际上，这两点是最容易被忽略的点，也是很容易丢失客户的点！拿我自己的感受来说，当我点击跳转链接后，经常会提示：“请复制该链接，并在浏览器中打开”，而这会极大地消耗我的耐心和冲动。本来这些软文广告就是在消费我们读者的冲动，而这些冲动都被繁琐的跳转链接给消耗了，还谈什么购买呢？对于支付页面，我也常有体会，很多时候下定决心要购买商品了，却发现没有微信支付，而只有支付宝支付，这每每令我相当恼火。<br>话转回来，如果我们将每个流程都优化 20%，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.</mn><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>4.29</mn></mrow><annotation encoding="application/x-tex">1.2^7=4.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4.29</span></span></span></span> ，你收获的成果将是别人的 4.29 倍！而你多做的努力只有 20% ！这就是复利的威力。因此，重视每一个细节，是我们成功的关键！</p><p>接着书中讲到了生态思维，生态思维侧重于发现事物之间的关系。《浪潮之巅》一书中介绍了计算机行业的一个著名生态链——以微软为首的软件公司吃掉硬件带来的全部好处（比如你内存越大，那我软件也刻意占用越大的内存），迫使用户更新机器让惠普和戴尔等公司收益，而这些计算机制造商再向英特尔这样的半导体厂商订货。在这条链上，相应公司的股票先后都会上涨，因此华尔街的投资者们都知道，如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔的股票。这些投资者们就深谙生态思维和逻辑链的威力。曾经在知乎上还看见一句令我印象很深刻的话：如果大家都知道某个产业赚钱，那就一定不能再挤进去，那怎么办呢——进入这个产业的上游产业。这也是一种生态思维的体现。生态思维下还有几个著名的模型：<strong>淘金模型、森林模型和平台模型</strong> 。<br>淘金模型的底层考虑是共生——如果恶龙太强，那就当恶龙的马仔！额…说错了——如果对手强大如河马，那我们可以成为牙签鸟！淘金模型来源于全球著名牛仔裤制造商李维斯。在疯狂的淘金热下，想要继续挖到大金矿已经几乎不可能，但大量的挖矿工人需要结实耐磨的裤子，聪明的李维斯便开始在金矿附近买起了牛仔裤，从而发展成了后来的著名牛仔裤品牌。相似的例子还有很多，比如为大量捡贝壳以求珍珠的人们提供坚实的橡胶手套。<br>森林模型强调的是错位竞争；平台模型则是为大量竞争者提供平台，而自己则成为平台的收益者。这些方法和事例看似简单，实践起来仍有很大难度。</p><p>文章最后提到的是大势思维。文章有一段很漂亮的话：</p><blockquote><p>古代诗人罗隐说：“时来天地皆同力，远去英雄不自由。”<br>荀子说：“君子生非异也，善假于物也。”<br>小米创始人雷军说：“站在风口上，猪都能飞起来。”</p></blockquote><p>这几句话都是对大势思维的例证。20年前，中国的富豪大多数是搞矿产的；10年前，中国富豪大多数是搞房地产的；现在，中国富豪则大多数是搞互联网的；那么可以预测，未来几十年，中国的富豪可能是发展人工智能或自动驾驶的。身为普通人的我们，又该如何发现并利用趋势呢？其实，趋势下往往隐藏着深刻的经济学规律，而文章中则给出了三条强大的规律——马太效应、科技进步和人口变化。这三条规律能够压制其他任何心理学或经济学规律，值得我们重视。</p><p>书中还有许多精彩的内容，限于笔者精力有限，就不再总结了，详细还请各位细品此书，定能有所收获。</p><p>在这个充满机遇和挑战的时代，共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更安全的用户进程?</title>
      <link href="/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/01/13/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>data_limit_3gb</code></p></blockquote><p>在<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程</a>一文的文尾，笔者留下了一个思考题：既然要求用户不能直接访问内核，那为什么不将用户代码段的界限设置为 3GB 呢？正如之前所演示的那样，如果用户代码段的界限为 4GB，则用户就可以随意修改内核，包括直接访问显存：<br><img src="/2022/img/image-20230112155046604-1673594986128-1.png" alt=""><br>其实笔者也不知道准确的答案，我粗略参考了 Linux 0.11 的代码，发现 Linux 0.11 <u>似乎</u>也是直接将段界限设置为 4GB 。至于规范的防止用户修改内核的方式，咋们以后遇上了再说，现在我们来看看到底能不能通过将数据段界限改为 3GB 来防止用户直接修改内核数据。</p><p>首先将用户数据段的段界限改为 <code>0xbfffffff</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:tss.c</span></span><br><span class="line"><span class="comment">//函数说明:tss_init()</span></span><br><span class="line">*((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xbffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br></pre></td></tr></table></figure><p>还要修改 syscall：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span></span><br><span class="line">    <span class="params">(<span class="string">&quot;int 0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (retval)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a&quot;</span> (no), <span class="string">&quot;b&quot;</span> (_arg1)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.....其他syscall也需要改为内联汇编</span></span><br></pre></td></tr></table></figure><p>为什么要将之前的静态变量方式改成扩展内联汇编呢？说到这，笔者不禁流下了悔恨的泪水…当初我也是为了少学这点看起来复杂的扩展汇编，所以使用了全局静态变量这样的“巧计”来代替这种复杂的汇编。没办法，未来某些场景必须使用到它，所以，该来的早晚会来。话说回来，目前而言，由于我们还没有真正的加载用户进程（真正的用户进程是从文件中读取，进而载入内存的，而当前我们使用函数代替用户进程的），所以一切代码和数据（的标号，即地址），不论用户进程还是内核，都被链接成了 3GB 以上，这都是下面这行 makefile 指令造成的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><p>这条指令将目前的所有文件全部链接成 kernel.bin，并指定入口的虚拟地址为 <code>0xc0001500</code> ，因此，所有的函数和全局、静态变量的地址实际上都在 <code>0xc0000000</code> 以上！所以，我们将用户段的界限限制在 3GB 以下时，在用户态中就不能再使用任何全局变量和静态变量！所以这里的 _syscallX 就不能使用静态变量来中转啦！于是乎，只有改成扩展内联汇编喽。<br>最后，还得修改系统调用入口函数，因为进入中断并不会自动切换 ds、es、fs（只会切换cs），所以咋们必须手动将这几个寄存器修改为内核态的数据段选择子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;.....</span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   push eax</span><br><span class="line">   mov  ax,0x10   ;内核的数据段选择子</span><br><span class="line">   mov  ds,ax</span><br><span class="line">   mov  es,ax</span><br><span class="line">   mov  fs,ax</span><br><span class="line">   pop  eax</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;.....</span><br></pre></td></tr></table></figure><p>ok，来试试看这下能不能直接在用户态访问显存：</p><p><img src="/2022/img/image-20230114134607206.png" alt="image-20230114134607206"></p><p>显然，发生了 GP 异常，禁止访问。说明这样是能够起到一定的保护作用的。来看看正常运行的效果：<br><img src="/2022/img/image-20230114150332216.png" alt=""></p><p>上图中用户只打印了一次，我就使用 Bochs 断点指令将其打断了，因为后面任务切换时引发了程序崩溃，原因就不细说了。这说明通过限制用户数据段的界限来禁止访问内核的这种方式是不可行的。<strong><font color='orange'>实际上，现代操作系统的内存保护机制并非在段上，而是在页上</font></strong> ，关于这点，以后再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆管理-实现malloc</title>
      <link href="/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/"/>
      <url>/2023/01/12/%E5%A0%86%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%8E%B0malloc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>k_block_descs</p><ul><li>为什么 1KB 以上就不分块</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统调用</title>
      <link href="/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/"/>
      <url>/2023/01/11/%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节分支：<code>printk</code></p></blockquote><h3 id="font-color-red-系统调用与API-font"><font color='red'>系统调用与API</font></h3><p>之前很长一段时间，笔者都将系统调用和 API 函数混为一谈，实际上两者有较大区别。</p><p><strong>API (Application Programming Interface，应用程序接口)</strong> ，其主要功能是提供<u>通用功能集</u>，程序员通过调用 API 对应用程序进行开发，可以减轻编程任务。</p><blockquote><p>API 可以简单的理解为一个通道或者桥梁，是一个程序和其他程序进行沟通的媒介，本质上一个函数。比如我们想往屏幕上打印字符，显然，如果自己从头实现，则需要了解显卡、汇编等知识，无疑相当麻烦。而且 C 库中早就为我们准备了打印函数，即 printf，你只需要按它的要求传入参数就行，无需了解 printf 内部实现。所以 printf 也可以称为 API 。说白了，<strong>接口，就是指两个不同程序之间交互的地方</strong> ，就这么简单。</p></blockquote><p>而系统调用是一种特殊的接口，通过这个接口，用户可以访问内核空间，进而实现一些只有内核才能完成的操作，比如屏幕打印、内存申请（malloc）等。<br>那么这两者有什么区别呢？严格来说，两者没有直接关系，但一般而言，系统调用一般封装在 API 中，但不是所有 API 内部都会进行系统调用。<strong>API 的提供者是运行库，运行库则使用操作系统提供的系统调用接口</strong> ，如果再往下，内核则调用驱动程序，由驱动程序来和硬件打交道。</p><h3 id="font-color-red-系统调用实现原理-font"><font color='red'>系统调用实现原理</font></h3><p>系统调用的直接目的是进入 ring0，以便进行一些只有 ring0 才能完成的工作。我们之前说过，想要从低特权级进入高特权级，则只能通过门完成。由于调用门开销较大，Linux 选择通过中断门进入高特权级，并进行系统调用。<strong><font color='orange'>Linux 系统调用的中断号为 0x80，子功能号存入 eax，而 ebx、ecx、edx、esi 和 edi 则依次传递最多五个参数，当系统调用返回时，返回值存放在 eax 中</font></strong> 。</p><blockquote><p>如果要传入五个以上的参数，则需要使用栈传递参数，后文将演示这一过程。</p></blockquote><p>如果细分，Linux 系统调用可以分为三种方式：<br><strong><mark class="hl-label blue">通过 glibc 提供的库函数</mark> </strong><br>glibc 是 Linux 下使用的开源的标准 C 库。glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了系统调用。比如通过 glibc 提供的 <code>chmod</code> 函数来改变文件 <code>etc/passwd</code> 的属性为 444：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rc;</span><br><span class="line">        rc = chmod(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="number">0444</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;chmod failed, errno = %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;chmod success!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用syscall</mark> &quot;</strong><br>syscall 也由库函数提供，但相比于其他调用方式， syscall 则更加灵活，比如你通过编译内核增加了一个系统调用，这时 glibc 不可能有你新增系统调用的封装 API，所以你可以利用 glibc 提供的 <code>syscall</code> 函数直接调用，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">syscall</span> <span class="params">(<span class="type">long</span> <span class="type">int</span> sysno, ...)</span></span><br></pre></td></tr></table></figure><p>其中 sysno 是系统调用号（子功能号），每个系统调用都有唯一的系统调用号来标识；<code>...</code> 则是可变参数列表，根据系统调用的不同，可带0~5个不等的参数，如果超过特定系统调用能带的参数，多余的参数被忽略。<br><strong><mark class="hl-label blue">通过int指令调用</mark> </strong><br>直接通过内联汇编进行系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rc;</span><br><span class="line">    <span class="type">char</span> *file_name = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode = <span class="number">0444</span>;</span><br><span class="line">    <span class="keyword">asm</span></span><br><span class="line">    (</span><br><span class="line">     <span class="string">&quot;int $0x80&quot;</span></span><br><span class="line">    :<span class="string">&quot;=a&quot;</span> (rc)</span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (SYS_chmod), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)file_name), <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)mode)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容易知道，这三种方式最终都会使用 <code>int</code> 指令进行系统调用</strong> 。</p><h3 id="font-color-red-实现系统调用-font"><font color='red'>实现系统调用</font></h3><p><strong><mark class="hl-label blue">添加_syscallX</mark> </strong><br>实际上，库函数也是通过操作系统提供的 _syscallX 宏来进行系统调用，其中 X 是参数个数，以 _syscall3 举例，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, atype, a, btype, b, ctype, c)              \</span></span><br><span class="line"><span class="meta">type name(atype a,btype b,ctype c)&#123;                                      \</span></span><br><span class="line"><span class="meta">long __res;                                                              \</span></span><br><span class="line"><span class="meta">asm volatile                                                             \</span></span><br><span class="line"><span class="meta">    (<span class="string">&quot;int $0x80&quot;</span>                                                         \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res)                                                       \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a)),<span class="string">&quot;c&quot;</span> ((long)(b)),<span class="string">&quot;d&quot;</span> ((long)(c))) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res&gt;=0)                                                            \</span></span><br><span class="line"><span class="meta">return (type) __res;                                                 \</span></span><br><span class="line"><span class="meta">errno=-__res;                                                            \</span></span><br><span class="line"><span class="meta">return -1;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>各位无需了解以上代码的含义，咋们会契合自己的操作系统，使用更简单的方式实现。另外，此 _syscallX 已经被 Linux 废弃，但为了简单，我们仍模仿 _syscallX 进行系统调用。</p><p>由于我们的操作系统最多只会使用三个参数的系统调用，所以这里咋们只实现 0~3 个参数的系统调用，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> callno_ret;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg1;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg2;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> arg3;</span><br><span class="line"><span class="type">uint32_t</span> _syscall0(<span class="type">uint32_t</span> no)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall1(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall2(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> _syscall3(<span class="type">uint32_t</span> no, <span class="type">uint32_t</span> _arg1, <span class="type">uint32_t</span> _arg2, <span class="type">uint32_t</span> _arg3)</span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = no;</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    arg2 = _arg2;</span><br><span class="line">    arg3 = _arg3;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ecx,arg2&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov edx,arg3&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于为什么要使用静态变量，这已在之前的文章多次提及，不再说明。</li></ul><p>啊哈，很简单吧！这里只解释 <code>mov callno_ret,eax</code> ：因为系统调用也遵循 ABI 规范，即，将返回值存入 eax 中，所以我们还要将 eax 转移到静态变量 callno_ret 中，并将其返回（callno_ret 即说明它既用来存放调用号，也用来作为返回值）。</p><p><strong><mark class="hl-label blue">编写中断入口函数</mark> </strong><br>进入 0x80 中断例程后，代码会根据传入的调用号跳转到相应的函数，函数执行完毕后回到中断，再通过 iret 返回到用户态。0x80 中断例程代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;文件说明:interrupt.s</span><br><span class="line">;......上文忽略.......</span><br><span class="line">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;</span><br><span class="line">[bits 32]</span><br><span class="line">extern syscall_table</span><br><span class="line">section .text</span><br><span class="line">global syscall_handler</span><br><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EID</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 为系统调用子功能传入参数</span><br><span class="line">   push edx            ; 系统调用中第3个参数</span><br><span class="line">   push ecx            ; 系统调用中第2个参数</span><br><span class="line">   push ebx            ; 系统调用中第1个参数</span><br><span class="line"></span><br><span class="line">;3 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;4 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><ul><li>以上代码的格式和之前中断处理的格式完全相同，不再赘述。</li><li><code>syscall_handler</code> 为系统调用的入口，所有系统调用都会通过该入口函数进入到指定的子功能处理函数。</li><li>第 25 行， <code>syscall_table</code> 是在 <code>syscall_init.c</code> 中定义的指针数组，该数组中存放的是各个系统调用的指针。</li><li>第 28 行，将存放返回值的 eax 存入内核栈的相应位置。为什么要这样呢？因为从用户态进入中断时，保存现场，存放调用号的 eax 被存入中断栈；所以从中断返回，恢复现场时，调用号重新被放入 eax；但 eax 必须用来存放返回值，所以必须将返回值提前放入中断栈的相应位置处，这样才能在返回用户态后从 eax 取得返回值。</li></ul><p><strong><mark class="hl-label blue">为 0x80 中断例程建立中断描述符</mark> </strong></p><p>想要通过 0x80 正确进入到相应例程，就必须建立相应的中断描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:idt.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_CNT 0x81  <span class="comment">//修改为0x81</span></span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    make_idt_desc(&amp;idt[<span class="number">0x80</span>],IDT_DESC_DPL3,syscall_handler); <span class="comment">//为0x80建立中断描述符</span></span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//........</span></span><br></pre></td></tr></table></figure><p>现在完事具备，就差一个具体的系统调用啦！为了让用户进程能够说话，咋们先实现 write 系统调用，该调用可以在屏幕上打印文字。</p><h3 id="font-color-red-加入write系统调用-font"><font color='red'>加入write系统调用</font></h3><p>write系统调用相当简单，不过是对 console_put_str 的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(str,DEFUALT);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这是实际的子功能函数，是通过 <code>syscall_handler</code> 中断入口函数调用的，而不是被用户直接调用。用户调用的 write 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall.c</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_WRITE,(<span class="type">uint32_t</span>)str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>SYS_WRITE</code> 为调用号，定义在 syscall.h 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SYSCALL_NR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SYS_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'><u>如此一来，整个系统调用的流程就清晰的呈现在我们眼前：</u></font></strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRB(write)--&gt;L(_syscall1)--&gt;G(int 0x80)--&gt;K(syscall_handler)--&gt;A(sys_write)  </pre></div><p>最后，别忘了初始化系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:syscall_init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    syscall_table[SYS_WRITE] = sys_write;</span><br><span class="line">    console_put_str(<span class="string">&quot;syscall_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:init.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;init_all\n&quot;</span>,DEFUALT);</span><br><span class="line">    idt_init();    <span class="comment">// 初始化中断</span></span><br><span class="line">    timer_init();  <span class="comment">// 初始化PIT</span></span><br><span class="line">    thread_init(); <span class="comment">// 初始化线程相关结构</span></span><br><span class="line">    mem_init();   <span class="comment">// 初始化内存管理系统</span></span><br><span class="line">    console_init();<span class="comment">// 初始化终端输出</span></span><br><span class="line">    tss_init();    <span class="comment">// 初始化tss</span></span><br><span class="line">    syscall_init();<span class="comment">// 初始化系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前用户进程无法直接调用 print 系列函数进行打印（否则发生 0xd 号异常），现在实现了 write 系统调用，就可以让它说话啦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line">    process_execute(u_prog_a,<span class="string">&quot;proa&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hi,man\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/protalk.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h3 id="font-color-red-栈传递参数-font"><font color='red'>栈传递参数</font></h3><p>前文说到，如果参数超过五个，那么寄存器就不够用了，此时只能通过栈来传递。其实通过栈传递参数是调用门的原生做法，这点在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中有提到过。对于中断门而言，使用栈传递需要手动实现，但也很简单：进入中断时，处理器自动压入旧栈的 ss 和 esp，由于段基址都为 0，所以我们就能直接根据该 esp 定位到旧栈中的参数（因为旧栈压入参数后，调用中断，旧栈的 ss 和 esp 紧接着就被自动压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断剖析</a>），图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE36-1673590654821-2.png" alt=""><br>根据上图，就很容易知道如何从旧栈获取参数啦，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syscall_handler:</span><br><span class="line">;1 保存上下文环境</span><br><span class="line">   push 0               ; 压入0, 使栈中格式统一</span><br><span class="line">   push ds</span><br><span class="line">   push es</span><br><span class="line">   push fs</span><br><span class="line">   push gs</span><br><span class="line">   pushad               ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span><br><span class="line">                        ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span><br><span class="line">   push 0x80            ; 此位置压入0x80也是为了保持统一的栈格式</span><br><span class="line"></span><br><span class="line">;2 获取当前栈中esp的值</span><br><span class="line">   mov ebx,[esp+4+48+4+12]</span><br><span class="line">;3 再将参数压入当前栈中</span><br><span class="line">   push dword [ebx+12]  ; 系统调用中第3个参数</span><br><span class="line">   push dword [ebx+8]   ; 系统调用中第2个参数</span><br><span class="line">   push dword [ebx+4]   ; 系统调用中第1个参数</span><br><span class="line">   mov eax,[ebx]        ; 子功能号</span><br><span class="line">;4 调用子功能处理函数</span><br><span class="line">   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span><br><span class="line">   add esp, 12                      ; 跨过上面的三个参数</span><br><span class="line">;5 将call调用后的返回值存入待当前内核栈中eax的位置</span><br><span class="line">   mov [esp + 8*4], eax</span><br><span class="line">   jmp intr_exit                    ; intr_exit返回,恢复上下文</span><br></pre></td></tr></table></figure><h3 id="font-color-red-思考-font"><font color='red'>思考</font></h3><p>你可能会问，为什么不直接在 API 中进行系统调用呢，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    callno_ret = SYS_WRITE</span><br><span class="line">    arg1 = _arg1;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov eax,callno_ret&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov ebx,arg1&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;int 0x80&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov callno_ret,eax&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callno_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式不是更直接吗？为啥还要通过 syscallX 来进行系统调用？答案是代码复用。系统调用有上百上千个，而它们的调用代码都像上面这样相似，如果每个函数都采用这种方式，无疑是相当冗余的。若参数个数相同的系统调用都使用同一种 syscall，如 syscall3，这样不就大大减少了代码量吗？</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf加强-支持short与long long</title>
      <link href="/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
      <url>/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/">printf 底层剖析及可变参数探究</a><br>本文参考文章：<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a> ，<a href="https://blog.csdn.net/kjlist2017/article/details/104113265">使用位运算代替取模</a><br>本节对应分支：<code>printk-enhanced</code></p></blockquote><p>上节说到 Linux 0.11 的 printk 不支持输出 short （不是不支持，而是表现得和 int 相同）和 long long，本节修改代码来支持 <code>%hd</code> 和 <code>%lld</code> 。<br>本以为很简单，只需像之前那样对 short 或 long long 数值不断除以基数并取模，依次得到数字字符，然后组成字符串即可。没想到的是，Bochs 的 <strong>32 位 x86 环境不支持 64 位除法和取模运算</strong> ，也就是说无法支持以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = a / b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = a % c;</span><br></pre></td></tr></table></figure><p>否则会报错，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `__divdi3&#x27;</span><br><span class="line">undefined reference to `__moddi3&#x27;</span><br></pre></td></tr></table></figure><p><strong><code>__divdi3</code> 和 <code>__moddi3</code> 是 gcc 为我们准备的 64 位除法和取模函数，当发生以上情况时，就用这两个函数来模拟除法和取模</strong> 。但由于咋们是自己实现操作系统，所以不能引入外部库函数（就算能，俺也不愿意，俺可不想让复杂的库函数来破坏我们操作系统的简洁性，而且链接了一个库，往往会连着其他许多库）。所以，我们要自己实现 64 位除法和取模函数。</p><p>坏消息是，笔者找了一天的相关资料，发现要么实现过于复杂，要么函数有 bug 。绞尽脑汁时，突然在知乎大佬的<a href="https://zhuanlan.zhihu.com/p/112361959">一篇文章</a>中看见了这样一个等式：</p><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x=2^{32}×H+L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></strong></p><p>其中 H 为 64 位整型 x 的高 32 位，L 为低 32 位。笔者狂喜，接着在草稿纸上写下了如下等式：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>y</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x/y=(2^{32}×H+L)/y=2^{32}×H/y+L/y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><br>其中 y 为 32 位整型，因为 y 就是基数 base，范围在 2~32 之间。<br>这样一来，不就将 64 位除法转换为了 32 位除法吗？哇哈哈哈哈，原来不过如此嘛！等着，别急，突然觉得哪有问题…计算机的除法是向下取整的，这也能使用分配律吗？当然不行，反例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">29</span>+<span class="number">32</span>)/<span class="number">8</span>=<span class="number">29</span>/<span class="number">8</span>+<span class="number">32</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span>  <span class="comment">//该等式成立,但换个方式拆分就不行了:</span></span><br><span class="line"><span class="number">61</span>/<span class="number">8</span>=(<span class="number">31</span>+<span class="number">31</span>)/<span class="number">8</span>=<span class="number">31</span>/<span class="number">8</span>+<span class="number">31</span>/<span class="number">8</span>=<span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span>  <span class="comment">//哦豁</span></span><br></pre></td></tr></table></figure><p>所以此方法无效喽，那怎么办？别急，考虑到我们的除法有一定特殊性，除数只为 8、10、16（printf只支持这三种格式打印），这个特性也许能用上。先想想，为什么取整除法不能像上面那样分配？因为拆分方式会影响两方的精度丢失情况，随着双方的精度丢失情况变化，就会影响最终结果。那么，使另一方被整除，从而将精度丢失只划给一方，这样不就能保证结果不受拆分方式而改变了吗？具体做法如下：</p><p>对于八进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>3</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><msup><mn>2</mn><mn>29</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">x/8=(2^{32}×H+L)/2^{3}=2^{32-3}×H+L/8=2^{29}×H+L/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/8</span></span></span></span></font><br>对于十六进制：<font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>4</mn></mrow></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>28</mn></msup><mo>×</mo><mi>H</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">x/16=(2^{32}×H+L)/2^4=2^{32-4}×H+L/16=2^{28}×H+L/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span><span class="mbin mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/16</span></span></span></span></font><br>可以发现，精度丢失只发生在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">L/base</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span></span></span></span> 上，所以结果一定正确。</p><p>上面解决了 64 位除法的问题，那取模怎么解决呢？使用位运算的一个特性就可以完美解决这个问题：<br><u><strong><font color='orange'>取模运算 (a%b) 在当 b 为 2^n 时可简化为 a &amp; (b - 1)</font></strong></u></p><blockquote><p>简单证明：当 b 为 2^n 时,a/b的意义就是 a 右移 n 位，而右移的 n 位的值，就是 a%b 的值。</p></blockquote><p>以上除法和取模的方法只能用于 2 的幂，而 10 不是 2 的幂，所以只有另找办法了。所幸，那位知乎大佬的代码恰好能解决这个问题，详细参见<a href="https://zhuanlan.zhihu.com/p/112361959">x86环境下将64位整数转换为字符串 - 仲夏夜的乙醇</a>。最终代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG    128     <span class="comment">//if long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_10</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = *n % <span class="number">10</span>;</span><br><span class="line">    *n = *n / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_div_16_8</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *n, <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = base==<span class="number">16</span>?<span class="number">28</span>:<span class="number">29</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> low = *n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hign= (*n)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mod = ((*n)&amp;(base==<span class="number">16</span>?<span class="number">15</span>:<span class="number">7</span>)); <span class="comment">//a &amp; (base - 1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(<span class="number">1</span>&lt;&lt;t) * hign + low / base;</span><br><span class="line">    *n = tmp;</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">long</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;LEFT) type &amp;= ~ZEROPAD;</span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) size--;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">16</span>) size -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">16</span> || base==<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> *p = &amp;num;</span><br><span class="line">            *(++p) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div_16_8(&amp;num,base)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LONG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">                tmp[i++] = digits[do_div_10(&amp;num)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> low = num;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hign= num&gt;&gt;<span class="number">32</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i++] = ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                low = <span class="number">429496729</span> * (hign % <span class="number">10</span>) + low / <span class="number">10</span> + ((hign % <span class="number">10</span>) * <span class="number">6</span> + low % <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">                hign = hign / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;precision) </span><br><span class="line">        precision=i;</span><br><span class="line">    size -= precision;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line">    <span class="keyword">if</span> (type&amp;SPECIAL) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line">    <span class="type">int</span> flags;<span class="comment">/* flags to number() */</span></span><br><span class="line">    <span class="type">int</span> field_width;<span class="comment">/* width of output field */</span></span><br><span class="line">    <span class="type">int</span> precision;<span class="comment">/* min. # of digits for integers; max number of chars for from string */</span></span><br><span class="line">    <span class="type">int</span> qualifier;<span class="comment">/* &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields */</span></span><br><span class="line">    <span class="keyword">for</span> (str=buf ; *fmt ; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process flags */</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">        repeat:</span><br><span class="line">        ++fmt;<span class="comment">/* this also skips first &#x27;%&#x27; */</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get field width */</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* get the precision */</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++fmt;</span><br><span class="line">                <span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the conversion qualifier */</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            fmt++;</span><br><span class="line">            <span class="keyword">if</span>(*fmt == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qualifier = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                flags |= LONG;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (*fmt) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">                len = <span class="built_in">strlen</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                    precision = len;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                    len = precision;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                    <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                    *str++ = *s++;</span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    field_width = <span class="number">8</span>;</span><br><span class="line">                    flags |= ZEROPAD;</span><br><span class="line">                &#125;</span><br><span class="line">                str = number(str,(<span class="type">unsigned</span> <span class="type">long</span>) va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                flags |= SMALL;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)<span class="comment">// %llx</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                flags |= SIGN;</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(qualifier==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">short</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(qualifier==<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">                *ip = (str - buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (*fmt)</span><br><span class="line">                    *str++ = *fmt;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --fmt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>do_div_16_8 函数就是处理 16 进制和 8 进制的例程，逻辑和前文所述相同，不再赘述。</p></li><li><p>此版本用 do_div_10 来代替了之前版本的 do_div 函数，没什么原因，只是不喜欢内联。do_div_10 只用来处理 32 位除法。</p></li><li><p>86~88 行用来处理 64 位 10 进制除法。</p></li><li><p>第 198 行，当类型为 long long 时，将 qualifier 赋值为 ‘m’，以便在 switch 中识别并处理</p></li><li><p>第 199 行，当类型为 long long 时，将 LONG 标记加入 flag 。打印 8 进制和 16 进制时，如果不为 long long，第 67~68 行则将 num 的高 4 位置零，只计算低 4 位。为什么要这样做呢？因为打印负的 16 进制和 8 进制的 32 位整型时，由于负数（补码）的首位为 1，传入 number 函数时，该数会发生符号扩展（因为 number 的参数 num 是 long long，而实参是 32 位），比如 32 整型数 -1 的二进制是 <code>0XFFFFFFFF</code> ，符号扩展后就成为 <code>0xFFFFFFFFFFFFFFFF</code> ，因此造成的结果就是：<code>printf(&quot;%x&quot;,-1)</code> 也会打印 <code>0xFFFFFFFFFFFFFFFF</code> ，而正确的结果应该是 8 个 F 。所以要对于 32 位负整型，需要将高 32 位清零。</p><blockquote><p>关于补码，详见[CSAPP][<a href="https://jyx-fyh.github.io/2022/07/08/CSAPP/">https://jyx-fyh.github.io/2022/07/08/CSAPP/</a>]。再次强调， <strong>打印八进制和十六进制的负数时，是直接打印其补码！</strong></p></blockquote></li></ul><p>最终效果如下：<br><img src="/2022/img/image-20230111102501588.png" alt=""><br>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统, C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf底层剖析及可变参数探究</title>
      <link href="/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/01/07/printf%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/">可变参数列表</a>，<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本文参考文章：<a href="https://book.douban.com/subject/3422332/">《你必须知道的495个C语言问题》</a><a href="https://book.douban.com/subject/1231236/">《Linux内核完全注释》</a>《操作系统真相还原》<a href="https://www.runoob.com/cprogramming/c-function-printf.html">printf-菜鸟教程</a><br>本节对应分支：<code>printk</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>相信每一位 C 选手写下的第一句代码都是下面这句经典的 Hello World 吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理所应当的，其中的 <code>printf</code> 函数也成为了咋们认识的第一个函数。对笔者个人而言， <code>printf</code> 是一个熟悉而陌生的函数，说熟悉是因为它伴随了我整个 C 语言的学习生涯；说陌生是因为学习过程中一直对它存疑，模模糊糊，始终没能一探究竟，不知道各位读者是否也是像笔者一样呢？记得 C 语言萌新阶段时，我时常吐槽 <code>printf</code> 中的那些格式符，如 <code>%d</code>、<code>%s</code>、<code>%c</code>、<code>%x</code> 等，乱七八糟的，实在是太难记啦！入门阶段时，我赞叹 <code>printf</code> 强大的格式处理能力，比如左右对齐、输出宽度、输出精度等；进阶阶段时，我又开始疑惑 <code>printf</code> 是如何做到参数可变的，但因为基础不足，就暂时搁浅。现在，天时地利人和，让我们对 <code>printf</code> 一网打尽吧！</p><p>本文将从以下几个方向逐个击破 <code>printf</code> ：</p><ul><li><strong><font color='gree'>默认参数提升</font></strong></li><li><strong><font color='gree'>可变参数的类型检查</font></strong></li><li><strong><font color='gree'>可变参函数实现原理</font></strong></li><li><strong><font color='gree'>其他注意事项</font></strong></li><li><strong><font color='gree'>printf源码详解</font></strong></li></ul><h3 id="font-color-red-默认参数提升-font"><font color='red'>默认参数提升</font></h3><p><strong><font color='orange'>注意，默认参数提升仅对可变参数列表有效</font></strong> ，其规则是：<strong><font color='orange'>char 和 short 自动提升为 int，float 自动提升为 double</font></strong> 。<br>比如我们一定知道，<code>%f</code> 用来输出 float，<code>%lf</code> 则用来输出 double；但实际上 <code>%f</code> 可以同时表示 float 和 double 类型，而无需专门指定 <code>%lf</code> 来表示 double（因为 printf 只能看到双精度），如下图：<br><img src="/2022/img/image-20230108145958396.png" alt=""></p><blockquote><p>本操作系统未支持浮点（难度较大，非常麻烦），且笔者对浮点的硬件支持不太了解，所以下面不讨论浮点。</p></blockquote><p>将 char/short 提升为 int 的原因是：<strong><u>可变参函数的原型无法提供参数个数以及参数类型，所以编译器无法针对各个参数生成相应代码，因此只好统一为 int 类型</u></strong> 。</p><blockquote><p>比如 <code>printf</code> 的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span></span><br></pre></td></tr></table></figure><p>显然，<code>...</code> （即可变参数列表）无法提供参数的个数和类型。值得一提的是，<code>printf</code> 中的 <code>f</code> 就是指的 <code>format</code> 。</p></blockquote><p>这么说原因大家可能还不太明白什么意思，下面笔者用代码进行解释，先来看普通函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">    test(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">short</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件生成的反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   8d 4c 24 04             lea    ecx,[esp+0x4]</span><br><span class="line">   4:   83 e4 f0                and    esp,0xfffffff0</span><br><span class="line">   7:   ff 71 fc                push   DWORD PTR [ecx-0x4]</span><br><span class="line">   a:   55                      push   ebp</span><br><span class="line">   b:   89 e5                   mov    ebp,esp</span><br><span class="line">   d:   51                      push   ecx</span><br><span class="line">   e:   83 ec 14                sub    esp,0x14</span><br><span class="line">  11:   c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">  18:   66 c7 45 f2 02 00       mov    WORD PTR [ebp-0xe],0x2</span><br><span class="line">  1e:   c6 45 f1 03             mov    BYTE PTR [ebp-0xf],0x3</span><br><span class="line">  22:   0f be 55 f1             movsx  edx,BYTE PTR [ebp-0xf]</span><br><span class="line">  26:   0f bf 45 f2             movsx  eax,WORD PTR [ebp-0xe]</span><br><span class="line">  2a:   83 ec 04                sub    esp,0x4</span><br><span class="line">  2d:   52                      push   edx</span><br><span class="line">  2e:   50                      push   eax</span><br><span class="line">  2f:   ff 75 f4                push   DWORD PTR [ebp-0xc]</span><br><span class="line">  32:   e8 fc ff ff ff          call   33 &lt;main+0x33&gt;</span><br><span class="line">  37:   83 c4 10                add    esp,0x10</span><br><span class="line">  3a:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3f:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">  42:   c9                      leave  </span><br><span class="line">  43:   8d 61 fc                lea    esp,[ecx-0x4]</span><br><span class="line">  46:   c3                      ret    </span><br><span class="line"></span><br><span class="line">00000047 &lt;test&gt;:</span><br><span class="line">  47:   55                      push   ebp</span><br><span class="line">  48:   89 e5                   mov    ebp,esp</span><br><span class="line">  4a:   83 ec 08                sub    esp,0x8</span><br><span class="line">  4d:   8b 55 0c                mov    edx,DWORD PTR [ebp+0xc]</span><br><span class="line">  50:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">  53:   66 89 55 fc             mov    WORD PTR [ebp-0x4],dx</span><br><span class="line">  57:   88 45 f8                mov    BYTE PTR [ebp-0x8],al</span><br><span class="line">  5a:   c7 45 08 0a 00 00 00    mov    DWORD PTR [ebp+0x8],0xa</span><br><span class="line">  61:   66 c7 45 fc 0b 00       mov    WORD PTR [ebp-0x4],0xb</span><br><span class="line">  67:   c6 45 f8 0c             mov    BYTE PTR [ebp-0x8],0xc</span><br><span class="line">  6b:   90                      nop</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   c3                      ret  </span><br></pre></td></tr></table></figure><p>从第 34~36 行就可以看出参数类型的区别：int、short、char 对应的反汇编分别为 DWORD、WORD、BYTE ，也就是说，编译器为不同的类型生成了不同的代码。</p><blockquote><p>笔者以前想当然地认为函数参数类型影响的是压栈的字节数，比如将 char 压入栈，对应的反汇编就应该为 <code>push BYTE PTR [xxx]</code> ；实际上并非如此，<strong><font color='orange'>不论是 char、short、int 或是 long、long long，编译器都会压入 4 字节（对于 long long 8 字节，分两次压入）</font></strong> ，这点从 15~17 行就能体现。所以参数类型影响的不是压栈，而影响的是从栈中取值或赋值。</p></blockquote><p>那么对于可变参数列表，默认参数提升是如何体现的呢？待会讲解 <code>printf</code> 源码时再回过头来说这点。</p><h3 id="font-color-red-可变参数的类型检查-font"><font color='red'>可变参数的类型检查</font></h3><p>还是由于可变参数列表无法提供参数类型，所以编译器无法对参数进行类型检查，换句话说，<strong>编译器不能执行默认的类型转换，通常也不会报错</strong> 。对于普通函数而言，如果实参和形参类型不匹配，编译器会将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153040201.png" alt=""></p><p>而对于可变参数函数，编译器则无法将实参隐式转换为形参类型，如下：<br><img src="/2022/img/image-20230108153229945.png" alt=""><br>所以程序员必须自己确保参数类型的匹配或手动强制转换。</p><h3 id="font-color-red-可变参数函数实现原理-font"><font color='red'>可变参数函数实现原理</font></h3><p>想要实现可变参数，最重要的是明白其函数的调用方式，如果没有特定的<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>，可变参数将无从谈起。<strong><u>可变参数函数的调用方式必须满足以下两个条件：</u></strong></p><ol><li><p><strong><font color='orange'>从右向左压栈</font></strong></p><blockquote><p>为什么要从右往左入栈？ 因为如果从左向右，编译器就不知道用户传入了多少实参。参数的信息是由第一个参数 <code>fmt...</code> 确定的（如 <code>printf (“% s % s”,str1 ,str2)</code> 的参数信息是通过检测两个 <code>%s</code> 来获取的）。若从左向右压栈，<code>fmt...</code> 就被放入了栈底，而 esp 由于不清楚参数个数和类型，就无法跨过这些参数来指向 <code>fmt...</code> ，因此无法获取各个参数的信息。相反，若从右向左压栈，<code>fmt...</code> 就存放在栈顶，这样就可以直接通过它得知参数的个数和类型，进而准确从栈中取得各个参数。</p></blockquote></li><li><p><strong><font color='orange'>外平栈（调用者平栈）</font></strong></p><blockquote><p>必须由调用者平栈的原因是：只有调用者才知道压入了几个参数，所以也只能由调用者进行平栈。读者可能感到疑惑，为什么只有调用者才知道压入了几个参数？仍然拿 <code>printf</code> 举例，是这样的：<code>printf</code> 作为库函数，是提前被编译好了的（一般作为动态链接库），最后直接与我们自己编写生成的可重定位文件链接在一起，从而生成可执行文件；所以 <code>printf</code> 完全不知道实际压入了多少个参数（因为压参是由我们的编译器进行的）！因此也就无法由 <code>printf</code> 自己来完成平栈。相反，如果是调用方本身来调用的 <code>printf</code> ，理所应当地，调用方就知道自己向栈中压入了多少个参数，所以调用方就可以承担平栈任务，如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d  %c&quot;, 1, 2);</span><br><span class="line">&#125;</span><br><span class="line">//对应汇编：</span><br><span class="line">//......省略</span><br><span class="line">00BF17E1  push        2  </span><br><span class="line">00BF17E3  push        1  </span><br><span class="line">00BF17E5  push        offset string &quot;%d\n&quot; (0BF7BD8h)  </span><br><span class="line">00BF17EA  call        _printf  </span><br><span class="line">00BF17EF  add         esp,0Ch  </span><br><span class="line">//......省略</span><br></pre></td></tr></table></figure><p>call 之前，编译器 push 了三次，所以它当然知道平栈需要 add esp,0xC ！而 printf 是已经编好的库，它就不知道 push 了几次。</p></blockquote></li></ol><p>而 __cdel 调用约定就符合以上两个规则，所以可变参函数必须使用此方式。值得一提的是，__cdel 是 C/C++ 默认方式。<br>有了以上两种条件的支持，现在无非就是处理 <code>fmt...</code> 获取参数信息，然后从栈中取得参数即可。这就是咋们接下来要干的事。</p><h3 id="font-color-red-其他注意事项-font"><font color='red'>其他注意事项</font></h3><p><strong><mark class="hl-label blue">需要打印%咋办？</mark> </strong><br>这点相信大部分读者都清楚，打印百分号需要再加个百分号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这是百分号%%&quot;</span>);</span><br></pre></td></tr></table></figure><p>很多小白会在 <code>%</code> 前加 <code>\</code> ，即 <code>printf(&quot;\%&quot;)</code> 来输出百分号。出现这种想法是因为没有理解转义字符的意义，要知道，<code>\n</code> 是一个 ASCII 码（10），由编译器负责将 <code>\n</code> 转为 10 。而 <code>\%</code> 可不是转义字符，对 <code>%</code> 的处理是由我们的代码负责，而不是由编译器负责！</p><p><strong><mark class="hl-label blue">printf实参问题</mark> </strong><br>很多读者应该都像下面这种方式调用过 printf 吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>这种方式有什么不对吗？结果正确，但这种调用方式十分危险。这是因为，<code>110</code> 没有指明类型，所以根据前面的默认参数提升，<code>110</code> 被视为 int，这符合 <code>%d</code> ，所以能够正确输出。但是碰到下面这种情况呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>结果就变得诡异，输出如下：<br><img src="/2022/img/image-20230110115919374.png" alt=""><br>这是因为 <code>110</code> 被编译器视为 int（4字节)，但 printf 内部代码根据 <code>%lld</code> 将 <code>110</code> 视为 long long（8字节)，在定位参数时，将 long long* 指针指向 <code>110</code> 所在的位置，那么用该指针解释数据的时候，将会把 <code>110</code> 后面的四字节包含进去，而这四字节中的数据是未定义的，所以造成以上错误。再来看下面的调用：<br><img src="/2022/img/image-20230110130458876.png" alt=""><br>怎么这种情况又能够正确显示呢？这是因为编译器判定 <code>0xfffffffff</code> 无法用 int 装下，所以该值的类型就变为了 long long，因此能够正确输出。正确的调用方式需要加上强制转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)<span class="number">110</span>);</span><br></pre></td></tr></table></figure><p>看完 printf 源码后，你会对上述行为有深刻理解。</p><h3 id="font-color-red-printf源码剖析-font"><font color='red'>printf源码剖析</font></h3><blockquote><p><strong>说明：</strong></p><ul><li>以下源码来自 Linux 0.11 ，也就是 Linus Torvalds 编写的初代 Linux ，所以其功能肯定不如现在的 printf 强大，这点读者需要清楚。</li><li>printk（print kernel）和 printf 的功能完全相同，只不过前者是在内核中使用的打印函数，而后者是在用户态中使用的打印函数。</li><li>为了契合咋们的操作系统，笔者会将 printk 作轻微修改，使其能够在用户态下使用（此时也就变成了 printf ），这不会影响对 printf 的理解。</li></ul></blockquote><p>以下是原版的 <code>printk</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">va_start(args, fmt);</span><br><span class="line">i=<span class="built_in">vsprintf</span>(buf,fmt,args);</span><br><span class="line">va_end(args);</span><br><span class="line">__asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $_buf\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;call _tty_write\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>提供原版的 printk 只是为了与下面咋们改进后的 printf 形成对比，大家无需纠结上面的代码</u>。以下是我们操作系统的 <code>printf</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * fmt, ...)</span> </span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="type">int</span> i = write(buf);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可见，除了第 9 行外，其他完全相同。实际上，第 9 行将最终的字符串传给我们之前实现的系统调用 write，由 write 进行打印。另外，<strong><font color='orange'>正因为 write 是系统调用，所以该 printf 既可以供内核使用，也可以供用户使用</font></strong> 。</li><li><code>printf</code> 返回字符个数。</li></ul><p>接下来重点说明处理可变参数的四个宏： <code>va_list</code> 、<code>va_start</code> 、<code>va_end</code> 和 <code>va_arg</code> 。</p><p><strong><mark class="hl-label blue">可变参数宏</mark> </strong><br>首先要破除大家的先入为主，别以为这四个宏是用来处理可变参数的，就觉得它们高大上，有什么特异功能，实际上这四个家伙的本质就普普通通：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(p, fmt) (p = (char*)&amp;fmt + sizeof(char*))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(p)        (p = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(p, type)  (p += __va_rounded_size(type), *((type*)(p - __va_rounded_size (type))))</span></span><br></pre></td></tr></table></figure><ul><li><p><em><em><code>va_list</code> <u>就是 char</em> 指针类型，该指针（args）用来在栈中依次遍历各个参数</u></em>* 。</p></li><li><p><strong><code>va_start</code> <u>的作用是将 args 指针指向参数列表（即 <code>...</code> ）中的第一个参数</u></strong> 。</p><blockquote><p><code>p = (char*)&amp;fmt + sizeof(char*)</code> 就是令 p 跳过栈中的 fmt ，指向栈中的下一个参数，即参数列表中的第一个参数。注意必须对 fmt 取地址，得到该指针的地址，也就是该指针在栈中的位置，<code>&amp;fmt</code> 为二级指针，还需要强制转换为一级指针 char* 。</p></blockquote></li><li><p><strong><code>va_end</code> <u>的作用是将 args 指针置 NULL</u></strong> 。</p></li><li><p><code>va_arg</code> 出现在下面的 <code>vsprintf</code> 函数中，<strong><u><code>va_arg</code> 的作用是返回当前 args 指向的参数的值，然后 args 向后移动，指向下一个参数</u></strong> 。</p><blockquote><p><code>__va_rounded_size(type)</code> 也是一个宏，<strong><u>用来得到取整后的 type 类型的大小，是 int 的整数倍</u></strong> ，比如 type 为 char，则返回 4；type 为 long long，则返回 8 ，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __va_rounded_size(type)  \</span></span><br><span class="line"><span class="meta">  (((sizeof (type) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span></span><br></pre></td></tr></table></figure><p>注意，va_arg 宏定义是一个逗号表达式，第一个表达式<u>根据目前所指参数 A 的大小</u>，将指针 p 移向了下一个参数 B（+=，p的值已经被改变）；接着将 A 的值返回（逗号表达式中的最后一个式子作为返回值）。顺便提一下，如果按照《操作系统真相还原》中的代码，将无法应对 long long 的情况。</p></blockquote></li></ul><p>接着来看 vsprintf 。</p><p><strong><mark class="hl-label blue">vsprintf</mark> </strong><br><strong>vsprintf 的作用是格式化字符串，也就是将参数列表中的所有参数值填入到 fmt 中的对应位置，并将最终的字符串存入 buf</strong> 。<code>fmt</code> 中的格式符，如 <code>%d</code> 、<code>%s</code> 等都在此函数中进行处理。在讲解该函数代码前，有必要先复习 printf 的用法，否则看代码时将一头雾水。</p><p>我们将 <code>%s</code> 这样的格式称之为一个 format 标签，format 标签的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.precision][length]specifier</span><br></pre></td></tr></table></figure><p>比如下面这样的 printf 调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10ld&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中的 <code>-</code> 为 flags，即指明左对齐；<code>10</code> 为 width，即指明输出宽度；<code>l</code> 为长度，对于 <code>d</code> 而言，即输出长整型 long；<code>d</code> 为 specifier，指明输出整型。<br>具体规则如下：</p><table><thead><tr><th><strong>flags</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>-</strong></td><td>在给定的字段宽度内左对齐，默认是右对齐</td></tr><tr><td><strong>+</strong></td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td><strong>空格</strong></td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td><strong>#</strong></td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。由于本操作系统暂不支持小数，所以不说明 # 对 f、e、g 等说明符的影响。</td></tr><tr><td><strong>0</strong></td><td>在左边填充零，而不是空格</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>width</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>number</strong></td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充；如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定宽度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>.number</strong></td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 <br />对于 s：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 <br />对于 c：没有任何影响。 当未指定任何精度时，默认为 1。</td></tr><tr><td style="text-align:left"><strong>.</strong>*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于可变参数列表中，由该参数指定精度。</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>length</strong></th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>h</strong></td><td style="text-align:left">参数被解释为短整型或无符号短整型 short（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left"><strong>l</strong></td><td style="text-align:left">参数被解释为长整型或无符号长整型 long，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left"><strong>L</strong></td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。本操作系统不支持。</td></tr><tr><td style="text-align:left"><strong>ll</strong></td><td style="text-align:left">本操作系统中，ll 仅被解释为 <strong>无符号 long long</strong>，适用于整数说明符。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">和 d 完全相同</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">到目前为止成功写入缓冲区的字符数，此值存储在指定的整数中，其地址作为参数给出。</td></tr></tbody></table><p>下面做几个示范：<br><img src="/2022/img/image-20230109092042387.png" alt=""><br><img src="/2022/img/image-20230109092442698.png" alt=""><br><img src="/2022/img/image-20230109094520482.png" alt="由于安全原因，VS默认禁止使用%n，所以此处用 Bochs 代替"></p><p>了解以上格式后，再来看 vsprintf 就十分轻松啦，总的来说，该函数就是在依次处理 flags --&gt; width --&gt; .precision --&gt; length --&gt; specifier 。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成2的倍数,是因为我们将flag变量视为位图,将属性保存到各个二进制位上</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD1<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN2<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS4<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE8<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT16<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL32<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL64<span class="comment">/* use &#x27;abcdef&#x27; instead of &#x27;ABCDEF&#x27; */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="type">char</span>* s;</span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">int</span> flags;          <span class="comment">// flags to number() </span></span><br><span class="line"><span class="type">int</span> field_width;    <span class="comment">// width of output field </span></span><br><span class="line"><span class="type">int</span> precision;      <span class="comment">// min of digits for integers; max number of chars for from string </span></span><br><span class="line"><span class="type">int</span> qualifier;      <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27;, or &#x27;L&#x27; for integer fields </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (str=buf ; *fmt ; ++fmt) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//如果不是format标签,则直接复制到str</span></span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//处理flags</span></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">repeat:</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: flags |= LEFT; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: flags |= PLUS; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: flags |= SPACE; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: flags |= SPECIAL; <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: flags |= ZEROPAD; <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理输出宽度</span></span><br><span class="line">field_width = <span class="number">-1</span>; <span class="comment">//默认为-1,即未指示宽度,因为 flag | -1 = flag</span></span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">field_width = skip_atoi(&amp;fmt); <span class="comment">//skip_atoi将字符转为数字,后文给出</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则width由下一个参数给出 </span></span><br><span class="line"><span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)  <span class="comment">//若宽度参数小于0,则左靠齐,和&#x27;-&#x27;号效果相同</span></span><br><span class="line">&#123;</span><br><span class="line">field_width = -field_width;</span><br><span class="line">flags |= LEFT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理精度</span></span><br><span class="line">precision = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">++fmt;</span><br><span class="line"><span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">precision = skip_atoi(&amp;fmt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">fmt++;  <span class="comment">//源码没有此句,官方承认为bug</span></span><br><span class="line">precision = va_arg(args, <span class="type">int</span>); <span class="comment">//若字符为*,则precision由下一个参数给出 </span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理长度描述符符</span></span><br><span class="line">qualifier = <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">qualifier = *fmt;  <span class="comment">//实际上,后面就没有用到qualifier了,显得鸡肋</span></span><br><span class="line">++fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理格式字符</span></span><br><span class="line"><span class="keyword">switch</span> (*fmt) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT)) <span class="comment">//如果不是左靠齐,则左边补field_width-1个空格</span></span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">*str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(args, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) <span class="comment">//否则后方补空格</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">precision = len;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) <span class="comment">//如果字符串长度大于精度,则丢弃超过精度的部分</span></span><br><span class="line">len = precision;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">*str++ = *s++;</span><br><span class="line"><span class="keyword">while</span> (len &lt; field_width--)<span class="comment">//如果执行了上面的while,此处就不会再执行</span></span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:  <span class="comment">//number函数用来将数字转换为字符串</span></span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="comment">//按十六进制输出指针,宽度为8,宽度不足则补前导0</span></span><br><span class="line"><span class="keyword">if</span> (field_width == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">field_width = <span class="number">8</span>;</span><br><span class="line">flags |= ZEROPAD;</span><br><span class="line">&#125;</span><br><span class="line">str = number(str,(<span class="type">unsigned</span> <span class="type">int</span>)va_arg(args,<span class="type">void</span>*), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">flags |= SMALL;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">flags |= SIGN;  <span class="comment">//%d和%i都是有符号数</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width, precision, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">*ip = (str - buf); <span class="comment">//返回目前字符串的宽度</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若格式转换符不是&#x27;%,则表示格式字符串有错,直接将一个%写入输出串中;如果格式转换符的位置处还有字符,则也直接将该字符写入输</span></span><br><span class="line">        <span class="comment">//出串中,并返回到107行继续处理格式字符串;否则表示已经处理到格式字符串的结尾处,则退出循环。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt)</span><br><span class="line">*str++ = *fmt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">--fmt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释得比较清楚，对照之前的规则来看代码就很容易理清其中的逻辑，不再详细说明。提一点，看第 90 行，<code>va_arg(args, int)</code> ，这说明从栈中取字符时，是以 int 大小来取的（ <strong><u><font color='orange'>这里就体现了默认参数提升</font></u></strong> ），然后再被强制转换为 char 。为什么不能 <code>va_arg(args,char)</code> 呢？实际上这样完全能够准确获取栈中字符的值，但如果这样的话，下一次使用 va_arg 宏取参数时，args 指针就指向了该字符的下一字节，但下一个参数应该是在该字符的四字节后，这无疑将引发错误，图示如下：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE35.png" alt=""></p><p>代码中还用到了 skip_atoi() 和 number() 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c)((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//判断是否为数字字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \    <span class="comment">// n=n/base,并返回n%base</span></span></span><br><span class="line"><span class="type">int</span> __res; \                   <span class="comment">//宏定义采用大括号的方式,最后一条语句作为返回值</span></span><br><span class="line">__asm__(<span class="string">&quot;div %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (n),<span class="string">&quot;=d&quot;</span> (__res):<span class="string">&quot;0&quot;</span> (n),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),<span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">__res; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **fmtp)</span><span class="comment">//pointer to fmt,即fmt的指针,所以该指针为二级指针</span></span><br><span class="line">&#123;                                      <span class="comment">//为什么要用二级指针?因为咋们要在函数中修改fmt的值(不仅是修改形参,实参也要修改)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;                           <span class="comment">//由于fmt是指针,所以要修改指针的值,就需要用二级指针</span></span><br><span class="line">    <span class="keyword">while</span> (is_digit(**fmtp))</span><br><span class="line">        i = i*<span class="number">10</span> + *((*fmtp)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//(*fmtp)++,就是fmt++</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * <span class="title function_">number</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision,<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SMALL) </span><br><span class="line">digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;LEFT) </span><br><span class="line">type &amp;= ~ZEROPAD; <span class="comment">//如果为左对齐,则无需0填充</span></span><br><span class="line"><span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">36</span>) <span class="comment">//仅支持2~36进制,否则返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">num = -num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sign=(type&amp;PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((type&amp;SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);<span class="comment">//要么+,要么空1格</span></span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">size--; <span class="comment">//如果有符号或空格,则占一位</span></span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">size -= <span class="number">2</span>; <span class="comment">//0x占两位</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">size--;    <span class="comment">//0占一位</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 以下开始处理数字</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span>)</span><br><span class="line">tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">tmp[i++]=digits[ do_div(num,base) ]; <span class="comment">//依次取得num的最低位数字,并填入tmp,</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;precision)                     <span class="comment">//此时顺序是反的,第72行会调整顺序</span></span><br><span class="line">precision=i; <span class="comment">//如果数字个数大于精度,不会截断,精度成鸡肋</span></span><br><span class="line">size -= precision;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (sign)</span><br><span class="line">*str++ = sign;</span><br><span class="line"><span class="keyword">if</span> (type&amp;SPECIAL)</span><br><span class="line"><span class="keyword">if</span> (base==<span class="number">8</span>)</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (base==<span class="number">16</span>) </span><br><span class="line">&#123;</span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">*str++ = digits[<span class="number">33</span>]; <span class="comment">//&#x27;X&#x27;或&#x27;x&#x27;,取决于digit的指向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(type&amp;LEFT))</span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>) <span class="comment">//如果是右靠齐,则补前导0或前导空格</span></span><br><span class="line">*str++ = c;</span><br><span class="line"><span class="keyword">while</span>(i&lt;precision--)<span class="comment">//精度大于数字个数,则补前导0</span></span><br><span class="line">*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = tmp[i];<span class="comment">//i--,str++,调整数字顺序</span></span><br><span class="line"><span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">*str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果67行已经执行,此处就不会再执行</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释详尽，不再说明。<br>值得一提的是，该版 printf 有许多不足，例如不支持 <code>%hd</code> (short)，<code>%lld</code> (long long) ，下节<a href="https://jyx-fyh.github.io/2023/01/10/printf%E5%8A%A0%E5%BC%BA%E7%89%88/">printf加强版</a>中我们会增加这两个功能。<br><img src="/2022/img/image-20230110134655302.png" alt=""></p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言, 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现用户进程-代码详解</title>
      <link href="/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程-进入用户态</a><br>本节对应分支：<code>userprog</code></p></blockquote><h3 id="font-color-red-初始化TSS、C语言接管GDT-font"><font color='red'>初始化TSS、C语言接管GDT</font></h3><p>下面是 <code>global.h</code> 中添加的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="comment">//=============用户进程的段选择子================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_CODE   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span></span><br><span class="line"><span class="comment">// ===============GDT描述符属性=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_G_4K    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DESC_D_32    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_L     0<span class="comment">// 64位代码标记，此处标记为0便可。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_AVL     0<span class="comment">// cpu不用此位，暂置为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_P     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_0   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_1   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_2   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_DPL_3   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_CODE1       <span class="comment">// s为1时表示存储段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_DATADESC_S_CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_S_SYS0       <span class="comment">// s为0时表示系统段.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_CODE8<span class="comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_DATA  2<span class="comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESC_TYPE_TSS   9<span class="comment">// B位为0,不忙</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ATTR_HIGH     ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_CODE_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_DATA_ATTR_LOW_DPL3 ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span></span><br><span class="line"><span class="comment">//================ TSS描述符属性===================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_DESC_D  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSS_ATTR_LOW ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_TSS ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2 ) + RPL0)</span></span><br><span class="line"><span class="comment">//================ GDT描述符 =====================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit_low_word;</span><br><span class="line">    <span class="type">uint16_t</span> base_low_word;</span><br><span class="line">    <span class="type">uint8_t</span>  base_mid_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  attr_low_byte;</span><br><span class="line">    <span class="type">uint8_t</span>  limit_high_attr_high;</span><br><span class="line">    <span class="type">uint8_t</span>  base_high_byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第 3~5 行定义了用户进程的段选择子，其中代码段选择子索引为 5，即用户代码段的描述符位于 GDT 的第 5 号描述符的位置处；数据段和栈段共享一个描述符，选择子索引为 6 。你可能会疑惑，为什么只定义了一套用户的选择子，万一将来有多个用户进程同时运行，这几个选择子岂不是不够用？实际上只需要一套用户选择子就可以了，<strong><font color='orange'>因为所有用户进程都共享这一套选择子</font></strong> 。为什么可以共享呢？这便体现出虚拟空间下平坦模型的优越性了。<strong><font color='orange'><u>因为每个进程都有自己独立的虚拟地址空间，平坦模型下数据段和代码段描述符的基址直接设为 0，所以执行流只取决于 EIP 而依赖 CS。反观分段模型，由于没有虚拟地址空间，各个用户进程被分配到不同区域的物理内存中，所以为了隔离它们，每个用户进程的段基址都不相同，因此需要为每个用户进程都分配一套段选择子和段描述符</u></font></strong> ，不仅管理繁琐，而且效率低下。<br>另外，当初咋们在 <code>loader.s</code> 中设计 GDT 表时，并没有为用户和 TSS 预留段描述符，所以现在必须在 <code>loader.s</code> 中加上一行代码以预留空间：<br><img src="/2022/img/image-20230103153548106.png" style="zoom:100%;" /></li><li>之前是在 <code>loader.s</code> 中直接书写 GDT ，为了方便，现在我们使用 C 语言接管 GDT，以方便在 GDT 中添加和修改段描述符。所以在头文件中定义了段描述符和 TSS 描述符的各个属性以及段描述符的结构体 <code>gdt_struct</code> 。关于各个位的解释，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">GDT</a> 。</li></ul><p>下面是 <code>tss.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">gdt_operand</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> tss_slt;</span><br><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> backlink;</span><br><span class="line">    <span class="type">uint32_t</span>* esp0;</span><br><span class="line">    <span class="type">uint32_t</span> ss0;</span><br><span class="line">    <span class="type">uint32_t</span>* esp1;</span><br><span class="line">    <span class="type">uint32_t</span> ss1;</span><br><span class="line">    <span class="type">uint32_t</span>* esp2;</span><br><span class="line">    <span class="type">uint32_t</span> ss2;</span><br><span class="line">    <span class="type">uint32_t</span> cr3;</span><br><span class="line">    <span class="type">uint32_t</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> ldt;</span><br><span class="line">    <span class="type">uint32_t</span> trace;</span><br><span class="line">    <span class="type">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新tss中esp0字段的值为pthread的0级线 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tss_esp</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    tss.esp0 = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建gdt描述符 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> gdt_desc <span class="title function_">make_gdt_desc</span><span class="params">(<span class="type">uint32_t</span>* desc_addr, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> attr_low, <span class="type">uint8_t</span> attr_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> desc_base = (<span class="type">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="type">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="type">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在gdt中创建tss并重新加载gdt */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tss_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"><span class="comment">/* gdt基址为0x910,把tss放到第4个位置,也就是0x910+0x20的位置 */</span></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">   *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000930</span>)  = make_gdt_desc((<span class="type">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000938</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((<span class="keyword">struct</span> gdt_desc*)<span class="number">0xc0000940</span>) = make_gdt_desc((<span class="type">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    load_xdt(&amp;gdt_operand,<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>,<span class="number">0xc0000910</span>);</span><br><span class="line">    tss_slt = SELECTOR_TSS;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lgdt gdt_operand&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ltr tss_slt&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;tss_init and ltr done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4~33 行定义了 TSS 结构，这没有太多要说的，有个小问题是，结构体定义不应该放在头文件中吗，这里为什么要放在 C 文件中呢？是不是不太规范？这也是笔者之前的误解，原以为只要是宏定义或者结构体定义一类的都应该放在头文件，而 C 文件中只放函数定义，这样才显得规范。实际上并不是如此，原则应该是：<strong><font color='orange'>如果其可见性超出一个 .c 文件，那么应当放入 .h 中，如果只是某一个 .c 里需要这么一个结构作为辅助，直接放入这个.c中更好一些</font></strong> 。放在 .c 还是 .h 取决于该结构是否要暴露给其他 .c，能放 .c 绝不放 .h 。而 TSS 结构只会在此文件中使用，所以就定义在此 .c 文件中。</li><li>第 37 行，update_tss_esp() 用来将 TSS 中 esp0 字段的值更新为 pthread 的内核线。如上节内容所说，所有任务共享一个 TSS，只是在任务切换时更新 ESP0 的值。</li><li>第 61 行，将 TSS 的 io_base 字段设置为 TSS 的大小，这表示此 TSS 中没有 IO 位图。</li><li>第 62 行，GDT 的基址为 0x910，这是如何确定的？见下面 <code>loader.s</code> 的片段即可知道。<br><img src="/2022/img/image-20230105121240944.png" style="zoom:67%;" /></li><li>第 69 行的 load_xdt 函数，咋们之前用它设置过 IDTR，定义在 global.h 中。gdt_operand 是加载 GDT 时用的操作数，设置好 gdt_operand 的基址和界限后，第 71 行便使用内联汇编 <code>lgdt</code> 指令加载 GDTR。至于为什么要将 gdt_operand 和 tss_slt 定义为全局静态变量，这在之前的文章中反复提及过，不再赘述。同理，第 72 行使用 <code>ltr</code> 指令将 TSS 的选择子 tss_slt 加载进 TR 寄存器，由于 TSS 只有一个，所以只会加载这一次，以后就不会再修改 TR 了。</li></ul><h3 id="font-color-red-用户进程的虚拟地址空间-font"><font color='red'>用户进程的虚拟地址空间</font></h3><p>在<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础篇</a>中，我们划出了三个内存池：内核物理内存池、内核虚拟内存池、用户物理内存池。为了实现用户进程的虚拟地址空间，我们还需要给每个进程设置私有的用户虚拟内存池。见以下步骤。</p><p><strong><mark class="hl-label blue">在task_struct中添加虚拟内存池</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      <span class="comment">// 各内核线程都用自己的内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              <span class="comment">// 每次在处理器上执行的时间嘀嗒数</span></span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       <span class="comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> <span class="comment">// general_tag的作用是用于线程在一般队列中的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span><span class="comment">// all_list_tag的作用是用于线程队列thread_all_list中的结点</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              <span class="comment">// 进程页表</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         <span class="comment">// 用这串数字做栈的边界标记,用于检测栈的溢出</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span>   <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 14 行即为用户进程的虚拟内存池。</p><p><strong><mark class="hl-label blue">用户虚拟内存管理</mark> </strong><br>在 <a href="">内存管理-进阶</a>中，我们留下了部分内容等到实现用户进程时补充，如下：<br><img src="/2022/img/image-20230105154723658.png" style="zoom:67%;" /><br>第 33 行的作用和其上内核部分的代码相似，都是在申请虚拟内存。以下代码补齐这部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct* cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">        <span class="comment">/*0xc0000000-PAGE_SIZE作为3级用户栈已经在start_process中被分配*/</span></span><br><span class="line">        assert((<span class="type">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>逻辑清晰，不再解释。另外还添加了几个必要的内存管理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:memory.c</span></span><br><span class="line"><span class="comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_user_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="type">void</span>* vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将地址vaddr与pf池中的物理地址关联,仅支持一页空间分配 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_a_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="type">int32_t</span> bit_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;pgdir != <span class="literal">NULL</span> &amp;&amp; pf == PF_USER)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;pgdir == <span class="literal">NULL</span> &amp;&amp; pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span></span><br><span class="line">        bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        assert(bit_idx &gt; <span class="number">0</span>);</span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        panic(<span class="string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">    <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">    lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址映射到的物理地址 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">addr_v2p</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"><span class="comment">/* (*pte)的值是页表所在的物理页框地址,</span></span><br><span class="line"><span class="comment"> * 去掉其低12位的页表项属性+虚拟地址vaddr的低12位 */</span></span><br><span class="line">    <span class="keyword">return</span> ((*pte &amp; <span class="number">0xfffff000</span>) + (vaddr &amp; <span class="number">0x00000fff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>get_user_pages 和 get_kernel_page 的逻辑完全相同，不再赘述。提一下，笔者在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶</a>中提到过如下内容：</p><blockquote><p>扫描和设置位图必须连续，中间不能切换线程 。这里和线程切换有关，简单解释：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题 。因此扫描和设置位图必须保证原子操作。需要注意的是，此处代码并没有保证原子性，未来我们会用锁来实现 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></blockquote><p>现在咋们已经实现了锁机制，所以这里申请内存时用锁来保证原子性。锁加在 pool 结构体中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span>                      //管理物理内存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 本内存池字节容量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">lock</span>;</span>            <span class="comment">// 保证内存申请时的原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第 13 行定义 get_a_page 函数，该函数与 get_kernel_page 或 get_user_page 的差别在于前者能够申请指定位置的虚拟内存，而后者则无法指定位置。该函数待会用来指定在 0xc0000000 处申请一页虚拟内存作用户栈。</p></li><li><p>addr_v2p 函数，其中 2 和 to 同音，即 addr_v_to_p，功能是将虚拟地址 vaddr 转换为对应的物理地址。下面咋们马上就会用到此函数。</p></li></ul><p><strong><mark class="hl-label blue">创建用户进程</mark> </strong><br>这部分内容很多，打起精神啦！</p><p>在中断栈中构建用户进程的上下文时，需要设置 eflags 寄存器，所以在 global 中定义好 eflags 的属性位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:global.h</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_MBS(1 &lt;&lt; 1)        <span class="comment">// 该位保留,总是为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_1(1 &lt;&lt; 9)        <span class="comment">// if为1,开中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF_00               <span class="comment">// if为0,关中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_3(3 &lt;&lt; 12)   <span class="comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IOPL_0(0 &lt;&lt; 12)   <span class="comment">// IOPL0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIV_ROUND_UP(X, STEP) ((X + STEP - 1) / (STEP)) <span class="comment">//用于除法的向上取整,如2/3=1</span></span></span><br></pre></td></tr></table></figure><p>下面则开始创建用户进程，<strong><font color='orange'>注意上节中的进程创建流程图对比</font></strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:process.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">proc_stack</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pagedir_phy_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">intr_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_process</span><span class="params">(<span class="type">void</span>* filename_)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* function = filename_;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);   <span class="comment">//跨过thread_stack,指向intr_stack</span></span><br><span class="line">    proc_stack = (<span class="keyword">struct</span> intr_stack*)cur-&gt;self_kstack; <span class="comment">//可以不用定义成结构体指针</span></span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>;          <span class="comment">// 不允许用户态直接访问显存资源,用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function; <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="type">void</span>*)((<span class="type">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,proc_stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;jmp intr_exit&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 击活页表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_dir_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">     * 执行此函数时,当前任务可能是线程。</span></span><br><span class="line"><span class="comment">     * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程,</span></span><br><span class="line"><span class="comment">     * 否则不恢复页表的话,线程就会使用进程的页表了。</span></span><br><span class="line"><span class="comment">     ********************************************************/</span></span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    pagedir_phy_addr = <span class="number">0x100000</span>;  <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)  <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov eax,pagedir_phy_addr&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov cr3,eax&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_activate</span><span class="params">(<span class="keyword">struct</span> task_struct* p_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 激活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0特权级,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0*/</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建页目录表,将当前页表的表示内核空间的pde复制,</span></span><br><span class="line"><span class="comment"> * 成功则返回页目录的虚拟地址,否则返回-1 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">create_page_dir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页目录表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">&quot;create_page_dir: get_kernel_page failed!&quot;</span>,FT_RED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span>*<span class="number">4</span>), (<span class="type">uint32_t</span>*)(<span class="number">0xfffff000</span>+<span class="number">0x300</span>*<span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="type">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_user_vaddr_bitmap</span><span class="params">(<span class="keyword">struct</span> task_struct* user_prog)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_execute</span><span class="params">(<span class="type">void</span>* filename, <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 **/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, DEFUALT_PRIO);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);<span class="comment">//start_process(filename)</span></span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>start_process 中，proc_stack 结构体指向中断栈，并初始化进程上下文。</p></li><li><p>第 9 行，需要说明的是，用户进程一般是硬盘中的一段程序，需要加载到内存，然后再运行，所以进程的定义就是“运行中的程序”。<strong>但目前我们还没有实现硬盘驱动程序和文件系统，所以用户进程只能由一个函数代替</strong> ，实际上，这两者也没有本质区别。</p></li><li><p>第 15 行，由于 <strong><font color='orange'>用户不能直接使用显存</font></strong>，所以将 gs 直接初始化为 0，则用户使用该选择子时，会索引到 GDT 的第 0 号描述符而引发异常。</p></li><li><p>第 20 行，调用 get_a_page() 在指定位置，即用户空间 3GB 顶端处申请一页内存用来作用户栈，这在之前有所提及。</p><blockquote><p>用户栈只有一页吗？笔者暂不清楚当栈使用超过一页会发生什么，后续补充。</p></blockquote></li><li><p>第 23 行，intr_exit 是从 <code>interrupt.s</code> 引入的函数，专门处理中断返回。这没有什么好说的，只是为了复用代码，也可以直接在 23 行处使用内联汇编连续弹栈并 <code>iret</code> 。<code>iret</code> 后执行流就转移到用户进程啦！</p></li><li><p>第 27 行，page_dir_active，页表激活函数。从流程图中可以看见，该函数在 schedule() 中被调用，如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:thread.c</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    process_activate(next);</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong><u>每当任务切换(swtich_to)前，都会重新激活页表</u></strong> ，这不禁引发我们的疑惑：不是进程才有独立的地址空间吗？怎么连线程都要激活页表了呢？其实这可以在上节<a href="">进程的实现方式</a>找到答案。在 Linux 中，<strong><u>多个地址空间相同的线程组成了一个进程</u></strong> ，所以线程也需要记录页表。需要注意的是，<strong><font color='gree'>目前我们只实现了内核线程(thread_start) 和用户进程 (process_execute)，还未实现用户线程</font></strong>  (未来看情况按需添加)，所以 task_struct 中的 pgdir 只分为两种情况：NULL 和其他值；如果为 NULL，则说明该任务为内核线程；如果为非 NULL，则说明该任务为用户进程。<br>另外，<strong>第 40 行加载 cr3 有大坑！</strong> 还记得吗，在<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>一文中，笔者将内核的起始虚拟地址设置为了 0x1500，并提醒读者未来这个 0x1500 会留下问题。这个问题就在此处浮现：首次切换页表之前，执行流一直位于内核进程中，而内核进程虚拟空间的低 1MB 和高 3GB 处都是内核（这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中早有说明，忘记的读者请回头复习）。又因为之前将内核的起始虚拟地址设置为了 0x1500，所以一直以来内核始终运行在低端 1MB 处，而非高 3GB 处。关键来了，当内核执行流运行到第 40 行切换页表时，切换前执行流位于 1MB 下，切换后当然也仍位于 1MB 下（因为代码中的地址都是提前编译好的），但是，切换到用户进程的页表后，低端 1MB 就不再是内核啦（对于用户进程而言，内核只位于高 3GB 处）之前说过，用户进程的低端 128MB 为保留，没有任何东西，所以执行流运行在用户进程虚拟空间的低端 1MB 下将必定出错！因此，为了保证切换页表前后执行流能够统一，我们必须将内核的起始虚拟地址设置为 0xc0001500，这样对于内核进程和用户进程来说，内核都运行在高 3GB 上，切换页表前后执行流就不会改变。修改如下：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件说明:makefile</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0xc0001500</span><br></pre></td></tr></table></figure><blockquote><p>这里也是卡了笔者很久，如果当初不作死修改 Ttext，也不会引发这些问题，但实际上，不就是这些找 Bug 的过程加深了我们对程序的理解吗？</p></blockquote></li><li><p>第 51 行，只有用户进程才会更新 TSS 中的 ESP0，因为从内核进入中断不涉及特权级转移，从用户进程进入中断才会切换到对应的内核栈。</p></li><li><p>第 58 行是笔者期待已久的页表创建函数 create_page_dir()，该函数为用户进程创建对应的页目录表，其任务很简单：1）<strong>申请一页内存用来存放页目录表 <strong>；2）</strong><u>将内核页目录的第 768~1022 项复制到用户页目录表的相同位置，从而实现所有用户进程共享内核</u></strong> （这在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中重点提到过）；3）将用户进程页目录表的物理地址写入第 1023 号页目录项，这是为了访问页目录表和页表本身，详细原因仍请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。注意，<strong><u>用户进程的页目录表和页表不能安装在用户空间中，而是安装在内核空间里</u></strong> ，否则用户就可能自己修改页表，映射任意的内存地址，访问任何内存，进程间、内核的隔离保护就失去了意义。</p><blockquote><p>另外，不知道读者是否和我一样有这样的疑惑：为什么没有为用户程序本身开辟页表？也就是说，现在只映射了 3~4GB 的内核，而没有映射 0~3GB 的用户空间，那用户程序本身运行在哪？笔者从两个方面来解释此问题：<br>1）由于现在还没有完成硬盘驱动和文件系统，所以只能使用函数（如下面的u_prog_a、u_prog_b）来代替用户程序。而这些函数也是同样定义在 main.c 中，所以它们都会被链接进 kernel.bin，然后载入内核。换句话说，这些函数虽然是用户进程，但也位于 3~4GB 空间中（即使位于内核空间，特权级仍然为 3）。<strong>这只是目前为了演示用户进程而作的妥协</strong> 。<br><img src="/2022/img/image-20230106150001512.png" style="zoom:67%;" /></p><p>2）真正的用户进程加载是从硬盘读取程序并载入内存，进而运行，大致流程是这样的：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  &gt; graph LR&gt; A{创建独立的虚拟空间}--&gt;B{读取可执行文件头}--&gt;C{建立虚拟空间和可执行文件的映射关系}--&gt;D{将EIP设置为可执行文件的入口地址，开始运行}&gt;   </pre></div><p>啊啥？这不是还没将程序加载进内存吗？怎么就开始运行啦？是这样的，比如入口地址为 <code>0x08048000</code> ，<strong><font color='orange'>当执行流运行到该地址时，发现页面 <code>0x08048000~0x08049000</code> 是空页面，于是陷入缺页异常，异常处理程序通过第三步建立的映射关系找到可执行文件中缺失页面对应的部分代码，然后再将该部分载入内存，最后重新运行</font></strong> 。相关详细内容可参考《链接、装载与库》。<br>综上两点考虑，当前无需建立其他部分的映射。</p></blockquote></li><li><p>第 78 行，create_user_vaddr_bitmap() 函数用来为用户进程创建虚拟内存池，以便管理内存空间。其中 USER_VADDR_START 的值即为 <code>0x08048000</code> 。该函数逻辑清晰，不做说明。</p></li><li><p>第 88 行便是 process_execute() 函数。需要说明的是，该函数是在内核中被调用来创建用户进程的，而 fork 函数则是在用户程序中来创建子进程的，两者有巨大区别，将来实现 fork 时还会提到这一点。</p></li></ul><p>大功告成，了解了具体实现后，再来回顾进程创建的整个过程，思路也许会变得更清晰：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><h3 id="font-color-red-运行用户进程-font"><font color='red'>运行用户进程</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> test_var_a = <span class="number">0</span>, test_var_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_all();</span><br><span class="line"></span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_a&quot;</span>, <span class="number">31</span>, k_thread_a, <span class="string">&quot;argA &quot;</span>);</span><br><span class="line">    thread_start(<span class="string">&quot;k_thread_b&quot;</span>, <span class="number">31</span>, k_thread_b, <span class="string">&quot;argB &quot;</span>);</span><br><span class="line">    process_execute(u_prog_a, <span class="string">&quot;user_prog_a&quot;</span>);</span><br><span class="line">    process_execute(u_prog_b, <span class="string">&quot;user_prog_b&quot;</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_a</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试用户进程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">u_prog_b</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        test_var_b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_a</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_int(test_var_a,FT_RED,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">k_thread_b</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* para = arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        console_put_int(test_var_b,FT_YELLOW,HEX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而运行结果不尽人意：<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br>可见，运行一段时间后任务就停止了切换。这个 Bug 目前还没有找到，只知道这是锁引起的问题，没办法，只能将锁改为开关中断了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明:console.c</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//console_acquire();</span></span><br><span class="line">    CLI;</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    STI;</span><br><span class="line">    <span class="comment">//console_release();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>再次运行：</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/userpro1.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>现在好多了。关于这个锁的问题，笔者调试了两天还是不知道原因，请知道原因的读者朋友们在评论区留言，感谢！<br>需要说明的是，print 和 console 系列打印函数只能在内核，即 ring0 下使用，在用户进程中调用则会引发 0xd 号异常：<br><img src="/2022/img/image-20230112092402708.png" alt=""><br>所以这里使用两个变量 test_var_b、test_var_a 来间接反映进程的调度情况。</p><p>最后留下一个问题：既然禁止用户直接访问内核，那为什么还要将用户代码段描述符的界限设置为 4GB 呢？这样用户不就能轻松访问高地址的内核了吗？就像下面这样直接在用户态访问显存：<br><img src="/2022/img/image-20230112155046604.png" alt=""><br>既然这样，为什么不将用户代码段的界限设置为 3GB 呢？留给读者思考，笔者将在后续文章给出答案。</p><p>本文结束，下节实现系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现用户进程—进入用户态</title>
      <link href="/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>本文前置内容(必看)：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> ，<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a></strong> ，<a href="https://markrepo.github.io/kernel/2018/08/22/memory/">进程的虚拟内存布局</a>、《装载、链接与库》<br>本节对应代码讲解：<a href="https://jyx-fyh.github.io/2023/01/06/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">实现用户进程-代码详解</a></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong><font color='gree'>操作系统有三大核心功能：内存管理、进程管理、文件管理</font></strong> 。截至目前，我们已经完成了内存管理和进程管理的部分内容，对于内存管理，咋们还差内存回收机制；对于进程管理，由于线程是进程的基础，之前咋们实现了线程，所以进程也就完成了一半；文件管理将在不久后实现文件系统后再进行。</p><h3 id="font-color-red-任务切换的原生方式-font"><font color='red'>任务切换的原生方式</font></h3><p>在 <a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 一文中，我们简单了解过 TSS 与 LDT 的作用，明白了 TSS 和 LDT 只是理想中的任务管理和切换的工具： <strong><font color='orange'>Intel 建议用 TSS 来保存并恢复任务的状态，用 LDT 来保存任务的实体资源</font></strong> 。而考虑到效率问题，现代操作系统并未（完全）使用 TSS 和 LDT 来进行任务切换。至于为什么效率低下，看看其任务切换的具体过程便能体会到：<br>CPU <strong>原生支持</strong> 的任务切换方式有两种：1）中断 + 任务门；2）call / jmp + 任务门；下面分别介绍这两种方式。</p><p><strong><mark class="hl-label blue">中断+任务门</mark> </strong><br>既然是通过中断调用，那么调用方式只能通过中断信号或 int 指令进行，此时任务门也当然是在 IDT 中注册。<br><strong>调用过程如下：</strong></p><ol><li><p>时钟中断发生，处理器自动从该任务门描述符中取出新任务的 TSS 选择子。</p><blockquote><p>之前咋们的时钟中断的向量号对应的是中断门描述符，对应时钟中断处理程序（schedule），而现在我们要使用任务门来切换任务，所以时钟中断向量号就应该指向任务门描述符：<br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>这里笔者有个问题，时钟中断号为 0x20，如果 0x20 指向任务门描述符，那岂不是每次发生时钟中断时，都会切换到同一个任务？那还如何实现任务调度呢？由于我们的操作系统不会使用任务门来进行任务切换（Linux也不会)，所以这里就不深究了，直到答案的读者还请麻烦在评论区指点一二。</p></blockquote></li><li><p>用 TSS 选择子在 GDT 中索引 TSS 描述符。</p></li><li><p>判断该 TSS 描述符的 P 位是否为 1，为 0 则表示对应的 TSS 不在内存中，这将引发异常。</p></li><li><p>从 TR 寄存器中获取旧任务（当前任务）的 TSS 位置，将当前寄存器状态保存到该 TSS 中。</p></li><li><p>将新任务 TSS 中的值加载进相应寄存器。</p></li><li><p>将新任务的 TSS 段选择子加载进 TR 寄存器，这由 CPU 自动完成。</p></li><li><p>将当前任务的 B 位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">TSS/LDT/GATE</a> 。</p></li><li><p>将新任务标志寄存器的 NT  位置 1，原因参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>将旧任务的 TSS 选择子写入到新任务 TSS 的 <code>上一个任务的TSS指针</code> 字段中。</p></li><li><p>开始执行新任务。</p></li></ol><p><strong>返回过程如下：</strong></p><ol><li>调用 <code>iret</code> ，检查 NT 位，如果为 1，则应该返回旧任务而非中断返回。</li><li>将当前任务的 NT 位置 0 。</li><li>将当前任务的 TSS 描述符中的 B 位置 0 。</li><li>将寄存器现场保存到当前 TSS 中。</li><li>获取当前 TSS 中 <code>上一任务的TSS指针</code> 字段，将选择子加载进 TR 。</li><li>根据 TR 指向的 TSS 恢复寄存器现场。</li></ol><p><strong><mark class="hl-label blue">call、jmp切换任务</mark> </strong><br>任务门除了可以在 IDT 中注册，还能在 GDT 和 LDT 中注册，当在后两者中注册时，就可以通过 call、jmp 指令来切换任务。call 和 jmp 有所不同，前者有去有回，<strong>所以通过 call 调用的新任务可以认为是旧任务的分支，本质上它们算是同一个任务</strong> ；而 jmp 则是有去无回，新旧任务之间没有关系。<strong><font color='orange'>此二者的区别体现在是否将旧任务的 B 位置 0</font></strong> ，先以指令 <code>call 0x0018:0x1234</code> 来看 call 的任务调用过程：</p><ol><li><code>0x0018</code> 表示在 GDT 中索引第 3 号描述符，即任务门描述符。不同于普通段描述符，任务门描述符中记录的是 TSS 选择子，所以处理器自动忽略 <code>0x1234</code> 。</li><li>检查 P 位，为 0 则表示该描述符不在内存中，抛出异常。</li><li>检测 S 和 TYPE 位，判断描述符类型，如果是任务门描述符，则检查 B 位，若为 1 则抛出异常。</li><li>特权级检查，数值上 CPL 和 TSS 选择子中的 RPL 都要小于或等于 TSS 描述符的 DPL，关于特权级检查与 RPL、CPL、DPL 的区别，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a> 。</li><li>将当前任务的现场保存到 TR 寄存器所指向的 TSS 中。</li><li>将新任务的 TSS 选择子加载到 TR 寄存器中。</li><li>将新任务 TSS 中的寄存器载入到相应寄存器中，并进行特权级检查。</li><li>将新任务的 NT 位置 1，表示为任务嵌套，以便 iret 时从新任务返回到旧任务，而非从中断返回。</li><li>将旧任务的 TSS 选择子写入到新任务 TSS 中 <code>上一任务的TSS指针</code> 字段中，以便能够返回。</li><li>将新任务的 B 位置 1 以表示当前任务忙，<strong><u>但旧任务的 B 位仍然为 1，不会置零</u></strong> ；</li><li>切换完成，新任务开始。</li></ol><p>任务返回则同上文中断调用相同。</p><p>jmp 的任务调度过程和 call 几乎相同，只是第 10 步 B 位置零有所不同：<strong><u>由于 jmp 有去无回，所以新旧任务不构成链式关系，因此会将旧任务的 B 位置 0</u></strong> 。<br>从以上过程便能看出，CPU 原生的任务调度方式很是繁杂，这降低了任务切换的效率和灵活性，因此现代操作系统都没有采用这种方式。</p><h3 id="font-color-red-任务切换的现代方式-font"><font color='red'>任务切换的现代方式</font></h3><p>虽然咋们没有用 Intel 建议的方式来进行任务调度，但这也不是说 TSS 就一无是处了（LDT 是真的完全成孤儿了），Linux 在以下两个地方还是会用到 TSS：</p><ul><li><p><strong><font color='gree'>I/O 特权级控制</font></strong><br>我们一直认为用户进程无法直接访问硬件，必须通过操作系统才行；但是，为了在某些场景下快速反应，TSS 中的 I/O 位图为用户程序直接控制硬件提供了途径。</p><blockquote><p>提示：我们的操作系统并不会使用 IO 位图。</p></blockquote></li><li><p><strong><font color='gree'>将进程的内核栈记录在 TSS 中的 SS0 和 ESP0 位置处</font></strong><br>我们通过时钟中断来进行任务调度，在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>一文中提到，<strong><u><font color='orange'>当发生中断并引用中断门描述符时，会检查是否发生特权级转移，如果特权级改变，则会自动转移到新栈，这个新栈就从 TSS 中获取</font></u></strong> 。换句话说，一个任务分为用户部分和内核部分，从用户转移到内核时，CPU 就会 <u><strong>自动</strong></u> 切换到内核自己的栈。</p></li></ul><p>同时注意，<strong><u>Linux 只使用一个 TSS ，任务切换时并不会随之切换 TSS，而是只修改 TSS 中的 ESP0</u></strong> ，这样也会大大提高任务切换的效率。后文解析代码时，读者朋友就能清楚地看到这一过程。</p><h3 id="font-color-red-进程的实现方式-font"><font color='red'>进程的实现方式</font></h3><p><strong>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。<font color='orange'>而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务（这点对于理解进程和线程的关系至关重要）</font>，这在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程基础</a>中有代码说明</strong> 。<strong><font color='red'>每个任务都类似于单线程，具有内存空间、执行实体（寄存器）、文件资源等，<u>但不同的任务可以选择共享同一虚拟内存空间，因此，共享了同一个内存空间的任务集合构成了一个进程</u></font></strong> 。</p><p>我们的操作系统是仿 Linux 系统，所以咋们实现用户进程就能够以线程为基础，具体方式如下：<br>先回顾线程创建的大概流程：</p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，调用 get_kernel_page() 向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息（task_struct），包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>要以线程为基础实现进程，<strong>就只需要将执行普通任务的线程函数替换成创建进程的新函数（即start_progress）即可</strong> 。那么，具体创建进程的流程是怎么样的呢？见下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE33-1672725867793-2.png" alt=""></p><p>以上函数具体的实现待会再说，先来看看程序是如何进入到用户进程的。我们已经知道如下几点：</p><ol><li>用户进程运行在 3 特权级（ring3），而内核则运行在 ring0；</li><li>在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>一文中我们了解到，除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上。<br><img src="/2022/img/image-20230103141410952.png" style="zoom:67%;" /></li><li>一直以来我们都在内核中运行，即执行流一直停留在 ring0 。</li></ol><p>那么现在，要在内核中，即 ring0 下创建用户进程，并进入到 ring3 用户态，该怎么做呢？显然，只能通过中断返回，即 <code>iret</code> 进入用户态。<u>所以我们采用的具体办法是：利用之前的方式创建线程，将线程里运行的函数设置为 start_progress() ；然后在 start_progress 中初始化该线程的中断栈（也就是将用户进程的寄存器现场提前写入中断栈）；最后 <code>iret</code> 中断返回，即可 ring0 -&gt; ring3，进入用户态</u>。</p><p>其实这种方式可以说是瞒天过海，妥妥地欺骗了 CPU。我们用 <code>iret</code> 指令使 CPU 以为咋们处于中断处理环境中，于是便假装从中断返回，顺利通过特权级检查并进入用户态。</p><h3 id="font-color-red-用户进程的虚拟内存分布-font"><font color='red'>用户进程的虚拟内存分布</font></h3><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE34-1672909464756-2.png" alt="未命名绘图34"><br><strong>上图是经典的 Linux 用户进程内存布局(内核2.4版本)</strong> ，下面依次对各个部分作简单阐述：</p><ul><li><p>3GB~4GB 虚拟内存映射为内核空间，由所有进程共享。</p></li><li><p>用户内存的顶部是用户栈。一般而言，用户栈的最大空间为 8MB，详见<a href="https://www.tiehichi.site/2020/10/22/Linux%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/#%E5%86%85%E6%A0%B8%E6%A0%88">Linux进程栈空间大小 - Tiehichi’s Blog</a>。另外，用户栈的最高处会用来保存命令行参数和环境变量，这些数据是由 C 运行库压入的，后续从文件系统加载进程时会再提及此处。</p></li><li><p>用户栈下面是共享库的内存映射区域。共享库就是动态链接库，一个共享对象（即.so文件）由所有用户进程共享。举个例子，A 进程用到了 math 库，B进程也用到了 math 库，则 math 库会被加载到物理内存中，进而被映射到各个进程的虚拟内存空间中，由此实现共享，大大节省了内存，这便是动态链接库相对于静态链接库的优势。</p></li><li><p>接着是运行时堆，用于满足程序运行时的动态内存需求。</p></li><li><p>.bss 用于保存未初始化的数据，如未初始化的静态变量和全局变量。</p></li><li><p>.data 段用来保存已初始化且可读写的数据。实际上还有 .rodata 用来存放只读数据，此段并未体现在图中。</p></li><li><p>.text 则是代码区。IA-32 体系结构中，进程空间的代码段都从 <code>0x08048000</code> 开始，这与最低可用地址 <code>0x00000000</code> 有 128M 的间距。</p><blockquote><p>关于 <code>0x08048000</code> 这个值有许多解释，<a href="">Linker And Loader</a>一书给出的解释如下：<br>在 386 系统上，代码的起始虚拟地址是 <code>0x08048000</code> ，这允许在代码下方有一个相当大的堆栈；同时保持在地址0x08000000上方，允许大多数程序使用单个二级页表（回想一下，在 386 上，每个页目录项映射 0x00400000 大小的空间）。其他原因可参见<a href="https://www.cnblogs.com/l2017/p/11879310.html">0x08048000由来</a></p></blockquote></li></ul><p>关于进程的虚拟内存分布，这将在《 <strong>链接、装载与库</strong> 》系列笔记中详细阐述，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁机制—代码实现</title>
      <link href="/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/12/23/%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/">浅谈锁机制</a><br>本节对应分支：<code>lock</code></p></blockquote><p>在上节内容中我们提到，当线程申请锁时，如果该锁已经被其他线程拥有，则此线程必须在该锁上陷入睡眠，直到锁的拥有者将其叫醒。所以我们先实现进程的睡眠与觉醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_block</span><span class="params">(<span class="keyword">enum</span> task_status stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line">    cur_thread-&gt;status = stat;</span><br><span class="line">    schedule();                  <span class="comment">//将当前线程换下处理器</span></span><br><span class="line">    intr_set_status(old_status); <span class="comment">//待当前线程被解除阻塞后才继续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_unblock</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));</span><br><span class="line">    <span class="keyword">if</span> (pthread-&gt;status != TASK_READY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag))</span><br><span class="line">            panic(<span class="string">&quot;thread_unblock: blocked thread in ready_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 4 行，只有为 TASK_BLOCKED、TASK_WAITING、TASK_HANGING 三种状态才会进行睡眠。</li><li>第 20 行，为了使觉醒的线程尽快得到调度，使用 list_push 而非 list_append 。</li><li>注意，thread_block() 是由当前线程主动执行来进入睡眠的，如果要觉醒，则只能等待其他线程来唤醒，此时是被动的。</li></ul><p>再来看锁的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>  //信号量</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  value;       <span class="comment">//锁的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">waiters</span>;</span>  <span class="comment">//在此信号量上等待的线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span>       //锁结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">task_struct</span>* <span class="title">holder</span>;</span>    <span class="comment">// 锁的持有者</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span>    <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">    <span class="type">uint32_t</span> holder_repeat_nr;    <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>holder_repeat_nr</code> 是同一线程对锁的申请次数。这是为了 1）防止重复申请锁导致陷入死锁；2）防止多次释放锁而出错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sync.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore* psema, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    psema-&gt;value = value;       <span class="comment">// 为信号量赋初值</span></span><br><span class="line">    list_init(&amp;psema-&gt;waiters); <span class="comment">//初始化信号量的等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;</span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_init(&amp;plock-&gt;semaphore, <span class="number">1</span>);  <span class="comment">// 信号量初值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_down</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    <span class="keyword">while</span>(psema-&gt;value == <span class="number">0</span>)<span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag))</span><br><span class="line">        &#123;</span><br><span class="line">            panic(<span class="string">&quot;sema_down: thread blocked has been in waiters_list\n&quot;</span>,__FILE__,__LINE__,__func__);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">        list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);</span><br><span class="line">        thread_block(TASK_BLOCKED);    <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">    psema-&gt;value--;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_up</span><span class="params">(<span class="keyword">struct</span> semaphore* psema)</span> &#123;</span><br><span class="line"><span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    assert(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread_blocked</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));</span><br><span class="line">        thread_unblock(thread_blocked);</span><br><span class="line">    &#125;</span><br><span class="line">    psema-&gt;value++;</span><br><span class="line">    assert(psema-&gt;value == <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line"><span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder != running_thread()) &#123;</span><br><span class="line">        sema_down(&amp;plock-&gt;semaphore);    <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">        plock-&gt;holder = running_thread();</span><br><span class="line">        plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">struct</span> lock* plock)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>;   <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_up(&amp;plock-&gt;semaphore);   <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第 60 行，如果自己已经持有该锁，则仅将 holder_repeat_nr 加 1，不做其他操作，否则重复进行 sema_down 会导致死锁！</p><blockquote><p><strong>为什么重复申请同一把锁会产生死锁？</strong><br>在已经持有锁的情况下继续申请该锁，若仍 sema_down ，则线程会陷入睡眠，等待锁的持有者将自己叫醒。而锁的持有者又是其本身，自己可不能叫醒自己，因此系统陷入死锁。</p></blockquote><p>所以这里为了应对重复申请锁的情况，当第二次申请时（内层），仅 holder_repeat_nr++ ；当释放锁时，肯定是先从内层释放，所以仅 holder_repeat_nr-- ；外层释放时，再 sema_up 。</p></li><li><p>第 70 行，<strong>必须将置空操作放在 sema_up 之前</strong> 。如果顺序放反，则可能出现这样的情况：线程 A 刚执行完 sema_up 还没来得及置空 holder 就被换下了处理器，轮到线程 B 执行。线程 B 申请该锁，因为线程 A 已经释放，所以 B 申请成功，成为该锁的持有人。当线程 B 还没来得及释放锁时，线程 A 重新被换上 CPU，执行的第一条语句就是置空 holder，然而此锁现在依然属于线程 B ，这就引发了错误。</p></li><li><p>第 19 行为什么使用 while 而非 if，这是因为锁也是通过抢占来获得的，一次抢占可能无法获得锁，举个例子：线程 A 执行 down 操作时发现锁已经被 B 占用，于是陷入睡眠；线程 B 解锁，叫醒 A ；而线程 C 却排在 A 之前，优先被调度，所以锁又被 C 占用，A 继续陷入睡眠。<br>但这里也可以用 if 呢？见上面 thread.c 第 20 行，我们把叫醒的线程放在了首位，不存在线程 C 排在 A 之前的情况，所以可以用 if 。</p><blockquote><p>再次强调，叫醒并不是立刻调度，而是将其放入 thread_ready_list 中。</p></blockquote></li></ul><p>本文件代码在源代码基础上删除了许多 assert 断言，因为笔者发现即使没有触发这些断言，程序最终总会停留在某个任务中，不再调度其他任务，这令笔者非常疑惑，怎么 assert 还会影响程序结果？即使其没有被触发？这里折磨了我很久，最终也是胡乱改，把这些 assert 删除之后才得到了满意的结果。有明白其原理的朋友麻烦在评论区指点一二，感谢！</p><h3 id="font-color-red-实现终端输出-font"><font color='red'>实现终端输出</font></h3><p>emm，终端输出，这玩意儿听起来高端，实际就是给打印函数添了个锁，来看实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">// 控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_init(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str, <span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_str(str,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci,<span class="type">uint8_t</span> clr)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_char(char_asci,clr);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_int(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_uint</span><span class="params">(<span class="type">uint32_t</span> num,<span class="type">uint8_t</span> clr,<span class="type">uint8_t</span> radix)</span></span><br><span class="line">&#123;</span><br><span class="line">    console_acquire();</span><br><span class="line">    put_uint(num,clr,radix);</span><br><span class="line">    console_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这么简单。直接看结果吧：</p><div id="dplayer10" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer10"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/lock.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈锁机制</title>
      <link href="/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/12/22/%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-前言-font"><font color='red'>前言</font></h3><p>在上节<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程 - 进阶 - 任务调度</a>的末尾，笔者演示了当删去 <code>put_str()</code> 上下的 <code>STI</code> 和 <code>CLI</code> 后发生的错误情况（打印不规律，且发生 GP 异常）这是为什么呢？这里就不卖关子了，直接原因是 <strong>线程不同步</strong> 。这样说了也当白说，让我们仔细还原现场：</p><ol><li>k_thread_a 在 put_char 中读取了字符打印的光标位置 p 。</li><li>当 k_thread_a 准备更新光标位置时，中断发生，切换到 k_thread_b 。</li><li>k_thread_b 读取光标位置，由于 k_thread_a 还未更新光标，所以此时光标值仍为 p 。</li><li>于是，k_thread_b 在相同地方打印字符，覆盖了 k_thread_a 的字符。</li></ol><p>因此才出现少字符的情况。对于其他错误，比如一大串空格以及 GP 异常，就不详细说明原因了，只需明白，它们的罪魁祸首都是线程不同步造成的。为了进一步解释什么叫线程不同步，先来看看下面几个概念：</p><ul><li><p><strong><font color='gree'>临界区</font>：</strong> 是指包含有共享数据的一段 <strong><u>代码</u></strong> ，这些代码可能被多个线程访问或修改。临界区的存在就是为了保证当有一个线程在临界区内执行的时候，不能有其他任何线程被允许在临界区执行。</p><blockquote><p><strong>注意，临界区是代码，不是受访的静态公共资源。</strong></p></blockquote></li><li><p><strong><font color='gree'>互斥</font>：</strong> 某一时刻公共资源只能被一个任务访问，即，不允许多个任务同时出现在临界区中。</p></li><li><p><strong><font color='gree'>竞争条件</font>：</strong> 多个任务以竞争的方式（非互斥）进入临界区，其最终的的结果依赖于多个进程的指令执行顺序。<br>举例：假设两个进程 P1 和 P2 共享了变量 a。在某一执行时刻，P1 更新 a 为 1，在另一时刻，P2 更新 a 为 2。因此两个任务竞争地写变量 a。在这个例子中，竞争的失败者（最后更新的进程）决定了变量 a 的最终值。多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。</p></li></ul><p>显然，我们代码中的临界区就应该为 put_char（准确来说，是 put_char 中操作光标的代码部分），而 k_thread_a 和 k_thread_b 两个线程以竞争的方式访问临界区，从而产生竞争条件，最终引发不同步导致错误。那么，如何才能实现互斥访问呢？<strong><u>最简单的方式就是像视频演示中的那样开关中断，但现实的方式是采用锁</u></strong> 。关于这两种方式的比较，请见文末。</p><p>下面我们来看看锁的进化历程，以此加深读者对锁的理解。</p><h3 id="font-color-red-锁的进化-font"><font color='red'>锁的进化</font></h3><p>情景：金鱼有个很奇怪的特点，就是没有饱的感觉，如果你不停地给它喂食，它就会一直进食直到把自己撑死。现在线程 A 和线程 B 共同喂养一条金鱼，要求只能由其中一个线程进行喂食，即，若 A 线程已经投喂，那么 B 就不能再继续投喂；如果 B 线程已经投喂，则 A 线程也不能再投喂，否则金鱼被撑死。除了不能多次投喂外，也不能不进行投喂，即 A 和 B 线程中总有一者必须投喂金鱼，否则金鱼被饿死。</p><p><strong><mark class="hl-label blue">第一阶段</mark> </strong></p><p>使用全局变量 if_feed 标记喂食情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能防止多次投喂了吗？<br><img src="/2022/img/未命名绘图29.png" style="zoom:67%;" /><br>哦豁，依旧投喂了两次，金鱼被撑死。这里的原因在于，A、B 两线程同时进入了临界区。</p><p><strong><mark class="hl-label blue">第二阶段</mark> </strong></p><p>经过第一阶段的失败，我们吸取了教训：要防止金鱼胀死，就必须避免多个线程同时进入临界区，即需要做到互斥。下面通过留字条的方式来互斥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>以上代码无论按什么顺序穿插执行 A、B 线程，都不会再造成金鱼胀死了，但却可能饿死！如下：</p><img src="/2022/img/未命名绘图30.png" style="zoom:80%;" />哈哈，即使饿死，也比撑死好。这是因为几个线程同时获得一个资源，最终出现崩溃几乎是必然的事；如果谁都获取不了资源，则可能只是停止推进，而不一定产生错误结果。让我们继续改进。<p><strong><mark class="hl-label blue">第三阶段</mark> </strong></p><p>为了保证投喂，我们让某个线程一直等着，直到确认对方投喂之后再离开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">noteA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(noteB == <span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteA = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//================</span></span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">noteB = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed==<span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">&#125;</span><br><span class="line">noteB = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这样一来就能够保证金鱼能够被投喂了。但即使如此，以上方式仍存在较大问题：</p><ol><li>程序不对称。功能完全相同，程序却不一样，这加大了代码的难度。</li><li>浪费 CPU 资源。线程 A 的 while 完全是白占着 CPU 资源。</li><li>可能造成优先级倒挂。</li></ol><p><strong><mark class="hl-label blue">第四阶段</mark> </strong><br>那么现在，我们又该怎么办呢？仔细思考后其实可以发现，第 2、3 个阶段的重心都落在字条上，即留字条是为了防止两个线程同时投喂或都不投喂金鱼。既然留字条不能完美地解决办法，那有没有其他方法来进行互斥呢？有，当要投喂时，进入房间，把门锁上，投喂金鱼，打好标记，解锁并离开房间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br><span class="line"><span class="comment">//thread_B</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    feed fish;</span><br><span class="line">    if_feed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><p>这种为房间上锁的方式实际上是对第一种方案的改善，即，将检查标记和打标记合并为一个原子操作（投喂金鱼也被合并了）。如此一来，似乎就完美了。但再仔细观察后仍可以发现一个问题：如果线程 A 喂鱼的动作很慢，那么线程 B 将会被锁很长一段时间，这种等待不仅浪费 CPU 资源，也会降低系统效率。而且，喂鱼这个动作并非临界区，对标记的操作才是，所以完全可以将喂鱼的动作移出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">    noteA = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteB == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteA = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================</span></span><br><span class="line"><span class="comment">//thread_A</span></span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">    noteB = <span class="literal">true</span>;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span>(noteA == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_feed == <span class="literal">false</span>)</span><br><span class="line">        feed fish;</span><br><span class="line">    noteB = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>谨记，临界区的动作越少越好！</font></strong> 另外，当其他线程被锁在临界区外时，只能苦等锁被打开，除此之外无法进行任何动作，<strong><font color='orange'>所以这些线程就不应该再占用 CPU 资源，即，在锁被打开前，CPU 不再调度这些任务，直到锁被打开后再恢复调度</font></strong> 。这就涉及到线程的 <strong><font color='orange'>睡眠</font></strong> 与 <strong><font color='orange'>觉醒</font></strong> 。</p><h3 id="font-color-red-睡眠与觉醒：生产者和消费者问题-font"><font color='red'>睡眠与觉醒：生产者和消费者问题</font></h3><p><strong>线程的睡眠和觉醒是指：当对方持有锁，将你锁在外面时，你无需一直敲门，而是可以在门口睡觉，等到对方解锁之后再来叫醒你</strong> 。下面用线程中经典的生产者和消费者问题来演示睡眠与觉醒。我们知道，一般来说，生产者（厂家）会将商品批发给超市，然后消费者在超市进行购买。如果没有超市这个中转站，生产者就无法独立操作，必须拿到消费者的订单才能生产；消费者也必须在每次订货后且等待商品完工后才能拿到货。显然，超市扮演着重要的缓冲区角色。现在抛出两个问题：1）当超市没货了怎么办？2）当超市货太多装不下怎么办？</p><p>现实的实际做法一般是：<strong>当超市没货了，如果有顾客上门购买商品，则告知顾客缺货并让顾客回家等候通知；当超市货满了，则通知厂商暂时不要再生产</strong> 。用代码表示即如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100  <span class="comment">//超市最多能存下的商品数</span></span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//超市中现存的商品数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            sleep();         <span class="comment">//不再生产</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            wakeup(consumer);<span class="comment">//通知客户取货</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            sleep();         <span class="comment">//回家等通知</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)     <span class="comment">//如果count==N-1,说明厂家一定处于睡眠状态</span></span><br><span class="line">            wakeup(producer);<span class="comment">//通知厂家生产</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，wakeup() 只是叫醒对方线程，即让其重新在 thread_ready_list 中，而不是立刻调度！</strong></p></blockquote><p>以上代码看上去正确无误，实际上存在着巨大问题：<strong><font color='red'>可能造成死锁！</font></strong></p><blockquote><p>死锁，即生产者和消费者均无法向前推进。</p></blockquote><p>例如，若消费者先来，此时 count=0，则去睡觉，但在<u>睡下的前一刻</u>，CPU 任务调度，执行流转移到生产者。生产者开始运行，生产一件商品后发现 count=1，于是叫醒消费者。但此时消费者并没有睡觉（还在 thread_ready_list 中），所以这个叫醒信号无用。缓冲区满后，生产者转入睡眠，执行流转移到消费者。而消费者执行的第一个操作就是 sleep()，于是消费者也转入睡眠。最后两者都陷入睡眠状态并等待彼此叫醒自己，显然，它们都无法再醒来，系统死锁发生。</p><p>解决上述问题的方法也很简单。很容易发现，造成死锁的原因是因为叫醒信号的丢失。那我们想个办法将信号收集起来不就OK了嘛！消费者换上 CPU 执行 sleep 后，生产者发送的叫醒信号依然保留，因此消费者检测到该信号而觉醒。<strong><font color='gree'>这种能够累积的信号就叫做信号量</font></strong> 。</p><h3 id="font-color-red-信号量-font"><font color='red'>信号量</font></h3><p>实际上，信号量是操作系统中一个极其重要，威力巨大的概念，它不仅可以用来线程同步，还能用于进程间通信。我们现在仅讨论其作为锁的用途。<strong>当信号量的取值限制在 0 和 1 时，则获得了一把锁，也称二元信号量</strong> 。对信号量有 up、down 两种操作：</p><p><strong><font color='orange'>up：</font></strong> 1）将信号量加 1；2）唤醒在此信号量上等待的线程。<br><strong><font color='orange'>down：</font></strong> 1）判断信号量是否大于 0；2）若信号量大于 0，则将信号量减 1；3）若信号量等于 0，则在此信号量上睡眠。</p><blockquote><p>因为信号量是荷兰科学家 Dijkstra 发明的一种程序设计规范，所以 up 和 down 也被称为 PV 操作，即荷兰语中的 Proberen 和 Verhogen 。</p></blockquote><p><strong><u><font color='orange'>down 即获得锁，up 即解锁</font></u></strong> 。<strong>初始状态下信号量值为 1，某线程获得锁后，其值减为 0，当其他线程申请锁时，则只能在此锁上陷入睡眠，直到该线程解锁。</strong></p><p>值得一说的是，信号量也不是完美的解决方案，当二元信号量多起来后，死锁也有极大的概率会发生，但由于我们的操作系统非常简单，不会发生如此复杂的情况，所以不考虑这些情况，详细内容请参考《操作系统之哲学原理》。</p><h3 id="font-color-red-死锁-font"><font color='red'>死锁</font></h3><p>有大概如下几种情况会产生死锁：</p><ul><li><strong>忘记释放锁</strong></li><li><strong>单线程重复申请锁</strong></li><li><strong>多线程多锁申请</strong></li></ul><h3 id="font-color-red-锁比开关中断好在哪？-font"><font color='red'>锁比开关中断好在哪？</font></h3><p>前文提到，关中断是避免资源竞争最简单的方式，那为什么还需要锁呢？<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE31.png" alt=""><br>从上图可见，当红色箭头进入临界区时，关闭中断，虽然这避免了资源竞争，但却令红色箭头在整个临界区内独占 CPU，其他任务得不到调度，从而导致系统效率下降。这是关中断的方式，下面来看看用锁是什么情况：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE32.png" alt=""><br>锁就不一样了，当红色箭头获得锁进入临界区后，绿色箭头仍然能够得到 CPU 调度，直到到达临界区才会被锁住而进入睡眠。因此，<strong>相比于开关中断，锁机制在任务调度上的效率更高</strong> 。</p><blockquote><p>以上是笔者的个人想法，若读者还有其他想法，不妨在评论区提出。</p></blockquote><p>本文就到这里，下节我们将实现锁机制。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-进阶-任务调度</title>
      <link href="/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a><br>本节分支：<code>thread-schedule</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>任务链表</font></strong><br>通常使用链表来维护任务队列。链表本身不是本节的重点，所以笔者将其放在文末。</li><li><strong><font color='gree'>任务调度基础</font></strong><br>基于上节内容对 <code>thread.c</code> 和 <code>thread.h</code> 进行改进。</li><li><strong><font color='gree'>任务切换</font></strong><br>改进时钟中断，添加任务调度器，开始任务切换。</li></ul><h3 id="font-color-red-任务调度基础-font"><font color='red'>任务调度基础</font></h3><p><strong><mark class="hl-label blue">thread.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;      </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span> priority;</span><br><span class="line">    <span class="type">uint8_t</span> ticks;              </span><br><span class="line">    <span class="type">uint32_t</span> elapsed_ticks;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span>* pgdir;              </span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>thread.h 中只对 <code>task_struct</code>  添加了一些成员：</p><ul><li><strong>ticks：</strong> 时间片，任务刚被调度时，时间片被初始化为 priority，随后每发生一次时钟中断 ticks 就减 1，减到 0 后被换下 CPU 。</li><li><strong>elapsed_ticks：</strong> 记录该任务一共被运行了多少 CPU 滴答数。它和 ticks 的区别是：ticks 减到 0 时任务被换下 CPU，但此时任务可能还未执行完毕，所以重新加入到任务队列等待下一次被调度。所以，elapsed_ticks 记录的是从任务初次被调度到任务执行结束所经过的总滴答数，而 ticks 只是任务的一次倒计时。</li><li><strong>general_tag：</strong> <font color='orange'>当任务处于<u>就绪或其他等待状态</u>时，需要把该 tag 添加到 thread_ready_list 或其他相应等待队列中</font>。将 tag 加入到队列就相当于将 task_struct 加入到队列吗？是的，可以通过 tag 来定位 task_struct，原因很简单，因为这些 tag 本来就位于 task_struct 内存中，只需要根据成员的偏移量就能反向推断出 task_struct 的地址。文末会演示这一过程。<br><img src="/2022/img/image-20221217171337120.png" alt="通过tag将各个PCB连接成队列" style="zoom:67%;" /></li><li><strong>all_list_tag：</strong> thread_all_list 用来管理所有任务，所有任务的 all_list_tag 都需要加入到 thread_all_list 中。</li><li><strong>pgdir：</strong> 上节提到过，对于进程，pgdir 指向自己的页目录表；对于线程，pgdir 被初始化为 NULL 。注意，pgdir 中装的是虚拟地址，经过手动转换变成物理地址后才会加载进 CR2 ，这是后话。</li></ul><p><strong><mark class="hl-label blue">thread.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">main_thread</span>;</span>    <span class="comment">// 主线程PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_ready_list</span>;</span>    <span class="comment">// 就绪队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">thread_all_list</span>;</span>    <span class="comment">// 所有任务队列</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">thread_tag</span>;</span><span class="comment">// 用于保存队列中的线程结点</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> tmp_esp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前线程pcb指针 */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">running_thread</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov tmp_esp,esp&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">/* 取esp整数部分即pcb起始地址 */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> task_struct*)(tmp_esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由kernel_thread去执行function(func_arg) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */</span></span><br><span class="line">    intr_enable();</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程栈thread_stack,将待执行的函数和参数放到thread_stack中相应的位置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再留出线程栈空间,可见thread.h中定义 */</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread)</span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    </span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">/* 加入就绪线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">/* 加入全部线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将kernel中的main函数完善为主线程 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_main_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 因为main线程早已运行,咱们在guide.S中进入内核时mov esp,0xc009f000,</span></span><br><span class="line"><span class="comment">已经为其预留了pcb,地址为0xc009e000,因此不需要通过get_kernel_page另分配一页*/</span></span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">&quot;main&quot;</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main函数就是当前线程,当前线程不在thread_ready_list中,</span></span><br><span class="line"><span class="comment"> * 所以只将其加在thread_all_list中. */</span></span><br><span class="line">    assert(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务调度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    assert(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> =</span> running_thread();</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING)    <span class="comment">// 若当前线程只是时间片到了,将其加入到就绪队列尾,等待重新被调度</span></span><br><span class="line">    &#123;  </span><br><span class="line">        assert(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">        cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">        cur-&gt;status = TASK_READY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前线程是被阻塞了,则不需要将其加入到就绪队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!list_empty(&amp;thread_ready_list));</span><br><span class="line">    thread_tag = <span class="literal">NULL</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu.</span></span><br><span class="line">    thread_tag = list_pop(&amp;thread_ready_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;thread_init start\n&quot;</span>,DEFUALT);</span><br><span class="line">    list_init(&amp;thread_ready_list);</span><br><span class="line">    list_init(&amp;thread_all_list);</span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">    make_main_thread();</span><br><span class="line">    put_str(<span class="string">&quot;thread_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老规矩，讲解以上代码前先理理脉络：</p><ol><li><strong>开启线程机制前需要调用 <code>thread_init()</code> 来初始化线程环境，内容包括初始化就绪任务链表和所有任务链表、创建 main 线程。</strong></li><li><strong>初始化线程环境后即可调用 <code>thread_start()</code> 创建线程。在此函数中进入如下动作：</strong><br><strong>1）调用 <code>init_thread()</code> 初始化线程信息，</strong><br><strong>2）调用 <code>thread_create()</code> 将线程函数及其参数写入到线程栈中。</strong><br><strong>3）将该线程加入到 thread_ready_list 和 thread_all_list 中。</strong></li><li><strong>随后等待调度。</strong></li></ol><p>下面进行代码讲解：</p><ul><li><p>第 12 行，使用内联汇编取得当前 esp 的值。和之前一样，内联汇编中用到的 C 变量必须是全局或者全局静态变量，因此使用全局静态变量 tmp_esp 中转。</p></li><li><p>第 14 行，因为栈位于 PCB 中，而 PCB 大小为一页，所以将 esp 向下取页框，即得 PCB 起始地址。</p></li><li><p>第 21 行，进入线程函数 <code>function()</code> 前需要先打开中断，这里需要重点说明其原因：任务切换是由时钟中断驱动的，也就是说，<code>schedule()</code> 是在时钟中断里被调用的，任务调度后直接进入 <code>function()</code> 执行任务 ，<strong><u>并不会返回中断（iret）</u></strong> ，这样一来，就相当于任务的调度和执行都发生在中断里。咋们之前说过，进入中断后 <code>IF</code> 位自动置 0，也就是屏蔽外部中断，如此一来，进入该任务后就无法发生时钟中断来调度其他任务啦，于是，该任务独占了 CPU 控制权！为了防止这种情况发生，<strong><font color='orange'>我们需要在进入任务前手动开启中断</font></strong> ！！！</p></li><li><p>第 68 行，<strong>只有将该任务加入到 thread_ready_list 队列中，才会被 CPU 调度</strong> ；目前还没有体现到 thread_all_list 的作用，后续才会用到该队列。</p></li><li><p>第 77 行，从 CPU 被启动的那一刻，执行流就一直在按我们的代码运行。现在，<strong>我们要将该执行流也包装成线程（即kernel_main线程）并加入到队列中，否则调度其他任务后就没法回到主线程了</strong> 。注意 <code>guide.s</code> ：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[BITS 32]</span><br><span class="line">extern kernel_main</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov esp, 0xc009f000</span><br><span class="line">    jmp kernel_main</span><br></pre></td></tr></table></figure><p>第 6 行，<strong>进入内核前必须将 esp 指向主线程 PCB 的顶端，即 0xc009f00 处，否则无法根据 esp 定位到 PCB</strong> 。</p></li><li><p>第 92 行，<code>schedule()</code> 函数可能在时钟中断里被调用，也可能被后续将要说到的 <code>thread_block()</code> 函数调用。<strong><font color='orange'>因此，在 <code>schedule()</code> 中需要考虑当前线程是出于什么原因才被换下 CPU 的，是因为时间片到期？还是说被阻塞了？所以必须针对不同的状态做出相应的应对措施</font></strong> 。另外，最下方调用的 <code>switch_to</code> 是汇编函数，下文会重点讲解。</p></li><li><p>第 109 行，由于我们还未实现 idle 线程，所以就绪队列可能为空，为了避免无线程可调度的情况，暂用 assert 来保障。</p></li><li><p>第 114 行，<code>elem2entry()</code> 是宏函数，用来将 general_tag 或 all_list_tag 转换为对应的 task_strcut 指针。此函数在文末介绍链表时会谈到。</p></li></ul><p>其他就没什么好说的了，下面进入正题。</p><h3 id="font-color-red-任务切换-font"><font color='red'>任务切换</font></h3><p>我们采用的调度方式是 <strong><font color='red'>轮询（Round-Robin，RR）</font></strong> ，这是一种基础的调度方式。轮询，说白了就是按先进先出（FIFO）的顺序一个一个调度。切换任务时，从 thread_ready_list 弹出队首，并将其调度上 CPU 。注意，正在执行的任务的状态是 RUNNING，该任务不在 thread_ready_list 中，而在 thread_all_list 中。</p><p><strong>完整的任务调度分为三个大步：</strong></p><ol><li><strong>进入时钟中断</strong></li><li><strong>时钟中断调用 <code>schedule()</code></strong></li><li><strong><code>schedule()</code> 调用 <code>switch_to()</code></strong></li></ol><p><strong><mark class="hl-label blue">1.进入时钟中断</mark> </strong><br>还记得吗？在<a href="https://jyx-fyh.github.io/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加入中断</a>一文中，我们将每个中断处理函数都统一初始化为 <code>general_intr_handler()</code> ，这是一般化函数，只是用来告诉我们发生了什么中断，以便于排错。现在咋们就需要将时钟中断专门化了，见以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idt.c</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_handler</span><span class="params">(<span class="type">uint8_t</span> vector_no, intr_handler function)</span></span><br><span class="line">&#123;</span><br><span class="line">    interrupt_handler_table[vector_no] = function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> ticks;          <span class="comment">// ticks是内核自中断开启以来总共的嘀嗒数</span></span><br><span class="line"><span class="comment">/* 时钟的中断处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intr_timer_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur_thread</span> =</span> running_thread();</span><br><span class="line"></span><br><span class="line">    assert(cur_thread-&gt;stack_magic == <span class="number">0x19870916</span>);  <span class="comment">// 检查栈是否溢出</span></span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;elapsed_ticks++;                    <span class="comment">// 记录此线程占用的cpu时间嘀</span></span><br><span class="line">    ticks++;  <span class="comment">//从内核第一次处理时间中断后开始至今的滴哒数,内核态和用户态总共的嘀哒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_thread-&gt;ticks == <span class="number">0</span>)                     <span class="comment">// 若进程时间片用完就开始调度新的进程上cpu</span></span><br><span class="line">        schedule();</span><br><span class="line">    <span class="keyword">else</span>                                            <span class="comment">// 将当前进程的时间片-1</span></span><br><span class="line">        cur_thread-&gt;ticks--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    put_str(<span class="string">&quot;timer_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);</span><br><span class="line">    register_handler(<span class="number">0x20</span>, intr_timer_handler);  </span><br><span class="line">    put_str(<span class="string">&quot;timer_init done: Clock interrupt frequency increased to 100Hz\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局变量 ticks 用来记录自中断开启后经历的总滴答数，类似于系统运行时长的概念。该变量当前保留，未来可能会用到。</li><li>第 14 行，<strong>cur_thread-&gt;ticks == 0 意味着<u>该任务还未结束，但时间片已经到期</u></strong> ，所以进入 <code>schedule()</code> ，将该任务重新放入队尾等待下一次调度。</li><li>第 25 行，注册专门的时钟中断。</li></ul><p><strong><mark class="hl-label blue">进入schedule()</mark> </strong></p><p>上文已作讲解，不再说明。</p><p><strong><mark class="hl-label blue">进入switch_to</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">section .text</span><br><span class="line">global switch_to</span><br><span class="line">switch_to:</span><br><span class="line">   ;栈中此处是返回地址</span><br><span class="line">   push esi</span><br><span class="line">   push edi</span><br><span class="line">   push ebx</span><br><span class="line">   push ebp</span><br><span class="line"></span><br><span class="line">   mov eax, [esp + 20]     ; 得到栈中的参数cur, cur = [esp+20]</span><br><span class="line">   mov [eax], esp          ; 保存栈顶指针esp</span><br><span class="line">                           </span><br><span class="line">                           </span><br><span class="line">;------------------  以上是保存当前线程的栈，下面是恢复下一个线程的栈  ----------------</span><br><span class="line">   mov eax, [esp + 24]     ; 得到栈中的参数next, next = [esp+24]</span><br><span class="line">   mov esp, [eax]          ; 恢复esp</span><br><span class="line">                           </span><br><span class="line">   pop ebp</span><br><span class="line">   pop ebx</span><br><span class="line">   pop edi</span><br><span class="line">   pop esi</span><br><span class="line">   ret                     ;第一次执行时会返回到kernel_thread</span><br><span class="line">                           ;后续执行则会返回到schedule函数</span><br></pre></td></tr></table></figure><ul><li>关于 esi、edi、ebx、ebp 的压栈问题已在<a href="https://jyx-fyh.github.io/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">线程-基础-加载线程</a>中阐述。</li><li>参数 cur 和 next 分别是当前任务和下个任务的 task_struct 指针，需要强调的是，<strong>由于 task_struct 的首个成员是 self_kstack，所以可以认为 cur 和 next 指针也是指向 self_kstack</strong> ！这样一来，<strong><font color='orange'>self_kstack 的真正作用便清晰了——记录线程被换下瞬间的 esp 值</font></strong> 。</li></ul><p><strong><code>switch_to</code> 是任务调度的核心，它向我们直接展示了操作系统是如何通过栈切换来完成任务调度的</strong> 。不过，大家可能还是很迷糊，不急，让我们看看实际的调度过程：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE28-1671258856847-2.png" alt="以下解析的步骤和上图的序号相对应"></p><ol><li><p>当前执行流位于 kernel_main() 主线程，esp 当然也位于 kernel_main 的 PCB 顶端。某一时刻，时钟中断发生，<strong>中断压栈保护任务现场</strong> ，接着进入 <code>schedule()</code> ，进而到 <code>switch_to()</code> 。<code>switch_to()</code> 前半段将当前 esp 的值保存到 kernel_main 的 self_kstack 中。</p><blockquote><p>为什么 cur 和 中断栈之间还有个省略号？这只是想告诉大家，实际的线程栈情况和 <code>thread_stack</code> 结构体并不能一一对应，比如，调用 <code>schedule()</code> 函数还需要将返回地址压栈呢，而这个并没有考虑进 <code>thread_stack</code> 或 <code>intr_stack</code> ，所以栈中的数据实际上是错位的！不能通过该结构体取得栈内对应的值。<code>intr_stack</code> 也同样不能对应，比如，在 kernel_main() 中调用了一个函数，执行此函数时发生中断，此时的 esp 就不是从 0xc009f000 开始的啦！</p></blockquote></li><li><p>执行 <code>mov esp,[eax]</code> 后即完成栈切换。<strong><font color='orange'>注意，这个新任务是首次被调度的，它的线程栈已经在 <code>thread_create()</code> 中被我们设计好了</font></strong> 。</p><blockquote><p>为啥没省略号了？因为现在对齐啦！！！要知道，在 <code>thread_create()</code> 中，我们跳过了中断栈和线程栈，将 self_kstack 不偏不倚地指向了线程栈的起点，所以这里是完全对齐了的，也是基于这一点，下面的 pop 和 ret 才能正确执行。</p></blockquote></li><li><p>四次 pop 并 ret，成功进入 eip 对应的 <code>kernel_thread()</code> ，进而 <code>function()</code> ，任务开始执行。</p></li><li><p>某时刻，中断再次发生，中断压栈，再一路来到 <code>switch_to()</code> 上半部分，即保存当前栈。<strong><font color='orange'>注意，由图可见，此时中断压栈是发生在线程栈中而非中断栈中！</font></strong></p><blockquote><p><strong><font color='orange'>注意步骤 3 和步骤 4 的栈中的 eip 差异，这点差异非常重要！步骤 3 中的 eip 是我们设计好的，指向 <code>kernel_thread()</code> ；而步骤 4 中的 eip 是 <code>schedule()</code> 中调用 <code>switch_to()</code> 时留下的返回地址，也就是说将来会通过这个 eip 回到 <code>schedule()</code></font></strong> 。<br>另外再次强调，中断之所以能够再次发生，是因为我们进入 <code>function()</code> 前手动打开了中断，这并不是 <code>iret</code> 的功劳。</p></blockquote></li><li><p>执行 <code>switch_to()</code> 的下半部分，<code>mov esp,[eax]</code> ，切换任务栈。</p></li><li><p>接着 pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复 kernel_main() 的任务。</p></li><li><p>一段时间后，中断发生，保存当前栈。</p></li><li><p>恢复之前的栈。此时的 eip 是 <code>schedule()</code> 留下的返回地址（而非 kernel_thread 的地址）。</p></li><li><p>pop 并 ret，依次退出 <code>switch_to()</code> 、<code>schedule()</code> 和中断函数，恢复线程任务。</p><blockquote><p>可见，该线程的线程栈栈底将一直存留这三个参数，这并不重要。问题是，当任务结束后，<code>kernel_thread()</code> 该如何返回呢？这个占位符原本应该是 <code>switch_to</code> 调用 <code>kernel_thread()</code> 留下的返回地址，但现在它仅是一个占位符，<strong><font color='orange'>这意味着任务结束后 kernel_thread() 将无法正常返回！</font></strong> 所以，<strong><u>在我们的操作系统中，线程返回不能通过普通 return 的方式进行</u></strong> ，而要专门调用一个线程退出函数（ <code>thread_exit()</code> ）来结束任务，这是后话，目前我们的策略是强制要求在任务末端放一个 <code>while(1)</code> ，以避免任务结束。关于这点的实验演示见以下视频。</p></blockquote></li></ol><blockquote><p><strong>为什么使用 <code>ret</code> 来调用 kernel_thread() ？</strong><br>从上面的过程你可以发现，<code>switch_to</code> 的最后一句 <code>ret</code> ，在线程首次被调度时，是进入 <code>kernel_thread()</code> ；后续被调度时，则是返回到主调函数 <code>schedule()</code> 中。<strong><font color='orange'>所以此处的 <code>ret</code> 有双重作用！而你可以通过 ret 调用 kernel_thread，也可以使用 ret 来返回 schedule，但你可不能使用 call 来返回 schedule 吧？这也是为什么要使用 <code>ret</code> 而非 <code>call</code> 来调用 <code>kernel_thread()</code> 的原因！</font></strong></p></blockquote><div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_exit.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>可见，一旦任务退出，就引发缺页异常。不知道有没有眼尖的小伙伴看见 while 语句中，打印语句上下的 <code>STI</code> 和 <code>CLI</code> ？为什么要在 <code>put_str()</code> 的上下分别放置这两条语句呢？先让我们看看，如果去掉这两条语句会发生什么：</p><div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/thread_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>看见了吗？若去掉 <code>STI</code> 和 <code>CLI</code> ，则会发生 0xd 号异常。这涉及到锁相关的内容，将在下节内容详细介绍。</p><p>另外，说说笔者在这里遇见的一个大坑，看下面的 <code>interrupt.s</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后的interrupt.s</span></span><br><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>上面是修改后的 <code>interrupt.s</code> ，也就是现在的版本。而之前，笔者是像下面这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line">INTERRUPT_ENTRY_%<span class="number">1</span>:        ;中断处理entry</span><br><span class="line">    %<span class="number">2</span></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %<span class="number">1</span></span><br><span class="line">    call [interrupt_handler_table + %<span class="number">1</span>*<span class="number">4</span>]</span><br><span class="line">    add esp, <span class="number">4</span>             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,<span class="number">0x20</span>            ;中断结束命令EOI</span><br><span class="line">    out <span class="number">0xa0</span>,al            ;向从片发送</span><br><span class="line">    out <span class="number">0x20</span>,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,<span class="number">4</span>   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,<span class="number">32</span>位下等同指令iretd</span><br></pre></td></tr></table></figure><p>嗯？只是处理 EOI 的代码改变了位置，有什么影响吗？影响可大了！前文已经强调，任务调度在时钟中断处理函数(第11行)中进行的，调度完成后直接开始执行任务，并不会返回到中断内并执行末尾的 <code>iret</code> 指令；而中断发生后 CPU 会自动将 IF 位置零来屏蔽外部中断，因此，为了防止任务独占 CPU，任务（即<code>function()</code>)正式开始前还要手动开中断。问题来了，<strong><font color='orange'>8259A 芯片发送中断信号后，必须要收到 CPU 发来的 EOI 结束命令后才会继续发送中断，否则即使你开了中断也没用！</font></strong> 所以，按上面的写法，进入第 11 行时钟中断处理函数后，压根不会执行后面的 EOI 发送代码，时钟中断无法产生，后续的任务调度也就没法进行了！这里坑了笔者两天之久！</p><h3 id="font-color-red-链表-font"><font color='red'>链表</font></h3><p>双向链表是用来维护任务队列的核心数据结构。数据结构不是本系列博客的重点，所以就不详细展开了，仅强调几个要点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset(struct_type,member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line"><span class="meta">        (struct_type*)((int)elem_ptr - offset(struct_type, struct_member_name))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">prev</span>;</span>  <span class="comment">// 前躯结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">next</span>;</span>  <span class="comment">// 后继结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span>   <span class="comment">//头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span>   <span class="comment">//尾节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数类型function,用于在list_traversal中做回调函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">bool</span> <span class="params">(function)</span><span class="params">(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_iterate</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span>;</span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>offset</code> 宏用来计算结构体内的某成员相对于该结构体起始处的偏移量。这个操作很骚，可以说将指针运用得炉火纯青了：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)(&amp;((struct_type*)<span class="number">0</span>)-&gt;member)</span><br></pre></td></tr></table></figure><p>将 0 强制转换为 struct_type* 指针，换句话说，<strong><u>该指针指向 struct_type 类型的结构体，而该结构体位于地址 0x0000 处</u></strong> 。如此一来，由于是以地址 0x0000 为基准，所以该结构体中成员的地址即为此成员相对于该结构体的偏移量。</p></li><li><p><code>elem2entry</code> 宏就好说了，用 tag 指针减去 tag 偏移量即得结构体的起始地址。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next</span> =</span> elem2entry(<span class="keyword">struct</span> task_struct, general_tag, thread_tag); <span class="comment">//thread.c第114行</span></span><br></pre></td></tr></table></figure><blockquote><p>那么，为什么这两个操作设计成宏而非函数呢？留给读者自己思考。</p></blockquote></li><li><p>注意，list 中的 head 是头节点，而非首元节点；尾节点同理；节点只会插在 head 与 tail 之间。</p><blockquote><p>头节点是一个不存放任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，<strong>它的作用只是为了方便解决某些实际问题</strong> ；<br>首元节点是链表中第一个存有数据的节点；首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p></blockquote></li><li><p>第 19 行，自定义函数类型，该类型在 <code>list_traversal()</code> 中作为回调函数的类型。如果不使用 typedef，那么第 30 行声明就需改成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="type">bool</span> (func)(<span class="keyword">struct</span> list_elem*, <span class="type">int</span>), <span class="type">int</span> arg)</span>;</span><br></pre></td></tr></table></figure><p>显然，这种方式没有上一种方式好看。<code>list_traversal()</code> 函数当前还未使用，后续用到了再介绍。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="comment">/* 初始化双向链表list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_init</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head.next = &amp;<span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.prev = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把链表元素elem插入在元素before之前 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_before</span><span class="params">(<span class="keyword">struct</span> list_elem* before, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    before-&gt;prev-&gt;next = elem;</span><br><span class="line">    elem-&gt;prev = before-&gt;prev;</span><br><span class="line">    elem-&gt;next = before;</span><br><span class="line">    before-&gt;prev = elem;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加元素到列表队首 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_push</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(plist-&gt;head.next, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 追加元素到链表队尾 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_insert_before(&amp;plist-&gt;tail, elem); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使元素pelem脱离链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_remove</span><span class="params">(<span class="keyword">struct</span> list_elem* pelem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">intr_status</span> <span class="title">old_status</span> =</span> intr_disable();</span><br><span class="line">    pelem-&gt;prev-&gt;next = pelem-&gt;next;</span><br><span class="line">    pelem-&gt;next-&gt;prev = pelem-&gt;prev;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将链表第一个元素弹出并返回,类似栈的pop操作 */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_pop</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    list_remove(elem);</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">elem_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, <span class="keyword">struct</span> list_elem* obj_elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == obj_elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把列表plist中的每个元素elem和arg传给回调函数func,</span></span><br><span class="line"><span class="comment"> * arg给func用来判断elem是否符合条件.</span></span><br><span class="line"><span class="comment"> * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的元素返回元素指针,否则返回NULL. */</span></span><br><span class="line"><span class="keyword">struct</span> list_elem* <span class="title function_">list_traversal</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist, function func, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(plist))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(elem, arg))   </span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        elem = elem-&gt;next;     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回链表长度 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">list_len</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> =</span> plist-&gt;head.next;</span><br><span class="line">    <span class="type">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (elem != &amp;plist-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        elem = elem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断链表是否为空,空时返回true,否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">list_empty</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span>* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (plist-&gt;head.next == &amp;plist-&gt;tail ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数都是常规的链表操作，不再解释。</p><p>本文结束。经过这两节的煎熬，想必读者朋友们也憔悴了吧？哈哈，休息再战！</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理-进阶-分配页内存</title>
      <link href="/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/"/>
      <url>/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节前置内容：<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理-基础-初始化内存池</a><br>本节对应分支：<code>memory-alloc</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>对笔者而言，内存分配一直是操作系统最神秘的部分之一，从学习编程开始，就一直能在耳边听到这个词，所以这也是本人最期待的部分，不知读者是否也是如此呢？本节我们实现的内存分配是“整页分配”，这与 malloc 函数不同，后者能申请任意大小的内容，而前者的申请单位则是以页为计。不过，malloc 也是基于“整页分配”进行的，所以未来我们也会借助本节内容来实现 malloc 函数。</p><p>本节的函数逻辑也都很简单，只是它们的数量较多，关系稍显复杂，所以贴心的笔者（手动狗头^_^）献上一幅函数关系图以供大家参考：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE22.png" alt=""><br>上图就是内存申请的全过程，大括号中包含的函数即为括号所指函数中调用的函数，且从上到下依次调用。上图只是为了让大家稍微熟悉页分配的过程，具体过程咋们还是来看代码吧。</p><h3 id="font-color-red-代码解析-font"><font color='red'>代码解析</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pool_flags</span> &#123;</span></span><br><span class="line">   PF_KERNEL = <span class="number">1</span>,    <span class="comment">// 内核内存池</span></span><br><span class="line">   PF_USER = <span class="number">2</span>     <span class="comment">// 用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_1  1<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_P_0  0<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_R  0<span class="comment">// R/W 属性位值, 读/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_RW_W  2<span class="comment">// R/W 属性位值, 读/写/执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_S  0<span class="comment">// U/S 属性位值, 系统级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_US_U  4<span class="comment">// U/S 属性位值, 用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">mem_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">malloc_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span>;</span><br></pre></td></tr></table></figure><ul><li>pool_flags 为枚举，用来指明当前的操作对象是内核内存池还是用户内存池。</li><li>第 18~23 行为页表项/目录项的属性，这将在我们创建页表项和页目录项时用到。读者可能已经忘了页表项/页目录项的格式：<br><img src="/2022/img/IMG_0526(20221115-170651)-1670564791259-2.png" alt="" style="zoom:67%;" /><br>关于这些属性的详细介绍，请回顾<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr对应的页目录表索引,其实直接addr&gt;&gt;22也是可以的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr对应的页表索引</span></span></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START   0xc0100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,</span></span><br><span class="line"><span class="comment"> * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pf == PF_KERNEL) </span><br><span class="line">   &#123;</span><br><span class="line">      bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">      <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span>(cnt &lt; pg_cnt)       <span class="comment">//将申请到的位置1,表示已使用</span></span><br><span class="line">        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">      vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pte指针*/</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pte_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pde的指针 */</span></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">pde_ptr</span><span class="params">(<span class="type">uint32_t</span> vaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 0xfffff是用来访问到页目录表本身所在的地址 */</span></span><br><span class="line">   <span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在m_pool指向的物理内存池中分配1个物理页,</span></span><br><span class="line"><span class="comment"> * 成功则返回页框的物理地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 扫描和设置位图要保证原子操作 */</span></span><br><span class="line">   <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>); <span class="comment">// 找一个物理页面</span></span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);       <span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">   <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">uint32_t</span>  vaddr = (<span class="type">uint32_t</span>)_vaddr;</span><br><span class="line">   <span class="type">uint32_t</span>  page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">   <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">   <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,可能会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">   <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">   <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>)           <span class="comment">//页目录项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">   &#123;                            <span class="comment">//如果存在，则添加映射(安装页表项)</span></span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);  <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                             <span class="comment">//如果页目录项对应的页表不存在,则先创建页表再创建页表项. </span></span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="comment">/* 页表所用页框一律从内核空间分配 */</span></span><br><span class="line">      <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool); <span class="comment">//申请页表空间</span></span><br><span class="line">      *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);     <span class="comment">//安装页目录项</span></span><br><span class="line">      <span class="comment">/* 以下将分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">       * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">       * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">       * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">       * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);    <span class="comment">//将申请到的页表清零</span></span><br><span class="line">      assert(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">//注册页表项</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   assert(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);       <span class="comment">//3840页内存=15MB</span></span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line">   <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">   <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">void</span>* page_phyaddr = palloc(mem_pool);      <span class="comment">//palloc每次申请一个物理页</span></span><br><span class="line">      <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>)   <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">      &#123;  </span><br><span class="line">          <span class="comment">//回滚,后续补充</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射 </span></span><br><span class="line">      vaddr += PG_SIZE;                          <span class="comment">// 下一个虚拟页</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_kernel_pages</span><span class="params">(<span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">   <span class="type">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>)  <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">      <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">   <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==========以下是mem_pool_init和mem_init函数,上节已做解析,不再展示。=====================</span></span><br></pre></td></tr></table></figure><p>建议看官阅读代码时，按上面给的函数关系图的顺序进行，这样思路会更加清晰。注释很详细，下面只对几个点做强调：</p><ul><li><p>第 41 行，获取虚拟地址对应的 PTE 地址。如何根据给定的虚拟地址定位相应的页目录和页表？这在<a href="">开启分页-代码详解</a>中提到过，请各位回顾该节，此处不再赘述。</p></li><li><p>第 57 行，“扫描和设置位图要保证原子操作”，这句话的意思是，<strong>扫描和设置位图必须连续，中间不能切换线程</strong> 。这里和线程切换有关，简单作下阐述：比如当线程 A 执行完第 58 行，成功找到一个物理页面；紧接着，切换到 B 线程，恰好 B 线程也执行到了 58 行，也成功找到了一个物理页面。<strong>由于线程 A 找到后还没来得及将该位置 1 就被换下 CPU，因此 A、B 这两个线程此时申请的是同一个物理页面！这必然会引发问题</strong> 。因此扫描和设置位图必须保证原子操作。需要注意的是，<strong><font color='orange'>此处代码并没有保证原子性，未来我们会用锁来实现</font></strong> 。当然，如果读者实在不放心，可以先在此函数首尾分别关开中断，避免时钟中断引发任务调度。</p></li><li><p>同样是申请页，为什么 vaddr_get() 有申请页数的参数，而 palloc() 没有呢？这个答案在第 100 行 malloc_page() 函数中。这是因为申请的 <strong>虚拟地址必须连续，即必须是一整块虚拟内存；而申请的物理内存则无需连续</strong> （如果要求物理内存连续，则分页机制将彻底变成鸡肋）。所以，申请一大块虚拟内存时，填写你所需的页数参数即可；而申请一大块物理内存时，则需要通过第 115 行的 while() 进行。同时注意，第 58 行的位图扫描，申请个数被指定为 1 。</p></li><li><p><strong><u><font color='gree'>第 79~96 行是需要重点强调的内容</font></u></strong> 。<br>（1）第 79 行判断该 vaddr 对应页目录项是否存在，这句话并不精确，应该是：判断该页目录项对应的页表是否存在。原因是，页目录项一定是存在的（因为页目录表是完整的），不管是现在的内核进程或是将来的用户进程，创建进程时我们都为其开辟一张完整的页目录表内存，<u>只是说可能并不会为所有的页目录项填写信息（安装页目录项）</u>。有人会问，既然并非每个页目录项都记录了信息，那怎么还能通过 79 行的 if 语句判断目录项对应的页表是否存在呢？好问题！<strong>这就是第 133 行将申请到的页内存全部清零的原因</strong> 。将来我们为用户进程开辟页目录表时，会通过 get_kernel_pages() 申请一页内存，并将其作为页目录表。此时页目录表所占字节全为 0（第133行），因此每个页目录项中的 P 位也为 0（表示不对应任何页表），如此一来，就可以通过 P 位来判断该目录项对应的页表是否存在。也就是说，如果不显式安装页目录项，则 P=0，无对应页表。<br>（2）第 85 行注释，<strong><font color='orange'>不论是内核页表还是用户页表，所用页框一律从内核空间分配</font></strong> 。注意，用户进程的页目录表/页表存放在内核空间而非用户空间中，否则恶意用户进程就可以通过某些方式修改内存映射，从而访问内核或其他进程的物理内存。<strong>因此，内存管理都由内核负责！</strong><br>（3）第 93 行，与前类似，须将申请到的页表内存初始化为 0，这样访问某虚拟地址时，如果对应的页表项不存在，即 P=0，则引发缺页异常。注意，笔者最初很疑惑为什么不直接利用 pde_phyadd 清零页表：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pde_phyadd, <span class="number">0</span>, PG_SIZE);</span><br></pre></td></tr></table></figure><p>这是因为：<strong><font color='orange'>由于开启了分页，即使 pde_phyadd 为页表的物理地址，编译器也会将其看作虚拟地址</font></strong> ，所以此方式清零的内存并非物理地址 pde_phyadd！经过第 87 行安装页目录项后，<code>(void*)((int)pte &amp; 0xfffff000)</code> 对应的物理地址才是 pde_phyadd 。这里很绕，请读者反复理解！</p><blockquote><p>内核的页目录被创建时也被初始化为 0，参见<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中 loader.s 的第 122 行代码。</p></blockquote><blockquote><p>在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">分页机制</a>中我们说过，页目录表必须完整，通过以上解析，大家理解了其中的原因吗？由于页目录表已经覆盖所有地址，页表才能够按需创建，这相比于一级页表，大大节省了页表所占用的内存。</p></blockquote><blockquote><p>实际上，只有在用户进程中才会出现页目录项对应的页表不存在的情况。内核代码只运行在 1MB 内，内核堆的约 1GB 空间也已经提前创建好了页表（第769~1022号页表），所以内核不会出现此情况。</p></blockquote></li><li><p>vaddr_get()、palloc()、page_table_add() 均被声明为静态函数，这是因为这三个函数仅供 malloc_page() 函数使用，对外部不可见。</p></li></ul><p><img src="/2022/img/image-20221211151606411.png" alt=""></p><p>OK，本节就到这里，内容少但密度大，注意消化。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解字符串操作函数</title>
      <link href="/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2022/12/05/%E8%AF%A6%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>string</code></p></blockquote><p>下节我们将要实现内存管理，这不可避免地要频繁使用到 memcpy、memset 等函数，有了内存操作函数就很容易实现字符串操作函数 strcpy、strcat 等。所以这节我们来实现内存操作和字符串操作函数。本节内容虽然简单，但有许多代码规范需要注意，还请读者不可掉以轻心。</p><p><strong><mark class="hl-label blue">memset</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst, <span class="type">char</span> var, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((size--) &gt; <span class="number">0</span>)</span><br><span class="line">        *tmp++ = var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，<code>void*</code> 是无法直接作指针运算的，因为编译器无法确定其步长及其解释方式</font></strong> 。因此，需要定义 <code>unsigned char* tmp</code> 来代替 <code>void* dst</code> ，tmp 指针的步长即为 1 字节。以下同理。</p><blockquote><p>什么是指针的步长？就是指 <code>++</code> 或 <code>--</code> 时指针移动的字节数。<br>什么是解释方式？就是指定编译器如何去解释指针所指向的这个数据。</p></blockquote><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">void</span>* src, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    src = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">    dst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(size--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">        dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有以下两点需要注意：</p><ol><li>规范问题：能直接 <code>assert(dst!=NULL &amp;&amp; src!=NULL)</code> 吗？<br>当然可以，但出问题时，你怎么确定是 dst 还是 src 的问题？所以最好细化，便于追踪错误。</li><li>解决了 <strong><font color='orange'>内存重叠</font></strong> 的问题，参考<a href="https://jyx-fyh.github.io/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/">memcpy和memmove</a> 。</li></ol><p><strong><mark class="hl-label blue">memcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* mem1, <span class="type">const</span> <span class="type">void</span>* mem2, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(mem1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(mem2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp1 = mem1;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp2 = mem2;</span><br><span class="line">    <span class="keyword">while</span>((size++) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp1 != *tmp2)</span><br><span class="line">            <span class="keyword">return</span> *tmp1 &gt; *tmp2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        tmp1++;</span><br><span class="line">        tmp2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcpy</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst,<span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="type">char</span>* tmp = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串 src 是不会被改变的，所以要声明为 const 。</li><li>注意第 5 行的检查，这是我们容易忽略的地方。</li><li>第 8 行，赋值运算符也是有返回值的，其返回所赋的值，即 <code>*src</code> 。</li></ul><p>上面代码看上去无懈可击，实际上也存在内存重叠的问题：<br><img src="/2022/img/image-20221205235315941.png" alt="存在内存重叠时，报错"></p><p>因此将代码改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dst == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst,src,<span class="built_in">strlen</span>(src)+<span class="number">1</span>); <span class="comment">//+1是包括&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20221205235435072.png" alt="修改代码后，正常运行"></p><p><strong><mark class="hl-label blue">strlen</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp++);</span><br><span class="line">    <span class="keyword">return</span> tmp-str<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 -1 可别忘了。</p><blockquote><p>这种方式很容易忽略 1，保险可采用此方式：<code>while(*tmp) tmp++;</code> ；如此就无需减 1 。</p></blockquote><p><strong><mark class="hl-label blue">strcmp</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*dst != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *dst==*src)</span><br><span class="line">    &#123;</span><br><span class="line">        dst++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *dst &lt; *src ? <span class="number">-1</span> : *dst &gt; *src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第 10 行，把 0、1、-1三种情况都概括了，很漂亮的方式。</p><p><strong><mark class="hl-label blue">strchr与strrchr</mark> </strong><br>strchr ：参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*str &amp;&amp; *str != ch)</span><br><span class="line">        str++;</span><br><span class="line">    <span class="keyword">if</span> (*str == ch)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strrchr ：参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong> 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* last_char = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == ch) </span><br><span class="line">            last_char = str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)last_char;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strcat</mark> </strong><br>string-concatenate：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//通过strcpy来实现strcat函数</span></span><br><span class="line">    <span class="built_in">strcpy</span> (dst + <span class="built_in">strlen</span> (dst), src);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">strchrs</mark> </strong><br>string-char-reserch：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">strchrs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* tmp = src;</span><br><span class="line">    <span class="keyword">while</span>(*tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == ch)</span><br><span class="line">            cnt++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础-加载线程</title>
      <link href="/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/03/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://blog.csdn.net/qq_26442553/article/details/78729793">并发和并行</a>，<a href="https://cloud.tencent.com/developer/article/1688297">区分进程和线程</a>，《操作系统真相还原》《操作系统哲学原理》<br>本节分支：<code>thread</code></p></blockquote><p>嚯，跨过千山万水，咋们终于要实现线程啦！这是既内存管理后，笔者最期待的部分。正式开干前，先让我们了解一下本节的学习框架。</p><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li><strong><font color='gree'>并发和并行、同步与异步</font></strong><br>这是常见而又容易混淆的几种关于任务执行的概念，它们与线程、进程息息相关。</li><li><strong><font color='gree'>任务、进程、线程</font></strong><br>任务是 CPU 的最小调度单元；任务既可以是线程，也可以是进程；<strong>线程是在进程基础上进行的第二次并发</strong> 。</li><li><strong><font color='gree'>PCB</font></strong><br>进程/线程的身份证，用于存放进程/线程的管理和控制信息。</li><li><strong><font color='gree'>线程的内核态与用户态实现</font></strong><br>粗略了解这两种方式的优缺点以及现代操作系统对线程的实现模型。</li><li><strong><font color='gree'>线程实现</font></strong><br>初步实现线程，这是下节实现任务调度的基础。</li></ul><h3 id="font-color-red-并发与并行、同步与异步-font"><font color='red'>并发与并行、同步与异步</font></h3><p><strong><mark class="hl-label blue">并发和并行</mark> </strong><br><strong>并发又称“伪并行”</strong> ，<strong>并发的实质是一个物理 CPU 在若干道程序之间来回切换，每一刻都只有一个任务在 CPU 上执行</strong> ，但因为切换任务的速度相当快，所以看上去是多个任务同时执行。</p><blockquote><p>需要注意的是，伪并行降低的是任务的平均响应时间，也就是说，并发让执行时间短的任务可以不必等待那些执行时间长的任务完全结束后再被调度，因此任务的响应速度快了许多；然而，<strong>所有任务的总执行时间实际上不减反增，这是因为任务切换也需要时间</strong> 。但显然，如果能让后面的紧急任务能够及时完成，这点时间成本是微不足道的。</p></blockquote><p><strong>并行则是真正意义上的多个任务同时执行，这必须建立在多核处理器的基础上，每个任务在不同的核上进行</strong> 。<br>另外，还有一个常见的名字是“串行”，并行和串行都指任务的执行方式。<strong>串行是指存在多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个</strong> ，并发的工作方式即为串行。</p><p><strong><mark class="hl-label blue">同步和异步</mark> </strong></p><p>同步和异步，以及阻塞和非阻塞，这两组概览看上去简单，实际上有很多细节需要区分。笔者尚未有讲解该知识点的能力，详细请参考<a href="https://www.zhihu.com/question/19732473/answer/241673170">同步和异步、阻塞与非阻塞</a> 。</p><h3 id="font-color-red-任务、进程、线程-font"><font color='red'>任务、进程、线程</font></h3><p>任务是一个相对而言比较抽象的概念，它是软件发起的某一个活动，其既可以是线程，也可以是进程。<strong><u>任务是独立的执行流，每个任务都具备自己的一套资源（栈、寄存器映像等），这些资源是保证该任务能够被 CPU 单独执行的关键</u></strong> ！什么叫做被 CPU 单独执行呢？举个例子：在 A 任务中调用了 func() 函数，这个 func() 函数是随 A 任务一块被带上处理器的，实际的调度单元是 A 任务而非该函数，换句话说，这个函数是在更大的执行流（A任务）中被“夹杂着、捎带着”执行的，甚至有可能没有等到执行该函数，任务 A 就被换下了 CPU 。在这个例子中，任务 A 为调度单元，即被 CPU 单独执行。如果我们想让 func() 函数成为单独的执行流，就必须为它分配上下文环境，使其成为任务。</p><p><strong><u>线程是任务调度的基本单位</u></strong> ，是独立的执行流，而进程则是多个线程的集合。它们的联系与区别如下：</p><ul><li><p>进程是对运行时程序的封装，是 <strong><font color='gree'>系统进行资源调度和分配的的基本单位</font>，实现了操作系统层面上的并发</strong> ；线程是进程的子任务，<strong><font color='gree'>是 CPU 任务调度和分派的基本单位</font>，是在进程基础上实现的第二次并发</strong> 。</p></li><li><p>一个进程可以有多个线程，<strong><font color='gree'>同一进程的所有线程共享该进程的资源</font></strong> ，如<u>地址空间</u>、代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）；<strong><font color='gree'>但是每个线程拥有自己的栈段，用来存放所有局部变量和临时变量</font></strong> 。</p><blockquote><p>需要强调的是，每个进程都有自己的 4GB 虚拟空间，同一进程内的线程共享该虚拟空间。</p></blockquote></li><li><p>进程可分为单线程进程与多线程进程，在我们平时写的程序中，<u>如果没有显式创建线程，那么该程序就是单线程进程</u>。线程不能独立于进程而存在。</p></li><li><p><strong><font color='gree'>进程=资源+线程</font></strong> 。</p></li></ul><blockquote><p><strong><font color='red'>Window 对线程和进程的实现如同教科书一般标准，不仅在概念上对线程和进程有明确的区分，在 API 上也是如此：使用 CreateProgress 和 CreateThread 来分别创建进程和线程。而在 Linux 下就不存在明显的线程概念，其将所有的执行实体都称为任务（task），并由 task_struct 结构体负责管理任务。这个task_struct 数据结构囊括了进程管理生命周期中的各种信息</font></strong> 。</p></blockquote><p>刚才我们提到，在某个任务中调用 func() 函数，则此函数是随该任务一起被放上 CPU 执行的，并非单独的执行流。那么有没有方法能够使某个函数成为单独的执行流呢？有，就是通过线程。<strong>在高级语言中，线程是运行函数的一种方式</strong> ，与普通函数的执行方式不同，线程机制可以为函数创造它所依赖的上下文环境，使函数代码具有独立性，进而能被 CPU 单独调度。下面是 Linux 下 C 语言创建线程的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ThreadFun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg is NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">char</span> * url = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="comment">//定义两个表示线程的变量（标识符）</span></span><br><span class="line">    <span class="type">pthread_t</span> myThread1,myThread2;</span><br><span class="line">    <span class="comment">//创建 myThread1 线程</span></span><br><span class="line">    res = pthread_create(&amp;myThread1, <span class="literal">NULL</span>, ThreadFun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>暂不深究 pthread_create() 函数，有兴趣的同学请自行研究。</p></blockquote><p><strong><mark class="hl-label blue">有了进程为什么还要引入线程？</mark> </strong></p><ul><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，线程之间切换的开销小。所以线程的创建、销毁、调度性能远远优于进程。</li><li>同一进程内的线程共享资源，因此它们之间相互通信无须调用内核，比进程间通信更方便。</li><li>进程采用多个线程（执行流）和其他进程抢占处理器资源，从而节省单个进程的总时间。</li><li>避免某些阻塞使整个进程都被挂起。</li></ul><blockquote><p>那么，在同一个进程下，哪些资源被线程共享，哪些又是线程私享的呢？一般的评判标准是：如果资源独享会导致线程运行错误，则该资源由线程共享。下表给出一般情况下的共享与独享资源划分：</p><table><thead><tr><th>线程共享资源</th><th>线程独享资源</th></tr></thead><tbody><tr><td>地址空间</td><td>栈</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开的文件</td><td>状态字</td></tr><tr><td>子进程</td><td>程序计数器</td></tr><tr><td>堆</td><td>…</td></tr><tr><td>…</td><td></td></tr></tbody></table></blockquote><h3 id="font-color-red-PCB-font"><font color='red'>PCB</font></h3><p>PCB(Process Control Block，程序控制块)，用于唯一地标识一个进程和记录进程的相关信息。<strong><u>PCB 的具体格式并不固定，这取决于操作系统厂商</u></strong> 。PCB 的一些基本信息如下：</p><table><thead><tr><th>内核栈</th><th><strong>内核栈指针</strong></th><th>优先级</th><th>PID</th><th>时间片</th><th>页目录表指针</th><th><strong>进程状态</strong></th><th>…</th></tr></thead></table><p>现代操作系统的 PCB 已经相当复杂，加之笔者也没有深入了解，因此本文不再对其展开，只说我们后面将要用到的东西以及重点内容：</p><ul><li><p>我们的操作系统较小，<strong>PCB 只会占到一页内存</strong> 。<strong><font color='orange'>在 PCB 的顶部是内核栈，内核栈分为中断栈与任务栈；PCB 底端则是 PCB 的相关信息，如栈指针、PID、时间片等</font></strong> 。这点在 <a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理基础</a>中说过，忘记的同学还请回头看看。</p><blockquote><p>既然是内核栈，<strong><font color='gree'>说明此栈是在 ring0 下使用的栈，而非 ring3 下的用户栈</font></strong> 。就因为栈在 PCB 中，所以 PCB 才会占一页的大小。<u>为什么要为每个线程都分配一个内核栈呢</u>？大概有以下原因：</p><ul><li>线程切换就是通过栈切换来实现的（下节内容），如果所有线程共享一个栈，就没法完成任务调度啦。</li><li>将线程相关的所有资源的集中在一起，方便管理。比如线程执行后需要销毁，由于 PCB 中存放着该任务的所有资源，所以直接回收该 PCB 就行了，无需其他多余动作（当然，堆管理另说，这由程序员自己负责 free，否则内存泄漏）。</li></ul></blockquote></li><li><p>不是说同一个进程下的线程共享虚拟空间吗，那为什么 PCB 中还会有页目录表指针呢？是这样的，<strong><font color='gree'>Linux 中不论线程还是进程，都统一由 task_struct 结构体管理，对于线程，页目录表指针被初始化为 NULL；对于进程，页目录表指针指向该进程的页目录表起始地址</font></strong> 。这是线程和进程的最大区别。另外，在进程创建之初，会重新加载 CR2 寄存器（该寄存器中存放的是页目录表的物理地址），这将在后续实现用户进程时提到。</p></li><li><p>优先级并不是说谁先执行，而是指定每次任务执行时所经历的中断次数。初始状态下，时间片等于优先级。之前说过，<strong><u>任务切换是由时钟中断驱动的，也就是说任务调度是在时钟中断处理函数中进行的</u></strong> 。当 A 任务刚被调度上 CPU 时，时间片被初始化为优先级，之后每发生一次中断，时间片就自减 1，当时间片等于 0 时，该任务被换下 CPU 。因此，<strong>优先级越大，占用 CPU 的时间就越长</strong> 。</p></li><li><p>严格来说，<strong><font color='gree'>内核栈指针并不是用来指向内核栈的（内核栈永远位于 PCB 顶端），它是用来指向内核寄存器现场的</font></strong> 。读者看完这句话一定是一头雾水，不急，该指针是任务切换的核心，下节我们会重点剖析该指针的作用，敬请期待。</p></li><li><p><strong>PID就是各进程的身份标识</strong> ，程序一运行系统就会自动分配给进程一个独一无二的 PID 。<strong>PID 只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程</strong> 。PID 将在后续添加，目前暂时不用。</p></li><li><p>一般来说，<strong><font color='gree'>按进程在执行过程中的不同情况至少要定义三种不同的进程状态：运行态(running)、就绪态(ready)、阻塞态(blocked)</font></strong>  。在我们的操作系统中，定义了六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead)。这几态的作用将在后续实现一一体现。</p><blockquote><p>虽然叫做“进程状态”，但这可不意味着只有进程才能使用这个信息，线程同样能使用。</p></blockquote></li></ul><h3 id="font-color-red-线程的内核态与用户态实现-font"><font color='red'>线程的内核态与用户态实现</font></h3><p>由于线程依附于进程而存在，所以其储存方案无需额外设计，而是直接使用进程的储存方案（这就是 Linux 中进程和线程都是用 task_struct 结构体作为任务信息存储结构的原因）。虽然进程与线程采用了相同的储存方案，但两者的调度方式却有所不同。线程产生于进程，理所当然的，其调度就可以由进程负责（用户态）；另一方面，线程调度也可以交给操作系统来管理（内核态）。</p><blockquote><p>进程调度只能由操作系统负责，并不存在用户态一说。</p></blockquote><p><strong><mark class="hl-label blue">内核态实现</mark> </strong><br><strong>优点：</strong></p><ol><li><p>并发性高。采用与进程类似的调度方式，从而使线程实现进程级并发。</p><blockquote><p>什么是进程级并发？由于操作系统直接控制进程，所以当某个进程被阻塞时，操作系统能够立刻检测到这个情况并将其他进程调度上 CPU 。对于内核态实现的线程而言，当某个线程被阻塞，操作系统也可以立即反应过来，并将其他线程调度上 CPU。</p></blockquote></li><li><p>简化用户编程。线程的复杂性由操作系统承担，程序员无需关心线程的调度。</p></li><li><p>提升了进程的速度。当进程内的线程较多时，该进程占据的 CPU 资源就更多，执行时间就越短。</p></li></ol><p><strong>缺点：</strong></p><ol><li>效率较低。每次调度都需要进入内核态，多了些现场保护的栈操作，因此减小了效率。</li><li>占用稀缺的内核资源。线程的数量远多于进程数，因此随着线程的数量增加，内核空间将迅速被耗尽。</li><li>内核态的实现需要修改操作系统。这在提出线程的初期是很难办到的，操作系统厂商可不会轻易将一个未被证明的新概念加入到操作系统中。因此，最初只能由用户自己管理线程。</li></ol><p><strong><mark class="hl-label blue">用户态实现</mark> </strong><br><strong>优点：</strong></p><ol><li>灵活性高。操作系统不知道线程的存在，其仅对用户可见，因此在任何操作系统上都能够实现此方式。</li><li>切换效率高。无需进入内核态，减少了栈操作。</li></ol><p><strong>缺点：</strong></p><ol><li>编程变得复杂。不同于由时钟中断驱动的内核态任务调度，程序员必须时刻考虑什么时候主动让出 CPU ，将控制权交给其他线程。实际上，一旦线程多起来，人为管理将是巨大麻烦。</li><li>无法实现进程级并发。用户态实现下，当进程中的某个线程被阻塞，这将使整个进程都被阻塞！这是致命的缺点。</li></ol><p><strong><mark class="hl-label blue">现代操作系统的线程实现模型</mark> </strong><br>现代操作系统对以上两种实现取其精华、剔其糟粕，将二者有机结合：<strong><u>用户态负责进程内部在非阻塞时的切换；内核态负责线程阻塞时的切换</u></strong> 。同时，每个内核态线程可以负责多个用户态线程，比如，某进程有 5 个线程，操作系统将这 5 个线程划分为两组，一组 2 个，另一组 3 个，每组使用一个内核线程，如下图：</p><img src="/2022/img/IMG_0564(20221216-100357).PNG" style="zoom:67%;" />当某个线程阻塞时，同组的线程皆被阻塞，当另一组仍可继续执行。如此一来，该模型就缓解了以上两种方式的缺点：<ol><li>不必为每个线程都创建对应的内核线程，减小了内核资源的压力。</li><li>不会因为一个线程的阻塞而使整个进程被挂起。</li><li>用户态线程的切换无需经过内核，提高了效率。</li></ol><p><strong>注意，为了简单，本操作系统仅使用内核态实现。</strong></p><h3 id="font-color-red-实现线程-font"><font color='red'>实现线程</font></h3><p>本节是对线程的简单实现，主要让大家理解操作系统是如何 <strong><font color='orange'><u>通过栈切换来完成线程切换的</u></font></strong> 。下面先看 thread.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>*)</span>; <span class="comment">//使用typedef自定义函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TASK_RUNNING,</span><br><span class="line">    TASK_READY,</span><br><span class="line">    TASK_BLOCKED,</span><br><span class="line">    TASK_WAITING,</span><br><span class="line">    TASK_HANGING,</span><br><span class="line">    TASK_DIED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> vec_num;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esp_dummy;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> gs;</span><br><span class="line">    <span class="type">uint32_t</span> fs;</span><br><span class="line">    <span class="type">uint32_t</span> es;</span><br><span class="line">    <span class="type">uint32_t</span> ds;</span><br><span class="line">    <span class="comment">//------以下为CPU自动压入------------</span></span><br><span class="line">    <span class="type">uint32_t</span> err_code;</span><br><span class="line">    <span class="type">void</span> (*eip) (<span class="type">void</span>);</span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="comment">//------以下为发生特权级转移时自动压入-----</span></span><br><span class="line">    <span class="type">void</span>* esp;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*eip) (thread_func* func, <span class="type">void</span>* func_arg);</span><br><span class="line">    <span class="type">void</span>* unused_retaddr;</span><br><span class="line">    thread_func* function;</span><br><span class="line">    <span class="type">void</span>* func_arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程或线程的pcb,程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>* self_kstack;   <span class="comment">//内核栈指针</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span> <span class="comment">//任务状态</span></span><br><span class="line">    <span class="type">uint8_t</span> priority;        <span class="comment">//优先级</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];           <span class="comment">//任务名</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_magic;    <span class="comment">//魔数，用于检测PCB是否被栈破坏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span>;</span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>第 4 行 task_status 枚举定义了前文提到的六态：运行态(running)、就绪态(ready)、阻塞态(blocked)、等待态(waiting)、挂起态(hanging)、终止态(dead) 。</p></li><li><p>第 14 行定义了中断栈。注意，结构体中靠前的成员位于内存低地址，靠后的成员位于高地址，所以可发现，结构体成员的声明顺序和 <code>interrupt.s</code> 中的压栈顺序是对应的：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE25.png" alt=""><br><strong>必须要说明的是，虽然这两者是一一对应的关系，但我们并不会通过 <code>intr_stack</code> 结构体来取得栈中寄存器的值</strong> ！原因有两点：</p><p>1）没必要取得这些寄存器的值，它们仅用来保护现场。为了安全，也不建议获取它们的值；<br>2）无法保证一定是一一对应的关系。比如，最下方的 SS 和 ESP，此二者仅在发生特权级转移时才会压入，所以是否发生特权级转移将直接影响其对应关系。因此，无法通过该结构体获取栈中的值。那为什么还要声明这个结构体呢？没有其他原因，<strong><u>只是为了得到该中断栈的大小</u></strong> ，以便后续跳过该栈。</p></li><li><p>第 39 行是线程栈，该栈有两个作用：<br>1）保存任务调度的现场，即 ebp、ebx、edi、esi 这四个寄存器。为什么只保存这四个寄存器？这涉及到 ABI，见<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C与汇编混合编程</a>。<br>2）指定线程中要运行的函数及其参数。即最后四个成员。下面重点说说这几个成员：</p><ul><li><p>eip：创建线程时，我们会将 eip 指向 kernel_thread() 函数，通过 kernel_thread 来调用想运行的函数：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span>&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unused_retaddr：这是用来占位的，没有其他作用。为什么要占位？说来话长。进入 kernel_thread() 时，并不是通过 <code>call</code> 指令来调用的，而是 <code>ret</code> 指令。什么不伦不类、莫名其妙的玩意儿？？？干嘛用 <code>ret</code> 来调用函数？读者朋友请别急，笔者初学此处时也是一脸懵逼，现在暂时无法解释，等到下节任务调度时笔者会专门解析这一点，现在只需记住，<u>kernel_thread() 是在 <code>switch.s</code> 中通过 <code>ret</code> 指令进入的</u> 。那么问题来了，<strong>kernel_thread() 是 C 语言写的函数，C 默认这个函数是 call 调用的，所以在寻参时会跳过 call 指令留下的返回地址（call下一条指令的地址）</strong> 。正常调用 kernel_thread() 函数时，其反汇编大致如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push  func_arg</span><br><span class="line">push  function</span><br><span class="line">call  kernel_thread </span><br><span class="line">;------------------进入kernel_thread后</span><br><span class="line">push  [esp-8]</span><br><span class="line">call  function</span><br></pre></td></tr></table></figure><p>其中 <code>[esp-8]</code> 就是寻参，寻的是 func_arg 参数，<strong><u>减 8 则是跳过返回地址和 function 参数</u></strong> 。由于我们用的是 <code>ret</code> 而非 <code>call</code> ，所以必须手动为 kernel_thread() 营造是 call 指令的假象，即，将原本的返回地址用占位符代替，以确保能够正确寻参。</p><blockquote><p>爱思考的读者可能会问，既然我们将返回地址用占位符代替，那这岂不是意味着 kernel_thread() 运行完毕后无法正确地返回？是的，它不能像普通函数那样返回，因为它本身可不普通，它可是运行在线程里的、高贵的函数。哈哈，开个玩笑，这点我们也会在下节中剖析。</p></blockquote></li><li><p>function 和 func_arg 的作用见上一点。值得一提的是，<strong>线程函数(function)的参数必须为 void</strong>* ！<strong>这是为了应对需要向线程函数传递多个参数的情况：<font color='gree'>当需要传递多个参数时，需要将这些参数包装成结构体，并将结构体指针传入即可。如果不使用此方式，想传几个参数就传几个，那么栈操作就无法统一，任务切换也无从谈起。</font></strong></p></li></ul></li><li><p>第 53 行的 task_struct 就是我们的线程控制块啦！前三个成员在前文提到过，这里重点讲解 stack_magic 是如何检测 PCB 是否被破坏的。我们已经知道，内核栈在 PCB 的顶部（高地址处），任务信息在 PCB 的底部（低地址处），由于栈是由高地址向低地址扩展的，所以在某些情况下栈可能会覆盖低地址的 task_struct ：<br><img src="/2022/img/未命名绘图26.png" style="zoom:80%;" /><br>可见，只要 task_struct 被破坏，那么最先被覆盖的一定是 stack_magic（这也是为什么将 stack_magic 声明在最后的原因） ，所以可以通过检测该魔数来判定是否发生破坏。stack_magic 任由你自己决定，应适当复杂。</p></li></ul><p>接着来看 thread.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>* <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kernel_thread</span><span class="params">(thread_func* function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> intr_stack);</span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_stack);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>* <span class="title">kthread_stack</span> =</span> (<span class="keyword">struct</span> thread_stack*)pthread-&gt;self_kstack;</span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread</span><span class="params">(<span class="keyword">struct</span> task_struct* pthread, <span class="type">char</span>* name, <span class="type">int</span> prio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line">    pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;self_kstack = (<span class="type">uint32_t</span>*)((<span class="type">uint32_t</span>)pthread + PG_SIZE); <span class="comment">//将栈指针指向PCB顶端,即栈底</span></span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19870916</span>;  <span class="comment">// 自定义的魔数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  name:线程名</span></span><br><span class="line"><span class="comment">*  prio:线程优先级</span></span><br><span class="line"><span class="comment">*  function:执行函数</span></span><br><span class="line"><span class="comment">*  func_arg:函数参数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">struct</span> task_struct* <span class="title function_">thread_start</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> prio, thread_func function, <span class="type">void</span>* func_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">thread</span> =</span> get_kernel_pages(<span class="number">1</span>); <span class="comment">//pcb都位于内核空间,包括用户进程的pcb也是在内核空间</span></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line">    <span class="built_in">stack</span> = thread-&gt;self_kstack;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov esp,stack&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebp&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop ebx&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop edi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pop esi&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ret&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='gree'>先理理线程创建的整体思路：</font></strong></p><ol><li><strong>调用 <code>thread_start()</code> 来创建线程。</strong></li><li><strong>在 <code>thread_start()</code> 中，向内核申请一页物理内存用来存放 PCB 。</strong></li><li><strong>接着，调用 <code>init_thread()</code> 来初始化线程的相关信息，包括任务状态、优先级、内核栈指针、魔数等。</strong></li><li><strong>然后，调用 <code>thread_create()</code> ，将线程函数及其参数写入该线程的内核栈中。</strong></li><li><strong>最终，切换到线程栈，调用线程函数，任务开始。</strong></li></ol><p>代码逻辑比较清晰，下面讲解重点内容：</p><ul><li><p>第 40 行，向内核申请一页内存用来存放 PCB 。之前说过，<strong><u>我们的线程采用内核态实现，由内核管理所有线程，所以必须从内核空间申请</u></strong> 。</p></li><li><p>第 12、13 行减去中断栈和线程栈，使 self_stack 指向线程栈的起点，这是为了让线程栈与 self_stack 结构体一一对应，使相关信息能够准确写入线程栈的正确位置。<strong><font color='orange'>注意，不同于中断栈，我们不会通过 inr_stack 结构体向中断栈赋值或取值；而对于线程栈，我们必须精确赋值，不能将位置搞错，一旦错位，就无法进入线程函数来实行任务啦</font></strong> ！</p></li><li><p>第 18 行，此四个寄存器可初始化为 0，下节你明白为什么。</p></li><li><p>第 44 行就是我们之前常听到的栈切换了，这是任务切换的最关键一步。切换栈很简单，就是通过修改 esp 的指向来完成的。对了，为什么要用静态全局变量 stack 来中转呢？这种用法在<a href="https://jyx-fyh.github.io/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/">assert断言</a>中已经提到过了，由于第 44 行是内联汇编，<strong>汇编只认识全局符号</strong> ，所以我们要使用一个全局变量来中转。经过下面的 4 次 pop 后，esp 便指向了 eip，而 eip 在 <code>thread_create()</code> 中被指向了 <code>kernel_thread()</code> 函数，所以接下来的 <code>ret</code> 指令就会进入到此函数中。之后，<code>kernel_thread()</code> 调用 <code>function()</code> ，开始执行任务。图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE27.png" alt=""></p><blockquote><p>这几句汇编这是我们这节临时使用的方案，下节实现任务切换时会使用正规方法。</p></blockquote></li><li><p>读者朋友可能已经发现，<code>thread_create()</code> 第三个参数是一个 void 指针，用来传递线程函数所需要的参数。问题是，为什么要用 void 指针来传递参数呢？而且万一要传递多个参数，那怎么办？很简单，将多个参数封装成一个结构体，然后将该结构体的指针传入该函数，然后在线程函数中解包就ok了。那么，传指针是唯一的方法吗？能不能学习 printf，使用可变参数列表来进行传参呢，这样可多方便呐！好问题！当你彻底理解任务调度和切换后（本小节和下一小节），你将明白为什么不能使用可变参数列表。</p></li></ul><p><img src="/2022/img/image-20221216210636536.png" alt=""></p><p>本文结束，休息一会，请移步<a href="https://jyx-fyh.github.io/2022/12/16/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/">线程-进阶-任务调度</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理-基础-初始化内存池</title>
      <link href="/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应分支：<code>memory</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p><strong>操作系统内存管理可以说是操作系统中最重要的部分</strong> ，它是未来所有工作的基础。内存管理相当复杂，大约有如下内容：<br><img src="/2022/img/v2-4c9fcddd65b35e84c4c6783aaeee3826_720w.jpg" alt="操作系统—内存管理"></p><p>但本节并不会讨论以上全部内容，而是根据我们自制操作系统的需要来进行。我们当前的任务是完成操作系统的内存划分（本节）以及虚拟内存的申请（下节），即虚拟空间到物理内存的映射，其他内容咋们后续按需补充。本节内容如下：</p><ol><li><strong><font color='orange'>通过 BIOS 中断获取内存容量</font></strong><br>既然要分配内存，就一定需要知道系统的内存容量有多大，这通过 BIOS 中断来获取。</li><li><strong><font color='orange'>通过位图来管理内存</font></strong><br>管理内存时，肯定需要知道哪些内存已经被使用，哪些还没有使用，这些信息通过我们自己维护的位图来获取。</li><li><strong><font color='orange'>规划内存池</font></strong><br>管理内存前，当然还需要对内存做出规划，比如，哪些内存给内核使用，哪些内存又给用户使用。</li><li><strong><font color='orange'>向页表填写映射关系</font></strong><br>我们早就实现了分页机制，就差向其中填入映射关系啦！笔者期待已久，让我们开始吧。</li></ol><h3 id="font-color-red-获取内存容量-font"><font color='red'>获取内存容量</font></h3><p>获取内存容量的例程已经由操作系统厂商写好并存入了 BIOS 中，因此我们只需要调用 BIOS 中断即可。现在问题是，进入保护模式后，BIOS 中断无法再被调用，这怎么办呢？不得已，<strong>我们只能回到 loader.s 中，即进入保护模式之前调用 BIOS 中断</strong> 。</p><blockquote><p><strong>为什么进入保护模式后不能再使用 BIOS 中断</strong> ？</p><ol><li>BIOS 中断例程的地址存放在中断向量表（IVT）中，实模式下使用 <code>int</code> 指令调用中断时，会跳转到 IVT 描述符指向的例程地址；而保护模式下使用 <code>int</code> 指令调用中断时，则是跳转到 IDT 描述符所指向的例程。因此，IVT 不再有效。</li><li>BIOS 中断例程是在实模式，即 16 位模式下运行的代码，这些代码并不能直接运行在 32 位保护模式下。</li></ol></blockquote><p>Linux 采用了三种方式来检测内存容量，如果一种方式失败，就调用下一种，全部失败则挂起。这三种方式都是通过调用 0x15 号 BIOS 中断来进行的，它们的功能号及其特点为：</p><ul><li>EAX = 0xE820 ：遍历主机所有内存。</li><li>AX   = 0xE801 ：最大支持 4GB 。</li><li>AH   = 0x88     ：最大支持 64 MB 内存。</li></ul><blockquote><p>功能号需要装在 EAX 或 AX 中。</p></blockquote><p>由于咋们的操作系统最大不会超过 100 KB，因此我们只使用第三种方式，即 0x88 功能号。因为该部分只需要调用中断，没有其他需要强调或理解的地方，所以此处笔者就不详细记录这三个功能号的中断参数和用途了，详情还请读者朋友移步《操作系统真相还原》第 177 页。下面只贴出我们要用到的 0x88 功能号：<br><img src="/2022/img/IMG_0561(20221206-184055).PNG" alt=""><br><strong>需要注意两点：</strong></p><ul><li><strong>0x88 功能号返回的内存不包括低端 1 MB，因此我们算总内存时还需要加上 1MB 。</strong></li><li>返回后 AX 中的值以 1KB 为单位，所以还需要换算成以 1 字节为单位。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">total_mem_bytes dd 0</span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88:</span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt     ;CF为0则跳转</span><br><span class="line">   and eax,0x0000FFFF;加上1024,即低端的1MB(1024KB)</span><br><span class="line"></span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16       ;把dx移到高16位</span><br><span class="line">   or edx, eax       ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line">   jmp prepare       ;跳转,准备进入保护模式</span><br><span class="line"></span><br><span class="line">.error_hlt:          ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure><p>代码逻辑很简单，注释也足够清晰，不再赘述。需要强调的是，标号 <code>total_mem_bytes</code> 用来存放所得结果，此结果待会会在 memory.c 中使用，因此，我们还得手动算出该标号所代表的地址，以方便在 C 文件中通过指针引用该值。有读者可能会疑惑了，为什么还得手动算地址呢？难道不能像我们之前那样，使用 <code>global</code> 关键字导出 <code>total_mem_bytes</code> ，然后在 C 文件中声明 <code>extern total_mem_bytes</code> 来直接引用这个变量吗？是的，不能。原因在于，我们链接时并没有将 loader.o 包含进来，看下面的 makefile 语句：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KERNEL=build/guide.o  build/print.o  build/main.o build/interrupt.o build/idt.o build/port_io.o \</span><br><span class="line">       build/timer.o  build/intrmgr.o  build/debug.o  build/string.o  build/memory.o  build/bitmap.o \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(KERNEL)</span></span><br><span class="line">ld  -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0x00001500</span><br></pre></td></tr></table></figure><p>其中并没有包含 loader.s 。我猜到你要说什么了：那就包含 loader.s 呗…昂，kernel.bin 可是咋们的内核呀，现在又将 loader 包含进去，可谓不伦不类啦。所以，我们需要手动算出 <code>total_mem_bytes</code> 的地址值，它的位置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段</span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06]</span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;检测出的总内存大小,位于0x90c处.前面一共0xc，即12字节</span><br><span class="line">    total_mem_bytes dd 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;BASE_ADDR=0X900</span><br><span class="line">;dd=4bytes, dw=2bytes</span><br><span class="line">BASE_ADDR+4+2+4+2=0x90c</span><br></pre></td></tr></table></figure><p>因此，<code>total_mem_bytes</code> 的地址为 0x90c 。如此，咋们就轻松获取了内存容量的大小，为 32MB，即 0x2000000<br><img src="/2022/img/image-20221207201205263.png" alt=""></p><h3 id="font-color-red-位图-font"><font color='red'>位图</font></h3><p>位图并不止用于内存管理，<strong><u>它是一种映射，用一个位来表示一个对象的状态</u></strong> 。在之前我们也接触过位图，比如 8259A 中的各个寄存器就是关于 IRQ 的位图。现在，我们要使用位图来管理内存，即用一个位来表示某片内存的状态（是否已经使用）。问题是，一个位应该映射成多大的一片内存呢？通过前面内存分页的学习，我们知道内存是按页来分隔的，一页的大小是 4KB，出于这个原因，我们将一个位映射为 4KB 内存，即一个位管理一页内存。<strong><font color='orange'>如果某位为 1，则表示对应的页已经被使用；为 0 则表示该页为空闲状态，可以使用</font></strong> 。<br><img src="/2022/img/IMG_0562(20221206-193514).PNG" style="zoom:67%;" /></p><p>位图结构体的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> btmp_bytes_len;</span><br><span class="line"><span class="comment">/* 在遍历位图时,整体上以字节为单位,细节上是以位为单位,所以此处位图的指针必须是单字节 */</span></span><br><span class="line">    <span class="type">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>btmp_bytes_len</code> 表示位图的长度，包含的总位数为 btmp_bytes_len*32 。该值由位图所管理的内存大小决定。</li><li><code>bits</code> 为位图的指针。<strong>位图也当然是存放在内存中的，所以我们用 <code>bits</code> 指针来记录位图的起始地址</strong> 。</li></ul><p>需要注意，虽然 <code>bits</code> 是 <code>uint8_t*</code> 型的指针，步长为 1 字节，但实际操作时我们会细化为按位处理，即通过掩码来判断相应位是否为 1 。<br>位图的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>bitmap_init</code> ：用来初始化位图，<strong><u>根据传入的 btmp 参数来决定将哪片内存视为位图，并将其初始化为 0</u></strong> 。</li><li><code>bitmap_scan_test</code> ：用来检测位图中第 <code>bit_idx</code> 位是否为 1，该函数只在 <code>bitmap_apply</code> 中调用。</li><li><code>bitmap_set</code> ：用来将位图中的第 <code>bit_idx</code> 位赋值为 0/1 。</li><li><code>bitmap_apply</code> ：在位图中申请<u>连续</u> <code>cnt</code> 个位，若成功则返回起始位的索引(下标)，失败则返回 -1 。</li></ul><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bitmap.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 7</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_init</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断bit_idx位是否为1,若为1则返回true，否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bitmap_scan_test</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line">    <span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &gt;&gt; bit_odd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitmap_apply</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line"><span class="comment">/* 先逐字节比较,蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> (( <span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len)</span><br><span class="line">    &#123;  <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位，</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对,返回空闲位的索引。*/</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &gt;&gt; idx_bit) &amp; btmp-&gt;bits[idx_byte])</span><br><span class="line">        idx_bit++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;    <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);  <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>;      <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;      <span class="comment">// 先将其置为-1,若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((bit_left--) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit)))  <span class="comment">// 若next_bit为0</span></span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt)     <span class="comment">//若找到连续的cnt个空位</span></span><br><span class="line">        &#123;</span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将位图btmp的bit_idx位设置为value */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bitmap_set</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> bit_idx, <span class="type">int8_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(value == <span class="number">1</span>);</span><br><span class="line">    assert(value == <span class="number">0</span>);</span><br><span class="line">    <span class="type">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整,取得该位所在字节</span></span><br><span class="line">    <span class="type">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余,取得该位在此字节中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/</span></span><br><span class="line">    <span class="keyword">if</span> (value)    <span class="comment">// 如果value为1</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 若为0</span></span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &gt;&gt; bit_odd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释较清晰，下面挑重点解释：</p><ul><li><p>第 13 行，重点理解这个按位检测，逻辑也比较简单。需要说明的是，《真相还原》中的原代码是：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));</span><br><span class="line"><span class="comment">//.......</span></span><br></pre></td></tr></table></figure><p>这和我们的代码效果是相同的，笔者之所以作如此改动，是因为改动之后的逻辑更符合我们直觉，即，位是按顺序排列的：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE23.png" alt=""></p><p>而原代码的逻辑是：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE21.png" alt=""></p></li><li><p>第 41 行，为什么要把 cnt==1 的情况单独拿出来呢？因为后面我们申请物理内存时，物理内存池中的页可以不连续，所以传参时 cnt=1；申请虚拟内存时，必须连续，所以 cnt 不必为 1 。由于会大量用到 cnt=1 的情况，所以单独拿出来，避免再做后续处理以提高效率。</p><blockquote><p>没懂上述解释的同学不用慌，下节内存管理进阶我们还会说到这点。</p></blockquote></li><li><p>第 54 行，每当连续的位被断开时，cnt 就需要清零，因为函数要求的是找出连续的 cnt 个位。</p></li></ul><p>位图的介绍就是这些，下面我们用位图来规划内存。</p><blockquote><p>值得一提的是，位图只是内存管理的一种方法，其他常用的方式还有链表，参见<a href="https://blog.csdn.net/qq_22238021/article/details/80175461">空闲内存管理，位图，空闲链表-CSDN</a></p></blockquote><h3 id="font-color-red-规划内存池-font"><font color='red'>规划内存池</font></h3><p><strong><mark class="hl-label blue">什么是内存池？</mark> </strong></p><p>说得高深一点，内存池是内存集合的抽象；说白了，内存池就是上面所说的用来管理内存的位图。所以，内存池的职责就是管理内存，需要内存时，从内存池（位图）中申请；回收内存时，则归还内存池。</p><blockquote><p>可以将位图理解成内存池的物理形式。既然将内存池等同于位图，就说明<strong>内存池的存取粒度和位图一样，都是以 4KB 为单位</strong> 。</p></blockquote><p><strong><mark class="hl-label blue">如何规划内存池</mark> </strong><br>规划内存池，分为两个大的方向：</p><ol><li><strong><font color='orange'>物理内存和虚拟内存的规划</font></strong></li><li><strong><font color='orange'>用户内存和内核内存的规划</font></strong></li></ol><p>这两者必须结合在一起讨论。我们已经知道，虚拟内存这个概念，其本身是针对于进程而言的，每个进程都有 4GB 的虚拟内存，<u>其中一部分</u>虚拟地址会映射到物理内存。那么，我们就不得不考虑如下两点：</p><ul><li><p>这么多进程都有各自的虚拟空间，它们都会争用物理内存，所以<u><strong>操作系统必须知道哪些物理内存被用了，哪些还未被使用</strong></u> ，因此，我们需要建立物理内存池，以管理物理内存的使用情况。</p></li><li><p>虽然每个进程都有自己的虚拟 4GB 空间，但在进程内部，虚拟内存也不能重复使用，即，<strong><u>虚拟地址在进程内是唯一的</u></strong> 。同样，为了管理虚拟地址的使用情况，我们需要建立虚拟内存池。</p><blockquote><p><strong><font color='orange'>注意，虚拟内存在进程是唯一的，但多个进程之间，可以使用相同的虚拟地址，各自的虚拟地址对外是不可见的，相互独立的！</font></strong></p></blockquote></li></ul><p>除此之外，我们还需要将物理内存分为内核内存和用户内存，这是基于以下两点原因：</p><ul><li>操作系统会占用较多内存，毕竟它是其他用户进程的载体，不仅要引导用户程序的运行，还要负责任务调度，内存开辟等诸多重要任务。</li><li>为了内核的正常运行，<u>不能用户申请多少内存就给多少，否则有可能因为物理内存不足而导致内核自己都不能正常运行</u>。</li></ul><p>因此，咋们专门分出内核的专属内存，其他物理内存则划给用户。</p><p>综上所述，我们最后划出三个内存池：<strong><font color='gree'>1）内核物理内存池；2）内核虚拟内存池；3）用户物理内存池</font></strong> 。<br><strong><font color='red'>有了前两者，当内核申请内存时，便会先从内核虚拟地址池中申请发配虚拟地址，接着从内核物理地址池中申请分配物理地址，最后在内核自己的页表中建立虚拟地址到物理地址的映射关系</font></strong> 。这个过程我们很快就会用代码展现出来。接着，你一定会问，为什么只有用户物理内存池，而没有用户虚拟内存池呢？是这样的，用户物理内存池是供所有用户进程使用的，用户共享这一片物理内存池；而 <strong>用户虚拟内存池则是每个用户进程私有的，当创建用户进程时，也会在其内部开辟虚拟池给自己使用</strong> 。用户虚拟内存池将在我们实现用户进程时介绍。</p><p><strong><mark class="hl-label blue">规划细节</mark> </strong><br>话不多说，先放出本操作系统的具体内存安排：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE20.png" alt=""></p><p>下面对以上内存规划进行阐述：</p><ul><li><p>低端 1 MB 完全给内核使用，内核的代码只运行在这 1MB 内，且低端 1MB 物理内存和虚拟内存是一一映射的。这点在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中讲解过。</p></li><li><p>为什么将这三个内存池位图放在低端 1MB 内呢？因为 <strong><font color='orange'>低端 1MB 是不会放入内存池中的</font></strong> ，这 1MB 空间相当于是上帝视角，不受内存管理约束，原因很简单——它自己就是管理者。内存池用于管理其他内存，而不用关心自己所在的内存，否则就是自己管理自己啦，这么说来，将自己所在内存的对应位置 1，岂不是相当于自杀了？哈哈哈哈开个玩笑，原因大概就是如此。</p></li><li><p>PCB (Process Control Block, 进程控制块)，用来管理进程，每个进程的信息（pid、进程状态等）都保存在各自的 PCB 内。关于 PCB 的详细内容会在后面讲线程时提到，现在读者只需记住两点：</p><ul><li><p><strong><u>PCB 需要用一个自然页存放</u></strong> ，即 PCB 的起始地址必须为 0xXXXXX000，结尾必须是 0xXXXXXfff 。</p><blockquote><p>这就是为什么 0x9f000~0x9fbff 未使用的原因——为了凑一个自然页。这么说大家可能还不清楚什么叫做未使用，放一张图各位就知道了：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70-1670387128776-1.png" alt=""><br>原本 0x7E00~0x9FBFF 都是空闲区域，咋们大可以将 PCB 放在 0x9E000~0x9FBFF 处，但无奈 PCB 只能占用一个自然页，所以 0x9F000~0x9FBFF 只能被废弃。</p></blockquote></li><li><p><strong>PCB 的最高处 0xXXXXXfff 以下用于进程/线程在 <u>ring0 下使用的栈</u></strong> 。为什么将栈放置于 PCB 内以及为什么只用于 ring0，这会在后面实现线程时详细阐述。现在读者仍只需知晓，<strong><u>我们的内核代码本身就是一个线程（主线程，或者说单线程进程），所以它也有自己的 PCB</u></strong> ，没错，就是上上图的那个 PCB。因此，在进入内核前（guide.s），我们会将 esp 指向 PCB 的顶端（栈底），即 <code>mov esp,0x9f000</code> 。</p><blockquote><p><strong>先向读者透露一下，PCB 中的栈与线程切换息息相关，可以说，线程切换就是通过栈操作来进行的。</strong></p></blockquote></li></ul></li><li><p>注意，在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>中，我们将页目录表和页表放在了 1MB 地址之上，刚好占用了 1MB~2MB 地址。<u>这里的目录表和页表是供内核进程使用的，已经被占用</u>，<strong><font color='orange'>所以这部分内存也不能划入用户/内核物理内存池</font></strong> 。</p></li><li><p>除开低 2MB 的内存外，<strong><font color='orange'>剩下的 30MB 物理内存<u>平均</u>(各自15MB)分给用户/内核物理内存池</font></strong> 。注意，内核物理内存池位图管理 15MB 物理内存（kernel_pool），所以内核虚拟内存池位图也管理 15MB 虚拟内存；用户物理内存池位图虽然管理 15MB 物理内存（user_pool），用户虚拟内存池位图（位于用户进程中）却管理 4GB 虚拟内存。</p></li><li><p>注意，虽然图示中 0x9a000~0x9e000 用来存放这三个位图，但实际上并没有完全放满。因为我们的操作系统目前就 32MB，压根用不了这么多，这个位图空间我们只用了一小部分（三个位图一共才占 0x5a0 字节），其他剩余空间是预留的，以便于未来扩展此操作系统。</p></li></ul><p><strong><mark class="hl-label blue">内存规划代码剖析</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span>  <span class="comment">// 内核虚拟内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> vaddr_start;        <span class="comment">// 内核虚拟起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">// 内核/用户物理内存池用到的位图结构</span></span><br><span class="line">    <span class="type">uint32_t</span> phy_addr_start; <span class="comment">// 内存池所管理物理内存的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> pool_size;     <span class="comment">// 内存池字节容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>virtual_addr</code> 结构体目前仅用于内核<u>虚拟</u>内存池，后期还会用该结构管理用户虚拟内存池。</li><li><code>pool</code> 结构体用于内核与用户<u>物理</u>内存池的管理。为什么 <code>pool</code> 比 <code>virtual_addr</code> 多一个 pool_size 成员呢？这是因为，物理内存是很有限的（本OS为32MB），虽然虚拟地址最大为 4GB，但相对而言却是无限的，因此 virtual_addr 无需记录容量。</li><li>至于为什么还需要指定起始地址，阅读下面的代码后你就会彻底明白。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memory.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment">* 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_HEAP_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_SIZE_ADDR  0x90c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>        <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"><span class="comment">/* 初始化内存池 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_pool_init</span><span class="params">(<span class="type">uint32_t</span> all_mem)</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;         <span class="comment">// 为什么乘256,详见下文解析</span></span><br><span class="line">    <span class="type">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;   <span class="comment">// 低端1M内存+页表/目录表都不算入内存池</span></span><br><span class="line">    <span class="type">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="type">uint16_t</span> all_free_pages = free_mem / PG_SIZE;     <span class="comment">// 1页为4k,不管总内存是不是4k的倍数,</span></span><br><span class="line">    <span class="comment">// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。</span></span><br><span class="line">    <span class="type">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;  <span class="comment">// 平均分给内核物理内存池和用户物理内存池</span></span><br><span class="line">    <span class="type">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">    好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span></span><br><span class="line">    <span class="type">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;      <span class="comment">// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> ubm_length = user_free_pages   / <span class="number">8</span>;      <span class="comment">// User BitMap的长度.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> kp_start = used_mem;                     <span class="comment">// Kernel Pool start,内核内存池的起始地址</span></span><br><span class="line">    <span class="type">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;  <span class="comment">// User Pool start,用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start   = up_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = PG_SIZE * kernel_free_pages;</span><br><span class="line">    user_pool.pool_size  = PG_SIZE * user_free_pages  ;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len   = ubm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********    内核内存池和用户内存池位图   ***********</span></span><br><span class="line"><span class="comment">    *   位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    *   全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    *   而我们需要根据总内存大小算出需要多少字节。</span></span><br><span class="line"><span class="comment">    *   所以改为指定一块内存来生成位图.</span></span><br><span class="line"><span class="comment">    *   ************************************************/</span></span><br><span class="line">    <span class="comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span></span><br><span class="line">    <span class="comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="type">void</span>*)MEM_BITMAP_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span></span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line">    <span class="comment">/******************** 输出内存池信息 **********************/</span></span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_bitmap_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_pool.pool_bitmap.bits + kernel_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_start:      &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_pool_phy_addr_end:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(kernel_pool.phy_addr_start + kernel_pool.pool_size,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_start:          &quot;</span>,DEFUALT);</span><br><span class="line"></span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_bitmap_end:            &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)user_pool.pool_bitmap.bits + user_pool.pool_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_start:        &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nuser_pool_phy_addr_end:          &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(user_pool.phy_addr_start + user_pool.pool_size,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将位图置0*/</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span></span><br><span class="line">    <span class="comment">// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="type">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.start: &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits,DEFUALT,HEX);</span><br><span class="line">    put_str(<span class="string">&quot;\nkernel_vaddr.vaddr_bitmap.end:   &quot;</span>,DEFUALT);</span><br><span class="line">    put_uint((<span class="type">uint32_t</span>)kernel_vaddr.vaddr_bitmap.bits + kernel_vaddr.vaddr_bitmap.btmp_bytes_len,DEFUALT,HEX);</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_pool_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理部分初始化入口 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;mem_init start...\n&quot;</span>,DEFUALT);</span><br><span class="line">    <span class="type">uint32_t</span> mem_bytes_total = *((<span class="type">uint32_t</span>*)MEM_SIZE_ADDR);</span><br><span class="line">    put_str(<span class="string">&quot;memory size:&quot;</span>,DEFUALT);</span><br><span class="line">    put_uint(mem_bytes_total,DEFUALT,HEX);</span><br><span class="line">    mem_pool_init(mem_bytes_total);</span><br><span class="line">    put_str(<span class="string">&quot;\nmem_init done\n&quot;</span>,DEFUALT);</span><br><span class="line">&#125;<span class="comment">/* 初始化内存池 */</span></span><br></pre></td></tr></table></figure><p>上面的代码配合注释以及之前的讲解，是完全能够看懂的，便不再挨个解释了，只对部分内容进行说明：</p><ul><li><p>第 12 行，<code>MEM_SIZE_ADDR</code> ，即 0x90c ，这就是前文我们存放内存容量的地址；第 98 行，通过对该地址解引用，取得内存大小，随后传参给 <code>mem_pool_init()</code> ，开始初始化内存池。</p></li><li><p>第 19 行，为什么页目录和页表所占内存大小是 <code>PG_SIZE*256</code> ？（1）页目录表，占 1 页；（2）第0、768号页目录项都指向第 0 号页表，此页表占 1 页；（3）第 769~1022 号页目录项一共指向 254 个页表，占 254 页。因此，所占内存大小为 <code>4096*(1+1+254)=PG_SIZE*256</code> 。</p><blockquote><p>有人肯定纳闷了，我们之前不是仅为 769~1022 号页目录项安装了页表的地址吗？并没有创建页表页呀？那为什么还要算入这 254 页的内存大小呢？就是因为我们提前指向了这些页表的地址，每个地址相差 4096 字节，所以才必须为这些页表预留空间哒！笔者起初对这点很疑惑，想了好一会才反应过来，不知道读者会不会有这样的问题。另外，我们在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中也提到过，提前为 769~1022 号页目录项安装页表的地址是为了实现内核的完全共享，忘记的朋友不妨回头看看。</p></blockquote></li><li><p>第 35 行，<strong>物理内存池所管理的物理内存被规定为从 2MB 开始</strong> ，那么为什么要跳过这 2MB 呢？这在前文已经详细说明，0~1MB 是内核空间，1~2MB 是内核进程的页目录和页表，因此这部分物理内存不能再使用，所以不可划入内存池。</p></li><li><p>第 86 行，为什么将内核虚拟起始地址设为 <code>K_HEAP_START</code> ，即 0xc0100000 ？这是因为在<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>中，<strong>我们已经将虚拟空间高 1GB 处的起始 1MB 直接映射到物理内存的低 1MB 了，所以 0x0~0xc0100000 实际上是运行的内核代码（内核镜像）。因此，内核虚拟池中对应的起始虚拟地址必须跳过这 1MB，即从 0xc0100000 开始分配</strong> 。另外，从 <code>K_HEAP_START</code> 应该也能看出，<strong><font color='gree'><u>内核物理池是用来存放内核开辟的堆</u></font></strong> ，读者应该对堆很熟悉了吧，这就是程序在运行时动态开辟的内存。<strong>内核代码都存放在 0x9a000 内，注意，代码是不会运行在内核物理池中的！</strong></p></li></ul><p><img src="/2022/img/image-20221208113835640.png" alt=""></p><p>好了，本节内容大致就是如此，各位一定还有未能想明白的问题，可在评论区留言。同时也请别着急，进入下一节<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶-分配页内存</a>后，也许你就会恍然大悟。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/2022/12/01/string/"/>
      <url>/2022/12/01/string/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://blog.csdn.net/u013354805/article/details/50057139">https://blog.csdn.net/u013354805/article/details/50057139</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的#和##</title>
      <link href="/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
      <url>/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-字符串化-font"><font color='red'>字符串化#</font></h3><p>C 语言中，<code>#</code> 号可用于将宏参数转为字符串，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(x)  #x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(STR(age)); <span class="comment">//输出字符串age,而非18</span></span><br><span class="line">    <span class="built_in">printf</span>(STR(<span class="number">18</span>));  <span class="comment">//输出字符串18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法有什么使用场景呢？如下，有时候我们需要取得宏函数参数（表达式/变量）的字面内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">warn(a==<span class="number">0</span>);    <span class="comment">//打印&quot;a==0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在某些情况下很有用，参见<a href="">assert剖析</a>。</p><p><strong>另外需要注意，当宏参数是另一个宏的时候，宏定义里有用 <code>#</code> 的地方宏参数不会再展开</strong> ，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;Π==3.14&quot;而不是&quot;3.14==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要宏参数展开，则需要使用以下两步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _warn(expr)  printf(#expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> warn(expr)   _warn(expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    warn(Π==<span class="number">3.14</span>); <span class="comment">//输出&quot;3.14==3.14&quot;而不是&quot;Π==3.14&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 warn(expr) 展开时会扩展它的参数，即替换 expr 中的宏变量。</p><h3 id="font-color-red-符号粘贴-font"><font color='red'>符号粘贴##</font></h3><p><code>##</code> 用于拼接两个符号，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ponit(x,y) x##.##y </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,point(<span class="number">12.32</span>));  <span class="comment">//输出12.32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，从以上结果可见，转换后的结果不是字符串！</strong> 而是正常的代码或数字。如果想将结果转为字符串，可以采用如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTR(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONT(a,b) TOSTR(a)##TOSTR(b)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(CONT(<span class="number">12</span>,<span class="number">32</span>)); <span class="comment">//输出&quot;1232&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window 下对 <code>##</code> 的一个简单使用是指定字符编码方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) L##x</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TEXT(x) x</span></span><br></pre></td></tr></table></figure><p>当定义了 <code>_UNICODE</code> 时，则 <code>TEXT(&quot;hello&quot;)</code> 为 <code>&quot;hello&quot; </code> ，否则为 <code>L&quot;hellp</code> 。</p><blockquote><p><code>L&quot;str&quot;</code> 是 C/C++ 对宽字节字符的原生支持，表示字符串中的每个字符都是双字节。</p></blockquote><p>另外需要强调的是，<code>#</code> 和 <code>##</code> 都只能用于预处理宏扩展，不能在普通源码中使用。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层剖析assert断言</title>
      <link href="/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/"/>
      <url>/2022/11/30/%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90assert%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/06/20/assert-%E4%B8%8Eif/">assert与if</a> ，<a href="https://jyx-fyh.github.io/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/">C语言中的#和##</a><br>本节对应分支：<code>assert</code></p></blockquote><p>关于 assert 断言函数的意义和用法，请参见<a href="https://jyx-fyh.github.io/2022/06/20/assert-%E4%B8%8Eif/">assert与if</a> ，本文不再赘述。在我们自制的 OS 中，会实现两种 assert 函数，一种为内核服务，另一种为用户进程服务。本节实现内核 assert 函数。</p><p>内核 assert 函数有以下几个要点需要注意：</p><p><strong><font color='gree'>1）</font></strong> 一旦内核 assert 函数被调用，就说明此时发生了严重的错误，系统可能面临崩溃的危险，所以应该立即停止运行。如何让系统停止运行呢？你可能会想到在 assert 函数末尾加上一个 <code>while(1)</code> 。没错，这也是我们的做法，但这还不够！还记得吗，<strong><font color='orange'>操作系统是由中断来驱动并发的，即使当前代码正在 <code>while(1)</code> 中循环，只要发生中断，执行流依旧会转移到中断程序</font></strong> 。如果中断目的是任务调度，那么执行流转移到任务后，因为操作系统已经出现问题，所以任务的执行也是不可靠的。因此，<strong>我们还<font color='orange'>需要关闭中断</font></strong> 。视频演示如下：</p><div id="dplayer6" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/assert.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><blockquote><p>显然，用户进程的 assert 函数无需关闭中断，即使 A 用户程序遇上 assert 而崩溃，B 程序可还要接着运行呢。再者，用户进程也没有关闭中断的权限，因为 <code>cli</code> 指令是 ring0 级别才能使用的指令。</p></blockquote><p><strong><font color='gree'>2）</font></strong> 发生错误后，我们需要快速定位错误源，因此还需要用到几个常见的预定义宏：<code>__FILE__</code> ，<code>__FUNC__</code> ，<code>__LINE__</code> ，分别指示 assert 被触发的所在文件、函数、行号。</p><p>本分支新增了 <code>debug.h</code> 、<code>debug.c</code> 、<code>intrmgr.c</code> 三个文件，以下对此三个文件进行分析。</p><p><strong><mark class="hl-label blue">intrmgr</mark> </strong><br><code>intrmgr</code> 为 <code>interrupt manager</code> 的缩写，意为管理中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/system.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> EFLAGS=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//以下函数的声明放在了interrupt.h</span></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(INTR_ON==intr_get_status())</span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        STI;</span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_disable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(INTR_OFF==intr_get_status())</span><br><span class="line">        <span class="keyword">return</span> INTR_OFF;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CLI;</span><br><span class="line">        <span class="keyword">return</span> INTR_ON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_get_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pushf; pop EFLAGS&quot;</span>)</span>; <span class="comment">//获取eflags的值</span></span><br><span class="line">    <span class="keyword">return</span> (EFLAGS_IF &amp; EFLAGS) ? INTR_ON:INTR_OFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> intr_status <span class="title function_">intr_set_status</span><span class="params">(<span class="keyword">enum</span> intr_status st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTR_ON &amp; st ? intr_enable() : intr_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>第 29 行，<code>intr_get_status()</code> 函数用于获取中断的开闭状态。第 29 行内联汇编，先使用 <code>pushf</code> 将 EFLAGS 寄存器压栈，再将其弹出到全局变量 EFLAGS 中，这样便获取了标志寄存器的值。注意，如果想要在内联汇编修改 C 语言变量的值，则该变量必须为全局变量！！因为局部变量是不会记录在符号表中的，所以编译器根本不认识局部变量的符号。这涉及到编译原理，详情请参阅《装载，链接与库》。</p><blockquote><p>其实，如果理解了笔者之前的文章<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a>，你也会明白为什么内联汇编不认识局部变量。简单来说，局部变量在函数栈中被创建，其定位是通过 EBP 进行的，而不是通过符号（符号本身代表地址）进行的。</p></blockquote><p>随后第 30 行识别中断开闭状态，并返回该状态。另外，EFLAGS_IF 定义在 interrupt.h 中：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS_IF  (1&lt;&lt;9)      <span class="comment">//eflags中的if位</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>intr_enable()</code> 和 <code>intr_disable()</code> 很简单，不再赘述。唯一可能的疑惑是，为什么要返回修改之前的状态？这与以后的任务调度有关，后续还会用到这些函数，我们先提前在这做好准备。</p></li><li><p><code>intr_set_status()</code> 并不多余，它可以提升代码的灵活性，后续我们也会看到这一点。</p></li></ul><p><strong><mark class="hl-label blue">debug.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OSLEARNING_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSLEARNING_DEBUG_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span>* err_msg, <span class="type">char</span>* file_name, <span class="type">int</span> line, <span class="type">char</span>* func)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(expression) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(expr) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(expr)&#123;&#125;       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>&#123;            \</span></span><br><span class="line"><span class="meta">    panic(#expr, __FILE__, __LINE__, __func__);&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//OSLEARNING_DEBUG_H</span></span></span><br></pre></td></tr></table></figure><ul><li><p>再次强调，assert 仅在 Debug 模式下使用，当软件发行（release）后，就需要屏蔽 assert 。因此，在非 Debug 时，定义 NDEBUG 宏，则 assert 成为空值，不参与编译；在 Debug 下，assert 被定义为第 7~10 行代码段。</p><blockquote><p>指定非 Debug 有两种方式：<br>1）使用 GCC 的 <code>-D</code> 参数即可定义 NDEBUG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DNDEBUG</span><br></pre></td></tr></table></figure><p>2）在 debug.h 第 2 行插入 <code>#define NDEBUG</code></p></blockquote></li><li><p>第 10 行使用到了 <code>#</code> 号，用于字符串化，详见<a href="https://jyx-fyh.github.io/2022/11/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/">C语言中的#与##</a> 。</p></li><li><p>宏定义是以行为单位的，跨多行需要使用 <code>\</code> 进行连接。</p></li><li><p><code>__FILE__</code> ，<code>__FUNC__</code> ，<code>__LINE__</code> 是预定义宏，分别指示该行所在文件、函数、行号，这是在编译阶段就确定了的。</p></li></ul><p><strong><mark class="hl-label blue">debug.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/print.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span>* err_msg, <span class="type">char</span>* file_name, <span class="type">int</span> line, <span class="type">char</span>* func)</span></span><br><span class="line">&#123;</span><br><span class="line">    intr_disable();  <span class="comment">//务必关闭中断</span></span><br><span class="line">    put_str(<span class="string">&quot;\n===============================&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\ndebug error:&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nFileName: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(file_name,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nFunction: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(func,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\nLine:     &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_int(line,BG_BLACK+FT_RED,DEC);</span><br><span class="line">    put_str(<span class="string">&quot;\nmessage:  &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(err_msg,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(<span class="string">&quot;\n===============================&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);       <span class="comment">//将程序停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示如下：</p><div id="dplayer7" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer7"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/assert_debug.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对8259a芯片编程</title>
      <link href="/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/"/>
      <url>/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://blog.csdn.net/weixin_46716100/article/details/122205489">中断控制器8259A(详细)</a> ，《操作系统真相还原》《x86汇编从实模式到保护模式》<br>说明：本文涉及硬件知识，非重点内容，对应代码也只有几行且逻辑简单。不感兴趣的朋友可以跳过本节。</p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>一文中我们了解到，外中断是通过 INTR (interrupt) 和 NMI (Non Maskable Interrupt) 这两根信号线来通知 CPU 的：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE15-1669431351849-2-1669701708393-1.png" alt="img"></p><p>CPU 通过与芯片引脚相连的 INTR 信号线来接收外部设备发送的中断。如果所有外部设备都同时直接与 INTR 信号线相连，那么，当多个设备同时发生信号，CPU 该先处理哪个信号呢？而那些本次没被选中的信号又该存放在哪呢？总不能直接丢弃吧？为了解决这些问题，8259A 可编程中断控制器粉墨登场。可编程中断控制器（Programmable Interrupt Controller，PIC），其任务相当于 <strong>CPU 的外部中断代理，负责<u>维护中断队列</u>和<u>仲裁中断优先级</u></strong> 。</p><p>IDT 能够存放 256 个中断，而一个 8259a 芯片只能管理 8 个中断（8个 IRQ 接口）。为了支持更多外部设备，需要将多个 8259A 芯片进行级联，最多支持 9 个芯片级联，即 64 个外部中断。为什么 9 个芯片只能支持 64 个外部中断呢？不应该是 8*9=72 个吗？这是因为级联时，其中一个芯片被设置为主片（master），其余被设置为从片（slave），来自从片的中断信号必须先传递给主片，再由主片传递给 CPU。而每级联一个从片，就需要占用主片一个 IQR 接口，从片则有专门的接口。两级级联图示如下：<br><img src="../../public/2022/img/IMG_0551(20221129-151459).PNG" alt=""></p><h3 id="font-color-red-工作流程-font"><font color='red'>工作流程</font></h3><p><img src="../../public/2022/img/IMG_0552(20221129-153136).PNG" alt="8259a内部结构"></p><ul><li><strong>中断请求寄存器IRR：</strong> 保存 8 个外界中断请求信号的请求状态（ IR0～IR7 ）；</li><li><strong>中断服务寄存器ISR：</strong> 保存 8 个正在被 8259A 服务着的中断状态；</li><li><strong>中断屏蔽寄存器IMR：</strong> 保存 8 个对中断请求信号IR的屏蔽状态；</li><li><strong>优先级比较器PR：</strong> 用以比较正在处理的中断和刚刚进入的中断请求之间的优先级别，以决定是否产生多重中断或中断嵌套 。</li></ul><p>以上寄存器都是 8 位，<strong>每一位代表一个接口，相当于接口的位图</strong> 。你可能会疑惑，8 位寄存器，怎么表示 IQR7 以上的接口呢？笔者是这样理解的：上图展示的是与 CPU 直接相连的主片，而从片中收到多个中断信号（IRQ8~IRQ15）后，也会进行排队和判别，优先级最高的再发往主片，因此，主片上的 IRQ2 接口就代表了 IRQ8~IRQ15 中的一个接口。</p><p><strong><mark class="hl-label blue">中断请求过程</mark> </strong></p><ol><li><p>外设发送信号，经过主板的信号通路后到达某个 IRQ 接口。</p></li><li><p>检查 IMR 寄存器中的位，若 IMR 中对应此 IRQ 接口的位被置 1，则表示该 IRQ 接口被屏蔽，丢弃该信号；反之则接收。</p></li><li><p>信号转入 IRR 寄存器，将对应位置 1，表示该中断信号等待被处理。IRR 相当于中断处理队列。</p><blockquote><p>优先级判断方式：<strong><font color='orange'>IRQ 接口值越小，优先级越大</font></strong> 。</p></blockquote></li><li><p>某个时刻，PR 从 IRR 中挑出优先级最高的中断，通过 INT 接口向 CPU 的 INTR 发送信号。</p></li><li><p>CPU 收到信号后，立刻通过自身的 INTA 接口向主片回复一个中断响应信号，表示自己已做好准备；</p></li><li><p>主片收到响应信号后，立即在 ISR 寄存器中将相应位置 1，表示当前正在处理该中断，同时还要将 IRR 中相应位置 0。</p></li><li><p>接着，CPU 再次发送 INTA 信号给主片，目的是获取中断号。</p></li><li><p>8259A 将中断号发送给 CPU ，CPU 收到后执行相应中断程序。</p></li><li><p><strong>如果 EOI（End Of Interrupt）被设置为手动模式，则中断处理程序末尾必须手动向 8259A 发送 EOI ；8259A 收到 EOI 后，将 ISR 中对应的位置 0 。如果 EOI（End Of Interrupt）被设置为自动模式，则主片收到 CPU 发的第二个信号后（寻求中断码），将 ISR 中对应位置 0。</strong></p></li></ol><p>值得一提的是，<code>中断号=起始中断号+IRQ接口号</code> ，其中起始中断号由我们自己编程设置，因此可以将 IRQ 接口映射到不同的中断号。</p><h3 id="font-color-red-8259A编程-font"><font color='red'>8259A编程</font></h3>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务切换的实际做法</title>
      <link href="/2022/11/27/%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%81%9A%E6%B3%95/"/>
      <url>/2022/11/27/%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#GP General Protection</p><ul><li>中断门而非调用门</li><li>tss只使用栈</li><li>不使用ldt</li></ul><blockquote><p>不得不提的是，包括我们本次项目，<strong><font color='orange'>现代操作系统一般都不会使用 LDT</font></strong> ，为什么？想想看，LDT 有什么作用？有隔离各个任务的作用。但是，现代操作系统都是在平坦模型下编程，每个用户进程都只能在自己的虚拟地址空间下工作，这已经起到了隔离的作用，因此 LDT 变得鸡肋。</p></blockquote><blockquote><p><strong>再插一句，由于效率问题，Linux 并没有为每个任务都创建一个 TSS，而是所有任务共享一个 TSS，我们的 OS 也会模仿 Linux 的做法。</strong></p></blockquote><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/fuck.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O位图</title>
      <link href="/2022/11/26/I-O%E4%BD%8D%E5%9B%BE/"/>
      <url>/2022/11/26/I-O%E4%BD%8D%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>特权级全面剖析(LDT/TSS/GATE)</title>
      <link href="/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/"/>
      <url>/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：《x86汇编：从实模式到保护模式》《操作系统：真相还原》，<a href="https://hackmd.io/@0xff07/HJ5FO4xXc">SegmentationAndPrivilege</a> ，<a href="https://www.scs.stanford.edu/05au-cs240c/lab/i386/s07_02.htm">80386 Programmer’s Reference Manual</a></p></blockquote><h3 id="font-color-red-特权级概述-font"><font color='red'>特权级概述</font></h3><p>我们知道，实模式是单任务系统，对于各个段的隔离，仅依靠分段机制来维护，可以说毫无安全可言。而在保护模式下，通过将内存分为大小不一的段，并用描述符指定各个段的类型与权限，就可以在程序运行时由<u>处理器硬件</u>实施访问保护。但这仍然无法有效保护操作系统，比如，如果恶意程序通过某种方式知道了 GDT 的位置，它就能向段寄存器加载操作系统的数据段描述符，或者在 GDT 中增加一个指向操作系统数据区的描述符，以此来修改操作系统的私有数据。再者，多任务系统对任务之间的隔离与保护，以及任务与操作系统之间的隔离与保护都提出了复杂的要求，基本的段保护机制已经无法胜任。因此，操作系统引入了特权级的概念。</p><p><strong>特权级分为 0、1、2、3 四级，数字越小，权力越大</strong> 。0 级特权级是操作系统拥有的权力；系统程序（如虚拟机, 驱动程序）分别位于 1、2 特权级；用户程序则位于第 3 特权级。<br><img src="/2022/img/IMG_0535(20221127-095601).PNG" alt="特权级环（ring）"></p><blockquote><p>需要注意的是，我们将数值小的级称为高特权级，数值大的称为低特权级，别搞混啦！</p></blockquote><h3 id="font-color-red-LDT-font"><font color='red'>LDT</font></h3><p>LDT，即局部描述符表，大家应该并不陌生了，前文经常提起它的大名。在之前的代码中，我们一直将所有的段描述符放在 GDT 中，而不管它是属于内核还是用户程序（当然，因为我们还没有用户进程，敬请期待）。为了有效地实现任务之间的隔离，处理器建议每个任务都应该有自己专属的描述符表，即 LDT，并且把专属于自己的段放在 LDT 中。</p><blockquote><p>想想看，这是不是很好地呼应了<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">开启分页</a>中的内容：<strong>一个完整的程序分为用户代码（私有部分）和操作系统代码（全局部分）</strong> 。</p></blockquote><p>LDT 与 GDT 不同的地方有（笔者目前所知道的）：</p><ol><li><p>每个任务都有自己的 LDT，而一个 CPU 只有一张 GDT ，由所有任务共享。</p></li><li><p>GDT 的第 0 号描述符不可用，LDT 的第 0 号描述符则是可用的。</p><blockquote><p>为什么有这个区别呢？因为在某些情况下（后文会提），CPU 为了控制权限会将选择子初始化为 0，如果后续用户忘记给选择子重新初始化，就会引发异常，<u>这是一种积极的保护措施</u>。而如果指定为 LDT，则选择子的 TI 位为 1，这必然是经过用户显式初始化的结果，完全排除了忘记初始化的可能，因此 LDT 的第 0 个描述符可用。</p></blockquote></li><li><p>GDT 由 <code>lgdt</code> 指令加载进 GDTR 寄存器；LDT 由 <code>lldt</code> 指令加载到 <code>LDTR</code> 寄存器。需要注意的是，与 GDTR 不同，LDTR 是一个 16 位的寄存器，且其中装载的是指向 GDT 的索引，是不是蒙圈啦？别急，接下来我们细说。</p></li></ol><p><strong><font color='orange'>LDTR 中本质上装载的是选择子，这个选择子将其引导到 GDT 中的某一个描述符(LDT描述符)，而这个描述符中装载着 LDT 的信息</font></strong>。换句话说，LDT 的基址和界限等信息都存在 GDT 的描述符当中。让我们看看 LDTR 的结构：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE17.png" alt=""></p><blockquote><p>显然，TI 为必须为 0，即指向 GDT，不然就会指向 LDT 本身。<br>至于为什么不直接将 LDTR 设计为 48 位，然后直接从其中获取 LDT 的基址和界限，而采用这种迂回的方式？这是考虑到特权级检查的问题：用选择子在 GDT 中索引 LDT 描述符，这样就可以套用引用段描述符时的特权级检查（后面我们将会介绍）。</p></blockquote><p>可见，LDTR 和段寄存器有着神之相似。我们在<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">全局描述符表</a>中提到过，32 位 CPU 的段寄存器分为 16 位可见部分(选择子)和不可见部分(高速缓存器,位数根据CPU型号而变)，LDTR 也是如此。<strong><font color='orange'>通过索引在 GDT 中定位到 LDT 描述符所在位置，然后将描述符中的信息加载进不可见部分的高速缓存中</font></strong> 。读者可能忘了，GDT 中可不仅有数据段/代码段，还有系统段，如下：<br><img src="/2022/img/IMG_0502(20221101-114007)-1669466423582-5.png" alt="第三项便是 LDT"></p><blockquote><p>注意，GDT 中不包含中断门和陷阱门。</p></blockquote><p>在多任务系统中，正在执行的任务被称为“当前任务(Current Task)”。<strong><font color='gree'>由于 LDTR 只有一个，所以它仅指向当前任务</font></strong> ，每当发生任务切换，LDTR 中的内容被更新，以指向新的 LDT 。那么问题来了，切换任务时，LDTR 是如何被更新的呢？也就是说 LDTR 中的内容从哪里获取？而且，任务切换时，必须保护旧任务的寄存器现场，这些又保存到哪里呢？这就不得不提到 TSS 了。</p><h3 id="font-color-red-TSS-font"><font color='red'>TSS</font></h3><p>为了保存任务的状态以便在下次切换时恢复，每个任务都需要使用一个额外的区域来保存相关信息，这个区域叫做<strong>任务状态段 (Task State Segment, TSS )</strong> 。TTS 具有固定格式，<u>且最小尺寸为 104 字节</u>，根据需要还可以接上 I/O 位图。TSS 结构如下：<br><img src="/2022/img/2C2361DFB1D1643813669F6D50FF92C5.png" alt=""></p><blockquote><p><strong><font color='pink'>看见 96 字节处的 LDT 段选择子了吗？LDTR 就是从这里获取内容并加载的</font></strong> 。</p></blockquote><p>TSS 是 32 位处理器在<u>硬件上原生支持多任务</u>的一种实现方式，处理器固件能够识别 TSS 中的每个元素，并在任务切换时<u>自动读取</u>其中的信息。既然 TSS 也是内存中的一块区域，且每个任务都有一个 TSS，那 CPU 又如何获取这些 TSS 的位置呢？和 LDT 类似，<strong><font color='orange'>处理器使用 TR(Task Register) 寄存器来指向当前任务的 TSS</font></strong> ，既然是指向当前任务的 TSS，所以 TR 寄存器也只有一个。当发生任务切换时，处理器将当前任务的寄存器现场保存到 TR 指向的 TSS 中；然后再使 TR 指向新任务的 TSS，并根据 TSS 恢复现场。TR 结构如下：<br><img src="/2022/img/fig7-3.gif" alt=""></p><p>可见，TR 寄存器也同段寄存器类似，分为可见的 16 位段选择子与不可见的高速缓冲器。其中 BASE 指向 TSS 所在的起始地址，LIMIT 则为其界限。为什么还有界限呢？因为 TSS 长度是不固定的，会根据 I/O 位图而变化。既然 TR 为选择子，那就肯定有 TSS 描述符，如下：<br><img src="/2022/img/fig7-2.gif" alt=""></p><blockquote><ul><li><strong>TSS 描述符可能只驻留在 GDT 中</strong> ，所以 TR 选择子的 TI 位只能为 1，否则会导致异常。</li><li><strong>LIMIT 字段的值必须等于或大于 103，尝试切换到界限小于 103 的任务会导致异常</strong> 。</li><li>YTPE 字段中的 B 位主要用来判断任务是否重入，即是否为自己调用自己。如果被调用的任务的 B 位为 1，则表明当前任务是在调用自己，这将破坏任务调用链，继而引发严重错误。另外，也并不是只有当前任务的 B 位才为 1，当使用 call 指令进入新任务（成为当前任务）时，不仅新任务的 B 位被置 1，旧任务的 B 位仍保持为 1，这是因为 call 指令是“有去有回”的指令，这说明新任务只是旧任务的分支，待新任务完成后还会回到旧任务，所以本质上它们属于同一个任务。同时，任务的嵌套调用还会影响 eflags 的 NT 位，详见 <a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断超详解</a> 文末。</li></ul></blockquote><p>另外，注意到一个细节没？TSS 中起始位置存放着前一个任务的指针，而这个指针只有 16 字节！奇了怪了，16 位地址怎么定位？细心的读者可能已经观察到了，上一张系统段类型图中，还包含了 TTS 类型，这说明什么？这说明此处 16 位的 <strong><font color='orange'>TTS 指针也是一个选择子</font></strong> ！<strong><font color='orange'>可见，不仅是 LDT，连 TSS 的信息也是作为段描述符存放在 GDT 当中的(即 TSS 也需要在 GDT 中注册)</font></strong> 。</p><blockquote><p><strong>插一句，由于效率问题，Linux 并没有为每个任务都创建一个 TSS，而是所有任务共享一个 TSS，我们的 OS 也会模仿 Linux 的做法，</strong> 详见<a href="https://jyx-fyh.github.io/2022/12/26/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/">实现用户进程</a> 。</p></blockquote><p>加载初始任务时，使用 <code>ltr</code> 指令将 TSS 选择子加载进 TR 寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltr 16位寄存器/16位内存单元</span><br></pre></td></tr></table></figure><p>后续任务切换时，由 CPU 自动加载 TR 寄存器。</p><p>关于最上方的 I/O 映射基地址，其内容较多，我们将在另一篇文章中详细阐述。另外一个疑惑是，为什么一个 TSS 中有三个栈呢？这涉及到特权级转移的相关内容，请见下文。</p><h3 id="font-color-red-特权级转移-font"><font color='red'>特权级转移</font></h3><p>代码段发生段间跳转时，其特权级检查是很严格的。<u>一般而言，跳转只允许发生在两个同级的代码段之间</u>。显然，这不能满足我们对操作系统的要求（这意味着不能进行系统调用，用户将什么也做不了）。<strong>因此，为了让低特权级能够调用高特权级的例程，处理器提供了两个办法</strong> ：</p><ol><li><strong><font color='gree'>将高特权级的代码段设为依从</font></strong> 。</li><li><strong><font color='gree'>使用门（ GATE ）</font></strong> 。</li></ol><p>下面我们来详细说明这两点。</p><p><strong><mark class="hl-label blue">依从代码段</mark> </strong><br>还记得段描述符中的 type 字段吗？不用说，肯定忘了，再把图搬过来：<br><img src="/2022/img/image-20221101105041738-1669515483779-2.png" alt=""><br>其中，代码段的 C 位表示代码段的依从属性。<strong><font color='orange'>依从表示可以从特权级比它低的代码段中进入该段</font></strong> 。注意，<strong><font color='orange'>将控制转移到依从的代码段时，要求当前特权级(CPL)必须低于或等于目标(依从)代码段的DPL</font></strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>除了返回指令（retf, iret/iretd），任何时候都不允许将控制从高特权级转移到低特权级上，因为操作系统无法相信用户程序的可靠性</font></strong> 。</p></blockquote><p>同时，<strong><font color='orange'>转移到目标(依从)代码段后，也并不是以它自己的 DPL 运行，而是在调用程序的特权级上运行。换句话说，当控制转移到依从的代码段上执行时，不会改变当前特权级(CPL)！</font></strong> 举个例子，从特权级为 3 的用户程序切换到特权级为 0 的依从代码段时，当前特权级(CPL)依然是 3，而非 0 。</p><blockquote><p>注意，仅代码段有依从属性，数据段只允许比自己更高或同级的代码段访问！</p></blockquote><p><strong><mark class="hl-label blue">门(GATE)</mark> </strong><br><strong><font color='gree'>另一种从低特权级转移到高特权级的方式就是通过门调用</font></strong> 。<strong>操作系统有调用门、中断门、陷阱门、任务门四种门，它们各有自己的应用环境，但相同点是它们都用来从低特权级的代码段转移到高特权级的代码段</strong> 。下面简单说一下各个门的用途与特权级：<br><strong><u>调用门</u>：</strong> 通过 <code>call</code> 和 <code>jmp</code> 指令进入调用门，操作数为门选择子。<strong><font color='orange'>call 以调用函数的方式向高特权级代码转移；jmp 可以转移到高特权级的代码段，但不改变 CPL</font></strong> 。返回时，使用 <code>retf</code> 返回；调用门可用来实现系统调用；<u>位于 GDT/LDT 中</u>。<br><strong><u>中断门</u>：</strong> 由 <code>int</code> 指令主动发起中断的形式向高特权级代码段转移。Linux 采用中断门实现系统调用。中断将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>中详细展开。另外，<strong><font color='orange'><u>进入中断后，eflags 中的 IF 位自动置零（cli），关闭可屏蔽中断以避免中断嵌套</u></font></strong> 。使用 <code>iret/iretd</code> 返回；<u>仅位于 IDT</u> 。</p><p><strong><u>陷阱门</u>：</strong> 由 <code>int3</code> 指令主动发起中断的形式向高特权级代码段转移，这一般是编译器在调试时使用。<strong><font color='orange'><u>陷阱门和中断门很类似，唯一区别是进入中断后，eflags 中的 IF 位不会自动置零</u></font></strong> 。<u>仅位于 IDT</u> 。<br><strong><u>任务门</u>：</strong> 可以借助中断发起，如果对应的中断向量号是任务门，则发起任务切换；也可以用 call 或 jmp 指令，后接任务门的选择子或 TSS 的选择子。<u>位于 GDT/LDT/IDT 中</u>。</p><h3 id="font-color-red-门（GATE）-font"><font color='red'>门（GATE）</font></h3><p>上文我们粗略了解了门结构，下面我们继续深入剖析。<strong><font color='red'>门结构存在目的就是为了让 CPU 提升特权级</font>，以便完成低特权级下不能完成的工作</strong> 。四种门结构的图示如下：<br><img src="/2022/img/IMG_0539(20221127-174054).PNG" alt="调用门描述符"><br><img src="/2022/img/IMG_0538(20221127-174029).PNG" alt="陷阱门描述符"><br><img src="/2022/img/IMG_0537(20221127-174008).PNG" alt="中断门描述符"><br><img src="/2022/img/IMG_0536(20221127-173936).PNG" alt="任务门描述符"><br>除了任务门以外，其他三种门都是直接指向一段例程（函数)。<strong>和普通段描述符的区别在于，普通段描述符中包含的是<u>段基址</u>和段界限，是在界定内存区域；而这三种描述符中包含的是<u>段选择子</u>和段内偏移地址，它们直接指向内存中的一段程序</strong> 。因此，<strong><font color='orange'>在调用任务门和调用门时，CPU 会忽略调用指令的偏移量</font></strong> ！比如，<code>call 0x9:0x1000</code> ，如果第 9 号段描述符是这两种门描述符，则 CPU 会忽略偏移量 <code>0x1000</code> 。</p><blockquote><p>大家一定疑惑为什么门描述符中还要放目标代码段的选择子，而不直接存放基址？这样迂回好麻烦啊。这一点笔者也不太清楚，但有理由推测，这应该与 LDTR 相同，都是为了引用段描述符的特权级保护（后文将提到）。</p></blockquote><p><strong><font color='orange'>任务门描述符可以放在 GDT、LDT、IDT 中，调用门可以位于 GDT、LDT 中，中断门和陷阱门则只能位于 IDT 中</font></strong> 。正因为调用门和任务门描述符位于 GDT、LDT 中，所以可以通过 <code>call</code> ，<code>jmp</code> 指令调用，原因是它们和普通段描述符类似，都需要通过选择子。而陷阱门和中断门位于 IDT 中，则只能通过中断信号或 <code>int</code> 指令来触发调用。</p><p>门（GATE）这个词很形象，因为“门槛”是调用者特权级的下限，也就是说 <strong>调用者的特权级(CPL)必须高于门描述符的 DPL(门槛)</strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≤门的DPL</span><br></pre></td></tr></table></figure><p>“门顶”则是调用者特权级的上限，<strong><u>调用者特权级不能高于门描述符中目标程序所在的代码段的 DPL</u></strong> ，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><p><img src="/2022/img/IMG_0543(20221127-230944).PNG" alt="门的作用相当于蹦床，只起引导作用"></p><blockquote><p><strong>有几点需要说明：</strong></p><ul><li>以上规则适用于调用门，中断门有所不同。</li><li>别忘了，门描述符中装载的是选择子而非段基址，选择子还要去索引目标段描述符。</li><li>为什么要求当前特权级必须高于目标代码段特权级？这点我们在前面已经强调过，这是因为，除了返回指令（iret），任何时候都不允许将控制从高特权级转移到低特权级上，因为操作系统无法相信用户程序的可靠性。</li></ul><p><strong>为什么要通过门这种结构来提升特权级？</strong></p><p>因为门不仅有“门顶”，还有“门槛”，门顶规定只能主动从低特权级转移到高特权级，而门槛规定了能向高特权级进行转移的最低特权级。前者在上面第三点解释了，那后者的原因是什么呢？这是为了防止某些低特权级软件通过门访问一些只为内核服务的程序，比如页故障处理。<strong><font color='orange'>这就是门的本质</font></strong> 。</p></blockquote><p>前面这两个检查，相信大家完全能够理解。然而，实际的特权级检查并非如此简单，这还会牵扯到 RPL，后文将详细剖析。先让我们先看看<strong>实际的特权级检查规则全览</strong> 。</p><h3 id="font-color-red-特权级保护规则-font"><font color='red'>特权级保护规则</font></h3><p><strong><font color='orange'>特权级检查只会发生在往段寄存器赋值的一瞬间</font></strong> ，规则如下：<br><strong>1）<font color='gree'>将控制直接转移到非依从的代码段：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL=目标代码段的DPL </span><br><span class="line">RPL=目标代码段的DPL</span><br></pre></td></tr></table></figure><p>典型例子为 <code>jmp 0x0012:0x2000</code> ，当两个代码段的特权级相同，则检查通过，顺利转移。</p><p><strong>2）<font color='gree'>将控制转移转移到依从代码段：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL≥目标代码段的DPL  //注意,数值上,CPL大于目标段DPL;实际上,当前特权级低于目标段DPL</span><br><span class="line">RPL≥目标代码段的DPL</span><br></pre></td></tr></table></figure><p>控制转移后，当前特权级不变。</p><p><strong>3）<font color='gree'>通过门转移控制权：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL≤门描述符的DPL</span><br><span class="line">RPL≤门描述符的DPL</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，调用门和中断门的特权级检查不同，调用门通过 call 和 jmp 进入，选择子中有 RPL 字段，因此还需要检测 RPL ；<u>而中断门通过中断号调用，所以无法检测 RPL</u> 。</strong> 中断门特权级检查还有几点不同，将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>详述。</p></blockquote><p><strong>4）<font color='gree'>访问数据段时：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL≤目标数据段的DPL</span><br><span class="line">RPL≤目标数据段的DPL</span><br></pre></td></tr></table></figure><p>与代码段转移不同，CPU 只允许高特权级代码段访问低特权级数据段。</p><p><strong>5）<font color='gree'>任何时候，栈段的特权级必须和当前特权级相同：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPL=目标栈段描述符的DPL</span><br><span class="line">RPL=目标栈段描述符的DPL</span><br></pre></td></tr></table></figure><p>注意，代码段发生特权级转移时，会自动根据 TSS 将栈更换为同特权级的栈（后文会详解），以上检查只发生在主动给 <code>ss</code> 赋值的时候。</p><p>大家肯定对 RPL 还不太明白，下面我们来理清 RPL，CPL，DPL 的关系。</p><h3 id="font-color-red-剖析-RPL-CPL-DPL-font"><font color='red'>剖析 RPL, CPL ,DPL</font></h3><p><strong><mark class="hl-label blue">DPL</mark> </strong><br>DPL（Descriptor Privilege Level，描述符特权级），位于 GDT/LDT/IDT 的描述符中。<u>对于门描述符，DPL 意味着访问该门的最低特权级；对于段描述符，DPL 意味着访问该段的最高特权级（参考前面的蹦床示意图）</u>。</p><p><strong><mark class="hl-label blue">CPL</mark> </strong><br>CPL（Current Privilege Level，当前特权级），<u>指正在运行的代码所对应的段描述符中的 DPL</u> 。也就是说，当前运行的代码的特权级就是 CPL 。<strong>注意，不要将 CPL 定义为 CS 段寄存器中的 RPL 位（CS.RPL），尽管绝大多数时候 CPL=CS.RPL ，这对后面理解非常重要。</strong></p><p><strong><mark class="hl-label blue">RPL</mark> </strong><br>RPL（Request Privilege Leve，请求特权级），指段寄存器中选择子的低 2 位。注意，什么能发出“请求”？<strong>显然，只有具备能动性的代码段（不一定是当前代码段）才能发出请求，所以 RPL 是指发出访问请求的代码段的特权级</strong> ，这对理解也很重要。</p><blockquote><p>不管是实施控制转移，还是访问数据段，这都能看作是一个请求，请求者请求访问指定的段。因此，<strong>RPL 就是指请求者的特权级</strong> 。<strong>请求者<u>往往</u>是当前代码段自己</strong> ，即 CPL=RPL，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;假设当前代码段的特权级为0</span><br><span class="line">mov eax,0x0009  </span><br><span class="line">mov ds,eax</span><br></pre></td></tr></table></figure><p><strong>由于 CPL 为 0，所以 ds 选择子中的 RPL 也被设置为 0，代表请求者的特权级为 0</strong> 。可是，这个选择子是我们自己设置的呀，我难道不能自己修改 RPL 来伪造请求者的身份吗？想到这点很不错！需要说明的是，上面只是演示，<strong><font color='orange'>实际上选择子是由操作系统提供的（GDT/LDT/IDT都是由操作系统构造，故选择子理所应当也由操作系统提供），操作系统会保障 RPL 的真实身份</font></strong> 。也就是说，<strong><font color='orange'>RPL 一定是为该段寄存器赋值时的代码的特权级</font></strong> ，这话有点绕，还是以上的例子：为 ds 赋值时，该代码段的特权级为 0，因此操作系统会保障 ds 中的 RPL 一定为 0 。怎么保障呢？使用 <code>arpl</code> 指令，其格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arpl 通用寄存器/16位内存, 16位通用寄存器</span><br><span class="line">;即</span><br><span class="line">arpl 用户提交的段选择子,用户代码段CS的值</span><br></pre></td></tr></table></figure><p>具体过程还要涉及栈切换，加上我们的操作系统不会用到该指令，所以此处不做过多讨论，详细请参考《操作系统真相还原》pdf 版第 245 页。有了该指令，即使用户伪造 RPL 也无济于事。</p></blockquote><p>说了半天，我们只了解了 RPL 的内涵，还不知道 RPL 的存在到底有什么必要性。下面对 RPL 的必要性进行阐述。</p><p><strong><mark class="hl-label blue">RPL的必要性</mark> </strong><br><u>假设段选择子不存在 RPL 字段</u>，发生如下场景：某个恶意程序通过一些奇淫巧计获取了内核的数据段选择子，它计划从硬盘读取一个扇区，并将所读数据写入内核的数据段。显然，它自己位于 3 特权级（ring 3），不能直接访问内核数据段。由于涉及硬盘读取，必须通过系统调用访问硬盘，此处使用调用门来进行系统调用。控制转移到调用门后，CPL 从 3 变为 0，此时将内核段选择子传递给内核例程，例程将选择子赋值进 ds，发生特权级检查：CPL=内核数据段描述符的DPL，检测通过。于是，<strong>恶意程序成功向内核数据段写入内容！</strong><br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE19.png" alt=""><br>就这样，恶意程序就这样成功利用调用门的掩护完成了对内核数据段的修改。以上方式出现问题的原因很容易得出：<strong><font color='orange'>受访者不知道访问者的真实身份</font></strong> 。在上例中，访问者的真实身份是恶意程序（ring 3)，然而恶意程序通过调用门这个代理(ring 0)去访问内核数据，内核就以为调用门是真正的请求者（毕竟是调用门直接接触内核的)，于是通过了特权级检查。因此，<strong><font color='orange'>要破解这个问题，我们就必须让内核知道某个请求后有没有背后的请求者，背后真正请求者的特权级是多少</font></strong> 。而 RPL 就是为了解决此问题而生，RPL 代表着 <strong><u>真正</u></strong> 的请求者的特权级。让我们看看当加入了 RPL 后，重复以上情形将发生什么：再一次，恶意程序通过某些方式获取了内核数据段选择子（其中 RPL=0)，当控制权转入调用门时，由于是远转移，处理器会将 cs, eip 等寄存器压栈以保护现场；因此调用门能够从栈中获取恶意程序 cs 中选择子的 RPL（也就是转移前的 CPL)，<strong><u>进而使用 <code>arpl</code> 指令将传入的内核数据段选择子的 RPL 更正为恶意程序自身的 CPL，以保证 RPL 的真实身份</u></strong> ，此时内核数据段选择子的 RPL 变成了 3 ；而后内核例程向 ds 中赋值，发生特权级检查，发现 <code>CPL&lt;=目标数据段的DPL</code> 成立，但 <code>RPL&lt;=目标数据段的DPL</code> 不成立（数据段选择子的RPL=3，而对应描述符的DPL=0)，因此拒绝访问，保卫成功！</p><p>从上面能够看出，<strong>光有 RPL 还不够，必须还要有 <code>arpl</code> 指令保证 RPL 的真实性</strong> 。同时也能发现，<strong>CPL 并不总是等于 RPL，这需要看当前运行的程序在访问数据段或代码段时用的是谁提供的选择子</strong> 。</p><blockquote><p>值得一提的是，<strong>由于效率原因，现代操作系统基本不使用调用门和任务门</strong> ，陷阱门也只在调试时使用。我们的 OS 只用到了中断门。因此，对调用门，任务门，陷阱门不做过多讨论，中断门将在<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>详细阐述。</p></blockquote><hr><h3 id="font-color-red-特权级下的栈保护-font"><font color='red'>特权级下的栈保护</font></h3><p>之前我们说过，<strong>一个任务被分为用户（私有）和内核（全局）两个部分</strong> ，内核位于第 0 特权级，用户位于第 3 特权级。因此，当特权级发生改变时（系统调用时，从用户态陷入内核态），栈也要发生改变，换句话说，<strong><font color='orange'>不同的特权级应该使用与其同等级的栈</font></strong> 。</p><blockquote><p>不同的特权级应该使用不同的栈，理由如下：</p><ol><li><strong>恶意的低特权级程序可以通过栈获取高特权级的信息，这非常危险。</strong></li><li>如果所有特权级都使用一个栈，那么这种交叉引用将会变得非常混乱。</li><li>用一个栈容纳所有特权级下的数据，栈很可能溢出。</li></ol></blockquote><p>处理器位于 0 特权级时要用 0 特权级的栈，位于 3 特权级时要使用 3 特权级的栈。问题是，一共有 4 个特权级，那么每个任务都应该有 4 个栈，<strong><u>为什么 TSS 中只有 3 个栈呢？这是由于 TSS 中记录的是转移后的高特权级对应的目标栈，因为 ring3 是最低级的，没有更低的特权级会向它转移，所以 TSS 不需要记录 ring3 的栈</u></strong> 。另外，也不是每一个任务都有 4 个栈，这取决于它最低的特权级别。比如 ring3 程序，还能提升 3 级，于是额外拥有 0，1，2 三个特权级的栈；而 ring0 程序则没有额外的栈。下面我们<u>以调用门为例</u>来看看发生特权级转移时，栈是如何变化的。</p><p><strong><font color='gree'>1）</font></strong> 假设当前位于 ring3，有两个参数，欲通过调用门执行 ring0 的内核例程。call 调用门前，先将两个参数压栈，此时的栈理所应当是 ring3 的栈。<br><img src="/2022/img/IMG_0544(20221128-145006).PNG" alt="" style="zoom:67%;" /><br><strong><font color='gree'>2）</font></strong> call 调用门，进行特权级检查，若检查通过，则顺利跳到目标代码段。<br><strong><font color='gree'>3）</font></strong> 由于此时 CPL=0，所以处理器自动在 TSS 中找到合适的栈段选择子 SS0 和 SP0，将其作为新栈。<u>为了在返回时切换回旧栈</u>，需要在新栈中保存旧栈的栈段选择子 SS_old 和栈指针 SP_old：<br><img src="/2022/img/IMG_0545(20221128-150757).PNG" alt="" style="zoom:50%;" /><br><strong><font color='gree'>4）</font></strong> 由于之前压入参数是在旧栈进行的，所以现在需要把参数转移到新栈，处理器怎么知道转移多少个字节呢？这由调用门描述符中的参数个数位给出。通过调用门描述符可知，需要转移两个参数，即 8 字节：<br><img src="/2022/img/IMG_0546(20221128-151203).PNG" style="zoom: 50%;" /></p><blockquote><p>注意，参数复制工作是由 CPU 自动完成，栈切换和参数复制对程序员来说是完全透明的。</p></blockquote><p><strong><font color='gree'>5）</font></strong> 为了将来恢复到用户进程，还需要压入转移前的段选择子 CS 和 EIP：<br><img src="/2022/img/IMG_0547(20221128-153129).PNG" alt="" style="zoom:50%;" /></p><blockquote><p>注意，不论转移前后 CS 中是否是同一个段选择子，CS 都会被重新加载，因此都必须记录 CS 。</p></blockquote><p>转移完成。另外需要注意，<strong><u>如果为平级转移，比如内核程序调用“调用门”，即从 ring0 到 ring0 ，则不会更新当前栈，直接跨过第 3，4 步，来到第 5 步压入 CS 和 EIP</u></strong> 。下面我们再来看看 retf 从调用门返回的过程：<br><strong><font color='gree'>1）</font></strong> 将 EIP_old 和 CS_old 分别弹出到 eip 和 cs 寄存器中，这个过程仍要进行特权级检查！ 若通过检查才能顺利赋值。</p><blockquote><p>你一定觉得返回时的特权级检查很鸡肋，明明我是通过调用门来到高特权级的，怎么返回时还要检查？原因为如下三点：</p><ol><li>retf 也涉及到给 CS 赋值，所以也会有特权级检查。</li><li><strong>retf(从调用门返回)、iret/iretd(从中断门返回) 这两类指令是从高特权级到低特权级的唯一办法</strong> ，而你完全可以使用 retf 来达到远转移的目的。谁说 retf 只能用来返回？给我目标段选择子和偏移量，将其存入栈中，再 retf ，完全可以达到 call 指令的效果。因此，为了防止使用 retf 来进行远转移（而非返回），必须再进行一次特权级检查。</li><li>再者，也可以通过修改栈内的 CS，EIP 来达到返回时进入其他段的目的。其实第 2，3 点也不算正经理由，因为系统调用是系统开发者编写的，开发者总不会这么来玩吧。</li></ol></blockquote><p><strong><font color='gree'>2）</font></strong> 如果有参数，则 ESP_new 跳过参数，指向 ESP_old 。<br><strong><font color='gree'>3）</font></strong> 如果在第 1 步检查中发现特权级发生了改变，则说明切换了新栈，所以从栈中分别弹出 ESP_old 和 SS_old 到 esp 和 ss 中。<br><strong><font color='gree'>4）</font></strong> 如果涉及到特权级改变，则还会检查 DS，ES，FS 和 GS 的内容，如果其中某个寄存器里的选择子所指向的数据段描述符的 DPL 比返回后的 CPL 高(数值上小于)，则会将该寄存器中填充 0 。</p><p>关于第 4 点，做简单解释：当控制转移到内核（ring 0）后，内核程序必然会使用自己的数据段，所以会向 DS/ES/FS/GS 赋予自己的数据段选择子，赋值时发生特权级检查，检查通过则赋值成功，此后对该数据段进行读写时将不再检查。问题就在于此，当从内核返回到用户程序后，DS/ES/FS/GS 很可能还指向内核的数据段，如果此时用户程序对其进行读写，将没有任何限制！因此，<strong>返回后 DS/ES/FS/GS 则可能被自动初始化为 0，如果用户程序直接使用值为 0 的段选择子，则会被索引到 GDT 的第 0 个描述符，而第 0 个描述符是不可用的</strong> ，<strong>从而引发 CPU 第 0x0d 号异常(#GP General Protection)</strong> 。这就是前文提到的为什么 GDT 第 0 号描述符不可用，而 LDT 第 0 号描述符可用的原因。</p><blockquote><p>前文强调过，<strong>特权级检查只发生在向段寄存器赋值的一瞬间，此后任何操作不再受限</strong> 。</p></blockquote><blockquote><p>另外需要注意，发生特权级转移时，调用门和中断门的栈处理是不同的，大概有以下两点：</p><ol><li>中断门还会压入 EFLAGS 寄存器，而调用门不会。</li><li>中断门不能通过栈压入参数，而调用门可以（因为调用门描述符中有4位用来记录参数个数）。</li></ol><p>以上是调用门压栈，关于中断门压栈，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">IDT与中断</a>。</p></blockquote><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加入中断-代码剖析</title>
      <link href="/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/26/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a> ，<a href="https://jyx-fyh.github.io/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a><br>本节对应分支：<code>interrupt</code></p></blockquote><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><p>本节我们为操作系统加入中断，初始化中断描述符表，并为 0~0x2f 中断添加对应的中断处理程序。当前的思路是，在 <code>interrupt.s</code> 中定义实际中断例程的入口函数（ <strong>通过入口函数转移到实际中断例程</strong> ），并利用汇编宏技术得到所有入口函数的地址，形成入口函数的地址数组 <code>interrupt_entry_table</code> ；然后在 <code>idt.c</code> 中引入该数组，进而我们能够很方便地向中断描述符中填写入口函数的地址。现在读者可能不明白这个思路的具体含义，别急，下面做具体阐述。</p><h3 id="font-color-red-代码解析-font"><font color='red'>代码解析</font></h3><p><strong><mark class="hl-label blue">interrupt.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">%define ERROR_CODE nop     ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span><br><span class="line">%define ZERO push 0        ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span><br><span class="line"></span><br><span class="line">extern interrupt_handler_table ;声明中断处理函数的指针数组</span><br><span class="line"></span><br><span class="line">%macro VECTOR 2</span><br><span class="line">INTERRUPT_ENTRY_%1:        ;中断处理entry</span><br><span class="line">    %2</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    push dword %1</span><br><span class="line">    call [interrupt_handler_table + %1*4]  ;进入实际中断函数</span><br><span class="line">    add esp, 4             ;外平栈</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov al,0x20            ;中断结束命令EOI</span><br><span class="line">    out 0xa0,al            ;向从片发送</span><br><span class="line">    out 0x20,al            ;向主片发送</span><br><span class="line"></span><br><span class="line">    add esp,4   ;跨过error_code,以保持堆栈平衡</span><br><span class="line">    iret   ;从中断返回,32位下等同指令iretd</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">;;;;;;;;;以下代码利用宏来定义函数;;;;;;;;;;;;;;;</span><br><span class="line">VECTOR 0x00, ZERO        ;divide by zero</span><br><span class="line">VECTOR 0x01, ZERO        ;debug</span><br><span class="line">VECTOR 0x02, ZERO        ;non maskable interrupt</span><br><span class="line">VECTOR 0x03, ZERO        ;breakpoint</span><br><span class="line">VECTOR 0x04, ZERO        ;overflow</span><br><span class="line">VECTOR 0x05, ZERO        ;bound range exceeded</span><br><span class="line">VECTOR 0x06, ZERO        ;invalid opcode</span><br><span class="line">VECTOR 0x07, ZERO        ;device not avilable</span><br><span class="line">VECTOR 0x08, ERROR_CODE  ;double fault</span><br><span class="line">VECTOR 0x09, ZERO        ;coprocessor segment overrun</span><br><span class="line">VECTOR 0x0a, ERROR_CODE  ;invalid TSS</span><br><span class="line">VECTOR 0x0b, ERROR_CODE  ;segment not present</span><br><span class="line">VECTOR 0x0c, ZERO        ;stack segment fault</span><br><span class="line">VECTOR 0x0d, ERROR_CODE  ;general protection fault</span><br><span class="line">VECTOR 0x0e, ERROR_CODE  ;page fault</span><br><span class="line">VECTOR 0x0f, ZERO        ;reserved</span><br><span class="line">VECTOR 0x10, ZERO        ;x87 floating point exception</span><br><span class="line">VECTOR 0x11, ERROR_CODE  ;alignment check</span><br><span class="line">VECTOR 0x12, ZERO        ;machine check</span><br><span class="line">VECTOR 0x13, ZERO        ;SIMD Floating - Point Exception</span><br><span class="line">VECTOR 0x14, ZERO        ;Virtualization Exception</span><br><span class="line">VECTOR 0x15, ZERO        ;Control Protection Exception</span><br><span class="line">VECTOR 0x16, ZERO        ;reserved</span><br><span class="line">VECTOR 0x17, ZERO        ;reserved</span><br><span class="line">VECTOR 0x18, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x19, ZERO        ;reserved</span><br><span class="line">VECTOR 0x1a, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1b, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1c, ZERO        ;reserved</span><br><span class="line">VECTOR 0x1d, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1e, ERROR_CODE  ;reserved</span><br><span class="line">VECTOR 0x1f, ZERO        ;reserved</span><br><span class="line">VECTOR 0x20, ZERO        ;clock 时钟中断</span><br><span class="line">VECTOR 0x21, ZERO        ;键盘中断</span><br><span class="line">VECTOR 0x22, ZERO        ;级联用的</span><br><span class="line">VECTOR 0x23, ZERO        ;串口2对应的入口</span><br><span class="line">VECTOR 0x24, ZERO        ;串口1对应的入口</span><br><span class="line">VECTOR 0x25, ZERO        ;并口2对应的入口</span><br><span class="line">VECTOR 0x26, ZERO        ;软盘对应的入口</span><br><span class="line">VECTOR 0x27, ZERO        ;并口1对应的入口</span><br><span class="line">VECTOR 0x28, ZERO        ;rtc实时时钟</span><br><span class="line">VECTOR 0x29, ZERO        ;重定向</span><br><span class="line">VECTOR 0x2a, ZERO        ;保留</span><br><span class="line">VECTOR 0x2b, ZERO        ;保留</span><br><span class="line">VECTOR 0x2c, ZERO        ;ps/2鼠标</span><br><span class="line">VECTOR 0x2d, ZERO        ;fpu浮点单元异常</span><br><span class="line">VECTOR 0x2e, ZERO        ;硬盘</span><br><span class="line">VECTOR 0x2f, ZERO        ;保留</span><br><span class="line"></span><br><span class="line">;;;;;;;;;中断函数地址表;;;;;;;;;;</span><br><span class="line">global interrupt_entry_table</span><br><span class="line">interrupt_entry_table:</span><br><span class="line">    dd INTERRUPT_ENTRY_0x00</span><br><span class="line">    dd INTERRUPT_ENTRY_0x01</span><br><span class="line">    dd INTERRUPT_ENTRY_0x02</span><br><span class="line">    dd INTERRUPT_ENTRY_0x03</span><br><span class="line">    dd INTERRUPT_ENTRY_0x04</span><br><span class="line">    dd INTERRUPT_ENTRY_0x05</span><br><span class="line">    dd INTERRUPT_ENTRY_0x06</span><br><span class="line">    dd INTERRUPT_ENTRY_0x07</span><br><span class="line">    dd INTERRUPT_ENTRY_0x08</span><br><span class="line">    dd INTERRUPT_ENTRY_0x09</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x0f</span><br><span class="line">    dd INTERRUPT_ENTRY_0x10</span><br><span class="line">    dd INTERRUPT_ENTRY_0x11</span><br><span class="line">    dd INTERRUPT_ENTRY_0x12</span><br><span class="line">    dd INTERRUPT_ENTRY_0x13</span><br><span class="line">    dd INTERRUPT_ENTRY_0x14</span><br><span class="line">    dd INTERRUPT_ENTRY_0x15</span><br><span class="line">    dd INTERRUPT_ENTRY_0x16</span><br><span class="line">    dd INTERRUPT_ENTRY_0x17</span><br><span class="line">    dd INTERRUPT_ENTRY_0x18</span><br><span class="line">    dd INTERRUPT_ENTRY_0x19</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x1f</span><br><span class="line">    dd INTERRUPT_ENTRY_0x20</span><br><span class="line">    dd INTERRUPT_ENTRY_0x21</span><br><span class="line">    dd INTERRUPT_ENTRY_0x22</span><br><span class="line">    dd INTERRUPT_ENTRY_0x23</span><br><span class="line">    dd INTERRUPT_ENTRY_0x24</span><br><span class="line">    dd INTERRUPT_ENTRY_0x25</span><br><span class="line">    dd INTERRUPT_ENTRY_0x26</span><br><span class="line">    dd INTERRUPT_ENTRY_0x27</span><br><span class="line">    dd INTERRUPT_ENTRY_0x28</span><br><span class="line">    dd INTERRUPT_ENTRY_0x29</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2a</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2b</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2c</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2d</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2e</span><br><span class="line">    dd INTERRUPT_ENTRY_0x2f</span><br></pre></td></tr></table></figure><p>读者可能又会泄气，怎么又用汇编？能用 C 尽量用 C 不行嘛？哈哈，您的心情我表示理解。使用汇编来编写此文件，有以下几点原因：</p><ol><li>用汇编处理错误码更加方便。</li><li>汇编能够直接发出 EOI 信号。</li><li>使用汇编的宏技术，所有宏函数直接展开，非常方便。</li></ol><p>当然，你也可以使用 C 语言来书写，笔者认为用 C 语言书写此部分应该可以使内核体积更小，毕竟这里的几十个宏函数未来都会被展开，体积就稍微大些。读者可以写两个 C 函数，分别应对有错误码和无错误码的情况。</p><p>接下来剖析代码：</p><ul><li><p>第 5 行，<code>interrupt_handler_table</code> 是位于 <code>idt.c</code> 的指针数组，其中的指针指向实际的中断处理函数。</p></li><li><p>第 7 行，<code>%macro VECTOR 2</code> ，这是汇编宏技术。前面我们使用过 <code>equ</code> 宏定义，它只能定义单行宏；对于多行宏，就需要使用 <code>%macro</code> 实现，其声明方式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%macro 宏名 参数个数</span><br><span class="line">........</span><br><span class="line">代码体</span><br><span class="line">........</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure><p>如果在代码体中想引用某个参数，则必须用 <code>%数字</code> 的方式来引用，参见第 8 行与第 9 行。我们将宏名定义为 VECTOR，并引入了两个参数。怎么压入参数呢？看第 35~82 行，直接在宏名后接上两个参数即可，参数直接用逗号隔开。<strong>注意，宏定义属于预处理指令（伪指令），这些宏会在编译期展开，也就是说，编译后，<code>interrupt.s</code> 中会有 0x30 个第 8~31 行这样的代码段</strong> 。</p></li><li><p>第 8 行为中断入口标号，代表入口函数的地址，下面定义函数指针的数组时会使用这些标号。</p></li><li><p>第 9 行，该行有两种情况，一种是 <code>ZERO</code> 宏对应的 <code>push 0</code> ，另一种是 <code>ERROR_CODE</code> 宏对应的 <code>nop</code> 指令，具体是哪种情况取决于利用宏定义函数时压入的什么参数，参见 35~82 行。注意，<strong><font color='orange'>对于有错误码的中断，CPU 会自动压入错误码；对于没有错误码的中断，CPU 则不进行动作(nop)；然而，对于前者，CPU 在函数返回时主动弹出错误码，必须由我们手动弹出错误码，这点尤其重要！</font></strong> 为了方便操作，有错误码的中断我们不做处理，无错误码的我们就压入 0，这样就统一了各中断函数的弹栈行为，无需特殊处理。关于错误码，参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>第 10~14 行，保存当前寄存器环境。由于在 17 行，我们调用了 C 语言编写的实际的中断处理函数，这必将破坏当前的寄存器环境，因此需要保存段寄存器和通用寄存器。其他寄存器会由 CPU 自动保存，关于这部分还请参见<a href="https://jyx-fyh.github.io/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/">中断详解</a>。</p></li><li><p>第 16 行，压入中断号，这是实际中断处理函数的参数。在我们的系统中，大多数异常我们不做处理，但发生异常时我们需要知道抛出了哪个异常，因此需要通过中断号来定位错误源。</p></li><li><p>第 17 行，interrupt_handler_table 是 idt.c 中的数组，该数组中装载的是实际中断处理函数的地址。因为是指针数组，指针大小为 4 字节，因此需要用序号乘 4 才能找到函数的地址。</p></li><li><p>第 18 行进行平栈，关于平栈请参见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>。</p></li><li><p>第 26~28 行，发送 EOI 信号，通知 8259A 芯片中断处理结束。这部分内容参见：<a href="https://jyx-fyh.github.io/2022/11/29/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-8259a/">8259A编程</a> 。</p></li><li><p>第 30 行，主动跨过错误码，原因已在前面阐述。</p></li><li><p>第 86~134 行，定义中断入口数组，即函数指针数组。该数组 <code>interrupt_entry_table[]</code> 会在 <code>dit.c</code> 文件中被引用。</p></li></ul><p><strong><mark class="hl-label blue">global.h</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OSLEARNING_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSLEARNING_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL0  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL1  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL2  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPL3  3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TI_GDT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TI_LDT 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_CODE   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_DATA   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_STACK   SELECTOR_K_DATA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTOR_K_VIDEO   ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================IDT描述符P================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_P_ON 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_P_OFF 0</span></span><br><span class="line"><span class="comment">//================IDT描述符DPL==============</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_DPL0   0       <span class="comment">//为什么只有0和3？</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_DPL3   3</span></span><br><span class="line"><span class="comment">//==========中断门的s位与type位=================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_DESC_GATE   0xE     <span class="comment">// S=0(系统段),TYPE=1110(32位中断门)</span></span></span><br><span class="line"><span class="comment">//============================================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> offset_L;       <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    <span class="type">short</span> selector;       <span class="comment">// 代码段选择子</span></span><br><span class="line">    <span class="type">char</span> reserved ;       <span class="comment">// 保留不用</span></span><br><span class="line">    <span class="type">char</span> s_type :<span class="number">5</span>;       <span class="comment">// 系统段:任务门/中断门/陷阱门/调用门</span></span><br><span class="line">    <span class="type">char</span> DPL    :<span class="number">2</span>;       <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    <span class="type">char</span> present:<span class="number">1</span>;       <span class="comment">// 是否有效</span></span><br><span class="line">    <span class="type">short</span> offset_H;       <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; __attribute__((packed));<span class="comment">//声明不要进行对齐</span></span><br><span class="line"><span class="comment">//=================GDT/IDT指针=================</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>     base;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="comment">//======加载GDT/LDT指针的函数，直接内联===========</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">load_xdt</span><span class="params">(<span class="keyword">struct</span> xdt_ptr* p, <span class="type">unsigned</span> <span class="type">short</span> limit, <span class="type">unsigned</span> <span class="type">int</span> base)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;base=base;</span><br><span class="line">    p-&gt;limit=limit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//OSLEARNING_GLOBAL_H</span></span></span><br></pre></td></tr></table></figure><ul><li>结构体 <code>gate_desc</code> 是中断描述符结构。该结构体有两点需要注意：<br>1）使用了位域，即为 <code>s_type</code> ，<code>DPL</code> ，<code>present</code> 字段按位分配而非按字节分配。可别以为声明了 char 就是分配了一个字节。<br>2）结构体声明的末尾 <code>__attribute__((packed))</code> 是在**<font color='orange'>指示编译器不要进行结构体对齐，这点很重要</font>** 。详细参考<a href="https://jyx-fyh.github.io/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a> 。</li><li><code>xdt_ptr</code> 是 IDTR/GDTR 的结构体。当前我们只使用 IDTR，后续还会使用 GDTR 。</li></ul><p><strong><mark class="hl-label blue">idt.c</mark> </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/system.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdt_ptr</span> <span class="title">idt_ptr</span> ;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*  interrupt_name[IDT_DESC_CNT];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> <span class="title">idt</span>[<span class="title">IDT_DESC_CNT</span>];</span>                 <span class="comment">//idt-中断描述符表</span></span><br><span class="line"><span class="keyword">extern</span> intr_handler interrupt_entry_table[IDT_DESC_CNT];   <span class="comment">//引用interrupt.s中的中断处理函数入口数组,注意，这是一个指针数组</span></span><br><span class="line">       intr_handler interrupt_handler_table[IDT_DESC_CNT]; <span class="comment">//实际中断处理例程的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_idt_desc</span><span class="params">(<span class="keyword">struct</span> gate_desc* p_desc, <span class="type">unsigned</span> <span class="type">char</span> DPL, intr_handler function)</span> &#123;</span><br><span class="line">    p_desc-&gt;offset_L = (<span class="type">unsigned</span> <span class="type">int</span>)function &amp; <span class="number">0x0000FFFF</span>;       <span class="comment">//低16位赋值给offset_L，高位丢弃</span></span><br><span class="line">    p_desc-&gt;offset_H = ((<span class="type">unsigned</span> <span class="type">int</span>)function&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000FFFF</span>; <span class="comment">//低16位赋值给offset_L，高位丢弃</span></span><br><span class="line">    p_desc-&gt;selector = SELECTOR_K_CODE;</span><br><span class="line">    p_desc-&gt;reserved = <span class="number">0</span>;</span><br><span class="line">    p_desc-&gt;s_type   = IDT_DESC_GATE;</span><br><span class="line">    p_desc-&gt;DPL      = DPL;</span><br><span class="line">    p_desc-&gt;present  = IDT_DESC_P_ON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_desc_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i],  IDT_DESC_DPL0, interrupt_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    put_str(<span class="string">&quot;idt is done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化可编程中断控制器8259A */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化主片 */</span></span><br><span class="line">    outb (PIC_M_CTRL, <span class="number">0x11</span>);   <span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x20</span>);   <span class="comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x04</span>);   <span class="comment">// ICW3: IR2接从片.</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0x01</span>);   <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化从片 */</span></span><br><span class="line">    outb (PIC_S_CTRL, <span class="number">0x11</span>);<span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x28</span>);<span class="comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x02</span>);<span class="comment">// ICW3: 设置从片连接到主片的IR2引脚</span></span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0x01</span>);<span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line">    <span class="comment">/* 打开主片上IR0,也就是目前只接受时钟产生的中断 */</span></span><br><span class="line">    outb (PIC_M_DATA, <span class="number">0xfe</span>);</span><br><span class="line">    outb (PIC_S_DATA, <span class="number">0xff</span>);</span><br><span class="line">    put_str(<span class="string">&quot;pic_init done\n&quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">()</span> &#123;</span><br><span class="line">    put_str(<span class="string">&quot;idt_init start\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">    idt_desc_init();         <span class="comment">//初始化中断描述符表</span></span><br><span class="line">    general_handler_regist();    <span class="comment">//默认中断函数注册</span></span><br><span class="line">    pic_init();             <span class="comment">//初始化8259A</span></span><br><span class="line">    load_xdt(&amp;idt_ptr,IDT_DESC_CNT*<span class="number">8</span><span class="number">-1</span>,idt); <span class="comment">//注意，limit=size-1，书中代码有误</span></span><br><span class="line">    <span class="comment">/* 加载idt */</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr&quot;</span>)</span>;</span><br><span class="line">    put_str(<span class="string">&quot;idt_init done\n&quot;</span>,BG_BLACK+FT_YELLOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">general_intr_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> vec_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec_num==<span class="number">0x27</span> || vec_num==<span class="number">0x2f</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    put_str(<span class="string">&quot;\ninterrupt &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_int(vec_num, BG_BLACK+FT_RED,HEX);</span><br><span class="line">    put_str(<span class="string">&quot; occur: &quot;</span>,BG_BLACK+FT_RED);</span><br><span class="line">    put_str(interrupt_name[vec_num],BG_BLACK+FT_RED);</span><br><span class="line">    put_int(time, BG_BLACK+FT_RED,DEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">general_handler_regist</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;IDT_DESC_CNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        interrupt_handler_table[i]= general_intr_handler;   <span class="comment">//将一般函数的地址安装到中断函数表中</span></span><br><span class="line">        interrupt_name[i]=<span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt_name[<span class="number">0</span>]    = <span class="string">&quot;Divide Error\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">1</span>]    = <span class="string">&quot;Debug Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">2</span>]    = <span class="string">&quot;NMI Interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">3</span>]    = <span class="string">&quot;Breakpoint Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">4</span>]    = <span class="string">&quot;Overflow Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">5</span>]    = <span class="string">&quot;BOUND Range Exceeded Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">6</span>]    = <span class="string">&quot;Invalid Opcode Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">7</span>]    = <span class="string">&quot;Device Not Available Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">8</span>]    = <span class="string">&quot;Double Fault Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">9</span>]    = <span class="string">&quot;Coprocessor Segment Overrun\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xa</span>]  = <span class="string">&quot;Invalid TSS Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xb</span>]  = <span class="string">&quot;Segment Not Present\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xc</span>]  = <span class="string">&quot;Stack Fault Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xd</span>]  = <span class="string">&quot;General Protection Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0xe</span>]  = <span class="string">&quot;Page-Fault Exception\n&quot;</span>;</span><br><span class="line">    <span class="comment">//interrupt_name[15]  第15项是intel保留项，未使用</span></span><br><span class="line">    interrupt_name[<span class="number">0x10</span>] = <span class="string">&quot;x87 FPU Floating-Point Error\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x11</span>] = <span class="string">&quot;Alignment Check Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x12</span>] = <span class="string">&quot;Machine-Check Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x13</span>] = <span class="string">&quot;SIMD Floating-Point Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x14</span>] = <span class="string">&quot;Virtualization Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x15</span>] = <span class="string">&quot;Control Protection Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x16</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x17</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x18</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x19</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1a</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1b</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1c</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1d</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1e</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x1f</span>] = <span class="string">&quot;reserved interrupt-unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x20</span>] = <span class="string">&quot;Clock interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x21</span>] = <span class="string">&quot;Keyboard interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x22</span>] = <span class="string">&quot;Clock interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x23</span>] = <span class="string">&quot;Cascade\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x24</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x25</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x26</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x27</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x28</span>] = <span class="string">&quot;RTC\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x29</span>] = <span class="string">&quot;Relocation\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2a</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2b</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2c</span>] = <span class="string">&quot;Unknown\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2d</span>] = <span class="string">&quot;FPU Exception\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2e</span>] = <span class="string">&quot;Disk interrupt\n&quot;</span>;</span><br><span class="line">    interrupt_name[<span class="number">0x2f</span>] = <span class="string">&quot;Reserved\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>make_idt_desc() 函数用于构造单个<u>中断门</u>描述符。注意第三个参数，是中断入口函数的指针，<code>typedef void* intr_handler</code> ，该声明在 interrupt.h 中。</li><li>idt_desc_init() 函数用来构造整个 IDT 表。</li><li>pic_init() 函数用来初始化 8259A 芯片，<strong>并将当前设置为只接收时钟中断</strong> 。其中还用到了 outb() 函数，该函数用汇编书写，在 <code>port_io.s</code> 文件中。端口号的宏在 <code>interrupt.h</code> 中。</li><li>general_intr_handler() 便是便是我们期待已久的实际中断程序，不过现在它很简陋。<strong><font color='orange'>先统一将所有的中断处理程序都设置为该函数，未来我们会使用 register_handler() 来注册专门的中断程序</font></strong>。另外，<strong>0x27 和 0x2f 无需处理</strong> 。</li><li>最后，在 general_handler_regist() 中将 interrupt_handler_table 数组的每一个元素赋值为 general_intr_handler 函数的指针。再次强调，现在虽然每个中断都使用同一个函数，但后期对于某些中断我们会将其专门化，现在只是为中断提供基本的信息，以便产生中断时我们能明白发生了什么中断。</li></ul><p>大家可能对各个函数之间的关系感到混乱，下面用一张图来帮助各位理清思绪：</p><p><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE0.png" alt=""><br><img src="/2022/img/image-20221201140151874.png" alt="运行截图"></p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断/IDT超详解</title>
      <link href="/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/11/21/%E5%8A%A0%E5%85%A5%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a><br>文章参考：<a href="https://blog.csdn.net/wlf_go/article/details/80319417">中断的作用</a> ，《真相还原》，<a href="https://blog.csdn.net/WriteAnything_/article/details/119205756">Bochs源码分析</a> ，《X86汇编：从实模式到保护模式》</p></blockquote><h3 id="font-color-red-什么是中断？-font"><font color='red'>什么是中断？</font></h3><p><strong><font color='orange'>定义：中断是指计算机运行过程中，出现某些情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</font></strong><br>中断是 CPU 对系统发生的某个事件作出的一种反应。引起中断的事件称为<strong>中断源</strong> ；中断源向 CPU 提出处理的请求称为<strong>中断请求</strong> ；发生中断时被打断程序的暂停点成为<strong>断点</strong> ；CPU 暂停现行程序而转为响应中断请求的过程称为<strong>中断响应</strong> ；处理中断源的程序称为<strong>中断处理程序</strong> ；CPU执行有关的中断处理程序称为<strong>中断处理</strong> ；而返回断点的过程称为<strong>中断返回</strong> 。</p><h3 id="font-color-red-中断的意义-font"><font color='red'>中断的意义</font></h3><ul><li><p><strong><font color='orange'>操作系统由事件驱动，而事件是以中断的形式来通知操作系统的，所以操作系统是由中断来驱动的。</font></strong></p></li><li><p><strong>中断机制是现代计算机系统中的基础设施之一，它在系统中起着通信网络作用(相当于信号)，以协调系统对各种外部事件的响应和处理。</strong></p></li><li><p><strong>中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率</strong> 。如果没有中断系统，CPU 就只能按照原来的程序编写的先后顺序，对各个外设进行查询和处理，即 <strong><u>轮询</u></strong> 工作方式，轮询方法貌似公平，但实际工作效率很低，不能及时响应紧急事件。</p></li><li><p><strong>中断能够显著提升并发，从而提高效率。</strong></p><blockquote><p>因为中断是由信号引发，只要收到信号，马上转移执行流，开始中断程序。只要信号频率足够，就能实现并发。</p></blockquote></li></ul><h3 id="font-color-red-中断的分类-font"><font color='red'>中断的分类</font></h3><img src="/2022/img/未命名绘图14-1669431386307-9.png" alt="" style="zoom:80%;" /><ul><li><p><strong><font color='gree'>外中断</font></strong> ：即来自 CPU 外部的中断，中断源为外部硬件，故而又叫硬件中断。<strong>外中断又分为可屏蔽中断和不可屏蔽中断：</strong></p><ul><li><p><strong><font color='gree'>可屏蔽中断</font></strong> ：<u>绝大多数外中断都是可屏蔽中断</u>，例如网卡收到网络包并通知 CPU；打印机向 CPU 发出提示等。当 eflags 中的 IF 位为 0 时，CPU 忽视可屏蔽中断；IF 为 1 时，接收可屏蔽中断。<strong><font color='red'>IF 仅对可屏蔽中断有效</font></strong> 。</p><blockquote><p>还记得吗？我们可以通过 <code>sti/cli</code> 指令开关外中断，即置 IF 位为 1/0 。</p></blockquote></li><li><p><strong><font color='gree'>不可屏蔽中断</font></strong> ：<u>通知CPU发生了灾难性事件</u> ，如电源掉电、总线奇偶位出错等。</p></li></ul></li><li><p><strong><font color='gree'>内中断</font></strong> ：来自 CPU 内部或软件的中断，分为以下三类：</p><ul><li><p><strong><font color='gree'>软中断(trap, 陷入)</font></strong> ：陷入是软件<u>主动</u>发起的中断，并不是某种内部错误。<strong><font color='red'>软中断是实现系统 API 函数调用的手段</font></strong> 。<strong>软中断通过 <code>int</code> 指令调用，如 <code>int 0x80</code></strong> 。</p><blockquote><p>在 Linux 中，使用了一个，也是唯一的一个软中断，就是 int 0x80 系统调用。</p></blockquote></li><li><p><strong><font color='gree'>终止(Abort)</font></strong> ：终止严重错误，如系统表 IDT、GDT 中的数据不一致或无效。发生该类错误时，恢复正常已经非常困难，所以操作系统通常只能把该任务从系统中抹去。</p></li><li><p><strong><font color='gree'>异常(fault)</font></strong> ：异常是 CPU 内部出错所发起的中断，<strong>有些异常可以主动调用，如 bound、int3；另一些异常则无需（不是不能）主动调用，如除零异常</strong> 。笔者了解的<u>可主动调用的异常</u>大概有以下几种：</p><ol><li><p><strong>bound</strong> ：检查数组越界指令，触发 5 号中断，用于检测数组的索引是否在上下边界之内。其格式为：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bound r16,m16</span><br><span class="line">bound r32,m32</span><br></pre></td></tr></table></figure><p>r16/r32 中存放的是数组索引，m32/m16 地址处存放了一对地址，第一个地址是数组的下限(起始)，第二个地址是数组的上限。如果索引不在边界内，则会发出超出边界范围的异常，即 0x5 号异常。</p></li><li><p><strong>ud2</strong> ：未定义指令，表示该指令无效，CPU 无法识别，触发 6 号中断。该指令常用于软件测试，无实际用途。</p></li></ol><blockquote><p>顺便提一下常见的两个<u>陷入</u>：</p><ol><li>into：中断溢出指令，触发 4 号中断。是否能触发还要看 eflags 寄存器中的 OF 位是否为 1，若不为 1，则直接无视。</li><li>int3：调试断点指令，触发 3 号中断。注意是 int3 而非 int 3，这两者不同。</li></ol><p>需要注意的是，into 与 int3 指令经常被划为异常，实际上它们是陷入，原因下面阐述。</p></blockquote></li></ul></li></ul><p>这里重点强调陷入和异常的区别：<strong><font color='red'>陷入时，会向栈中压入 EIP，该 EIP 指向触发异常的那条指令的<u>下一条指令</u> ；而异常发生时，压入的 EIP 是指向触发异常的那条指令</font></strong> ！<strong><font color='red'>因此，当从异常返回时，异常会重新执行那条指令；而陷入就不会重新执行</font></strong> 。这一点实际上也是相当重要的，比如我们熟悉的缺页异常（page fault），由于是 fault，所以当缺页异常处理完成之后，还会去尝试重新执行那条触发异常的指令（此时所缺页一般已经被加载进内存）。而上面我们谈到的 into/int3 中断执行完后并不会再执行原指令，所以它应该是 trap 而非 fault 。下面调用除零溢出来证实上面观点，见下图：<br><img src="/2022/img/image-202211252258470191.png" alt=""><br>大家快看！咋们只 div 了一次，却一直循环发生除零错误，这就是因为当异常处理完毕后，还会跳转到之前那条触发异常的指令。图中还夹杂了时钟中断，后续会详解。<strong>需要说明的是，如果你手动调用异常，就不会循环跳转了</strong> ：<br><img src="/2022/img/image-20221125230745566-1669431365728-6.png" alt=""></p><blockquote><p>这部分代码在 <code>interrupt</code> 分支，有兴趣的朋友可以提前玩玩。</p></blockquote><p>下面给出中断的类型分布图：<br><img src="/2022/img/image-20221125231200731-1669431362976-4.png" alt=""></p><p>另外，外中断是通过 INTR(interrupt) 和 NMI(Non Maskable Interrupt) 这两根信号线来通知 CPU 的。<strong>从 INTR 引脚收到的外中断是可屏蔽中断，由 eflags 的 IF 位决定是否接受；从 NMI 引脚收到的是不可屏蔽中断</strong> ，不可忽略。图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE15-1669431351849-2.png" alt=""><br>需要注意的是，由于不可屏蔽中断一旦发生，就意味着局面已经无法挽回，操作系统也无能为力，所以就没必要再细分原因。因此，<strong><font color='orange'>所有不可屏蔽中断都被划入一个中断号，即 0x2</font></strong> 。</p><p><strong><font color='gree'>异常和不可屏蔽中断的中断向量号由 CPU 自动提供，不能修改；可屏蔽中断的中断向量号由中断代理(8259A)提供；软中断(陷入)的中断向量号由操作系统提供</font></strong> 。<strong>CPU 为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是： （1）除法错、溢出中断、软件中断 （2）不可屏蔽中断 （3）可屏蔽中断 （4）单步中断。</strong></p><h3 id="font-color-red-中断描述符表IDT-font"><font color='red'>中断描述符表IDT</font></h3><p><strong>中断描述符表（Interrupt Descriptor Table，IDT）</strong> 是 <strong><u>保护模式</u></strong> 下用于储存中断程序入口地址的表。当 CPU 接收到中断时，需要用该中断的中断号去检索 IDT 中对应的描述符，描述符中储存着该中断例程的地址，接着跳到该地址处执行程序。</p><blockquote><p>需要注意的是，实模式下的中断表叫做 <strong>中断向量表（Interrupt Vector Table，IVT）</strong> ，它的作用和 IDT 完全相同，其他不同之处有以下两点：</p><ul><li><u>IVT 的描述符为 4 字节，而 IDT 的描述符为 8 字节</u>。</li><li>IVT 的位置固定在 0x0000~0x03FF ，而 IDT 可放于任意位置（由 IDTR 跟踪）。</li><li>IVT 是由 BIOS 在开机时建立的，中断例程也已经建立好了；而 IDT 以及其对应的中断例程都需要我们自己建立。</li></ul><p>另外，<strong><font color='orange'>BIOS 中断在保护模式下无法使用</font></strong> ，因为其中断例程都是用于 16 位指令架构，不再适用于 32 位保护模式。关于 IVT，详细内容可参考<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。</p></blockquote><p>中断描述符中装着各种门的描述符，<strong>包括<u>任务门</u>、<u>中断门</u>和<u>陷阱门</u>描述符（注意，不包含调用门）</strong> ，这三种描述符的结构和作用请参见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> ，就不在此赘述了。</p><p>IDT 与 GDT 的不同之处大概有以下几点：</p><ol><li>GDT 的第 0 个描述符不可用；IDT 的第 0 个描述符是可以用的，且第 0 个中断为著名的除零异常（上面已经演示）。</li><li>GDT 中包含普通段描述符、TSS描述符、LDT描述符、调用门/任务门描述符。而 IDT 则只包含中断门/陷阱门/任务门描述符。</li><li>GDT 最多能容纳 8192 个描述符，<strong>而 IDT 最多只能有 256 个描述符</strong> （即使 IDTR 的索引部分有 13 位）。</li><li>GDT 描述符由操作系统编写者自己定，而 IDT 中第 0~19 号描述符的作用已经写死进 CPU，不能自己决定。</li></ol><p>另外，IDT 的位置由 IDTR 寄存器进行跟踪，其格式和 GDTR 相同（回想一下 IDTR 的结构）：</p><p><img src="/2022/img/2%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1669635127754-1.png" alt=""><br>使用 <code>lidt</code> 进行加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lidt 48位内存数据</span><br><span class="line">;lidt [idt_ptr]</span><br></pre></td></tr></table></figure><h3 id="font-color-red-中断错误码-font"><font color='red'>中断错误码</font></h3><p><strong>有些异常产生时，CPU 会<font color='orange'>自动</font>在中断任务的栈中压入一个错误代码</strong> ，此错误码一般用来报告异常是在哪个段上发生的，因此错误码中包含了选择子等信息。错误码格式如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE163.png" alt=""></p><ul><li><strong>EXT(External Event)</strong> ：此位置 1 时，表示异常由 NMI、硬件中断等引发，</li><li><strong>IDT</strong> ：用于指示该选择子索引是指向哪的。为 1 时，指向中断描述符表(IDT)；为 0 时，指向 GDT 或 LDT 。</li><li><strong>TI</strong> ：<u>仅在 IDT 为 0 时有效</u>。此位为 1 时，指向 GDT；为 0 时，指向 LDT 。</li></ul><p>需要重点强调的是，<strong><font color='orange'>当通过 iret/iretd 指令从中断程序返回时，CPU 并不会自动弹出错误码</font></strong> ！因此，<strong><font color='red'>对于那些有错误码的中断例程(见上文的中断图)，必须在 iret/iretd 前手动弹出错误代码</font></strong> ，否则堆栈将失衡，最终引发程序崩溃。演示如下（先别管代码）：</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/error_code.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>另外，<strong><font color='orange'>对于外部异常（由 CPU 引脚触发），以及用软中断指令 int n 引发的异常，处理器不会压入错误代码，即使它原本是一个有错误代码的异常</font></strong> ！演示如下：</p><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/2022/video/positive_intr.mp4","pic":"/2022/image/1.jpg"},"danmaku":{"id":"9E2E3368B56CD123BB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","maximum":1000,"addition":["['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>能压入错误码的中断属于 0~32 号的异常，外部中断和陷入不会压入错误码。</p><h3 id="font-color-red-中断处理及其压栈过程-font"><font color='red'>中断处理及其压栈过程</font></h3><blockquote><p><a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> 中剖析了调用门的处理过程，建议读者将中断门处理和调用门处理对比阅读。</p></blockquote><p><strong><font color='gree'>（1）</font></strong> 发生中断，CPU 收到中断向量号，由此在 IDT 中定位到响应中断描述符。<br><strong><font color='gree'>（2）</font></strong> 进行特权级检查。<strong><font color='orange'>由于中断向量号只是一个整数，所以特权级检查并不涉及 RPL</font></strong> 。分以下两种情况：<br>a）由陷入 <code>int n</code> ，<code>int3</code> ，<code>into</code> 引起的中断，这些中断由用户主动发起，因此进行如下检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL≤门描述符的DPL</span><br><span class="line">其中目标代码段指的是该中断门描述符中的选择子指向的代码段描述符</span><br></pre></td></tr></table></figure><p>​b）由外部设备(可屏蔽中断)和异常引起的，只作如下检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标代码段的DPL≤CPL</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么由外部设备和异常引起的中断不检查门描述符的 DPL ？</strong><br>这点笔者在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a>留下了线索，其中提到“门槛”的作用是防止某些低特权级应用通过门来调用只服务于内核的程序，如页故障处理。而应用能这么做的前提是它可以主动发起门，但，由外部设备和异常引起的中断并不能由用户主动调用，因此也无需用门槛进行检查啦。</p></blockquote><p><strong><font color='gree'>（3）</font></strong> <strong>若特权级检查通过，则将中断门描述符中的选择子加载进 cs</strong> 。然后根据检查结果判断是否要转移到新栈，若发生特权级转移，则会转移到新栈。下面以转移到新栈为例。处理器先临时在其他地方保存旧栈的 SS 和 ESP，记为 SS_old 和 ESP_old，然后在对应 TSS 中找到相同等级的栈并转移到新栈，为了返回时能够切换回旧栈，在新栈中压入临时保存的 ESP_old 和 SS_old：<br><img src="/2022/img/IMG_0548(20221129-094330).PNG" alt="" style="zoom:67%;" /></p><blockquote><p><strong>注意，不管是否发生特权级转移，都会保存之前的 SS 和 ESP！</strong></p></blockquote><p><strong><font color='gree'>（4）</font></strong> 压入 EFLAGS 寄存器。需要注意，中断发生后 EFLAGS 的 NT 位和 TF 位会被自动置零（ <strong><font color='orange'>先将 EFLAGS 压栈再置零</font></strong> ）；<strong>如果中断对应的是中断门，则 IF 也被自动置零；如果中断对应的是任务门/陷阱门，IF 则不会置零</strong> 。详细原因见下文。<br><strong><font color='gree'>（5）</font></strong> 为了中断结束后能够顺利返回，将 CS_old 和 EIP_old 压栈：<br><img src="/2022/img/IMG_0549(20221129-095315).PNG" style="zoom: 50%;" /><br><strong><font color='gree'>（6）</font></strong> 某些异常可能有错误码，有错误码则压栈，无错误码则不做操作：<br><img src="/2022/img/IMG_0550(20221129-095535).PNG" style="zoom:50%;" /><br><strong><font color='gree'>（7）</font></strong> 进行中断处理过程。处理完毕后使用 <code>iret/iretd</code> 返回，栈中内容自动弹出，恢复到转移前的状态。<br><strong><font color='gree'>（8）</font></strong> 如果返回时需要改变特权级，则还会检查 DS/FS/GS/ES 中的内容，如果某个寄存器中选择子指向的数据段描述符的 DPL 比返回后的 CPL 高，则处理器自动将选择子置零。原因在<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a>中分析过，不再赘述。</p><p>下面对几个细节进行说明：</p><p><strong><mark class="hl-label blue">关于 IF 置零</mark> </strong></p><ul><li>对于中断门，将 IF 置零，忽略可屏蔽中断。这是为了避免中断嵌套，防止在中断处理时又来一个相同的外中断，这将导致 GP 异常（0xd中断）。</li><li>对于陷阱门，无需将 IF 置零。陷阱门用于调试，允许响应其他中断。</li><li>对于任务门，无需将 IF 置零。任务都应该在开中断的情况下进行，否则就会独占 CPU，多任务系统便退化为单任务系统。</li></ul><p><strong><mark class="hl-label blue">关于 TF 置零</mark> </strong><br>TF（Trap Flag），陷阱标志位，用于调试环境，能够使 CPU 单步执行。处理器执行一条指令前，如果检测到单步标志位 TF 为 1，则在该条指令执行后立即停止，引起 0x1 号中断，0x1 号中断处理程序中可以安排自己想实现的功能，如显示各个寄存器的值以及下一条指令（Debug就是如此，参见<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a>）。问题是，当 TF=1 时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序，注意，中断处理程序也是由一条条指令组成的，如果在执行中断处理程序时，TF=1，则 CPU 在执行完中断处理程序的第一条指令后，又会引发单步中断，重新进入中断处理程序，进而一直在此循环。因此，进入中断前必须将 TF 置 0 。</p><p><strong><mark class="hl-label blue">关于 NT 置零</mark> </strong><br>NT（Next Task Flag），任务嵌套标志位。任务嵌套指旧任务调用了新任务，旧任务挂起，执行流转入新任务。新任务如何返回到旧任务呢？通过两点：1）新任务的 TSS 中记录了旧任务 TSS 的指针，详见<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a>。2）新任务的 EFLAGS 中 NT 位被置 1 。<strong><font color='orange'>新任务返回到旧任务也是通过 <code>iret</code> 指令进行的</font></strong> ，那么问题来了：如果在新任务中发生了中断，当执行到 <code>iret</code> 指令时，处理器怎么知道该从中断返回还是从新任务返回到旧任务呢？这就是 NT 位起的作用，<strong>当 NT=0，则 iret 从中断返回；当 NT=1，则 iret 从任务返回</strong> 。</p><p><strong><mark class="hl-label blue">对错误码的压栈处理</mark> </strong><br><strong><font color='red'>对于那些有错误码的中断例程，弹栈时 CPU 不会主动越过错误码，所以我们必须在 iret/iretd 前手动弹出错误代码</font></strong> ，否则堆栈将失衡，最终引发程序崩溃。通常我们接收但无需处理错误码。</p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单步调试内核</title>
      <link href="/2022/11/20/%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8/"/>
      <url>/2022/11/20/%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现系统打印函数/除法溢出</title>
      <link href="/2022/11/20/%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/20/%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-概述-font"><font color='red'>概述</font></h3><ol><li><p>实现 <code>put_char()</code> 函数，<strong><u>这是最基础的系统级打印函数，其他打印函数都基于此函数</u></strong> 。</p></li><li><p>实现 <code>put_str()</code> 函数，该函数以 <code>put_char()</code> 为基础，极大地方便了字符串的打印。</p></li><li><p>实现 <code>put_int()</code> 函数，该函数以 <code>put_str()</code> 为基础，<strong><u>支持有符号 32 位整型的打印，同时支持十进制与十六进制格式打印</u></strong> 。</p></li><li><p>后续文章将利用以上函数实现 <code>printf()</code> 可变参打印函数。</p><blockquote><p>注意，前三者是系统级打印函数，也就是所谓的系统调用，和普通的库函数(如printf)要区分开。</p></blockquote></li></ol><p><strong>函数原型如下</strong> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">radix</span>&#123;</span>HEX=<span class="number">16</span>,DEC=<span class="number">10</span>&#125;;</span><br><span class="line">put_char(<span class="type">char</span>, <span class="type">unsigned</span> <span class="type">char</span>);  <span class="comment">//参数1:字符;  参数2:字符属性</span></span><br><span class="line">put_str(<span class="type">char</span>*, <span class="type">unsigned</span> <span class="type">char</span>);  <span class="comment">//参数1:字符串; 参数2:字符属性</span></span><br><span class="line">put_int(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">char</span>, <span class="keyword">enum</span> radix); <span class="comment">//参数1:数字; 参数2:字符属性; 参数3:进制</span></span><br></pre></td></tr></table></figure><p>实现打印函数之前，我们还需要了解一些显存的知识。毕竟是系统调用，多多少少都会直接操作硬件，话不多说，开干。</p><h3 id="font-color-red-显存的端口操作-font"><font color='red'>显存的端口操作</font></h3><p>之前咋们都是通过直接操控 <code>0xb8000</code> 的显存区域来实现屏幕输出，为啥现在要使用端口啦？简单来说，是为了方便。我们之前一直使用如下类似的方式进行打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0xb8000  ;现在是在保护模式下，所以是0xb8000而非0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line">mov [gs:0],&#x27;w&#x27;</span><br><span class="line">mov [gs:2],&#x27;o&#x27;</span><br><span class="line">mov [gs:4],&#x27;w&#x27;</span><br><span class="line">mov [gs:6],&#x27;!&#x27;</span><br></pre></td></tr></table></figure><p>这种方式的麻烦之处在于：</p><ol><li>一行代码只能打印一个字符。显然，我们不可能用这个方法打印一整屏的内容。</li><li>我们必须手动指定打印位置。屏幕内容少时还能接受，一旦屏幕内容较多，打印时稍有不慎就会将之前的内容覆盖。</li></ol><p>而通过操作显存端口来获得光标位置后，我们就可以放心地将字符定位任务交给光标啦。</p><blockquote><p><strong>操作端口的直接原因就是为了获取光标位置。</strong> 需要注意的是，在实模式下可以通过 BIOS 中断来获取光标位置，进入保护模式后就不能再使用 BIOS 中断了，所以必须手动操作端口。</p></blockquote><p>显卡一般有 <u>CGA、EGA、VGA</u> 三种显示标准，功能复杂，这使得显卡具备相当多的寄存器（端口）。我们知道，计算机系统为这些端口统一编址，每个端口占用一个地址（Intel 系统的寄存器地址范围为 0~65535，注意，<strong>这个地址可不是内存地址</strong> ）。如果为显卡的每个端口都分配一个系统端口</p><p>地址，这就十分浪费硬件资源了，毕竟显卡如果这么干，那就意味着其他硬件也能这么干，那端口地址不一会就会分配光啦。所以，制造商根据功能的不同将显卡寄存器分为不同的组（并排列成数组），每个组中有两个特殊的寄存器：1）<strong>Address Register</strong> ；2）<strong>Data Register</strong> 。<strong><u><font color='orange'>Address Register 作为数组的索引，通过该寄存器来指定要访问的寄存器；Data Register 则用来输入输出，相当于所有寄存器的读写窗口</font></u></strong> 。</p><blockquote><p><strong>CGA</strong> ：彩色图形适配器，提供两种标准文字显示模式：40×25×16 色和 <u>80×25×16</u> 色；以及两种常用的图形显示模式：320×200×4 色和 640×200×2 色；<br><strong>EGA</strong> ：增强图形适配器，在显示性能方面(颜色和分辨率)介于 CGA 和 VGA 之间；<br><strong>VGA</strong> ：视频图形阵列，具有分辨率高、显示速率快、颜色丰富等优点，在彩色显示器领域得到了广泛的应用，VGA最早指的是显示器 640×480 这种显示模式。</p></blockquote><p><img src="/2022/img/IMG_0533(20221124-233242).PNG" alt="仅作了解"><br>以上只对显卡寄存器做了个简单的讲解，因为我们待会也只需要通过端口获取光标而已，就不再做过多阐述，避免劝退。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;获取光标</span><br><span class="line">   mov dx, 0x03d4  ;索引寄存器</span><br><span class="line">   mov al, 0x0e   ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   in al, dx   ;得到了光标位置的高8位</span><br><span class="line">   mov ah, al</span><br><span class="line"></span><br><span class="line">   ;再获取低8位</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   in al, dx       ;此时ax中就存放着光标的位置</span><br></pre></td></tr></table></figure><p>注意，读写 8 位端口时，只能用 al 中转；读写 16 位端口时，只能用 ax 中转。</p><h3 id="font-color-red-print-char-font"><font color='red'>print_char</font></h3><p>这三个系统调用我们都使用汇编来写，实际上，这里使用汇编比 C 语言更简单。不用害怕，就 put_char 稍长一点，但其逻辑十分简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">;------------------------   put_char   -----------------------------</span><br><span class="line">;功能描述:把栈中的1个字符写入光标所在处</span><br><span class="line">;-------------------------------------------------------------------</span><br><span class="line">TI_GDT equ  0</span><br><span class="line">RPL0  equ   0</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0</span><br><span class="line">global put_char</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">put_char:</span><br><span class="line">   pushad              ;备份32位寄存器环境</span><br><span class="line">   mov ax, SELECTOR_VIDEO ;需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">;;;;;;;;;  获取当前光标位置 ;;;;;;;;;</span><br><span class="line">   ;先获得高8位</span><br><span class="line">   mov dx, 0x03d4  ;索引寄存器</span><br><span class="line">   mov al, 0x0e   ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   in al, dx   ;得到了光标位置的高8位</span><br><span class="line">   mov ah, al</span><br><span class="line"></span><br><span class="line">   ;再获取低8位</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   in al, dx</span><br><span class="line"></span><br><span class="line">   mov bx, ax                 ;将光标存入bx</span><br><span class="line">   ;下面这行是在栈中获取待打印的字符</span><br><span class="line">   mov ecx, [esp + 36]      ;pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节</span><br><span class="line">   mov edx, [esp + 40]        ;获取字符属性</span><br><span class="line">   cmp cl, 0xd                ;CR(回车)是0x0d,LF(换行)是0x0a</span><br><span class="line">   jz .is_carriage_return</span><br><span class="line">   cmp cl, 0xa</span><br><span class="line">   jz .is_line_feed</span><br><span class="line"></span><br><span class="line">   cmp cl, 0x8                ;backspace的ascii码是8</span><br><span class="line">   jz .is_backspace</span><br><span class="line">   jmp .put_other             ;调转到可显示字符的打印</span><br><span class="line">;backspace的一点说明:</span><br><span class="line">;当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符</span><br><span class="line">;但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,</span><br><span class="line">;这就显得好怪异,所以此处添加了空格或空字符0</span><br><span class="line">.is_backspace:</span><br><span class="line">   dec bx</span><br><span class="line">   shl bx,1</span><br><span class="line">   mov byte [gs:bx], 0x20     ;将待删除的字节补为0或空格皆可</span><br><span class="line">   inc bx</span><br><span class="line">   mov byte [gs:bx], 0x07     ;黑底白字</span><br><span class="line">   shr bx,1</span><br><span class="line">   jmp .set_cursor</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"> .put_other:</span><br><span class="line">   shl bx, 1  ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节</span><br><span class="line">   mov [gs:bx], cl  ; ascii字符本身</span><br><span class="line">   inc bx</span><br><span class="line">   mov byte [gs:bx],dl        ; 字符属性</span><br><span class="line">   shr bx, 1  ; 恢复老的光标值</span><br><span class="line">   inc bx                     ; 下一个光标值</span><br><span class="line">   cmp bx, 2000</span><br><span class="line">   jl .set_cursor             ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值</span><br><span class="line">                              ; 若超出屏幕字符数大小(2000)则换行处理</span><br><span class="line"> .is_line_feed:               ; 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，</span><br><span class="line"> .is_carriage_return:         ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。</span><br><span class="line">                              </span><br><span class="line">   xor dx, dx                 ; dx是被除数的高16位,清0.</span><br><span class="line">   mov ax, bx                 ; ax是被除数的低16位.</span><br><span class="line">   mov si, 80                  </span><br><span class="line">   div si                     </span><br><span class="line">   sub bx, dx                 ; 光标值减去除80的余数便是取整</span><br><span class="line">                              </span><br><span class="line"> .is_CRLF_end:                ; 回车符CRLF处理结束</span><br><span class="line">   add bx, 80</span><br><span class="line">   cmp bx, 2000</span><br><span class="line">   jl .set_cursor</span><br><span class="line"></span><br><span class="line">;屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充</span><br><span class="line"> .roll_screen:                ; 若超出屏幕大小，开始滚屏</span><br><span class="line">   cld</span><br><span class="line">   mov ecx, 960               ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次</span><br><span class="line">   mov esi, 0xb80a0          ; 第1行行首</span><br><span class="line">   mov edi, 0xb8000           ; 第0行行首</span><br><span class="line">   rep movsd</span><br><span class="line"></span><br><span class="line">;将最后一行填充为空白</span><br><span class="line">   mov ebx, 3840              ; 最后一行首字符的第一个字节偏移= 1920 * 2</span><br><span class="line">   mov ecx, 80                ;一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次</span><br><span class="line"> .cls:</span><br><span class="line">   mov word [gs:ebx], 0x0720  ;0x0720是黑底白字的空格键</span><br><span class="line">   add ebx, 2</span><br><span class="line">   loop .cls</span><br><span class="line">   mov bx,1920                ;将光标值重置为1920,最后一行的首字符.</span><br><span class="line"></span><br><span class="line"> .set_cursor:</span><br><span class="line">;将光标设为bx值</span><br><span class="line">;;;;;;; 1 先设置高8位 ;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4             ;索引寄存器</span><br><span class="line">   mov al, 0x0e               ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5             ;通过读写数据端口0x3d5来获得或设置光标位置</span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">;;;;;;; 2 再设置低8位 ;;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5</span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line"> .put_char_done:</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure><p>这里的代码笔者直接扣的《操作系统：真相还原》(略作修改)，代码注释已经非常清晰，下面对部分内容做说明：</p><ul><li>第 7,8 行：为了防止将来因为 GS=0 导致 CPU 抛出异常（选择子不能为0，还记得吗），这和特权级有关，后面文章会剖析。</li><li>第 28,29 行：这里直接使用 esp 来定位参数，并不规范。一般我们会在函数开头 <code>push ebp</code> ， <code>mov ebp,esp</code> ，然后使用 ebp 来定位参数。</li><li>第 77,81 行，<code>cld</code> 与 <code>rep movsd</code> 详见<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。</li></ul><p>以上就是 put_char 的内容，代码多，但逻辑简单。</p><h3 id="font-color-red-put-str-font"><font color='red'>put_str</font></h3><p><code>put_str</code>  以 <code>put_char</code> 为基础，代码相对简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------------------</span><br><span class="line">;put_str 通过put_char来打印以0字符结尾的字符串</span><br><span class="line">;--------------------------------------------</span><br><span class="line">;输入：参数1:字符串 参数2:字符属性</span><br><span class="line">;输出：无</span><br><span class="line">global put_str</span><br><span class="line">put_str:</span><br><span class="line">;由于本函数中只用到了ebx和ecx,只备份这两个寄存器</span><br><span class="line">   push ebx</span><br><span class="line">   push ecx</span><br><span class="line">   push edx</span><br><span class="line">   xor ecx, ecx           ; 准备用ecx存储参数,清空</span><br><span class="line">   mov ebx, [esp + 16]    ; 从栈中得到待打印的字符串地址</span><br><span class="line">   mov edx, [esp + 20]    ; 获取字符属性</span><br><span class="line">.goon:</span><br><span class="line">   mov cl, [ebx]</span><br><span class="line">   cmp cl, 0              ; 如果处理到了字符串尾,跳到结束处返回</span><br><span class="line">   jz .str_over</span><br><span class="line">   push edx               ; 传递字符属性参数</span><br><span class="line">   push ecx               ; 为put_char函数传递参数</span><br><span class="line">   call put_char</span><br><span class="line">   add esp, 8             ; 回收参数所占的栈空间</span><br><span class="line">   inc ebx                ; 使ebx指向下一个字符</span><br><span class="line">   jmp .goon</span><br><span class="line">.str_over:</span><br><span class="line">   pop edx</span><br><span class="line">   pop ecx</span><br><span class="line">   pop ebx</span><br><span class="line"></span><br><span class="line">   ret</span><br></pre></td></tr></table></figure><ul><li>第 13,14 行，同样不规范，请读者试试用 ebp 定位参数。不清楚的朋友可参考：<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a> 。</li><li>第 22 行，外平栈，不熟悉的朋友仍请参考<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用过程</a> 。</li></ul><h3 id="font-color-red-put-int-font"><font color='red'>put_int</font></h3><p>put_str 和 put_char 笔者直接使用的《操作系统：真相还原》中的代码，而 put_int 为笔者原创，添加了有符号数打印与十六进制格式打印，代码质量不敢作保证（本人菜比），如有错误，请读者指出。下面内容较多，请读者打起精神继续阅读，哈哈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">;====================put_int===========================================</span><br><span class="line">;参数1：数字  参数2：字符属性 ;参数3:进制</span><br><span class="line">section .data</span><br><span class="line">buffer times 12 db 0     ;字符串缓冲区</span><br><span class="line">sign db 0                ;符号标记</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global put_int</span><br><span class="line">put_int:</span><br><span class="line">    push ebp             ;保存原函数栈底</span><br><span class="line">    mov ebp,esp          ;ebp指向本函数栈底</span><br><span class="line">    pushad               ;保存所有通用寄存器</span><br><span class="line"></span><br><span class="line">    mov eax,[ebp+8]      ;取得参数1</span><br><span class="line">    mov ebx,eax          ;备份</span><br><span class="line">    mov byte [sign],1    ;先默认该数为正</span><br><span class="line">    mov edi,11           ;edi作为变址寄存器,指向buffer[11]</span><br><span class="line">    mov esi,buffer       ;esi作为基址寄存器,指向buffer[0]</span><br><span class="line">    mov cl,31            ;右移的位数如果不是1,则必须使用cl储存</span><br><span class="line">    shr eax,cl           ;将数字右移31位,得到符号位</span><br><span class="line">    cmp eax,1            ;如果符号位为1,则说明该数为负</span><br><span class="line">    jne  .positive       ;如果不为负,则跳转至.positive处理正数</span><br><span class="line"></span><br><span class="line">.negative:</span><br><span class="line">    mov byte [sign],0    ;符号标志位设为0,表示负数</span><br><span class="line">    not ebx              </span><br><span class="line">    inc ebx              ;取反并加1,得到相反数,即得正数,并进入下面.positive</span><br><span class="line"></span><br><span class="line">.positive:</span><br><span class="line">    mov ax,bx</span><br><span class="line">    mov cl,16</span><br><span class="line">    shr ebx,cl</span><br><span class="line">    mov dx,bx            ;以上四步将参数1的高16位存入dx,低16位存入ax</span><br><span class="line">.loop:</span><br><span class="line">    mov cx,[ebp+16]      ;取得进制</span><br><span class="line">    call divdw           ;输入:ax:数字的低16位  dx:数字的高16位  cx:除数|输出：cx:余数 ax:商的低16位 dx:商的高16位</span><br><span class="line">    sub edi,1            ;指定该字符的预放置位置</span><br><span class="line">    cmp cl,10            ;cx存的余数，最大不超过16，故余数一定在cl中，直接使用cl</span><br><span class="line">    jb  .dec             ;如果小于十就跳转到10进制处理，大于10就去16进制处理</span><br><span class="line">.hex:</span><br><span class="line">    add cl,&#x27;a&#x27;-10        ;将该数字转为字母(16进制)</span><br><span class="line">    jmp .@2</span><br><span class="line">.dec:</span><br><span class="line">    add cl,&#x27;0&#x27;           ;将该数字转为数字字符</span><br><span class="line">.@2:</span><br><span class="line">    mov [esi+edi],cl     ;将该字符移入缓冲区</span><br><span class="line">    mov cl,16            </span><br><span class="line">    mov bx,dx</span><br><span class="line">    shl ebx,cl</span><br><span class="line">    mov bx,ax            ;以上4步将商存入ebx</span><br><span class="line">    cmp ebx,0            </span><br><span class="line">    jne .loop            ;如果商为0,则该数处理完毕</span><br><span class="line"></span><br><span class="line">.@1:</span><br><span class="line">    mov cx,[ebp+16]      ;如果为16进制，则在数字前还要加上0x</span><br><span class="line">    cmp cx,16</span><br><span class="line">    jne .sign            ;如果为10进制数，则直接处理符号</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;x&#x27;</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;0&#x27;</span><br><span class="line"></span><br><span class="line">.sign:</span><br><span class="line">    mov al,[sign]</span><br><span class="line">    cmp al,0</span><br><span class="line">    jne .@3              ;若为正数，则跳转到.@3直接打印数字</span><br><span class="line">    sub edi,1</span><br><span class="line">    mov byte [esi+edi],&#x27;-&#x27;</span><br><span class="line">.@3:</span><br><span class="line">    push dword [ebp+12]</span><br><span class="line">    add  esi,edi</span><br><span class="line">    push esi</span><br><span class="line">    call put_str</span><br><span class="line">    add esp,8</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop ebp              ;恢复原函数栈底</span><br><span class="line">    ret</span><br><span class="line">;============================</span><br><span class="line">;输入：ax:数字的低16位  dx:数字的高16位  cx:除数</span><br><span class="line">;输出：cx:余数 ax:商的低16位 dx:商的高16位</span><br><span class="line">divdw:</span><br><span class="line">    push ax</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,0</span><br><span class="line">    div cx               ;div后,ax存放商,dx存放余数</span><br><span class="line">    mov bx,ax</span><br><span class="line">    pop ax</span><br><span class="line">    div cx</span><br><span class="line">    mov cx,dx</span><br><span class="line">    mov dx,bx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>代码注释很详细，笔者只解释以下几个地方：</p><ul><li><p>如何在 buffer 中定位字符？流程如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.13png.png" alt=""></p></li><li><p>第 10,11 行使用 ebp 来定位参数。笔者在这吃过大亏，曾想当然地省略了第 10 行，结果就是排了一天的错。在函数内使用过的寄存器一定要提前保存！</p></li><li><p>为什么第 39 行除法不直接使用 <code>div</code> 指令，而使用 divdw 函数呢？这是因为 div 可能发生溢出，即 <strong><font color='orange'>除法溢出</font></strong> ，这将引发 CPU 异常。div 指令功能为：如果除数为 16 位，则被除数须为 32 位，高位放在 DX 中，低位放在 AX 中；将商放入 AX，余数放入 DX。而当被除数为 100000，除数为 1 时，商就无法完全存入 AX，从而发生溢出。为了避免这一问题，我们就用 divdw 函数来进行除法操作。divdw 原理剖析见文末。</p></li><li><p>注意，字符串末尾必须为 0 ！在 C 语言中，字符串 “abcd” 会在编译时由编译器在其末尾加 0，但是在汇编中，0 必须要我们自己加！</p><blockquote><p><code>\n</code> 也是如此，在汇编中，以下数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data db&quot;wow!\n&quot;</span><br></pre></td></tr></table></figure><p>最后的 <code>\n</code> 会被解析为 <code>\</code> 和 <code>n</code> ！这是因为高级语言中的 <code>\n</code>  是在编译阶段被识别并处理为 ASCII 码 <code>0x8</code> ，这个转换是编译器的功劳。而我们自己手写汇编时，可不会还经过编译器处理。</p></blockquote></li><li><p>有人可能不明白为什么三个参数在栈中的位置分别是 [ebp+18]，[ebp+12]，[ebp+16]，这意味着这三个参数的大小都是 4 字节。问题在于，我们的函数原型是 <code>put_int(int, unsigned char, enum radix);</code> ，第二个参数是 char 呀，不应该只压入 1 个字节吗？是这样的，<strong><font color='red'>C 语言不管函数参数类型是 char 还是 short 或者 int，压参时每个参数都会压入 4 字节</font></strong> ，关于这点的讨论请参见<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C和汇编混合编程</a> 。</p></li></ul><p>关于上面的除法溢出，可以利用后面将学习的中断描述符表（IDT）来检验，如下：<br><img src="/2022/img/image-20221125162813996.png" alt=""><br>显然，除法溢出引发 CPU 的 0 号异常。</p><p>最后，来看看效果：<br><img src="/2022/img/image-20221125161434097.png" alt=""></p><p>大功告成！</p><blockquote><p>另外，负十六进制数一般是由补码形式来显示的，这里转换就比较复杂，所以上面的 put_int 没考虑这一点，直接在十六进制数前加负号。</p></blockquote><blockquote><p>补更：后续学习中发现有符号整型不够用（比如显示地址，大于 2GB 就为负了），因此还需要一个无符号整型打印函数 put_uint，该函数的实现也只是在 put_int 上稍作修改，具体请参考 <code>memory</code> 分支。</p></blockquote><h3 id="font-color-red-divdw原理浅析-font"><font color='red'>divdw原理浅析</font></h3><p>为避免除法溢出，我们将一次除法分解成两次除法，核心公式为：<br><strong><font color='orange'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X/n=(H&lt;&lt;16+L)/n=(H/n)&lt;&lt;16+(L/n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></font></strong></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo separator="true">,</mo><mi>L</mi><mo>=</mo><mi>X</mi><mi mathvariant="normal">%</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H=X&gt;&gt;16,L=X\%(2^{16})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">16</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">%</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>我们一步一步来分析：</p><ol><li>首先我们要知道，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">!</mo><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">X!=(X&gt;&gt;16)&lt;&lt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> ，这个大家一定都清楚。正确的等式（注意是等式，而非赋值）应该为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>X</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">X=(X&gt;&gt;16)&lt;&lt;16+X\%2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8697em;vertical-align:-0.0556em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> ，即得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X=(H&lt;&lt;16+L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 。</li><li>接下来的问题是，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">(H&lt;&lt;16)/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span> 如何得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(H/n)&lt;&lt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> ？这个简单：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mo>&lt;</mo><mo>&lt;</mo><mn>16</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mo>∗</mo><mn>65536</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mi>H</mi><mo>∗</mo><mn>65536</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>65536</mn><mo>=</mo><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>&gt;</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(H&lt;&lt;16)/n=(H*65536)/n=H*65536/n=(H/n)*65536=(H/n)&gt;&gt;16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">65536</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">65536/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span><br>得证。</li></ol><p>由此，我们便将 X/n 分解成了 H/n 和 L/n ，这无论如何也不可能发生溢出。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加载内核-代码详解</title>
      <link href="/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前置内容：<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">浅析C语言和汇编混合编程</a>，<a href="https://jyx-fyh.github.io/2022/10/09/makefile%E5%85%A5%E9%97%A8/">makefile入门</a><br>本节对应分支：<code>load-kernel</code></p></blockquote><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><p>让我们看看目录结构：<br><img src="/2022/img/image-20221116184755024.png" alt="目录结构/main.c"><br>相比 <code>open-page</code> 分支，本分支新增了两个文件，一个是 <code>/kernel/main.c</code> (如上)，另一个是 <code>/src/guide.s</code> ：<img src="/2022/img/image-20221116190141563.png" alt="guide.s"></p><p>loader.s 作了改动，下面是分支  <code>load-kernel</code> 相对于 <code>open-page</code> 的修改：<br><img src="/2022/img/image-20221116191353841.png" alt=""><br>显然，<code>load-kernel</code> 从硬盘中读取内核并加载到 KERNEL_ADDR 地址处，最后跳转进入内核，<strong>loader 使命到此结束</strong> 。</p><blockquote><p>loader 的使命虽然结束了，但里面的 GDT 我们可还要用呢，后面注意不能把 loader 覆盖，即使要覆盖，也必须先转移 GDT。</p></blockquote><h3 id="font-color-red-为什么需要引导文件？-font"><font color='red'>为什么需要引导文件？</font></h3><p>容易知道，main.c 就是内核。按之前编写 mbr.s 和 loader.s 的经验，我们可能会想到直接将 main.c 编译成 main.bin 文件，然后将 main.bin 直接加载到内存 KERNEL_ADDR 处，接着再跳转进入内核，这不就大功告成了吗？那么为啥还得先进入 guide.s ，然后再调用内核 kernel_main？感觉它很鸡肋啊…嗯，这个问题也困扰了我好一会。<strong>其实，前面这个想法很容易被否定，原因在于，你怎么能保证 main.bin 文件的开头一定是 kernel_main 函数的入口而不是其他描述信息</strong> ？注意看，kernel_main 函数里面可也是定义了数据的，<strong>所以你又怎么保证 main.bin 文件的开头是指令还是数据</strong> ？综上，直接将 main.bin 加载到某个位置并跳转过去，这个方案是不可取的。你可能又会说，kernel_main 函数中不就定义了两个 char* 指针和一个字符串吗，<code>char*</code> 四字节，字符串 15 字节，总字节数为<code>4+4+15=23</code> ，那么在 loader 中跳转时，我越过这个 23 字节，直接跳到代码处不就行了？哈哈哈，我一开始也这么想过，不过马上就否定了。我们会产生这种想法的原因在于之前 loader 和 mbr 都是用汇编写的（也只能用汇编），而汇编能让我们掌握程序的每一个细节。可 C 语言这种高级语言呢？它虽然大大简化了程序的编写难度，但却对上层屏蔽了很多细节，这些细节我们很难完全把控。所以，由 main.c 转换 main.s 时，<strong><u>你并不清楚 main.s 中的内存布局</u></strong> 。所以，这个想法也被否定啦。因此，我们使用引导文件 guide.s 来引导(guide)程序进入内核。</p><blockquote><p>其实，guide.s 也是可以省略的，我们只需要把 kernel_main 的名字改为 _start ，这样编译器就能识别，并将其作为程序入口。</p></blockquote><h3 id="font-color-red-编译链接解析-font"><font color='red'>编译链接解析</font></h3><p>方案确定了，那么这个引导过程是如何进行的呢？首先，我们将 main.c 和 guide.s 编译为可重定位文件并链接，具体命令见以下 makefile(简化后)：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BUILD= ./build</span><br><span class="line">SRC=./src</span><br><span class="line"></span><br><span class="line">CFLAGS:= -m32           <span class="comment"># 32 位的程序</span></span><br><span class="line">CFLAGS+= -masm=intel    <span class="comment"># 采用intel汇编语法</span></span><br><span class="line">CFLAGS+= -fno-builtin   <span class="comment"># 不需要 gcc 内置函数</span></span><br><span class="line">CFLAGS+= -nostdinc      <span class="comment"># 不需要标准头文件</span></span><br><span class="line">CFLAGS+= -fno-pic       <span class="comment"># 不需要位置无关的代码  position independent code</span></span><br><span class="line">CFLAGS+= -fno-pie       <span class="comment"># 不需要位置无关的可执行程序 position independent executable</span></span><br><span class="line">CFLAGS+= -nostdlib      <span class="comment"># 不需要标准库</span></span><br><span class="line">CFLAGS+= -fno-stack-protector  <span class="comment"># 不需要栈保护</span></span><br><span class="line">CFLAGS:=<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/pure_kernel.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">objcopy -O binary <span class="variable">$(BUILD)</span>/kernel.bin <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/guide.o <span class="variable">$(BUILD)</span>/main.o</span><br><span class="line">ld -m elf_i386 <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext 0x00001500</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/main.o: ./kernel/main.c</span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> -g -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/guide.o: <span class="variable">$(SRC)</span>/guide.s</span><br><span class="line">nasm -f elf32 -g <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li><p>第 24~25 行，将 guide.s 编译为 guide.o(可重定位文件) 。注意编译选项：</p><ul><li><code>-f</code> ：大家对这个应该很熟悉了吧，即指定文件输出格式。这里的输出格式为 <code>elf32</code> ，<strong>目的是待会要和 gcc 编译的 elf 格式的目标文件链接，所以格式必须相同</strong> 。</li><li><code>-g</code> ：添加调试信息。<strong><font color='orange'>这点对我们后面调试内核至关重要</font></strong> ！如果你编程能力极强，完全不需要调试，一眼就能看出错误(手动狗头)，那可以忽略该选项。</li><li><code>-o</code> ：不必多说，指定输出文件的名称。</li></ul></li><li><p>第 21~22 行，将 main.c 编译为 main.o(可重定位文件) 。注意编译选项：</p><ul><li><code>$(CFLAGS)</code> ：上面一大堆的 gcc 配置，<strong>这非常重要</strong> ！这是在指示 gcc 不要生成其他无关的东西，我只要 main.c 中的原生汇编代码，别瞎搞。因为一般 .c 文件编译成 .o 文件后都会增加大量描述信息和其他库代码，现在我们不需要这个。</li><li><code>-g</code> ：和之前一样，添加调试信息，用于内核调试。</li><li><code>-c</code> ：只生成可重定位文件。如果不加该选项，会直接生成可执行程序。</li><li><code>-o</code> ：指定输出文件的名称。</li></ul></li><li><p>第 17~18 行，链接 guide.o 和 main.o 。注意链接选项：</p><ul><li><p><code>-m</code> ：指定输出格式为 elf_i386 。</p></li><li><p><code>-Ttext</code> ：指示代码的起始地址。也就是说，你将内核加载到哪个地方，选项后就跟哪个地址；由于 loader.inc 中的 <code>KERNEL_ADDR</code> 为 0x1500，所以这里也为 0x1500。<strong><font color='red'>这个选项的作用和 vstart 完全相同</font></strong> ！所以基础可不能落下，不明白 vstart 的朋友请回 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>。</p><blockquote><p><strong><font color='gree'>由于我们已经开启了分页，所以按理来说指定起始地址时也必须指定虚拟地址</font></strong> ！但是，还记得之前我们已经将第 0 号页表的地址同时写入了第 0 号和第 768 号目录项中吗？所以 <strong>目前</strong> 这里填 0x1500 或 0xc0001500 都没有问题。目前没有问题？以后就有问题啦？是的，未来我们会回到此处并解析这个问题。</p></blockquote></li></ul></li><li><p>第 14~15 行，将 kernel.bin 中最原生的代码段和数据段抠出来，放入 pure_kernel.bin 中。</p><blockquote><p>现在的 kernel.bin 是 ELF 格式，其中含有大量的描述信息（程序头，节头等）和调试信息，而这些是 CPU 看不懂的，不能直接把该文件交给 CPU 运行。所以使用 objcopy 命令，只将其中的代码段和数据段抠出来，并整理到 pure_kernel.bin 中，这才是 CPU 能够运行的文件。关于 objcopy 可参考<a href="https://www.jianshu.com/p/beef56fec4ba">objcopy命令</a> 。</p></blockquote><ul><li><code>-O binary</code> ：指定输入目标为二进制文件。</li></ul></li></ul><blockquote><p>说实话，这些配置是很难找的，至少整个中文网上都是找不到的，即使找到相关介绍，你也不知道怎么去使用。此处的配置由子牙老师提供，笔者在此表示感谢，这至少让我们省了一个月的精力。</p></blockquote><p>说了这么多，大家有没有对这个引导过程产生一点感觉？好吧，挑明了讲，<strong><font color='red'>由于 <code>_start</code> 是默认的程序入口地址（这点已在本节前置文章中讲过），所以可以料到，objcopy 后，pure_kernel.bin 文件的开头就是 <code>guide.s</code> 中 <code>_start</code> 标号处的指令</font></strong> ，即 <code>call kernel_main</code> 。又因为我们指定了代码的起始地址（-Ttext 0x1500），所以 <code>call kernel_main</code> 指令的地址就为 0x1500 。这样，当我们把内核加载到内存 0x1500 后，就可以由 loader 中的最后一条指令 <code>call SELECTOR_CODE:KERNEL_ADDR</code> 跳转到 0x1500 处，然后调用内核。</p><p>你不信 pure_kernel.bin 文件的开头是指令 <code>call kernel_main</code> ？那我们就看看 pure_kernel.bin 长什么样：<img src="/2022/img/image-20221117002754476.png" alt=""><br>看见开头的 <code>E8 02</code> 没？这就是近转移指令 <code>call kernel_main</code> 。这下信了吧，哈哈。</p><h3 id="font-color-red-其他说明-font"><font color='red'>其他说明</font></h3><p><strong><mark class="hl-label blue">count参数</mark> </strong><br>这是 loader.inc 文件：<br><img src="/2022/img/image-20221117092239137.png" alt="loader.inc"><br>以下是 makefile 中写入硬盘的部分：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">./$(DISK):<span class="variable">$(BUILD)</span>/mbr.bin <span class="variable">$(BUILD)</span>/loader.bin <span class="variable">$(BUILD)</span>/pure_kernel.bin</span></span><br><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat <span class="variable">$@</span></span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/mbr.bin of=<span class="variable">$@</span> bs=512  conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/loader.bin of=<span class="variable">$@</span> bs=512  seek=2 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/pure_kernel.bin of=<span class="variable">$@</span> bs=512 seek=50 count=200 conv=notrunc</span><br></pre></td></tr></table></figure><p>看最后一行，seek=50 表示跳过 50 个扇区，从第 50 个扇区(起始为0)开始写，这对应了第四行 inc 配置。但为什么 <code>count=200</code> ？即一次写入 200 个扇区？这是因为后面我们的内核会越来越大，每次更新完内核需要向硬盘中同步，而我们可能会忘记修改 count，导致内核写入不全，所以一次性把 count 设置大一点。额，好吧，其实最方便的是直接不加 count，文件有多大就写多大，这不香嘛？</p><p><strong><mark class="hl-label blue">显存</mark> </strong><br>有人可能不太明白 kernel_main 函数中的第一行 0xb8000 后为啥加上 480，这是因为我们现在的显示模式是 25×80 的文本显示模式，每行 80 个字，25 行，所以一屏最多容纳 2000 字。一个字符占两个字节，第一字节是 ASCII 码，第二字节是字符属性(颜色,闪烁等)，所以如果我们要从第 4 行开始打印，则地址就应该为 <code>0xb8000+80×2×3</code> ，即 <code>0xb8000+480</code> 。</p><blockquote><p>0xb8000 是啥就不必多说了吧。。。</p></blockquote><p><strong><mark class="hl-label blue">char与short</mark> </strong><br>为了使大家更深刻地理解指针，笔者对 kernel_main() 做了如下修改：<br><img src="/2022/img/image-20221119165243020.png" style="zoom:67%;" /><br>第 11 行的 0x2 代表字符属性，黑底绿字。代码含义请读者自行思考。</p><h3 id="font-color-red-运行结果-font"><font color='red'>运行结果</font></h3><p><code>-Ttext 0x1500</code> 或 <code>-Ttext 0xc0001500</code> 都得到如下结果：</p><p><img src="/2022/img/image-20221117094137891.png" alt=""><br>到此为止，我们已经分别在实模式、保护模式、开启分页后、加载内核后打印了信息。</p><blockquote><p>运行方式：转到 makefile 下，点击顺序：clean --&gt; all --&gt; bochs</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析C和汇编混合编程/ABI规则</title>
      <link href="/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节说明：本节内容与编译和链接相关，该部分内容繁杂，不是一篇博客就能说明的，且本文仅为后续文章<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核</a>作铺垫，关于这方面详细的内容请阅读《装载，链接与库》。如有错误，请在评论区提出，谢谢。</p><p>本文前置内容：<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a><br>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">加载内核-代码详解</a></p></blockquote><h3 id="font-color-red-C和汇编相互调用-font"><font color='red'>C和汇编相互调用</font></h3><p><strong><mark class="hl-label blue">编写源文件</mark> </strong><br>给出如下两个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件说明：cprint.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">asm_print</span><span class="params">(<span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c_print</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len++]);</span><br><span class="line">asm_print(str, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：asm_print.s</span><br><span class="line">[bits 32]</span><br><span class="line">section .data</span><br><span class="line">str: db &quot;asm_print say hi youyifeng!&quot;,0xa,0x00 </span><br><span class="line">;0x0a是换行符，0x00是字符串结束符，不加的话会把后面字符陆续输出，直到遇到空白字符</span><br><span class="line">;while循环遍历字符串统计字符串长度，遇空白字符结束。汇编不支持NULL</span><br><span class="line">str_len equ $-str</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">extern c_print       ;外部申明引用c_print</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">push str_len</span><br><span class="line">push str</span><br><span class="line"></span><br><span class="line">call c_print</span><br><span class="line">add esp,8        ;cdecl,调用者清理栈空间(外平栈)</span><br><span class="line">mov eax,1        ;调用1号中断,告诉Linux咋们要正常退出</span><br><span class="line">int 0x80</span><br><span class="line"></span><br><span class="line">global asm_print ;定义函数asm_print</span><br><span class="line">asm_print:</span><br><span class="line">push ebp         ;保存原函数栈底</span><br><span class="line">mov ebp,esp      ;ebp指向当前栈帧的栈底</span><br><span class="line">mov eax,4        ;调用4号子功能，需要传入三个参数:ebx,ecx,edx</span><br><span class="line">mov ebx,1        ;此参数为文件描述符，固定3个，0表示标准输入，1表示标准输出，2表示标准错误输出</span><br><span class="line">mov ecx,[ebp+8]  ;长度参数len </span><br><span class="line">mov edx,[ebp+12] ;字符串首地址参数  char *str</span><br><span class="line">int 0x80         ;功能号填写完毕，发起0x80中断</span><br><span class="line">pop ebp          ;恢复ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>让我们先聚焦 cprint.c 文件：</p><ol><li>第 2 行，extern 声明，引入函数 asm_print 。因为在 c_print 函数中调用了 asm_print 函数，而在当前文件中并没有 asm_print 的定义，所以必须进行声明，<strong><font color='orange'>告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后链接时会把定义补上</font></strong> 。这里可以省略 extern 关键字，直接声明函数。</li><li>第 2 行，函数原型给出了参数类型：asm_print 有俩参数，一个是 char* 类型，一个是 int 类型。这里声明了两个参数，和 asm_print.s 中的第14,15 行的两个 push 恰能对应；但看到参数类型时，我们不禁大呼一句卧槽，asm_print 是用汇编写的啊，哪来的类型？哈哈，是的，<strong>汇编语言没有类型之分，只有操作数大小之分</strong> 。那这里为什么可以指定参数类型 char* 和 int 呢？其实，<strong><font color='red'>数据类型，只是在指导编译器如何去解释这个数据以及如何控制它的行为</font></strong> 。比如你声明 <code>char* ptr</code> ，那么编译器就认为 ptr 中装的是地址，且将 ptr 的步长指定为 1(也就是自增自减时以1为单位)；如果你声明 <code>int* ptr</code> ，那么编译器就认为 ptr 中装的是地址，且将 ptr 的步长指定为 4 。好了，由于这里涉及编译原理，笔者暂不熟悉，就不多做解释，以免误导读者。</li></ol><p>另外需要注意的是，<strong><font color='red'>C 语言不管函数参数类型是 char 还是 short 或者 int，压参时每个参数都会压入 4 字节</font></strong> ！这点在我们后面编写供 C 语言调用的汇编函数时有重要作用。演示如下：<br><img src="/2022/img/image-20221125152130185.png" style="zoom:67%;" /></p><p>其汇编代码如下：<br><img src="/2022/img/image-20221125152228134.png" style="zoom:80%;" /></p><p>看，参数 b 先被放入 eax 中，再压入参数，则压入 4 字节；对于 <code>push 3</code> ，32 位下压立即数时，也是压入 4 字节。我们再来看看编译器如何从栈中去参数：<br><img src="/2022/img/image-20221125153009512.png" alt=""><br>注意第 1 行，使用了 word 修饰，因为 b 的类型本就是 short，只占两个字节。movsx 是带符号扩展传送指令，不在此阐述。</p><p>再来看 asm_print.s ：</p><ol><li><p>第 2 行，<code>[bits 32]</code> 声明以下环境为 32 位，之前有提到过，见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a> 。</p></li><li><p>第 10 行，引入 c_print ，与前面提到的不同，此处 extern 关键字不能省略。</p></li><li><p>第 11 行，<code>global</code> 的作用是导出某符号，使其他文件可以发现该符号。<code>_start</code> 是默认的程序入口，这个咋们待会再详细讨论。</p></li><li><p>第 22 行，导出 asm_print ，这样在 cprint.c 中的 cprint() 函数才能调用 asm_print 。</p></li><li><p>第 14,15 行，将两个参数压栈，随后调用 c_print 。</p></li><li><p>第 18 行，由于 c_print() 是由 C 语言编写的函数，所以默认的调用约定是 cdecl，所以必须由调用者手动平栈。对此陌生的朋友可参考<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>。</p><blockquote><p>这里就体现出调用约定的重要性了。如果 c_print() 采用 stdcall（只需要在定义时在函数名前声明 __stdcall），则是被调函数平栈。如果不清楚调用约定，则会导致最终堆栈不平衡，引发程序错误。</p></blockquote></li><li><p>第 24,25 行，也请参见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a> 。</p></li><li><p>第 30 行，0x80 是 Linux 下系统调用的统一入口，具体的子功能在 eax 中指定。后续会详述该部分内容。</p></li></ol><p><strong>简单总结</strong> ：</p><ul><li>在汇编中导出符号供外部引用，使用关键字 <code>glbal</code> ；引用外部文件的符号使用 <code>extern</code> 。</li><li>在 C 文件中只要将符号定义为全局就能供外部引用，无需额外关键字；引用外部符号时用 <code>extern</code> 声明。</li></ul><p><strong><mark class="hl-label blue">编译</mark> </strong><br>分别编译上述两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c cprint.c -o cprint.o</span><br><span class="line">nasm -f elf32 asm_print.s -o asm_print.o</span><br></pre></td></tr></table></figure><p><code>-m32</code> 与 <code>-f elf32</code> 是在指定编译器将源文件编译为 32 位的 ELF 文件格式。</p><p><strong><mark class="hl-label blue">链接</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 asm_print.o cprint.o -o print</span><br></pre></td></tr></table></figure><p><code>-m elf_i386</code> 同样是在指定指令架构。最终得到可执行文件 print 。</p><p><strong><mark class="hl-label blue">运行</mark> </strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./print</span><br><span class="line">asm_print say hi youyifeng!</span><br></pre></td></tr></table></figure><h3 id="font-color-red-初识ELF文件-font"><font color='red'>初识ELF文件</font></h3><p>在以上过程中，我们链接 asm_print.o 和 cprint.o 这两个文件后便能直接运行该程序。问题是，计算机是怎么知道程序的入口在哪的呢？由于程序内的地址是在链接时就编排好了（重定位），所以链接阶段就必须确定好程序入口。<strong><font color='orange'>于是链接器规定，默认只把名为 _start 的函数(或标号)作为程序的入口符号</font></strong>。如果要另行指定入口，则需要使用 <code>-e</code> 参数来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将入口符号指定为main</span></span><br><span class="line">ld -m -e main elf_i386 asm_print.o cprint.o -o <span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>那么问题又来了，入口符号确定了，计算机又从哪获得该符号对应的地址呢？这就不得不提到 ELF 文件格式了。其实，我们早在本系列的前期文章就已经接触到了 ELF 的雏形，即<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。<strong>ELF 文件格式同程序加载器一样，都是调用程序和被调程序的一种协议，而协议的意义在于通用性</strong> 。也就是说，只要遵守协议，那么一个调用方就能调用多种用户程序，比如，调用方一般都为操作系统，而操作系统能调用无数种类，不同厂商开发的应用程序。<strong>Linux 的可执行程序为 ELF 格式，ELF 格式采用文件头 header+文件体 body 的形式</strong> 。文件头用来描述程序的布局，包括入口，代码段，程序段的地址等。有了文件头的好处是调用方式变得通用，坏处是这些文件不再是纯粹的二进制可执行文件了，CPU 不能直接运行。<strong>所以，将 ELF 可执行文件读入内存后，必须先解析文件头，找到程序的入口地址，然后直接跳转到入口处，CPU 才能够运行该程序</strong> 。好了，ELF 的知识较繁杂，就不在此处展开了，想了解详情的朋友可参阅《装载，链接与库》。</p><p>接下来，就进入激动人心的时刻了：<a href="https://jyx-fyh.github.io/2022/11/16/%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">载入内核</a> 。</p><h3 id="font-color-red-ABI-规则-font"><font color='red'>ABI 规则</font></h3><p>ABI（Application Binary Interface，应用程序二进制接口），描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的接口。ABI涵盖了各种细节，如：</p><ul><li>数据类型的大小、布局和对齐；</li><li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数等。</li><li>系统调用的编码和一个应用如何向操作系统进行系统调用；</li><li>以及在一个完整的操作系统ABI中，目标文件的格式、程序库等等。</li></ul><p>这里我们不展开，只强调 ABI 中这样一个规定：位于 Intel386 体系上的所有<u>通用</u>寄存器都具有全局性，因此在函数调用时，所有通用寄存器对被调函数和主调函数都可见。但是，规定要求 epb、ebx、esi、edi、esp 这五个寄存器归主调函数使用，其他寄存器随便供被调函数使用。换句话说，<strong><u><font color='gree'>不管被调函数中是否使用了这五个寄存器，当被调函数返回时，这几个寄存器都不应该被改变</font></u></strong> 。这实际上是属于编译原理的范畴，这些规定会被编译器严格遵守，因此，当我们使用 C 语言编写函数时，无需关心这些东西。但在 C 和汇编混合编程时，就需要留点心了：当 C 函数调用我们自己写的汇编函数时，需要保证调用前后这五个寄存器的值不变。其实，我们之前是直接通过 pushad 和 popad 来保存主调函数现场的，但现在咋们就只需要保证这五个寄存器不变就好啦！另外：</p><ol><li><strong>eax 用来储存返回值</strong> 。</li><li><strong>esp 一般无需压栈保存，它是通过内外平栈（见<a href="https://jyx-fyh.github.io/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/">函数调用约定</a>）来保证堆栈平衡（即调用前后 esp 不变）的</strong> 。下面举例为证：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b)                   </span><br><span class="line">&#123;</span><br><span class="line">00FB1750  push        ebp  </span><br><span class="line">00FB1751  mov         ebp,esp  </span><br><span class="line">00FB1753  sub         esp,0C0h  </span><br><span class="line">00FB1759  push        ebx  </span><br><span class="line">00FB175A  push        esi  </span><br><span class="line">00FB175B  push        edi  </span><br><span class="line">00FB175C  mov         edi,ebp  </span><br><span class="line">00FB175E  xor         ecx,ecx  </span><br><span class="line">00FB1760  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FB1765  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FB1767  mov         ecx,offset _206B94B3_源@c (0FBC000h)  </span><br><span class="line">00FB176C  call        @__CheckForDebuggerJustMyCode@4 (0FB130Ch)  </span><br><span class="line">return a + b;</span><br><span class="line">00FB1771  mov         eax,dword ptr [a]  ;[ebp+8]</span><br><span class="line">00FB1774  add         eax,dword ptr [b]  ;[ebp+0Ch]</span><br><span class="line">&#125;</span><br><span class="line">00FB1777  pop         edi  </span><br><span class="line">00FB1778  pop         esi  </span><br><span class="line">00FB1779  pop         ebx  </span><br><span class="line">00FB177A  add         esp,0C0h  </span><br><span class="line">00FB1780  cmp         ebp,esp  </span><br><span class="line">00FB1782  call        __RTC_CheckEsp (0FB1235h)  ;上行和本行，检查堆栈平衡(ebp==esp)</span><br><span class="line">00FB1787  mov         esp,ebp  </span><br><span class="line">00FB1789  pop         ebp  </span><br><span class="line">00FB178A  ret  </span><br></pre></td></tr></table></figure><p>看见第 3、6、7、8 行的压栈没？这就和上文很好地呼应了，不信你自己试试。</p><p>本文结束。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启分页-代码详解</title>
      <link href="/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>阅读<a href="">开启分页机制</a>是本节的前置要求。<br>本节代码对应分支 <code>open-page</code> 。</p></blockquote><p><strong><mark class="hl-label blue">boot.inc</mark> </strong><br>在进入保护模式的基础上，<code>boot.inc</code> 增添了如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;========页目录地址和页表起始地址===========</span><br><span class="line">PAGE_DIR_POS    equ  0x00100000            ;目录表起始位置为1MB处</span><br><span class="line">PAGE_TABLE_POS  equ  PAGE_DIR_POS + 4096   ;页表起始位置</span><br><span class="line">;===========页表相关属性===================</span><br><span class="line">PG_P     equ   1b</span><br><span class="line">PG_RW_R equ  00b</span><br><span class="line">PG_RW_W equ  10b</span><br><span class="line">PG_US_S equ  000b</span><br><span class="line">PG_US_U equ  100b</span><br></pre></td></tr></table></figure><ul><li>和 GDT 相同，<strong>页目录也可以放置在内存中的任何地方</strong> ，这里我们直接将其放在 <code>0x100000</code> 处。</li><li>为了使内存紧凑，这里让页表紧挨着页目录。注意，这不是必须的！页目录表大小为 4KB，所以页表地址在页目录地址的基础上加 4096 (0x1000)。</li></ul><p>以下为内存映像图：<br><img src="/2022/img/未命名绘图9.png" style="zoom:67%;" /></p><p><strong><mark class="hl-label blue">loader.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.s</span><br><span class="line">;%include &quot;boot.inc&quot;</span><br><span class="line">;%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段</span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06]</span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;GDT</span><br><span class="line">;第0描述符不可用</span><br><span class="line">    GDT_BASE        dd    0x00000000</span><br><span class="line">                    dd    0x00000000</span><br><span class="line">;第1描述符CODE</span><br><span class="line">    DESC_CODE       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_CODE_HIGH4</span><br><span class="line">;第2描述符DATA</span><br><span class="line">    DESC_DATA       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_DATA_HIGH4</span><br><span class="line">;第3描述符VIDEO</span><br><span class="line">    DESC_VIDEO      dd    0x80000007</span><br><span class="line">                    dd    DESC_VIDEO_HIGH4</span><br><span class="line"></span><br><span class="line">    GDT_SIZE        equ   $ - GDT_BASE</span><br><span class="line">    GDT_LIMIT       equ   GDT_SIZE - 1</span><br><span class="line">;GDT指针</span><br><span class="line">    gdt_ptr         dw    GDT_LIMIT</span><br><span class="line">                    dd    GDT_BASE</span><br><span class="line"></span><br><span class="line">    SELECTOR_CODE   equ   ((DESC_CODE - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_DATA   equ   ((DESC_DATA - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_VIDEO  equ   ((DESC_VIDEO- GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">    loader_msg      db    &#x27;r&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;a&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;-&#x27;,11000010b</span><br><span class="line">                    db    &#x27;m&#x27;,11000010b,&#x27;o&#x27;,11000010b,&#x27;d&#x27;,11000010b,&#x27;e&#x27;,11000010b</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br><span class="line">start: ;程序入口</span><br><span class="line">mov ax,0             ;转移到loader代码后,如果不想立即进入保护模式</span><br><span class="line">mov ds,ax            ;则最好先将各段寄存器清0</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">print:</span><br><span class="line">mov ax,0xb800        ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,loader_msg    ;ds:si</span><br><span class="line">mov di,0             ;es:di</span><br><span class="line">mov cx,18            ;9个字符,占18字节</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">;========================================================</span><br><span class="line">;1.打开A20</span><br><span class="line">;2.加载GDT</span><br><span class="line">;3.置PE=1</span><br><span class="line">prepare:</span><br><span class="line">;关中断</span><br><span class="line">    cli</span><br><span class="line">;打开A20</span><br><span class="line">    in   al,0x92</span><br><span class="line">    or   al,0000_0010B</span><br><span class="line">    out  0x92,al</span><br><span class="line">;加载GDT</span><br><span class="line">    mov  ax,0</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line">;CR0的第0位置1</span><br><span class="line">    mov  eax,cr0</span><br><span class="line">    or   eax,0x0000_0001</span><br><span class="line">    mov  cr0,eax</span><br><span class="line">;此后进入保护模式</span><br><span class="line">    jmp  dword SELECTOR_CODE:p_mode_start ;刷新流水线,装载CODE选择子</span><br><span class="line">;======================================================</span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">    mov ax,SELECTOR_DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov esp,BASE_ADDR       ;可以找其他合适的地方作为栈顶，这里使用BASE_ADDR</span><br><span class="line">    mov ax,SELECTOR_VIDEO</span><br><span class="line">    mov gs,ax</span><br><span class="line"></span><br><span class="line">    mov byte [gs:160],&#x27;p&#x27;   ;在保护模式下打印</span><br><span class="line">    mov byte [gs:161],11000010b</span><br><span class="line">    </span><br><span class="line">call setup_page</span><br><span class="line">sgdt [gdt_ptr]          ;store gdt,将GDTR中的信息存到标号gdt_ptr处</span><br><span class="line">mov  ebx,[gdt_ptr+2]    ;此时ebx中为GDT的基地址</span><br><span class="line"></span><br><span class="line">;显存段是第3个段描述符，段描述符8字节,24~31段基址在高4字节</span><br><span class="line">or dword [ebx+8*3+4],0xc0000000   ;c刚好对应高字节</span><br><span class="line"></span><br><span class="line">;将gdt的基址加上0xc0000000使其位于内核镜像所在的高地址</span><br><span class="line">add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">add esp, 0xc0000000     ;将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">mov eax, PAGE_DIR_POS   ;把页目录地址赋给cr3</span><br><span class="line">mov cr3, eax</span><br><span class="line"></span><br><span class="line">mov eax, cr0            ;打开cr0的pg位(第31位)</span><br><span class="line">or eax, 0x80000000</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">lgdt [gdt_ptr]          ; 重新加载</span><br><span class="line"></span><br><span class="line">mov byte [gs:320], &#x27;V&#x27;  ;视频段段基址已经被更新</span><br><span class="line">mov byte [gs:322], &#x27;i&#x27;     </span><br><span class="line">mov byte [gs:324], &#x27;r&#x27;     </span><br><span class="line">mov byte [gs:326], &#x27;t&#x27;     </span><br><span class="line">mov byte [gs:328], &#x27;u&#x27;     </span><br><span class="line">mov byte [gs:330], &#x27;a&#x27;     </span><br><span class="line">mov byte [gs:332], &#x27;l&#x27;     </span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;=======================================================</span><br><span class="line">;将页目录要存放的内存清零,每次清空4bytes,清1024次,共4KB</span><br><span class="line">setup_page:</span><br><span class="line">mov ecx,1024</span><br><span class="line">mov esi,0</span><br><span class="line">.clear:</span><br><span class="line">mov dword [PAGE_DIR_POS+esi],0</span><br><span class="line">add esi,4</span><br><span class="line">loop .clear</span><br><span class="line"></span><br><span class="line">;创建页目录项,向页目录项中安装各个页表的物理地址</span><br><span class="line">.create_PDE:</span><br><span class="line">mov eax,PAGE_TABLE_POS       ;此时eax为第0个页表的物理位置</span><br><span class="line">mov ebx,eax                  ;备用</span><br><span class="line"></span><br><span class="line">;下面在第0和0xc00目录项中安装第0个页表的地址，一个页表可表示4MB内存,</span><br><span class="line">;这样虚拟地址中高1GB空间的起始4MB和低3GB空间的起始4MB都指向相同的页表。详见博客分析</span><br><span class="line">;这是在为内核映射做准备。</span><br><span class="line">or  eax, PG_US_U | PG_RW_W | PG_P        ;写入目录项属性,RW,PG位和US都为1</span><br><span class="line">mov [PAGE_DIR_POS + 0*4], eax            ;安装第0个目录项,对应虚拟地址0~4MB</span><br><span class="line">mov [PAGE_DIR_POS + 768*4], eax          ;安装第768个目录项,对应虚拟地址3GB~3GB+4MB</span><br><span class="line"></span><br><span class="line">mov eax, PAGE_DIR_POS</span><br><span class="line">or  eax, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">mov [PAGE_DIR_POS + 1023*4], eax ;使最后一个目录项(第1023项)指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建第0页表的部分表项(PTE)</span><br><span class="line">mov ecx,256                      ;1M低端内存/每页大小4KB=256</span><br><span class="line">mov esi,0</span><br><span class="line">mov edx,PG_US_U | PG_RW_W | PG_P ;属性为7,US=1,RW=1,P=1;高12~31位的物理页地址为0,所以直接mov</span><br><span class="line">.create_PTE:</span><br><span class="line">mov [PAGE_TABLE_POS+4*esi],edx</span><br><span class="line">add edx,4096                     ;一个页表项一个物理页框,包含的物理空间为4KB</span><br><span class="line">inc esi</span><br><span class="line">loop .create_PTE                 </span><br><span class="line"></span><br><span class="line">;创建虚拟地址高1GB空间其他对应的目录项</span><br><span class="line">mov eax,PAGE_TABLE_POS+4096*1    ;此时eax为第1个页表的物理位置</span><br><span class="line">or  eax,PG_US_U | PG_RW_W | PG_P ;页目录项的属性US,RW和P位都为1</span><br><span class="line">mov ecx, 254                     ;范围为第769~1022的所有目录项数量,第1023目录项已经安装</span><br><span class="line">mov esi, 769                     ;从第769目录项开始</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">mov ebx,PAGE_DIR_POS</span><br><span class="line">mov [ebx+esi*4], eax</span><br><span class="line">inc esi</span><br><span class="line">add eax, 4096</span><br><span class="line">loop .create_kernel_pde</span><br><span class="line">ret</span><br><span class="line">;========================================================</span><br><span class="line">program_end  equ  $-BASE_ADDR</span><br></pre></td></tr></table></figure><p>首先，务必先理清楚<u>页目录表</u>、<u>页目录项</u>、<u>页表</u>、<u>页表项</u>的关系，否则上面的代码将会看得你一头雾水！另外再次强调，页目录项和页表项中装载的是物理地址，这点很重要。为方便对照，将<a href="">开启分页机制</a>中的页目录项/页表项的结构图搬过来：</p><img src="/2022/img/IMG_0522(20221113-175513).PNG" style="zoom: 67%;" /><p>让我们先聚焦 <code>setup_page</code> ，从第 123 行代码开始。</p><ol><li><p>第 137 行，<code>PG_US_U | PG_RW_W | PG_P</code> ，这三位为 1，其他位都为 0 。</p></li><li><p>第 140 行，为什么要将第 0 号页表的地址装载到第 0 号目录项中？原因是：分页机制是在 loader 中开启的，而 loader 本身已经位于 1MB 物理内存中，所以我们必须保证开启分页前后 <code>CS : EIP</code> 都正确指向 1MB 内的相关 loader 代码，<strong><font color='orange'>即必须保证之前段机制下的线性地址和分页后的虚拟地址所对应的物理地址一致</font></strong> 。<strong>也就是说虚拟地址下的 1MB 内存与真实物理地址下的 1MB 内存是完全一一对应的</strong> 。还是举个例子：开启分页前一瞬间 <code>CS:IP=0x0000:1002</code> 即 <code>0x00001002</code>，<u>这是真实的物理地址</u>；开启分页后执行的一条指令的地址为 <code>CS:IP=0x0000:1004</code> ，由于已经开启分页，这就成了虚拟地址，即 <code>0x00001004</code> 。按照<a href="">分页机制</a>中的计算方法，这个虚拟地址将映射到第 0 号页目录，因为其中装载的是第 0 号页表的地址，进而到第 0 号页表，虚拟地址中的 <code>1</code> 则将其映射到第 1 号页表项，对应的物理页框为 <code>0x1000</code> (<u>后续147~155行代码会将物理页框写入页表项</u>)，最后加上偏移地址 <code>0x04</code> ，得到物理地址 <code>0x00001004</code> 。可见，开启分页前后物理地址和虚拟地址是相同的。</p></li><li><p>第 141 行，为什么将第 0 号页表的地址装载到第 768 号目录项中？原因是：<strong>第 768 号目录项对应的虚拟地址是 3GB~3GB+4MB，我们的内核镜像就在此处。实际内核位于低 1MB 的内存中，现在将其映射到内存 3GB 处，所以必须把第 0 号页表的地址装载到第 768 号目录项中</strong> 。</p><blockquote><p><strong>必须说明的是，第 2, 3点之所以能够顺利将虚拟地址下的 1MB 内存与真实物理地址下的 1MB 内存一一映射，其基础是 147~155 代码，这段代码将虚拟 1MB 与物理 1MB 地址空间一一对应。</strong></p></blockquote></li><li><p>第 145 行，为什么往最后一个(1023)目录项中安装目录表自身的地址？<strong><font color='orange'>这是为了在开启分页后，通过虚拟地址找到页表，这样才能动态操作页表</font></strong> 。二级页表是一种动态的数据结构，要申请一大块内存时可能会添加页表项，释放一块内存时可能会删减页表项。而页表和页目录都是存在于内存中的，要对其进行删减就必须知道它的地址，问题是现在已经进入了虚拟地址空间，我们该如何访问它呢？通过往最后一个目录项中安装目录表自身的地址可以迂回实现。当虚拟地址为 <code>0xfffff000</code> ，即高 10 位和中间 10 位都为 <code>0x3ff(1023)</code> 时，通过高 10 位访问到第 1023 目录项，取得其中的地址；因为该地址为目录表自身地址，所以通过中间 10 位进行索引时会以该地址为基准， <strong>也就是说，第一次索引和第二次索引都是在目录表中进行的（原本第一次索引是在目录表中，第二次索引在页表中）；第二次索引后，取得的地址仍为目录表自身起始地址，<u><font color='gree'>而 CPU 会将其当作物理页框地址来使用</font></u>；最后 12 位页内偏移地址置为 0，<font color='orange'>则最终虚拟地址就被映射成了目录表起始地址</font></strong> 。<strong>如果想访问目录表项，将 <code>0xfffff000</code> 改为 <code>0xfffffxxx</code> 即可，其中 <code>xxx</code> 为 <code>索引值*4</code> ，原因不再赘述。如果想访问页表项，则高 10 位为 <code>0x3ff</code> ，中间 10 位为索引值，此时得到相应页表的起始地址，CPU 将其作为物理页框地址，加上最后 12 位，为 <code>索引值*4</code> ，最终映射成某页表项的地址</strong> 。此方式的核心在于：CPU 很笨，通过目录项原本应该取得页表的地址，然后访问该页表；然而此方式通过目录项取得的却仍是目录表的起始地址，但 CPU 可不知道这个是目录表的地址，它仍将其看作页表地址，并用中间 10 位继续索引。用代码描述可能更清晰：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22) <span class="comment">//取得addr对应的页目录表索引,其实直接addr&gt;&gt;22也是可以的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) <span class="comment">//取得addr对应的页表索引</span></span></span><br><span class="line"><span class="type">uint32_t</span>* pte = (<span class="type">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line"><span class="comment">//此时pte即为虚拟地址vaddr对应的PTE的地址</span></span><br><span class="line"><span class="type">uint32_t</span>* pde = (<span class="type">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line"><span class="comment">//此时pde即为虚拟地址vaddr对应的PDE的地址</span></span><br></pre></td></tr></table></figure></li><li><p>第 148 行，注意这里只填充了一张页表的四分之一，一张页表可映射 4MB 内存，但我们的内核当前只有不到 1MB，所以只映射了 1MB 的空间。</p></li><li><p>第 157~168 行，物理内核不是只映射在高 1GB 虚拟空间的最低 1MB 处吗？为什么还要安装高 1GB 虚拟地址对应的其他目录项？<strong><font color='gree'>这是为了实现内核完全共享</font></strong> 。所有用户进程的高 1GB 虚拟空间都会被映射到物理内核处，<strong>所以在为用户进程创建页表时，我们必须把内核页目录中第 768~1022 目录项复制到用户进程页目录的相同位置处（第 1023 目录项指向用户目录表的起始位置）</strong> 。如果不这样的话，进程陷入内核时，内核可能因为申请大量内存而新增页表，此时就必须手动将新增的内核页表同步到其他进程的页目录中，否则就只能部分共享。手动同步是很麻烦的，最简单的方式就是提前把高 1GB 的目录项定下来，未来创建用户进程页目录时直接复制过去。<strong>这是实现内核共享的关键！</strong></p><blockquote><p>读者可能还是对这点存有疑惑，不要慌，学到<a href="https://jyx-fyh.github.io/2022/12/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理基础篇</a>后，你将恍然大悟。</p></blockquote></li></ol><p>以上是对 <code>setup_page</code> 代码的解析，下面我们聚焦 91~199 行代码。</p><ol><li>第 91 行，<code>sgdt</code> 即 <code>store gdt</code> ，作用是将 GDTR 中的基地址和边界重新倒(dump)在指定地址处。因为无法直接在 GDTR 中修改，所以要先倒出来，在内存中修改，然后再使用 <code>lgdt</code> 重新加载进去。此处 <code>sgdt</code> 似乎有点鸡肋，因为 <code>gdt_ptr</code> 还在内核中，没有被覆盖。</li><li>第 95 行，将显存段的基地址放在了 3GB 处。打印功能涉及硬件(显存)，所以是在内核中实现的，用户要打印须陷入内核，然后再调用打印功能，<strong>肯定不能让用户直接控制显存</strong> 。因此显存段的段基址要改为 3GB 以上。</li><li>第 98 行，将 GDT 也移入内核空间，将其基地址加上 3GB 。<strong>这不是必须的，如果分页后不重复加载 GDT，也可以不修改 GDT 的基址</strong> 。</li><li>第 100 行，将栈指针也指向内核空间，这点原因暂不清楚，后续补充。</li></ol><p>最终效果如下：<br><img src="/2022/img/image-20221115112336872.png" alt=""></p><p>另外，也可以通过 C 语言来设置页表，读者可自行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启分页机制</title>
      <link href="/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文参考：<a href="https://www.zhihu.com/question/436136392">为什么要分页</a> ，《操作系统真相还原》《x86汇编：从实模式到保护模式》《操作系统之哲学原理》《装载、链接与库》<br>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a> 。</p></blockquote><h3 id="font-color-red-为什么分页？-font"><font color='red'>为什么分页？</font></h3><p>分页机制 <strong>最早</strong> 是为了解决内存碎片利用的问题。举例如下：<br><img src="/2022/img/IMG_0523(20221115-141809).PNG" style="zoom:67%;" /><br>在图 1 中，内存被完美利用，还多出 15MB 可用内存。来到图 2，进程 B 运行完毕，从内存中移除，则原来的 20MB 内存变为空闲，则现在一共有 35MB 可用内存。而后进程 D 想要运行，但其需要的内存大小为 20MB+3KB，没有空闲内存段装得下。没办法，即使一共有 35MB 可用内存，<strong>由于必须要连续的空闲内存</strong> ，进程 D 就只有等待进程 A 或 进程 C 加载完毕，腾出空间后才能载入内存运行。</p><p>显然，等待是不能等待的，谁知道这些进程什么时候运行完呢。细心的你可能会发现，<strong>以上问题并不在于内存不够，而在于无法利用“断开”的内存</strong> 。当运行许多进程后，可用内存就会参差不齐，形成大量内存碎片，虽然总可用内存数量很客观，但却完全无法利用。为了解决这个问题，便提出了分页的概念。<strong><font color='gree'>分页和虚拟内存是两个密不可分的概念</font></strong> 。接下来让我们看看这两个概念是如何解决以上问题的。<br>聚焦问题本质，<strong>其根本在于程序必须连续地占用内存</strong> ，你不能将某个程序的一部分代码放在 20MB 处，另一部分放在 15MB 处。那怎么办呢？接下来便是 <strong>抽象</strong> 大展身手的时候了（抽象贯穿了整个计算机体系）：<strong><font color='orange'>我们让程序运行在虚拟地址空间中，使它以为自己运行在连续的线性地址上，而幕后我们将虚拟地址空间映射到实际物理内存中，实际上它仍运行在物理内存中(这有点废话)</font></strong> ，这样就欺骗了程序，目的达成。哈哈，可能你还有点迷糊，那么请看下图：<br><img src="/2022/img/IMG_0524(20221115-150238).PNG" style="zoom: 67%;" /></p><p>通过这种方式，我们就能充分利用内存碎片了。而这只是引入分页机制最初的目的，现在它还具备以下几个重要功能：</p><ul><li><p><strong>控制内存访问权限</strong> 。</p></li><li><p><strong>方便内存和硬盘的交换</strong> 。</p><blockquote><p>开启分页后，将以页为单位进行内存和硬盘的交换。某一程序不常用的页会被清出内存，存入硬盘，这也增加了内存的利用率。</p></blockquote></li><li><p><strong>分页是平坦模型的基础</strong> 。</p><blockquote><p>32 位 4G 平坦内存模型下，段的意义不大；64 位模式下段已经完全失去意义。</p></blockquote></li></ul><p>这几个功能的具体实现后面我们将会说到。</p><h3 id="font-color-red-分页实现机制-font"><font color='red'>分页实现机制</font></h3><p>现在我们知道，开启分页后，程序都运行在虚拟地址空间中，而虚拟地址则被映射到物理内存。那么，总应该找个地方来存放这种映射关系吧？是的，存放这种映射关系的地方就是页表。</p><p><strong><mark class="hl-label blue">一级页表</mark> </strong><br>页的标准大小是 4KB，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span> 字节；当页数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 时，覆盖的内存空间就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 字节，即 4GB 。所以在一级页表模型中，一张页表有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 个页表项，每个页表项对应着一个页：<br><img src="/2022/img/IMG_0525(20221115-155044).PNG" style="zoom:67%;" /></p><p><strong>页表也是存放在内存中的，页表项大小为 4 字节，所以这样一张页表的大小为 4MB</strong> 。现在问题是，线性地址(开启分页后，也叫虚拟地址)如何转化为物理地址呢？很简单，<u>将 32 位线性地址的高 20 位作为页表索引，用来寻找页表项；将低 12 位作为页内偏移</u>。比如虚拟地址为 <code>0x92f11f23</code> ，则 <code>0x92f11</code> 为索引，对应页表中第 <code>0x92f11</code> 个页表项，假设该页表项中装的 <strong><u>物理页框</u></strong> 为 <code>0x20001</code> ，那么该物理页框加上低 12 位 <code>0xf23</code> ，最终得到物理地址 <code>0x20001f23</code> 。这个计算过程由页部件自动实现。</p><blockquote><p>物理页框即为内存中某页的起始地址。<strong><font color='gree'>物理页框一定是 4K 的整数倍</font></strong> ，即最后 12 位一定为 0 (二进制下)。</p></blockquote><p><strong><mark class="hl-label blue">两级页表</mark> </strong><br>两级页表在一级页表的基础上增添了页目录表（ <strong><font color='red'>在两级页表结构中，页目录表称为一级页表，页表称为二级页表</font></strong> ）：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE10.png" alt=""><br>1024 个目录项对应 1024 张页表，每张页表有 1024 个页表项，每个页表项对应 4KB 的物理内存，即 <code>1024×1024×4KB=4GB</code> ，仍覆盖了 32 位下的整个内存空间。<strong><font color='orange'>二级页表下的映射方式为：将虚拟地址的高 10 位作为目录表索引，中间 10 位作为页表索引，低 12 位作为页内偏移</font></strong> 。比如虚拟地址 <code>0x1f25e9a2</code> ，其高 10 位为 124，即访问第 124 个目录项(起始为第0个目录项)，假设该目录项指向 A 页表；中间 10 位为 1136，则访问 A 页表中的第 1136 个页表项，假设该页表项中的物理页框为 <code>0xff120000</code> ；最后 12 位为 <code>0x9a2</code> ，作为页内偏移地址；故最终该虚拟地址映射到的物理地址为 <code>ff1209a2</code> 。</p><p><strong><mark class="hl-label blue">页表项和页目录项结构</mark> </strong><br><img src="/2022/img/IMG_0526(20221115-170651).PNG" style="zoom:80%;" /></p><ul><li><p>页目录项和页表项中的地址只有 31~12 共计 20 位，这是因为其中装载的都是物理页地址，而标准页大小为 4KB，故地址都是 4KB 的倍数，即低 12 为一定为 0，所以不再花多余空间记录。</p></li><li><p>标志位：</p><ul><li><p><strong>AVL</strong> ：软件/操作系统使用该位，CPU 不使用该位。</p></li><li><p><strong>G</strong> ：Global，全局位。表示当前页是否是全局的，而不是属于某一特定任务的。1 表示为全局页，0 则表示非全局页。该位 TLB 相关，详见文末。</p></li><li><p><strong>PAT</strong> ：页属性表支持位。PAT位使 CPU 能够支持不同页大小的分页管理。当 PAT=0 时，每一页的大小为 4KB；当 PAT=1 时，每一页的大小是 4MB，或是其它大小。该位只存在于页表项。</p></li><li><p><strong>D</strong> ：Dirty，脏页位。<strong>当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1 。<font color='orange'>此项仅对页表项有效，不会修改目录项的 D 位。</font></strong></p><blockquote><p>操作系统在进行内存页调度时，如果发现需要被换出的内存页 D 位为 1 时，则需要将对应物理内存页数据写回虚拟页对应的磁盘交换区，保证磁盘/内存数据的一致性；当发现需要被换出的物理内存页的 D 位为 0 时，表示当前页自从换入物理内存以来没有被修改过，和磁盘交换区中的数据一致，<strong>便直接将其覆盖，而不进行磁盘的写回</strong> ，减少不必要的 I/O 以提高效率。</p></blockquote></li><li><p><strong>A</strong> ：Accessed，访问位。和段描述符中的 A 位和 P 位相同，这两位结合能够实现虚拟内存管理，参见<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">段描述符详解</a> 。</p></li><li><p><strong>PCD</strong> ：页级高速缓存禁止位。PCD 为 1 时，表示访问当前物理页禁用高速缓存；PCD 为 0 时，表示访问当前物理页时允许使用高速缓存。</p></li><li><p><strong>PWT</strong> ：页级通写位。PWT 为 1 时，表示当前物理页的高速缓存采用通写法；PWT 为 0 时，表示当前物理页的高速缓存采用回写法。</p><blockquote><p>PWT与PCD位的使用，涉及到了80386高速缓存的工作原理与内存一致性问题，笔者暂不清楚。</p></blockquote></li><li><p><strong>US</strong> ：User/Supervisor，用户/管理位。当 US 为 1 时，标识当前页是用户级别的，允许所有当前特权级的任务进行访问。当 US 为 0 时，表示当前页是属于管理员级别的，只允许当前特权级为0、1、2的任务进行访问，而当前特权级为 3 的用户态任务无法进行访问。</p></li><li><p><strong>RW</strong> ：Read/Write，读写位。标识当前页是否能够写入。当 RW 为 1 时，代表当前页可读可写；当 RW 为 0 时，代表当前页是只读的。</p></li><li><p><strong>P</strong> ：present，存在位。标识当前虚拟内存页是否存在于物理内存页中。当 P 位为 1 时，表示当前虚拟内存页存在于物理内存中，可以直接进行访问。当 P 位为 0 时，表示对应的物理内存页不存在，需要新分配物理内存页或是从磁盘中将其调度回物理内存。<strong>该位和 A 位共同实现虚拟内存管理</strong> 。</p></li></ul></li></ul><h3 id="font-color-red-两级页表的优越性-font"><font color='red'>两级页表的优越性</font></h3><p>两级页表比一级页表优越在哪？首先我们来看一级页表的缺点：</p><ul><li><p><strong><font color='orange'>一级页表的所有表项必须连续存放</font></strong> （因为你只能通过索引访问，而不是通过地址访问表项），这需要很大一片连续的空间（4MB）。</p></li><li><p><strong><font color='orange'>一级页表必须完整</font></strong> 。然而进程在一段时间内只会访问几张页表，因此没必要让所有页表项常驻内存。当进程很多时，页表占用的内存将会非常可观！</p><blockquote><p>为什么一级页表必须完整？因为一级页表承担的职责是将虚拟地址翻译成物理地址，如果虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。</p></blockquote></li></ul><p>对比之下，我们来看两级页表的优点：</p><ul><li><p>由于页目录项中装载的是页表的物理起始地址（物理页框），而不是索引，<strong><font color='orange'>所以页表可以不连续存放</font></strong> （但页表项还是要连续存放）。这也许能使我们利用一些零散的空间。</p><blockquote><p><strong><font color='orange'>需要注意，由于页目录项中只能容纳页表地址的 31~12 位，所以页表必须以 4K 对齐！也就是说页表的起始地址必须是物理页框。</font></strong></p></blockquote></li><li><p><strong><font color='orange'>页表可以不存在</font></strong> 。<strong>页目录表覆盖到了全部虚拟地址空间</strong> ，所以页表就可以在需要时创建。相对于一级页表结构(4MB)，这大大节省了内存空间。</p><blockquote><p><strong><font color='gree'>顶级页表（页目录表）必须完全创建，且常驻内存，即必须涵盖全部虚拟地址空间</font></strong> 。这里提前说一下，小伙伴们阅读下节内容<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>后会发现实际上我们并没有完全创建页目录项（只创建了第0、768~1022、1023号页目录项），这是为什么呢？注意，<strong><u>“页目录表必须完全创建”指的是必须为页目录表预留 4KB 内存</u></strong> ，且须将此片内存初始化为 0 ；<strong>至于是否安装全部页目录项，可按需进行（一般不会一次性安装全部目录项）</strong> 。为什么需要将页目录表初始化为 0 ，这将在<a href="https://jyx-fyh.github.io/2022/12/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9B%E9%98%B6-%E5%88%86%E9%85%8D%E9%A1%B5%E5%86%85%E5%AD%98/">内存管理-进阶-分配页内存</a>中详细阐述。<br>值得说明的是，在 i386 的 Linux 下，创建虚拟内存空间只是分配一个页目录表就行了，甚至不需要创建页映射关系，这些映射关系会等到后面程序发生缺页错误时再进行映射。</p></blockquote></li><li><p><strong><font color='orange'>页表可以不在内存中</font></strong> 。由于程序的局部性原理，一段时间内只会访问少量页表，所以可以将其他页表放入硬盘，并标记相应的页目录项（标记 P 位），需要的时候再从硬盘调入内存。</p><blockquote><p>如果对应的页不在内存中，CPU 将发出缺页中断，由缺页中断程序将所缺页调入内存。那么缺页中断程序如何知道虚拟页面在磁盘中的哪个地方呢？它并不知道。但它知道产生缺页中断进程所对应的源程序文件名和产生缺页中断的虚拟地址，中断程序会根据虚拟地址计算该地址在对应程序文件中的偏移量，然后要求文件系统在该文件此偏移量处进行文件读取，一般会读取多个页。详细内容后续会进行说明。</p></blockquote></li></ul><p>另外需要说明的是，现代操作系统大多都采用 3~5 级页表了。</p><h3 id="font-color-red-开启分页-font"><font color='red'>开启分页</font></h3><p><strong><font color='orange'>通过将 CR0 寄存器的 PG(第 31 位) 置 1 开启分页机制</font></strong> ：<br><img src="/2022/img/IMG_0516(20221102-163923)-1668327746253-1.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0                 </span><br><span class="line">or  eax, 0x80000000</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><p>但一般而言，<strong><font color='orange'>在此之前，需要将页目录表的起始地址赋给 CR3 寄存器</font></strong>。CR3 结构如下：<br><img src="/2022/img/IMG_0520(20221113-163114).PNG" alt=""></p><p>其中 PCD 和 PWT 用户设置高速缓存的相关特性，在此置 0 即可。所以，可以直接用以下方式赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, PAGE_DIR_POS   ;把页目录地址(0x00100000)赋给cr3</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure><p><strong>注意，CR3 中装载的是物理地址，而非虚拟地址！</strong></p><h3 id="font-color-red-几类地址的关系-font"><font color='red'>几类地址的关系</font></h3><ul><li>物理地址：就是真实的内存地址，不必多说。</li><li>逻辑地址：不论在实模式还是保护模式，都指段内偏移地址。</li><li>有效地址：和逻辑地址相同。</li><li>线性地址：在保护模式下，未开启分页时，线性地址就是物理地址；开启分页后，线性地址又叫虚拟地址。</li><li>虚拟地址：<strong><font color='red'>用来描述任务或进程的地址空间，每个进程都有 4GB 虚拟地址空间！</font></strong> 开启分页后，进入虚拟地址空间。</li></ul><h3 id="font-color-red-TLB-font"><font color='red'>TLB</font></h3><p>我们已经知道，虚拟地址转化成物理地址需要访问多次内存，以上还只是两级页表，如果换成五级页表，那么转换效率将下降得非常明显！那有没有办法解决呢？有的，仍然利用程序的局部性原理，如果一个页面被访问，该页面中的其他地址很有可能随后就被访问，这样我们就能将该页面的翻译结果放入缓存，后面访问该页内中的地址时直接在缓存中取得相应页框，而无须每次访问该页面中的地址时都翻译一次，这样就能大大提高效率。</p><p>该缓存就是 <strong>TLB(Translation Lookaside Buffer)</strong> ，又称为<u>快表</u> 。快表的结构如下：<br><img src="/2022/img/IMG_0527(20221116-151219).PNG" alt=""></p><p><strong>处理器会在寻址前用虚拟地址的高 20 位来匹配 TLB 中每个项的虚拟页框号，如果匹配成功（命中），则返回对应的物理页框号</strong> ；<strong>如果不中，则按原方式寻找物理页框，获得物理页框后再更新 TLB</strong> 。</p><blockquote><p>需要注意的是，这种匹配方式并不是挨个比较，想一想，如果按顺序挨个比较的话，只要 TLB 中的表项稍多，那么搜索 TLB 的时间就可能多于查找多级表所需要的时间了，这样 TLB 就失去了意义。所以，比较时并不是按顺序比较，而是与所有表项同时比较！这种离谱的操作需要特殊的电路，这也就是 TLB 如此昂贵的原因。</p></blockquote><p>另外，不同于其他普通缓存，TLB 涉及到内存访问（取指令，取数据），如果不能时刻保证其中地址的有效性，那么程序将必然出错！这么说，TLB 就需要时刻更新。可是若实时读取内存中的页表去更新 TLB 的话，这又回到了内存查找映射的老路，TLB 又失去了意义。<strong><font color='orange'>因此，TLB 并不自动更新，处理器也不负责 TLB 的有效性，它将 TLB 的维护工作交给操作系统开发人员</font></strong> ，毕竟是由操作系统开发人员负责的页表维护，他们肯定知道何时修改了哪些页表或条目。TLB 对开发人员不可见，但有两种以下方式可以间接更新 TLB：</p><ol><li><p>重新加载 CR3 。将 CR3 读出来再重新写入，这会使整个 TLB 失效。</p></li><li><p>使用指令 <code>invlpg</code> 。该指令用来刷新 TLB 中某个虚拟页框对应的条目，所以操作数也是虚拟地址：<code>invlpg [m]</code> 。</p><blockquote><p>未来我们在编写内存管理代码时会用到该指令。</p></blockquote></li></ol><h3 id="font-color-red-内核与用户的关系-font"><font color='red'>内核与用户的关系</font></h3><p>不同于实模式，我们现在实现的是多任务调度系统，多个任务能够同时运行。进程可以有很多个，但操作系统，或者说内核，只有一个，<strong><font color='orange'>因此内核必须共享给所有用户进程</font></strong> 。进而，我们需要设计内存布局，以达到所有进程共享内核的目的，<u>这需要通过规划页表来实现</u>。</p><p>保护模式下，用户进程以低特权级身份运行，内核则以高特权级运行，当用户进程要访问硬件资源时，需要向操作系统申请，由操作系统代办，然后将结果返回给用户。换句话说，<strong><font color='gree'>一个完整的程序分为用户代码（私有部分）和操作系统代码（全局部分）</font></strong> ，两者相互配合才能完成任务。</p><blockquote><p>特权级相关内容后面会详细说到，耐不住的同学请移步<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级剖析</a></p></blockquote><p>前面我们说过，<strong>虚拟地址空间是用来描述任务或进程的，每个进程都有 4GB 的虚拟地址</strong> 。为了实现内核共享，我们将虚拟地址空间分为两个部分：<strong><font color='orange'>一部分划给内核，占高 1 GB；另一部分划给用户进程，占低 3 GB</font></strong> 。进一步说，我们会将所有用户的 3~4GB 虚拟地址空间指向同一个操作系统，也就是所有进程的 3~4GB 虚拟地址都指向同一片物理页。具体方式和代码请参考<a href="https://jyx-fyh.github.io/2022/11/13/%E5%BC%80%E5%90%AF%E5%88%86%E9%A1%B5-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">开启分页-代码详解</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile入门</title>
      <link href="/2022/11/08/makefile/"/>
      <url>/2022/11/08/makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进入保护模式-代码详解</title>
      <link href="/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong><font color='orange'>MBR --&gt; Loader --&gt; Kernel</font></strong><br>本节代码只涉及 MBR 和 Loader 部分，暂未考虑内核代码。同时，为规范操作，我们使用 [加载器-用户程序] 方式将 Loader 从硬盘载入内存。这种方式非常漂亮，同时能让你理解重定位的本质，详细请阅读<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器-重定位</a> (本节前置要求，务必阅读)。</p></blockquote><blockquote><p>本节代码对应分支 <code>protected-mode</code> 。</p></blockquote><p><strong><mark class="hl-label blue">配置文件</mark> </strong><br>本节的 MBR 可以直接引用 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 一文中的 MBR 代码，并在文件头引入配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION mbr align=16 vstart=0x7c00                                     </span><br><span class="line">;....................以下省略....................</span><br></pre></td></tr></table></figure><p>其中 <code>loader.inc</code> 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.inc</span><br><span class="line">BASE_ADDR    equ 0x900 ;最好不超过0xFFFF,原因在下文解释</span><br><span class="line">START_SECTOR equ 2     ;从硬盘的第2(lba)扇区将加载器载入内存</span><br></pre></td></tr></table></figure><p>接着，定义保护模式的配置文件 <code>boot.inc</code> 。将此图和以下代码对比阅读：<br><img src="/2022/img/IMG_0499(20221101-085023).PNG" alt="其中的含义参见《全局描述符表 &amp; 段选择子概述》"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：boot.inc ,包含保护模式中要用到的段选择子,描述符等内容</span><br><span class="line">;以下为段描述符的子属性</span><br><span class="line">DESC_G_4K         equ   1000_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_DB_32        equ    100_0000_0000_0000_0000_0000B </span><br><span class="line">DESC_L            equ     00_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_AVL          equ      0_0000_0000_0000_0000_0000B</span><br><span class="line">DESC_LIMIT_CODE2  equ        1111_0000_0000_0000_0000B</span><br><span class="line">DESC_LIMIT_DATA2  equ        DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2 equ        0000_0000_0000_0000_0000B</span><br><span class="line">DESC_P            equ             1000_0000_0000_0000B</span><br><span class="line">DESC_DPL_0        equ              000_0000_0000_0000B</span><br><span class="line">DESC_DPL_1        equ              010_0000_0000_0000B</span><br><span class="line">DESC_DPL_2        equ              100_0000_0000_0000B</span><br><span class="line">DESC_DPL_3        equ              110_0000_0000_0000B</span><br><span class="line">DESC_S_SYS        equ                0_0000_0000_0000B</span><br><span class="line">DESC_S_DATA       equ                1_0000_0000_0000B</span><br><span class="line">DESC_TYPE_CODE    equ                  1000_0000_0000B;只执行1000</span><br><span class="line">DESC_TYPE_DATA    equ                  0010_0000_0000B;可读写0010</span><br><span class="line"></span><br><span class="line">;以下为段描述符的高四位(低四位在loader.s中定义)</span><br><span class="line">DESC_CODE_HIGH4   equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_CODE + 0X00</span><br><span class="line">DESC_DATA_HIGH4   equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_DATA + 0X00</span><br><span class="line">DESC_VIDEO_HIGH4  equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_DB_32 + DESC_L + DESC_AVL +\</span><br><span class="line">                        DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA +\</span><br><span class="line">                        DESC_TYPE_DATA + 0X0b</span><br><span class="line">;========段选择子属性=============</span><br><span class="line">RPL0   equ   00B</span><br><span class="line">RPL1   equ   01B</span><br><span class="line">RPL2   equ   10B</span><br><span class="line">RPL3   equ   11B</span><br><span class="line">TI_GDT equ   000B</span><br><span class="line">TI_LDT equ   100B</span><br></pre></td></tr></table></figure><p>下面对以上宏定义进行说明：</p><ul><li>将各个子属性进行宏定义，最后相加组成段选择子的高四字节（低四字节后续定义）。相比一大串莫名奇妙的数字，这样更加直观。</li><li>第 7, 8 行，将 DATA 和 CODE 的 4 位段界限全设置为 1（后面会将 DATA 和 CODE 的另外16位段界限全设为1），由于 G=1，粒度为 4KB，所以实际段大小为 4GB。第 21,24 行 <code>0x00&lt;&lt;24</code> 以及末尾加上 0x00，这是在将高4字节中的段基址设为 0（后面会将 DATA 和 CODE 的另外16位段基址全设为0），所以段基址为 0。<strong><font color='orange'>将段基址设为 0，段界限设为 4GB，这样做是为了形成平坦模型</font></strong> ，即整个内存都在一个段中。平坦模型使用起来很方便，后期我们会慢慢体会到。</li><li>第 29 行，为啥最后加的 0x0b？之前说过，文本显示适配器的内存地址为 <code>0xb8000~0xbffff</code> ，<strong><font color='orange'>为了方便显存的操作，显存段不使用平坦模型</font></strong> ，所以将段基址设置为 0xb8000，其中的 b 在段描述符的高 4 字节上，这就是为啥 26 行末尾加 0x0b；显存的段大小为 <code>0xbffff-0xb8000=0x7fff</code> ，粒度为 4KB，因此段界限为 <code>0x7fff÷4KB=7</code> ，这将在段描述符的低 4 位设置，高 4 位直接设 0 即可。</li><li>第 15,16 行，SYS 表明该段是系统段；DATA 不是指数据段，<u>而是相对于 SYS 而言的</u>，代码段/数据段/栈段都属于 DATA 。</li><li>以上宏定义并未定义栈段，这是因为此处将栈段和数据段定义在了一起，即 DATA 段。关于为什么栈段和数据段能够放在一个段中，参见<a href="https://jyx-fyh.github.io/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/">内存段与段寄存器保护</a> 。</li><li><code>_</code> 仅作分隔符，方便阅读，编译时会自动忽略。</li></ul><p><strong><mark class="hl-label blue">loader.s</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">;文件说明：loader.s</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">%include &quot;loader.inc&quot;</span><br><span class="line"></span><br><span class="line">SECTION loader vstart=BASE_ADDR              ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end           ;程序总长度[0x00]    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start-BASE_ADDR       ;偏移地址[0x04]</span><br><span class="line">                    dd section.loader.start  ;段地址[0x06] </span><br><span class="line">    realloc_tbl_len dw 0                     ;段重定位表项个数为0</span><br><span class="line">;=========================================================</span><br><span class="line">;GDT</span><br><span class="line">;第0描述符不可用</span><br><span class="line">    GDT_BASE        dd    0x00000000</span><br><span class="line">                    dd    0x00000000</span><br><span class="line">;第1描述符CODE</span><br><span class="line">    DESC_CODE       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_CODE_HIGH4</span><br><span class="line">;第2描述符DATA   </span><br><span class="line">    DESC_DATA       dd    0x0000FFFF</span><br><span class="line">                    dd    DESC_DATA_HIGH4</span><br><span class="line">;第3描述符VIDEO</span><br><span class="line">    DESC_VIDEO      dd    0x80000007</span><br><span class="line">                    dd    DESC_VIDEO_HIGH4</span><br><span class="line">    </span><br><span class="line">    GDT_SIZE        equ   $ - GDT_BASE</span><br><span class="line">    GDT_LIMIT       equ   GDT_SIZE - 1    </span><br><span class="line">;GDT指针</span><br><span class="line">    gdt_ptr         dw    GDT_LIMIT    </span><br><span class="line">                    dd    GDT_BASE</span><br><span class="line"></span><br><span class="line">    SELECTOR_CODE   equ   ((DESC_CODE - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_DATA   equ   ((DESC_DATA - GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    SELECTOR_VIDEO  equ   ((DESC_VIDEO- GDT_BASE)/8)&lt;&lt;3 + TI_GDT + RPL0</span><br><span class="line">    </span><br><span class="line">    loader_msg      db    &#x27;r&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;a&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;-&#x27;,11000010b</span><br><span class="line">                    db    &#x27;m&#x27;,11000010b,&#x27;o&#x27;,11000010b,&#x27;d&#x27;,11000010b,&#x27;e&#x27;,11000010b</span><br><span class="line">;=======================================================</span><br><span class="line"></span><br><span class="line">start: ;程序入口          </span><br><span class="line">mov ax,0             ;转移到loader代码后,</span><br><span class="line">mov ds,ax            ;将各段寄存器清0是头等大事</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">print:</span><br><span class="line">mov ax,0xb800        ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,loader_msg    ;ds:si</span><br><span class="line">mov di,0             ;es:di</span><br><span class="line">mov cx,18            ;9个字符,占18字节</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">;========================================================</span><br><span class="line">;1.打开A20</span><br><span class="line">;2.加载GDT</span><br><span class="line">;3.置PE=1</span><br><span class="line">prepare: </span><br><span class="line">;关中断</span><br><span class="line">    cli</span><br><span class="line">;打开A20</span><br><span class="line">    in   al,0x92</span><br><span class="line">    or   al,0000_0010B</span><br><span class="line">    out  0x92,al</span><br><span class="line">;加载GDT</span><br><span class="line">    mov  ax,0</span><br><span class="line">    mov  ds,ax</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line">;CR0的第0位置1</span><br><span class="line">    mov  eax,cr0</span><br><span class="line">    or   eax,0x0000_0001</span><br><span class="line">    mov  cr0,eax</span><br><span class="line">;此后进入保护模式</span><br><span class="line">    jmp  dword SELECTOR_CODE:p_mode_start ;刷新流水线,装载CODE选择子</span><br><span class="line">;======================================================</span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">    mov ax,SELECTOR_DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov esp,BASE_ADDR       ;可以找其他合适的地方作为栈顶，这里使用BASE_ADDR</span><br><span class="line">    mov ax,SELECTOR_VIDEO</span><br><span class="line">    mov gs,ax</span><br><span class="line"></span><br><span class="line">    mov byte [gs:160],&#x27;p&#x27;</span><br><span class="line">    mov byte [gs:161],11000010b</span><br><span class="line">    jmp $</span><br><span class="line">;========================================================</span><br><span class="line">program_end  equ  $-BASE_ADDR </span><br></pre></td></tr></table></figure><p>以上代码的解释：</p><ul><li><p>为什么此 loader 段的 <code>vstart</code> 不能像<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>中的 loader 段一样设为 0 ？有以下两个原因：</p><ol><li><p>注意第 75 行代码，该代码执行后，代码段的段基址为 0（因为CODE段描述符的段基址之前被全设为0了），进入了平坦模式，所以在内存中寻址并取得指令就全靠偏移地址啦！该行代码将直接跳转至 <code>p_mode_start</code> 处。那么，<code>p_mode_start</code> 的值为多少呢？这个问题至关重要。如果我们将 loader 段的 <code>vstart</code> 设为 0，那么标号 <code>p_mode_start</code> 的值就为 79 行代码相对于文件头的偏移量，本文件编译后所得二进制文件大小大概为 172 字节，所以 <code>p_mode_start</code> 相对于文件头的偏移大概为 140(0x8C) 字节，即 <code>p_mode_start=0x8C</code> 。问题在于，我们已经将此 loader 载入到内存 0x900 处，如果跳转到  <code>0x8C</code>  处，显然将执行错误的代码。实际应该跳转到 <code>0x98C</code> 处，而 <code>vstart=BASE_ADDR</code> 便能将 <code>p_mode_start</code> 以 0x900 开始计算偏移，这样就能跳转到正确位置啦！说清楚真不容易。。</p></li><li><p>再注意第 30 行的 GDT_BASE。要知道，GDT_BASE 为 32 位段基地址，<strong>CPU 是直接在内存中的 <code>GDT_BASE</code> 处来找到 GDT 的</strong> 。说到这读者就应该懂了吧？原因和上点相同。</p><blockquote><p>vstart 不好理解，具体参见 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p></blockquote></li></ol></li><li><p>整个 loader 自成一段，这是为了方便。你也可以将以上代码分成数据段和代码段，<strong><font color='pink'>但务必注意，除 loader 段外的其他段不能用 vstart 修饰</font></strong> ！</p></li><li><p>第 8 行，偏移地址为什么是 <code>start-BASE_ADDR</code> ，因为在 MBR 最后的跳转指令(71行) <code>jmp far [0x04]</code> 的效果是 <code>jmp 0x900:偏移地址 </code> ，所以要此处放置的必须是 start 标号相对于本文件开头的偏移量。</p></li><li><p>第 29 行，注意 GDT 的 LIMIT 等于 SIZE-1（因为偏移从0开始算）。</p></li><li><p>第 23 行，<code>(DESC_CODE - GDT_BASE)/8</code> 得到索引值（段描述符为8字节），<code>&lt;&lt;3</code> 将索引值移到正确的位置上。<br><img src="/2022/img/3未命名绘图-1667637847644-1.png" style="zoom:50%;" /></p></li><li><p>第 61 行，关闭中断。<strong><font color='orange'>保护模式下的中断机制和实模式不同，原有的中断向量表不再适用，BIOS 中断无法继续使用</font></strong>。</p></li><li><p>第 87 行，之前我们说过，为了方便显存操作，对 VIDEO 段仍使用分段模型而非平坦模型。</p></li><li><p>注意！最后 <code>program_end equ $-BASE_ADDR</code> 得到整个文件二进制代码的大小。</p></li></ul><p>最后需要单独强调的是，第 41~46 行代码并非必须要执行。这主要针对的是打印信息，即后面要用到的 ds 寄存器。如果 ds 不清零，则后续寻找字符时，<code>ds:loader_msg</code> 就是错误的地址，原因见上面第 1、2 点。然而如果按照我们上面的这种方式，则该 loader 必须加载到内存 0xFFFF 以内！否则打印无法正常进行（保护模式仍然能够正确进入）。这是因为打印时还在实模式，有效地址最大还是 16 位，如果 loader_msg 的标号超过 0xFFFF，那么有效地址就无法容纳 loader_msg。如果想把这 loader 加载到内存任意位置，则无需清零段寄存器，且第 50 行代码需要改为：<code>mov si,loader_msg-BASE_ADDR </code> 。<br>执行结果如下：<br><img src="/2022/img/image-20221105222138942.png" alt="image-20221105222138942"></p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进入保护模式五部曲</title>
      <link href="/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
      <url>/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本节对应代码：<a href="https://jyx-fyh.github.io/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">进入保护模式-代码详解</a><br>参考：《操作系统真相还原》《x86汇编：从实模式到保护模式》</p></blockquote><h3 id="font-color-red-五部曲概览-font"><font color='red'>五部曲概览</font></h3><ul><li>打开 A20 地址线</li><li>加载 GDT</li><li>将 CR0 寄存器的 PE 位设置为 1</li><li>关闭中断</li><li>刷新流水线</li></ul><blockquote><p>以上五个步骤没有顺序，但为了保险起见，最好将操作 CR0 放在最后一步。</p></blockquote><h3 id="font-color-red-打开-A20-地址线-font"><font color='red'>打开 A20 地址线</font></h3><p>8086/8088 CPU 的地址总线为 20 位，寻址空间为 1MB 。当地址超过 1MB 时，地址就会发生回绕，即重新从 0 算起，相当于对 1MB 求模。这种缺陷被当时很多程序员利用，成为了一个编程技巧，并写入了程序（一旦用得多，就必须考虑兼容）。后来的 80286 CPU的地址总线扩展到 24 位，寻址空间达到 16MB 。考虑到 80286 需要兼容 8086 实模式，即在实模式下必须只使用 20 位地址线，以确保能够发生回绕。为实现这一目的，CPU 在 A20 地址线(第21根地址线)处设置了一个开关(A20Gate)，在实模式下关闭，则最大地址空间为 1MB，能够发生回绕；在保护模式下打开，寻址空间扩展到 24 位。</p><p>32位 CPU 类似，只有打开 A20Gate 后，地址空间才能由 1MB 扩展到 4GB，从而进入更大的空间。</p><p>打开 A20Gate 的方法很简单，<strong><font color='orange'>将 0x92 端口的第 1 位(起始位是第0位)置 1 即可</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in  a1,0x92       #先读进来</span><br><span class="line">or  al,0000_0010B #第1位置1</span><br><span class="line">out 0x92,al       #再写出去</span><br></pre></td></tr></table></figure><h3 id="font-color-red-加载GDT-font"><font color='red'>加载GDT</font></h3><p><strong><font color='orange'>使用指令 <code>lgdt</code> (load gdt)将 GDT 的信息加载进 GDTR</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt  gdt_ptr</span><br></pre></td></tr></table></figure><p><code>gdt_ptr</code> 是标号，代表 GDT 所在的地址，<strong>指向一个包含了 48 位的内存区域。该区域的高 32 位必须为 GDT 的基地址，低 16 位为边界</strong> 。该指令在实模式和保护模式下都能够使用。<strong><font color='orange'>注意，必须先加载 GDT 才能够进入保护模式</font></strong> ！由于实模式下的内存空间为 1MB，所以只有先将 GDT 放在 1MB 内存以内，进入保护模式后可以转移 GDT 的位置。</p><h3 id="font-color-red-置-PE-位为-1-font"><font color='red'>置 PE 位为 1</font></h3><p>CR0 寄存器的 PE 位(第 0 位)是进入 32 位保护模式的开关，开启后，对指令的解释将改变，参见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a>。CR0 结构如下：<br><img src="/2022/img/IMG_0516(20221102-163923).PNG" alt=""><br>各位的解释如下：<br><img src="/2022/img/image-20221102164337278.png" alt=""></p><p>置 1 方式和打开 A20Gate 差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,cr0</span><br><span class="line">or  eax,1</span><br><span class="line">mov cr0,eax</span><br></pre></td></tr></table></figure><p>此后，CPU 就进入到保护模式啦！</p><h3 id="font-color-red-关闭中断-font"><font color='red'>关闭中断</font></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure><p>准确来说是禁止可屏蔽中断。从实模式进入保护模式时，不关中断也是可以的，如果中断发生在实模式进入保护模式之前和之后都没有问题，但若在模式切换进行时发生中断就会发生异常了，这个情况概率比较低。具体原因笔者也不太明白，可参考<a href="https://www.zhihu.com/question/532841878">为什么保护模式需要使用cli指令禁止硬件中断？)</a></p><blockquote><p>另外，保护模式下不能再使用 BIOS 中断。</p></blockquote><h3 id="font-color-red-刷新流水线-font"><font color='red'>刷新流水线</font></h3><p>其实本来只有前三步曲，但进入保护模式后还有一个相当重要的步骤必须马上进行：刷新流水线。未进入保护模式时，CPU 使用 16 位指令格式译码，进入保护模式后，使用 32 位指令格式译码（两者区别参见<a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">32位保护模式概览</a>）。而进入保护模式这一瞬间，有很多实模式下的指令之前已经进入了流水线，而保护模式对这些指令的解释有所不同，可能引发错误，所以必须清空流水线。关于流水线，参见<a href="https://jyx-fyh.github.io/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/">处理器微架构</a> 。<strong><font color='orange'>使用 jmp 指令即可刷新流水线</font></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SELECTOR_CODE:p_mode_start</span><br></pre></td></tr></table></figure><p>关于这条指令的详细解释，参见<a href="https://jyx-fyh.github.io/2022/11/02/%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">进入保护模式-代码详解</a> 。</p><blockquote><p>另外，其实在置 PE 位为 1 和刷新流水线的这段时间内，系统实际上是处于 16 位保护模式下。这是因为置 PE 为 1 后，即刚进入保护模式时，CS 的描述符高速缓存器中仍然是实模式下的内容（此时还没来得及更新），其 D 位是 0，因此在刷新流水线前，处理器运行在 16 位保护模式下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存段与段寄存器保护</title>
      <link href="/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-修改段寄存器时的保护-font"><font color='red'>修改段寄存器时的保护</font></h3><p>处理器在变更段寄存器以及描述符高速缓存器时，会检查代入值的合法性，若不合法，则抛出异常。将段选择子送入段寄存器时，CPU 的固件会自动确认选择子和该选择子对应的段描述符的正确性。<br><strong><font color='gree'><u>对选择子的检查内容包括</u></font></strong>：</p><ol><li><p><strong>选择子的索引是否超界</strong> ，即对应的段描述符是否在 GDT 范围内。要求 <code>索引号×8+7 &lt;= 边界</code> 。若超过边界，则产生异常中断 13，同时段寄存器的原值不变。</p></li><li><p><strong>选择子的索引是否为 0</strong> 。在<a href="https://jyx-fyh.github.io/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/">全局描述符表 &amp; 段选择子概述</a>一文中说过，GDT 的第 0 个描述符不可用。对于 DS,ES,FS,GS 这四个段寄存器，可以向其中加载索引为 0 的段选择子，CS,SS 段寄存器则不可。</p><blockquote><p>虽然能够加载索引为 0 的段选择子，但访问内存时就会出错并抛出中断。CPU 使用这种特殊的设计来保证系统安全。</p></blockquote></li></ol><p><strong><font color='gree'><u>对段描述符的检查内容包括</u></font></strong>：</p><ol><li><strong>结合 S 位判断 TYPE 字段的有效性</strong> 。比如 <code>0000</code> 就是无效值。</li><li><strong>检查描述符类型是否和段寄存器用途匹配</strong> 。段的类别检查规则如下：<br><img src="/2022/img/image-20221101211058505.png" style="zoom:80%;" /><br>大概原则可以总结为：<br>1）只有可执行的段才能加载进 CS；<br>2）只有可读写的段才能加载进 SS；<br>3）至少可读的段才能加载进 DS, GS, ES, FS；<br><strong>注意，可读的代码类似于 ROM，既可以用 CS 执行，也可被 DS,ES,FS,GS 当作数据访问</strong> ！</li><li><strong>检查 P 位</strong> 。若 P=0 ，则表示该段虽然已经被定义，但并不在内存中，抛出异常中断11。应当定义相应的中断处理程序，抛出异常后，把该描述符对应的段从硬盘中调入内存，中断返回时，处理器再进行操作。</li></ol><h3 id="font-color-red-对代码段的保护-font"><font color='red'>对代码段的保护</font></h3><p>EIP 中装着下一条指令的偏移地址。在获取下一条指令前，CPU 会检查 EIP 的有效性，以防止执行超出范围之外的指令。检查方式为：<code>0&lt;=(EIP+指令长度-1)&lt;=实际段界限</code> ，其中 <strong><code>实际段界限=(段界限+1)×粒度-1</code></strong> 。跨越边界的指令同样不允许执行，这种指令也已经被包含在此公式中。</p><h3 id="font-color-red-对数据段的保护-font"><font color='red'>对数据段的保护</font></h3><p>同代码段类似，其检查方式为：<code>0&lt;=(EA+操作数的长度-1)&lt;=实际段界限</code> 。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x2000],edx</span><br></pre></td></tr></table></figure><p>其中 EA=0x2000 。</p><h3 id="font-color-red-对栈段的保护-font"><font color='red'>对栈段的保护</font></h3><p>同上类似，其检查方式为：<code>(ESP-操作数长度)&gt;=实际段界限</code> 。</p><p>你可能会在源代码中进行以下的栈段定义：<br><img src="/2022/img/6%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt="注意图中为偏移地址，不是物理地址"><br>将 ESP 初始值设为 <code>0x7c00</code> ，段界限设为 <code>0x7A00</code> ，粒度设为 1 字节，扩展方向设为向下 (E位为1) ，则定义出 <code>0x7C00~0x7A00</code> 的栈段。虽然 ESP 不能低于 <code>0x7A00</code> ，但它却能够一直 POP 从而高于 <code>0x7C00</code> ，这仍然超过了我们指定的空间。最可怕的是，即使高于 <code>0x7C00</code> ，CPU 也不会抛出异常，这很有可能导致我们悄无声息地改变其他内存空间中的重要数据或代码，从而使程序崩溃。<strong><font color='orange'>正确的栈段定义应该采用如下方式：</font></strong><br>将段描述符中的段基址设为 <code>0x00007c00</code> ，段界限设为 <code>0x000FFFFE</code> ，粒度设为 4KB（即设 G 为1) ，初始 ESP 设为 0 。则实际段界限为 <code>FFFFEFFF</code> ，又因为 ESP 的最大值为 <code>FFFFFFFF</code> ，所以操作该段时，CPU 的检查规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFFEFFFF&lt;=(ESP-操作数长度)&lt;=0xFFFFFFFF</span><br></pre></td></tr></table></figure><p>访问内存时，<code>物理地址=段基址+ESP</code> ，所以该栈段的栈底 <strong>物理地址</strong> 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007C00 + 0xFFFFF000 = 0X00006C00</span><br></pre></td></tr></table></figure><p>该栈段的最高端地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00007C00 + 0xFFFFFFFF = 0X00007BFF</span><br></pre></td></tr></table></figure><p>从而，该栈段被限制在物理地址 <code>0x00006C00 ~ 0x00007BFF</code> 范围内，长为 512 字节 。这波操作实在 666 。稍加思考就能发现，上面的方法是 <strong><font color='orange'>通过 ESP 本身的最大值限制来为栈段创造了一个上边界</font></strong> 。</p><p>注意，<strong>数据段和栈段的段基址可以相同</strong> 。比如，上面讲的栈的基地址设为 <code>0x7c00</code> ，但其栈底元素所占内存为 <code>0x7BFC~0x7BFF</code> ；若讲数据段的基地址也设为 <code>0x7C00</code> ，则起始数据的内存就是从 <code>0x7C00</code> 开始。</p><p>实际上，可以将数据段作为栈段，这种方式定义起来比较简单，但其中有些细节问题笔者还未搞清楚，搞明白后再更新。</p><h3 id="font-color-red-利用段别名修改代码段-font"><font color='red'>利用段别名修改代码段</font></h3><p>一般情况下，任何指令都不允许向代码段写入数据，而且，只有可读的代码才允许访问。但很多时候又需要对代码作一些修改，比如调试程序时需要加入断点指令 int3。此时，就不能使用原描述符来进行访问，而应该重新定义一个段描述符，并将其定义成可读写的段，这样就可以通过这个新定义的段描述符来修改之前的代码段。像这样，当多个不同的描述符指向同一个段时，把另外的描述符称为该段的别名。</p><blockquote><p>如果两个程序想共享同一个内存区域，也可以采用此方式。</p></blockquote><blockquote><p>文章参考：《操作系统真相还原》《x86汇编语言：从实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDT&amp;段描述符&amp;选择子概述</title>
      <link href="/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/10/31/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了方便程序的浮动装配(重定位)，处理器访问内存时采用了 [段地址+偏移地址] 的策略，这是 IA-32 的基因。在保护模式下，段有了新的作用——权限管理的单位，<strong>操作系统将一定权限赋予给某些段</strong> ，当段内指令访问内存或进行其他操作时，<strong>CPU 会根据段的权限来检查其行为的可行性</strong> ，如果其行为越界，则会阻止并抛出异常。那么这些权限是如何记录的呢？请见下文。</p><h3 id="font-color-red-段描述符-font"><font color='red'>段描述符</font></h3><p>段的各类权限信息和其地址都被记录在 <strong>段描述符</strong> 中，其结构如下：</p><img src="/2022/img/IMG_0499(20221101-085023).PNG" style="zoom: 67%;" /><ul><li><p>段基址共 32 位，段界限共 20 位。可见它们都是“断开”的，这是因为需要兼容 80286 的 16 位保护模式，详细原因可见下一点。这种散乱分布不利于 CPU 获取段基址和段界限，<strong>所以段描述符中的内容会被整理好后存入描述符高速缓存器，CPU 直接从缓存器中获取段基址和段界限</strong> 。注意，<strong>对于数据段和代码段来说，段界限决定了偏移量的最大值；对于栈段而言，段界限决定了偏移量的最小值</strong> ，其细节差异在<a href="https://jyx-fyh.github.io/2022/11/01/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%82%A8%E5%AD%98%E5%99%A8%E4%BF%9D%E6%8A%A4/">内存保护与寄存器保护</a>中有详细阐述。<strong>实际段界限等于 <code>(段界限+1)*粒度-1</code></strong> (减1是因为偏移从0开始)。段基址可选在任何地方，但最好与 16 位对齐。以段基址为起点开始偏移，如下：<br><img src="/2022/img/1%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt="栈段与代码/数据段的段基址可以相同, 后续详述"></p></li><li><p><strong>G</strong> ：段界限的粒度。G=0 时，粒度为 1 字节，则段最大扩展范围为 64KB；G=1 时，粒度为 4KB，则段最大扩展范围为 4GB。</p></li><li><p><strong>D/B</strong> ：默认 操作数/堆栈指针 大小。D=0 时表示该段指令中的偏移地址和操作数为 16 位，栈操作使用 SP 寄存器，偏址用 IP；D=1 时表示该段指令中的偏移地址和操作数为 32 位，栈操作使用 ESP 寄存器，偏址用 EIP。设置该标志位是为了兼容 80286 的 16 位保护模式。16 位保护模式基本绝迹，该位总是为 1。</p></li><li><p><strong>L</strong> ：64 位代码段标志，保留给 64 位处理器使用，现在直接置 0 即可。</p></li><li><p><strong>AVL</strong> ：软件可以使用的位，处理器不使用它，但使用该位是不安全的，谁也不知道 Intel 公司未来是否会使用该位。</p></li><li><p><strong>P</strong> ：段存在位。用来描述该段是否在内存中。当内存紧张时，有可能只建立描述符但对应的内存空间不存在，此时应将 P 设为 0；另外，内存紧张时，可能会把用得很少的段从内存移到硬盘中，腾出空间给急需内存的应用，此时同样应该将 P 清零，当需要该段时，再移入内存并置 P 为 1。<strong>这是多任务系统下常见的虚拟内存调度策略</strong> 。P 位通常由操作系统负责设置，由 CPU 负责检查。</p></li><li><p><strong>DPL</strong> ：Descriptor Privilege Level，描述符特权级。CPU 支持 4 种特权级：0，1，2，3，数字越小特权越高。<strong>注意，特权级描述的是要访问该段的最低特权级</strong> 。比如，若该段 DPL=2，则只有 DPL 为 0、1、2 的段才能访问该段。</p></li><li><p><strong>S</strong> ：指定描述符的类型。S=0 表示该段为系统段；S=1 表示该段为数据段/代码段/栈段。<strong>S 位和 TYPE 位配合才能确定段描述符的确切类型</strong> 。</p></li><li><p><strong>TYPE</strong> ：共 4 位，用于表示内存段或门的子类型。<br><strong>当 S=1 时</strong> ：对于代码段而言，这 4 位是 X, C ,R ,A；对于数据段/栈段而言，这 4 位是 X, E ,W ,A：<br><img src="/2022/img/image-20221101105041738.png" alt="" style="zoom: 67%;" /></p><ul><li>X：是否可执行。数据段/栈段总是不可执行，代码总是可执行。</li><li>E：扩展方向。<strong>栈段向下扩展，数据段向上扩展</strong> 。</li><li>W：是否可写。</li><li>C：指示段是否为特权级依从(Conforming)；C=0 表示非依从的代码段，这样的代码段只能供与它特权级相同的代码段调用，或通过门调用；C=1 表示可依从的代码段，可以被特权级比它低的代码段调用。好奇的同学可提前阅读<a href="https://jyx-fyh.github.io/2022/11/26/%E7%89%B9%E6%9D%83%E7%BA%A7%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90/">特权级全面剖析</a> 。</li><li>R：是否可读。代码段一定可执行，一定不可写。是否可读，取决于 R 。<strong>若 R=1，则可以把此段当作 ROM 使用</strong> 。注意，是否可读是针对于其他代码段而言，而非 CPU ，CPU 不能读，哪还怎么运行。</li><li>A：指示最近是否访问过。创建该描述符时总是置 A 为 0；每当该段被访问，就置此位为 1。<strong>对 A 置 1 由 CPU 负责，置 0 由操作系统负责(创建时除外)，操作系统通过定期监视该位状态来统计该段的使用频率。当内存紧张时，就可以把不经常用的段转移到硬盘中，从而实现虚拟内存管理。</strong></li></ul><p><strong>当 S=0 时</strong> ：<br><img src="/2022/img/IMG_0502(20221101-114007).PNG" style="zoom: 67%;" /></p></li></ul><p>段描述符一共占 8 字节，每个段在使用之前都必须用段描述符“注册登记”。现代计算机都是多任务系统，所以会同时存在多个段，这些段描述符会被集中存放在内存中，这片集中存放的区域就构成了一个描述符表。</p><h3 id="font-color-red-描述符高速缓存器-font"><font color='red'>描述符高速缓存器</font></h3><p>8086 CPU中，访问内存时，会先将段寄存器中的值左移四位，再和 IP 的值相加，得到物理地址。<u>在 32 位 CPU 的实模式下</u>，获取物理段地址的方式得到了优化：当引用一个段时，先将 CS 的中左移四位得到物理段地址，然后将该值放入 <strong>描述符高速缓存器</strong> 。此后就一直使用该缓冲器中的值，直到该段寄存器被重新赋值。这样一来，就省去了左移四位的时间，进一步提高了 CPU 访问内存的效率。<strong><font color='orange'>注意，在实模式下，缓存器仅低 20 位有效，其他位全部为 0</font></strong> 。<u>在保护模式下</u>，当引用一个段时，段描述符中的内容会被<u>整理好</u>后存入缓存器，之后 CPU 访问内存时直接使用缓存器，直到该段寄存器被重新赋值。也就是说，<strong>在 32 位 CPU 下，实模式和保护模式都能够使用描述符高速缓存器</strong> ，只是细节上略有差别。</p><blockquote><p>整理的结果包括：1）结合零散的段界限和段基址；2）粒度*段界限，得到真实的段界限。</p></blockquote><p><strong>描述符高速缓存器是 32 位 CPU 中<u>段寄存器的扩展部分</u>，用来“整齐”存放段基址和段界限以及段属性。描述符高速缓存器是不可见的，由 CPU 内部使用</strong> ，其结构如下：<br><img src="/2022/img/IMG_0506(20221101-172536).PNG" alt=""><br>可见，80386 后的处理器将段描述符整理进缓冲器前，都事先将粒度(G位)乘以段界限(20位)得到真实的段界限(32位)，再存入缓存器。</p><p><strong><font color='orange'>再次强调，32 位 CPU 下，每个段寄存器都具有一个描述符高速缓存器。</font></strong> 其实准确来说，32 位 CPU 的段寄存器分为 16 位可见部分和不可见部分，不可见部分就是描述符高速缓存器，具体位数随 cpu 型号而变。</p><h3 id="font-color-red-全局描述符表GDT-font"><font color='red'>全局描述符表GDT</font></h3><p>全局描述符（Global Descriptor Table，<strong>GDT</strong> ）为整个软硬件系统服务。<strong><font color='orange'>进入保护模式前，必须定义全局描述符表</font></strong> 。<strong>GDT 可以存放在内存的任意位置</strong> ，为了定位 GDT，CPU 内部有一个全局描述符寄存器（ <strong>GDTR</strong> ），该寄存器为 48 位，其结构如下：<br><img src="/2022/img/2未命名绘图.png" alt=""  /><br>基地址部分保存的是 GDT 在内存中的起始地址，边界在数值上等于 GDT 的大小减 1 ，换句话说，边界的值就是表内最后一字节相对于基地址的偏移量。<strong>表最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> ，每个段描述符大小为 8 字节，故 GDT 最多能够装下 8192 个段描述符</strong> 。</p><p>GDT 可以在内存中的任何位置，但由于必须在进入保护模式之前定义 GDT ，而实模式下最多能访问 1MB 内存，所以一般将 GDT 定义在 1MB 以内的地址中。可以在进入保护模式后移动 GDT 的位置，但需要重新加载 GDTR 。</p><p><strong><font color='orange'>使用指令 <code>lgdt</code> (load gdt)将 GDT 的信息加载进 GDTR</font></strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt  gdt_ptr</span><br></pre></td></tr></table></figure><p><code>gdt_ptr</code> 是标号，代表 GDT 所在的地址，<strong>指向一个包含了 48 位的内存区域。该区域的高 32 位必须为 GDT 的基地址，低 16 位为边界</strong> 。该指令在实模式和保护模式下都能够使用。</p><p>注意，<strong><font color='orange'>GDT 中第 0 个描述符不可用</font></strong> ，这是因为，如果使用的段选择子未经初始化，其值就为零，这便会访问到第 0 个段描述符继而处理器发生异常。这样就避免了忘记初始化而直接使用段选择子。</p><h3 id="font-color-red-段选择子-font"><font color='red'>段选择子</font></h3><p>我们已经知道，在保护模式下，段寄存器中装的不再是段基址，而是段选择子。段选择子索引到 GDT 表中的段描述符，然后 CPU 通过段描述符获得真实的段基址和偏址，从而进行段访问。段选择子结构如下：<br><img src="/2022/img/3未命名绘图.png" style="zoom: 67%;" /></p><ul><li><p>描述符索引：占高 13 位，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup><mo>=</mo><mn>8192</mn></mrow><annotation encoding="application/x-tex">2^{13}=8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8192</span></span></span></span> ，和 GDT 能容纳的最多描述符个数相对应。<code>索引值×8+GDT基地址</code> 就能够定位到 GDT 中的表项。</p></li><li><p>TI：Table Indicator，描述符表指示器。TI=0 时，表示描述符在 GDT 中；TI=1 时，表示描述符在 LDT 。一般设置为 0 即可。</p></li><li><p>RPL：Request Privilege Leve，请求特权级。</p><blockquote><p>RPL，RCL，RDL 的区别？</p></blockquote></li></ul><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p>用一张图来总结以上四者的关系：<br><img src="/2022/img/4未命名绘图.png" style="zoom:67%;" /></p><h3 id="font-color-red-关于-G-位和-D-B-位的疑惑-font"><font color='red'>关于 G 位和 D/B 位的疑惑</font></h3><p>前面说过，D/B 位为 0 时，表明该段模拟 16 位保护模式，段最大为 64KB 。但描述符中是 20 位段界限，即使粒度为 1 字节，最大段界限也能达到 1MB 。那么，CPU是否允许在 D/B 为 0 时，20 位段界限全部有效？或者，仅允许 16 位段界限有效（这似乎很好解释了为什么描述符中的段界限是断开的两部分）？粒度是否能为 4KB？</p><blockquote><p>文章参考：《操作系统真相还原》《x86汇编语言：从实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理地址,逻辑地址,有效地址,线性地址,虚拟地址的区别</title>
      <link href="/2022/10/31/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/10/31/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>32位保护模式概览</title>
      <link href="/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/"/>
      <url>/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-概览-font"><font color='red'>概览</font></h3><ul><li>基本工作模式</li><li>线性地址</li><li>寄存器扩展</li><li>寻址扩展</li><li>模式反转</li><li>指令扩展</li><li>全局描述符表、特权级、分页等</li></ul><h3 id="font-color-red-基本工作模式-font"><font color='red'>基本工作模式</font></h3><p>Intel 32 位处理器架构简称 IA-32，尽管 8086 是 16 位的处理器，但它也是 32 位架构内的一部分。<strong>16 位到 32 位，不单单是地址线和数据线的扩展</strong> ，实际上还有更多的部分，包括高速缓存、流水线、浮点处理部件、多处理器（核）管理、多媒体扩展、乱序执行、分支预测、虚拟化、温度和电源管理等。</p><p>80286 首次提出保护模式的概念。<strong>80286 的地址线扩充到 24 位，能够访问 16 MB的内存，但即使这样</strong> ，<strong><font color='gree'>其仍然遵守内存分段模型，即使用 [段地址+偏址] 方式来访问内存，这是<u>整个 IA-32 的基因</u></font></strong> 。在保护模式下，<strong><font color='orange'>段寄存器中存放的不再是段地址，而是段选择子，段选择子映射到段描述符，段描述符中记录了段基址和段界限以及各种权限</font>。</strong> 同时，<strong><font color='orange'>访问内存也不再需要将段地址向左移动四位，而是直接将段地址和偏移地址相加</font></strong> 。这样一来，段地址就无须位于 16 字节对齐的地方，而可以在 16 MB内存的任何角落。<strong>然而，80286 的偏移地址仍被限制在 64KB</strong> ，对段长度的限制阻碍了 80286 的应用，这是其最大的败笔。</p><blockquote><p>虽然段地址可以不在 16 字节对齐的地方，但对齐有利于提高 CPU 寻址的效率。实际操作时，仍然会对齐。</p></blockquote><p>80386 是划时代的，它的地址线和寄存器扩充到了 32 位，能够访问 4GB 的内存，其偏移地址也能达到 4GB！<strong>但如前文所说，分段是 IA-32 的基因，80386 也使用 [段地址+偏址] 方式来访问内存</strong> 。在 32 位模式下，处理器要求在加载程序时，先定义该程序所拥有的段(段描述符)，然后才允许使用这些段。定义段时，除了基地址外，还附加了段界限、特权级别、类型等属性，当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。80386 及其后续的 32 位处理器都兼容实模式，<u>而且在刚加电启动时，这些处理器都位于实模式下，只有经过一番设置后才会进入保护模式</u> 。</p><p>需要强调的是，<strong><font color='orange'>实模式并不是说 32 位的 CPU 退化成了 16 位的 CPU，即使是在实模式下，其也能够使用 32 位 CPU 的资源</font></strong> 。也就是说，32 位 CPU 在 16 位实模式下，其本质仍然是 32 位 CPU，仍具备操作 32 位寄存器和 32 位操作数的能力！另外，<u>不存在 32 位实模式</u>（只能说32位 CPU 下的实模式）。</p><blockquote><p>可以这么说：实模式一般指 8086 工作模式，而 32 位 CPU 的实模式是 8086 工作模式的扩展。</p></blockquote><h3 id="font-color-red-线性地址-font"><font color='red'>线性地址</font></h3><p>IA-32 支持多任务，在多任务环境下，操作系统会给每个任务分配内存空间。在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。<strong>时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务</strong>。为了解决这个问题，IA-32 处理器支持分页功能， 分页功能将物理内存空间划分成逻辑上的页。<strong>页的大小是固定的，一般为 4KB，通过使用页，可以 简化内存管理</strong> 。当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（Linear  Address），线性地址还要经页部件转换后，才是物理地址。</p><p>段的管理是由处理器的段部件负责进行的，段部件将段地址和偏移地址相加，得到访问内存的地址。<strong><font color='orange'>不开启分页时，段部件产生的地址就是物理地址</font></strong> 。<strong><font color='orange'>当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址（Linear  Address），线性地址还要经页部件转换后，才是物理地址</font></strong> 。</p><p>注意，<strong>线性地址是用来<font color='orange'>描述任务的地址空间</font>的一种概念</strong> ，IA-32 处理器上的<strong>每个任务都拥有 4GB 的虚拟内存空间</strong> ，这是一段长 4GB 的平坦空间（平坦模型），就像一段平直的线段，因此叫线性地址空间。详细内容将在后续博客中讨论。</p><blockquote><p><strong><font color='gree'>平坦模型一定在分页机制下运行，分页机制是内存平坦模型的基础</font></strong> 。</p></blockquote><h3 id="font-color-red-寄存器扩展-font"><font color='red'>寄存器扩展</font></h3><ol><li>16 位下的 8 个通用寄存器被扩展到 32 位：eax，ebx，ecx，edx，esp，ebp，edi，esi；就如前文所说，即使在实模式下也可以使用这些 32 位寄存器。注意：1）指令的源操作数和目的操作数必须有相同的长度；2）<strong>32 位通用寄存器的高 16 位不可独立使用</strong> ，低 16 位保持对 16 位处理器的兼容。</li><li>标志寄存器 FLAGS 由 16 位扩展到 32 位 EFLAGS，低 16 位与之前保持一致，见汇编入门一文；高 16 位将在后续文章阐述。</li><li>段寄存器仍为 16 位，但其中不再存放段基址，而是存放 16 位的段选择子。<strong>增添了两个新段寄存器：FS，GS</strong> 。</li><li><strong>每个段寄存器都包含一个 64 位的不可见部分，称为描述符高速缓存寄存器</strong> ，其中装着被整理后的段描述符。引入该寄存器的原因是：1）段描述符在内存中，获取较慢；2）段描述符中，段基址被分成 3 部分，段界限被分成两部分，CPU 无法直接使用，需要整理放入寄存器后才能供CPU使用。</li></ol><h3 id="font-color-red-寻址扩展-font"><font color='red'>寻址扩展</font></h3><p>实模式的内存寻址方式：<br><img src="/2022/img/IMG_0496(20221031-144326).PNG" style="zoom: 50%;" /><br>32 位 CPU 的寻址方式：<br><img src="/2022/img/IMG_0497(20221031-144451).PNG" style="zoom:50%;" /></p><p>可见，32 位保护模式允许所有通用寄存器作为 <strong>基址寄存器</strong> ，除 ESP 之外的所有通用寄存器也可以作为 <strong>变址寄存器</strong> ，同时变址寄存器还能够乘上固定的比例因子。注意，<u>实模式下不能使用 SP 作为基址寄存器，而 32 位保护模式下可以使用 ESP 作为基址寄存器</u> 。</p><h3 id="font-color-red-模式反转-font"><font color='red'>模式反转</font></h3><p>IA-32 的指令格式：</p><table><thead><tr><th>前缀</th><th>操作码</th><th>寻址方式和操作类型</th><th>立即数</th><th>偏移量</th></tr></thead></table><p>以上格式起源于 16 位处理器，32 位处理器在此基础上扩展了数据的宽度，其他基本保持不变。虽然 32 位采用的是和 16 位相同的指令格式，<strong>但寻址方式和寄存器的定义却是另起炉灶的</strong> 。考虑如下机器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8B 50 02</span><br></pre></td></tr></table></figure><p>其对应的 16 位指令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dx,[bx+si+0x02]</span><br></pre></td></tr></table></figure><p>其对应的 32 位指令位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,[eax+0x02]</span><br></pre></td></tr></table></figure><p>所以说，<strong><font color='orange'>相同的机器代码在两种模式下可能对应着不同的指令</font></strong> 。而我们在前文中已经反复强调，在32位 CPU 的实模式中仍然可以使用 32 位寄存器，那么问题来了，对于机器代码 <code>8B 50 02</code> ，CPU 怎么知道将它翻译成 16 位指令还是 32 位指令呢？为解决此问题，编写程序时必须使用 bits 关键字指定运行环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#有无[]都可</span><br><span class="line">bits 16</span><br><span class="line">[bits 16]</span><br><span class="line">bits 32</span><br><span class="line">[bits 32]</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>如果不指定，则默认为 [bits 16]</font></strong>  。指定环境后，如果某条指令在 A 模式下使用了 B 模式下的寄存器，则该指令的机器码就会加上前缀 <code>0x66</code> ，来临时反转当前模式。比如在 16 位模式下，<code>inc ax</code> 的机器码为：<code>0x40</code> ，而 <code>inc eax</code> 的指令则为 <code>66 40</code> 。因此，<strong>前缀 <code>0x66</code> 具有临时反转当前模式的作用</strong> 。</p><p>值得一提的是，<strong><font color='orange'>对于 <code>mov 段寄存器,通用寄存器</code> 这样的指令，在 16 位和 32 位模式下的机器码完全相同</font></strong>。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">mov ds,ax</span><br><span class="line">[bits 32]</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>这两条指令的机器码都为 <code>8E D8</code> 。为什么这样设计？因为有前缀会使处理器多花一个时钟来处理，而这样的指令很频繁，而且牵涉到内存段的访问，所以也很重要，因此它们被设计得相同。</p><h3 id="font-color-red-指令扩展-font"><font color='red'>指令扩展</font></h3><ul><li><p>对于 shl，shr 指令，在实模式下使用 cl 寄存器存储移动的位数，在 32 位保护模式下同样如此。</p></li><li><p><code>mul bx</code> ，实模式下，另一个乘数在 ax 中，积的高位放在 dx 中，低位放在 ax 中。在 32 位下，<u>积直接放在 eax 中</u>。<br><code>mul ebx</code> ，另一个乘数放在 eax 中，积的高位放在 edx，低位放在 eax 中。<br><code>div bx</code> ，实模式下，被除数高位在 dx 中，低位在 ax 中，商存放在 ax，余数放在 dx 中。<u>32 位下相同</u>。<br><code>div ebx</code> ，被除数高位放在 edx，低位放在 eax，商放在 eax，余数放在 edx。</p></li><li><p>对于 push 指令：</p><ul><li><p>立即数：<br>无论是实模式还是保护模式，压入 16 位，则栈指针减 2；压入 32 位，则栈指针减 4 。<strong>压入 8 位数据则按当前模式默认大小压入</strong> ，见下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#实模式下：</span><br><span class="line">push byte  0x1  #sp-=2</span><br><span class="line">push word  0x1  #sp-=2</span><br><span class="line">push dword 0x1  #sp-=4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#保护模式下：</span><br><span class="line">push byte  0x1  #esp-=4</span><br><span class="line">push word  0x1  #esp-=2</span><br><span class="line">push dword 0x1  #esp-=4</span><br></pre></td></tr></table></figure></li><li><p>段寄存器：<br>按当前模式的默认操作数大小压入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#实模式下：</span><br><span class="line">push es #sp-=2</span><br><span class="line">#保护模式下：</span><br><span class="line">push es #sp-=4</span><br></pre></td></tr></table></figure></li><li><p>通用寄存器和内存：</p><p>无论在保护模式还是实模式，如果压入 16 位，则栈指针减 2；如果压入 32 位，则栈指针减 4；</p></li></ul></li></ul><p>保护模式的其他特性如全局描述符表、特权级、分页等内容较多，也是保护模式的精髓，后续将单独记录。</p><blockquote><p>文章参考：《操作系统真相还原》《x86实模式到保护模式》<a href="https://blog.csdn.net/Zheng__Huang/article/details/122494192">分段、分页和平坦模型</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理器微架构</title>
      <link href="/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/10/30/%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-流水线-font"><font color='red'>流水线</font></h3><p>CPU 流水线技术 (pipeline) 是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令<strong>并行处理</strong> ，以加速程序运行过程的技术。采用流水线技术后，并没有加速单条指令的执行，每条指令的操作步骤一个也不能少，<strong>只是多条指令的不同操作步骤同时执行</strong> ，因而从总体上加快了指令流速度，缩短了程序执行时间。</p><p>比如，假设执行一条指令需要经过如下步骤：1）取指令；2）译码；3）执行。如果按 <strong><font color='orange'>串行</font></strong> 方式来运行指令，如下：<br><img src="/2022/img/IMG_0489(20221030-190533).PNG" style="zoom:67%;" /></p><p>可见，每执行一个指令，就需要 3 个时钟。要知道，<strong>完成各个操作的单元是相互独立的、<font color='orange'>并行</font>的</strong> ，译码时，取指令单元就处于等待中；执行时，取指令单元和译码单元就处于空闲。所以，要想加快 CPU 执行速度，就不能让这些单元处于空闲，要让它们忙起来。流水线工作方式就是让这些单元并行，如下：<br><img src="/2022/img/IMG_0490(20221030-191339).PNG" style="zoom:67%;" /></p><p>以上是一个简单的三级流水线，而奔腾 CPU 可是达到了惊人的 32 级流水线，这是怎么做到的呢？很简单，就是 <strong><font color='orange'>不断地细分这些操作，让更多的微操作并行处理</font></strong> 。显然，流水线级数越多，每级所花的时间越短，时钟周期就越短，指令速度越快，指令平均执行时间也就越短。</p><blockquote><p>实际上，现代处理器的流水线操作可不止以上三个，还包括：写回执行结果、寄存器分配、重命名、微操作排序、引退等。</p></blockquote><p>需要注意的是，<strong>CPU 是按<u>内存中</u>指令的顺序来填充流水线的</strong> ，当前指令和下一条指令在空间上是紧挨着的。如果当前执行的指令是 jmp，那么下一条指令已经被送上流水线译码，下下条指令已经被送上流水线取指，但问题是，jmp 后就不会执行这些指令，而是跑到其他地方执行另外的指令了，所以当前流水线就废了。所以，<strong><font color='orange'>当 CPU 遇上 jmp 指令时，就会清空流水线</font></strong> 。</p><blockquote><p><strong><font color='gree'>串行、并行：</font></strong><br><strong>并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，<u>异步是多个任务并行的前提条件</u>。</strong></p></blockquote><h3 id="font-color-red-分支预测-font"><font color='red'>分支预测</font></h3><p>当程序出现分支（if, switch）将不利于过深流水线，整条流水线可能将会无效化。<strong><font color='orange'>流水线越长，处理器在用错误的分支填充流水线时，浪费的时间越多</font></strong> 。为了缓解这个问题，1996 年的 Pentium Pro 处理器引入了分支预测技术。分支预测的核心问题就是预测某个转移条件是否成立。当然，之所以叫预测，是因为不能百分百地判断是否一定发生跳转。但从统计学的角度上来看，某些事情一旦发生，下次发生该事件的概率就比较大，一个典型例子便是循环：<code>for(int i=0;i&lt;10;i++)</code> ，i 第一次小于 10，其后 9 次都小于 10 ，这种情况就能够较为精准地预测。<br><strong>在处理器内部有一个分支预测部件，即 BTB (Branch Target Buffer)</strong>  。BTB 中记录着分支指令地址，当 CPU 遇到分支时，先用该分支地址在 BTB 中查找，如果找到相同地址的指令，则根据跳转统计信息判断是否把相应预测分支搬上流水线。如果预测失败，则清空流水线，刷新 BTB，这个代价较大。</p><h3 id="font-color-red-乱序执行-font"><font color='red'>乱序执行</font></h3><p>乱序执行（out-of-order execution）是指 CPU 采用的允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。在这种方式下，可以避免因为获取下一条程序指令所引起的处理器等待，取而代之地处理下下条可以立即执行的指令。当然，<strong><font color='orange'>这种方式必须保证指令之间不具备相关性</font></strong> 。比如，如下两行代码就不能乱序执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[10]</span><br><span class="line">mov bx,ax</span><br></pre></td></tr></table></figure><p>而如下三行代码则可以乱序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[10]</span><br><span class="line">mov dx,ax</span><br><span class="line">mov bx,cx</span><br></pre></td></tr></table></figure><p>显然，第 3 行代码和第 1、2 行无关，所以可以在第一行代码访问 [10] 内存时(较慢)，将 cx 赋值给 bx 。</p><p>可见，指令之间越不相关，就越能够乱序执行。所以当务之急便是提高指令之间的不相干性，如何做到呢？<strong><font color='orange'>同流水线的策略一样，不断细分指令，将其分成由多步组合的微操作</font></strong> 。微操作级别的指令往往具有较低的相关性，比如以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[0x10]</span><br><span class="line">push eax</span><br><span class="line">call func</span><br></pre></td></tr></table></figure><p><code>push eax</code> 可以分为两步操作：1）<code>sub esp,4</code> 2）<code>mov [esp],eax</code> 。第一步访问内存的等待时间较长，所以可在等待时执行 <code>sub esp,4</code> ；而执行完 <code>sub esp,4</code> 后，可以直接执行 <code>call func</code> ，因为此指令只需要知道 esp 的最新位置，并将其减 4，无需知道 eax 的值。所以在访问内存时，CPU 就已经通过乱序执行完成了第二行代码的一部分和第三行代码，这无疑大大地提高了 CPU 的运行效率。</p><h3 id="font-color-red-高速缓存-font"><font color='red'>高速缓存</font></h3><p>高速缓存是用来解决如 CPU 这类高速运行器件与硬件这类低速运转器件的速度不匹配问题。<strong>寄存器速度最快，原因在于它使用的是触发器，其工作速度是纳秒级别</strong> ；而硬盘是机电设备，速度最慢，工作速度一般为毫秒级。因为要等待内存(DRAM)和硬盘这样的慢速设备，CPU 的工作速度就被大大拖慢。为解决这一矛盾，就必须使用一种比内存更快的储存器作为缓冲区，使 CPU 不用等待，直接从缓冲区取走数据。于是，高速缓存应运而生。</p><blockquote><p>内存也可以用触发器实现，即 SRAM，但造价很高，一般容量只有几 MB。</p></blockquote><p>高速缓存是位于 CPU 和内存(DRAM)之间的一个静态储存器(SRAM)。<strong><font color='orange'>高速缓存的用处源于程序运行时的局部性规律</font></strong> 。比如，数据一般是在内存里集中存放的(如数组)，访问某个数据后，下次很可能就会访问临近的数据；一个数据被访问后，也很有可能再次被访问。利用这种局部性原理，可以把处理器正访问的或可能将访问的数据或指令放入高速缓存中。于是，每当 CPU 要访问内存时，就会先检索高速缓存，如果缓存中有相应内容，则可以用极快的速度取走，这称为<u>命中</u> ，反之则<u>不中</u> 。在不中的情况下，<strong>处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容</strong> 。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为<u>不中惩罚</u> 。</p><p>现代处理器一般都有多级缓存：</p><p><img src="/2022/img/20220709092100-1667177627583-3.png" alt="缓存分级"></p><h3 id="font-color-red-寄存器重命名-font"><font color='red'>寄存器重命名</font></h3><p>考虑如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[mem1]</span><br><span class="line">shl eax,3</span><br><span class="line">mov [mem2],eax</span><br><span class="line">mov eax,[mem3]</span><br><span class="line">add eax,2</span><br><span class="line">mov [mem4],eax</span><br></pre></td></tr></table></figure><p>仔细观察这几行代码，可以发现，前三行和后三行做了两件毫不相干的事，即使它们使用了相同的寄存器 eax：前三行执行乘法，后三行执行加法。所以 CPU 会为后三条指令使用另一个不同的临时寄存器来代替 eax，因此乘法和加法就能并行处理！</p><blockquote><p>注意，并不是所有类似的乘法和加法都能并行处理。上述例子的乘法仅通过左移就能实现，不需要用到加法器，而其他大多数乘法需要用到加法器，此时就不能并行处理。</p></blockquote><p>由此可以推测，当给某个寄存器通过 mov 指令赋予新值时，就大概可以判定此时发生了新的不相干事件，此时就能够使用寄存器重命名。当所有操作完成后，那个代表 eax 寄存器最终结果的临时寄存器中的内容将被回写到真实的 eax 寄存器中，这称为 <strong><u>引退</u></strong> 。</p><p>所有通用寄存器甚至段寄存器都有可能被重命名。</p><blockquote><p>文章参考：《操作系统真相还原》《x86实模式到保护模式》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘基础及其读写</title>
      <link href="/2022/10/30/%E8%AF%BB%E5%86%99%E7%A1%AC%E7%9B%98/"/>
      <url>/2022/10/30/%E8%AF%BB%E5%86%99%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-硬盘组成概述-font"><font color='red'>硬盘组成概述</font></h3><ul><li><strong>盘片</strong></li><li><strong>盘面</strong></li><li><strong>磁头</strong></li><li><strong>磁道</strong></li><li><strong>扇区</strong></li><li><strong>柱面</strong></li></ul><h4 id="font-color-gree-盘片、盘面和磁头-font"><font color='gree'>盘片、盘面和磁头</font></h4><p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，称为盘面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘面的编号和磁头编号相对应，从上到下从零开始，如最上边的盘片有 0 面和 1 面，再下一个盘片就编号为 2 面和 3 面。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。如下图：<br><img src="/2022/img/01.jpg" style="zoom:67%;" /></p><blockquote><ul><li>早期的硬盘不工作的时候，磁头停靠在靠近主轴接触盘片的表面，即线速度最小的地方，这里是一个不存放任何数据的特殊区域，称为启停区或着陆区，启停区以外就是数据区。</li><li>在硬盘的最外圈，离主轴最远的磁道称为 0 磁道，<strong>硬盘数据的存放是从最外圈 0 磁道开始的</strong> 。即硬盘数据从最外圈开始，而停止时磁头又是在最内圈启停区。</li><li>0磁道非常重要，我们知道，系统的引导程序就在 0 柱面 0 磁道 1 扇区的前 446 Bytes，后 64 字节是分区表，最后两字节是结束标志 0x55 和 0xaa。0磁道属于隐藏磁道，这个磁道的 63 个扇区属于隐藏扇区。操作系统的所有命令，除了 FDISK 以外都不能访问它们。就连格式化程序 FORMAT，对它们也无能为力。</li></ul></blockquote><h4 id="font-color-gree-扇区和磁道-font"><font color='gree'>扇区和磁道</font></h4><p>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。<strong>扇区是硬盘的最小读写单元</strong> ，<u>数据容量</u>通常是 512 字节。<strong>每个扇区包括 512 个字节的数据和扇区头</strong> ，扇区头包含本扇区的信息，主要有本扇区的磁道号、磁头号、扇区号，用来供硬盘定位机构使用。<br><img src="/2022/img/03.jpg" alt=""></p><blockquote><p>越靠外的磁道旋转的线速度越快，读取数据的速率也就越快。</p></blockquote><h4 id="font-color-gree-柱面-font"><font color='gree'>柱面</font></h4><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有 <strong>相同编号的磁道形成一个圆柱</strong> ，称之为柱面。硬盘的柱面数与一个盘面上的磁道数是相等的。 如下图：<br><img src="/2022/img/SouthEast.jpeg" alt=""><br><strong>柱面是一个用来优化数据读写的概念</strong> 。需要注意的是，硬盘读写数据是柱面顺序来读的，而不是按磁道顺序来读的。举个例子，磁头读完 0 面 0 磁道后，接着读 1 面 0 磁道，再读 2 面 0 磁道，一直将该柱面读完。我们很容易认为磁头是这样读取数据的：磁头读完 0 面 0 磁道后，接着读 0 面 1 磁道，再读 0 面 2 磁道…为什么按柱面读取数据呢？因为按柱面读取数据就会大大减少寻道时间。参见后文<a href="#%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%8F%96%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4">硬盘读取响应时间</a>。</p><h3 id="font-color-red-硬盘容量计算-font"><font color='red'>硬盘容量计算</font></h3><p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p><blockquote><p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p></blockquote><h3 id="font-color-red-硬盘读取响应时间-font"><font color='red'>硬盘读取响应时间</font></h3><ol><li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前硬盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li><li>旋转延迟：将数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于硬盘转速。普通硬盘一般都是 7200rpm，慢的 5400rpm。</li><li>数据传输时间：完成传输所请求的数据所需要的时间。</li></ol><blockquote><p>读写一次硬盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高硬盘传输效率，应着重考虑减少寻道时间和延迟时间。</p></blockquote><h3 id="font-color-red-硬盘寻址方式-font"><font color='red'>硬盘寻址方式</font></h3><p><strong><mark class="hl-label blue">CHS方式</mark> </strong><br><strong>CHS</strong> (Cylinder/Head/Sector) 方式通过柱面、磁头、扇区来定位。 由于早期硬盘的每个磁道的扇区数一样多（外圈磁颗粒稀疏），整体硬盘空间大小也不大，所以此方式比较高效。但 CHS 模式支持的硬盘容量有限，用 8bit 来存储磁头地址，用 10bit 来存储柱面地址，用 6bit 来存储扇区地址，而一个扇区共有 512 Byte，这样使用 CHS 寻址一块硬盘最大容量为 <code>256 * 1024 * 63 * 512B = 8064 MB</code>（约8.4GB）。<strong><u>CHS 下扇区从 1 开始编号</u></strong> 。</p><p><strong><mark class="hl-label blue">LBA方式</mark> </strong><br>现在很多硬盘采用同密度盘片，意味着内外磁道上的扇区数量不同，扇区数量增加，容量增加，CHS 很难定位寻址，所以 LBA 方式应运而生。在 LBA 地址中，地址不再表示实际硬盘的实际物理地址（柱面、磁头和扇区）。LBA 编址方式将 CHS 这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的物理扇区的 C/H/S 编号通过一定的规则转变为一线性的编号，系统效率得到大大提高，避免了烦琐的磁头/柱面/扇区的寻址方式。在访问硬盘时，由硬盘控制器再将这种逻辑地址转换为实际硬盘的物理地址。<strong><u>LBA 下扇区从 0 开始编号</u></strong> 。</p><h3 id="font-color-red-块-簇-font"><font color='red'>块/簇</font></h3><p>硬盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与硬盘打交道的最小单位是硬盘块。通俗的来讲，在 Windows 下如NTFS 等文件系统中叫做簇；在 Linux 下如 Ext4 等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。<br>为什么存在硬盘块？1）读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。2）分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来硬盘块的概念，在系统中认为块是最小的单位。</p><h3 id="font-color-red-page-font"><font color='red'>page</font></h3><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p><h3 id="font-color-red-扇区、块-簇、page的关系-font"><font color='red'>扇区、块/簇、page的关系</font></h3><ol><li>扇区： 硬盘的最小读写单元</li><li>块/簇： 是操作系统针对硬盘读写的最小单元</li><li>page： 是内存与操作系统之间操作的最小单元。</li></ol><p>扇区 &lt;= 块/簇 &lt;= page</p><h3 id="font-color-red-硬盘预读-font"><font color='red'>硬盘预读</font></h3><p>硬盘存取，硬盘 I/O 涉及机械操作。硬盘是由大小相同且同轴的圆形盘片组成，硬盘可以转动(各个硬盘须同时转动)。硬盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个硬盘的内容。磁头不动，硬盘转动，但磁臂可以前后动，用于读取不同磁道上的数据。磁道就是以盘片为中心划分出来的一系列同心环。磁道又划分为一个个小段，叫扇区，是硬盘的最小存储单元。</p><p>硬盘读取时，系统将数据逻辑地址传给硬盘，硬盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道——寻道，消耗的时间叫——寻道时间，硬盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫——旋转时间，这一系列操作是非常耗时。<br><strong>为了尽量减少I/O操作，计算机系统一般采取预读的方式，预读的长度一般为页（page）的整倍数</strong> 。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和硬盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和硬盘以页为单位交换数据。<strong>当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向硬盘发出读盘信号，硬盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行</strong> 。<br>计算机系统是分页读取和存储的，一般一页为4KB（8个扇区，每个扇区125B，8*125B=4KB），每次读取和存取的最小单元为一页，而硬盘预读时通常会读取页的整倍数。根据局部性原理，程序运行期间所需要的数据通常比较集中，当一个数据被用到时，其附近的数据也通常会马上被使用。由于硬盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），所以即使只需要读取一个字节，硬盘也会读取一页的数据。</p><h3 id="font-color-red-磁盘碎片-font"><font color='red'>磁盘碎片</font></h3><p>文件系统碎片是文件系统将文件内容非连续排列以方便就地修改其内容的结果。<strong>磁盘碎片会增加磁盘磁头移动频率，即增加了寻道时间，会降低磁盘读写性能，进而影响操作系统操作系统及软件性能</strong> 。另外，文件系统不能承受无限制的碎片。对现有碎片的更正称为碎片重组，是将文件和可用空间重新组织为连续区域的过程。<br><img src="/2022/img/1373708-20181204140705426-1630212745.png"  /><br><strong>需要注意的是，固态磁盘(SSD)不是真正的磁盘，也不是“旋转的”，所以没有文件碎片问题</strong> 。</p><h3 id="font-color-red-Linux-下读写硬盘-font"><font color='red'>Linux 下读写硬盘</font></h3><ol><li><p><strong>创建硬盘</strong> ：利用 Bochs 的 bximg bool 创建硬盘，在 bochs 文件夹下输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat ./build/hd.img</span><br></pre></td></tr></table></figure><p>参数解释：<br><code>-q</code> ：以静默模式创建，不会和用户交互<br><code>-hd</code> ：创建硬盘，<code>-fd</code> 创建软盘；后面的 16 笔者也不太清楚。<br><code>-func=create</code> ：表明创建硬盘。<br><code>-imgmode</code> ：硬盘类型，有 flat，sparse，growing 三种。<br><code>-secsize</code> ：硬盘大小，以 MB 为单位。<br><code>./build/hd.img</code> ：为硬盘位置及其名称。<br><strong>也可以直接输入 bximage 然后一步一步按提示创建。</strong></p></li><li><p><strong>写入硬盘</strong> ：使用 LInux 的 dd 命令写入硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./app.bin of=./hd.img bs=512 seek=100 conv=notrunc</span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>if=文件名</td><td>输入文件名，默认为标准输入。即指定源文件。</td></tr><tr><td>of=文件名</td><td>输出文件名，默认为标准输出。即指定目的文件。</td></tr><tr><td>ibs=bytes</td><td>一次读入bytes个字节，即指定一个块大小为bytes个字节。</td></tr><tr><td>obs=bytes</td><td>一次输出bytes个字节，即指定一个块大小为bytes个字节。</td></tr><tr><td>bs=bytes</td><td>同时设置读入/输出的块大小为bytes个字节。</td></tr><tr><td>cbs=bytes</td><td>一次转换bytes个字节，即指定转换缓冲区大小。</td></tr><tr><td>skip=blocks</td><td>从输入文件开头跳过blocks个块后再开始复制。</td></tr><tr><td>seek=blocks</td><td>从输出文件(硬盘)开头跳过blocks个块后再开始复制。</td></tr><tr><td>count=blocks</td><td>仅拷贝blocks个块，块大小等于ibs指定的字节数。</td></tr><tr><td>conv=&lt;关键字&gt;</td><td>关键字可以有 11 种，通常用 notrunc 就行。</td></tr></tbody></table></li></ol><blockquote><p>文章参考<a href="https://www.cnblogs.com/whl320124/articles/10063813.html">硬盘详解</a>，<a href="http://www.daileinote.com/computer/sys_about/01">硬盘介绍</a> ，<a href="https://blog.csdn.net/xd_1437/article/details/103253632">硬盘介绍</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bochs虚拟机的使用</title>
      <link href="/2022/10/27/bochs%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/27/bochs%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-bochs简介-font"><font color='red'>bochs简介</font></h3><p>bochs 是一个虚拟机（模拟器），能够完整的模拟一台计算机。详细来讲 bochs 是 X86 硬件平台的开源模拟器，完全可以通过软件来给我们提供各种所需的硬件资源。和 bochs 类似的虚拟机软件还有我们常用的 VMware、Virtuabox，但区别也是明显的。bochs 是完全依靠软件来模拟整个环境的：从启动到重启包括 PC 的外设键盘、鼠标、磁盘以及网卡等，全部都是由软件来模拟的，而其余软件则不然(部分依赖于硬件)。也就是说，bochs 可以从头到尾模拟整个硬件环境。它可以从PC机刚启动的那一刹那起就开始模拟。同时，bochs 带有强大的调试功，能够直接单步调试二进制文件，我们可以看到二进制代码在硬件上运行的每一步！<strong>后面咋们的操作系统都将由 bochs 运行</strong> 。</p><h3 id="font-color-red-bochs安装与配置-font"><font color='red'>bochs安装与配置</font></h3><blockquote><p>本自制操作系统笔记系列都在 Ubuntu 下进行，关于 Bochs 在 Windows 下的使用，可参考 <a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 一文末尾。</p></blockquote><ol><li><p>前往 <a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/">bochs官网</a> 下载 2.7 版本：<code>bochs-2.7.tar.gz</code> 。必须为 2.7 版本，后面的 bochs 配置仅对此版本有效。</p></li><li><p>安装依赖：解压后进入 bochs-2.7 目录，在终端执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx11-dev libc6-dev build-essential xorg-dev libgtk2.0-dev libreadline-dev</span><br></pre></td></tr></table></figure></li><li><p>生成配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-debugger-gui --enable-x86-debugger --enable-a20-pin --enable-fast-function-calls --enable-debugger</span><br></pre></td></tr></table></figure></li><li><p>编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>安装完毕，但此时 bochs 还只是一台裸机，无法运行。</p></li><li><p>bochsrc 配置：<br>在 bochs 目录中创建 bochsrc，写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: unmapped=<span class="literal">true</span>, biosdev=<span class="literal">true</span>, speaker=<span class="literal">true</span>, extfpuirq=<span class="literal">true</span>, parallel=<span class="literal">true</span>, serial=<span class="literal">true</span></span><br><span class="line">config_interface: textconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># display_library: x</span></span><br><span class="line"><span class="comment"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两个一起开启</span></span><br><span class="line"><span class="comment">#魔术断点：</span></span><br><span class="line">magic_break: enabled=1 </span><br><span class="line"><span class="comment">#gui调试</span></span><br><span class="line">display_library: x, options=<span class="string">&quot;gui_debug&quot;</span></span><br><span class="line"></span><br><span class="line">memory: host=32, guest=32</span><br><span class="line">romimage: file=<span class="string">&quot;/usr/local/share/bochs/BIOS-bochs-latest&quot;</span>, address=0x00000000, options=none</span><br><span class="line">vgaromimage: file=<span class="string">&quot;/usr/local/share/bochs/VGABIOS-lgpl-latest&quot;</span></span><br><span class="line">boot: disk</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"><span class="comment"># no floppya</span></span><br><span class="line">floppya: image=<span class="string">&quot;a.img&quot;</span>, status=inserted</span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=<span class="literal">true</span>, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/hd.img&quot;</span>, mode=flat</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=<span class="literal">true</span>, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=<span class="literal">false</span></span><br><span class="line">ata3: enabled=<span class="literal">false</span></span><br><span class="line">optromimage1: file=none</span><br><span class="line">optromimage2: file=none</span><br><span class="line">optromimage3: file=none</span><br><span class="line">optromimage4: file=none</span><br><span class="line">optramimage1: file=none</span><br><span class="line">optramimage2: file=none</span><br><span class="line">optramimage3: file=none</span><br><span class="line">optramimage4: file=none</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">vga: extension=vbe, update_freq=5, realtime=1</span><br><span class="line">cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0</span><br><span class="line">cpuid: level=6, stepping=3, model=3, family=6, vendor_string=<span class="string">&quot;GenuineIntel&quot;</span>, brand_string=<span class="string">&quot;              Intel(R) Pentium(R) 4 CPU        &quot;</span></span><br><span class="line">cpuid: mmx=<span class="literal">true</span>, apic=xapic, simd=sse2, sse4a=<span class="literal">false</span>, misaligned_sse=<span class="literal">false</span>, sep=<span class="literal">true</span></span><br><span class="line">cpuid: movbe=<span class="literal">false</span>, adx=<span class="literal">false</span>, aes=<span class="literal">false</span>, sha=<span class="literal">false</span>, xsave=<span class="literal">false</span>, xsaveopt=<span class="literal">false</span>, smep=<span class="literal">false</span></span><br><span class="line">cpuid: smap=<span class="literal">false</span>, mwait=<span class="literal">true</span></span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line"><span class="comment"># no gdb stub</span></span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">private_colormap: enabled=0</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment"># no cmosimage</span></span><br><span class="line"><span class="built_in">log</span>: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: action=ignore</span><br><span class="line">info: action=report</span><br><span class="line">error: action=report</span><br><span class="line">panic: action=ask</span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2, enabled=<span class="literal">false</span>, toggle=ctrl+mbutton</span><br><span class="line">speaker: enabled=<span class="literal">true</span>, mode=system</span><br><span class="line">parport1: enabled=<span class="literal">true</span>, file=none</span><br><span class="line">parport2: enabled=<span class="literal">false</span></span><br><span class="line">com1: enabled=<span class="literal">true</span>, mode=null</span><br><span class="line">com2: enabled=<span class="literal">false</span></span><br><span class="line">com3: enabled=<span class="literal">false</span></span><br><span class="line">com4: enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>接下来就需要创建硬盘，并写入 mbr 使其运行起来。详细内容参见：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a>文末。</p></li></ol><h3 id="font-color-red-bochs调试-font"><font color='red'>bochs调试</font></h3><p>后续补充。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解函数调用过程和约定</title>
      <link href="/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/"/>
      <url>/2022/10/27/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文涉及汇编知识，没有基础的朋友请移步<a href="https://jyx-fyh.github.io/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编入门</a> 。<br>本文参考：<a href="https://blog.csdn.net/doubleintfloat/article/details/78522881">为什么用0xcc初始化内存</a> ，<a href="https://blog.csdn.net/sap_jack/article/details/1041220">C/C++函数调用约定与函数名称修饰规则</a></p></blockquote><h3 id="font-color-red-函数执行流-font"><font color='red'>函数执行流</font></h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR开辟栈帧 --&gt; 分配栈内存 --&gt; 保存现场 --&gt; 代码逻辑 --&gt; 恢复现场 --&gt; 恢复栈帧  </pre></div><blockquote><p><strong>栈帧本质上是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）</strong></p></blockquote><p>我们使用 VS 反汇编以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">00041DB0  push        ebp               ;保存原函数栈底</span><br><span class="line">00041DB1  mov         ebp,esp           ;ebp指向新栈底</span><br><span class="line">00041DB3  sub         esp,0E4h          ;开辟栈帧，大小为0x0E4H</span><br><span class="line">00041DB9  push        ebx               ;6,7,8行保存现场</span><br><span class="line">00041DBA  push        esi  </span><br><span class="line">00041DBB  push        edi  </span><br><span class="line">00041DBC  lea         edi,[ebp-24h]     ;将起始地址ebp-24h填入edi</span><br><span class="line">00041DBF  mov         ecx,9             ;重复stos的次数</span><br><span class="line">00041DC4  mov         eax,0CCCCCCCCh    ;内存初始值设置为0xCCCCCCCC</span><br><span class="line">00041DC9  rep stos    dword ptr es:[edi];开始初始化内存</span><br><span class="line"></span><br><span class="line">;---------------------------------忽略以下两行代码，vs增加的调试指令</span><br><span class="line">00041DCB  mov         ecx,offset _206B94B3_源@c (01AB000h)  </span><br><span class="line">00041DD0  call        @__CheckForDebuggerJustMyCode@4 (041307h)  </span><br><span class="line">;--------------------------------------------------------------</span><br><span class="line">int a = 1;</span><br><span class="line">00041DD5  mov         dword ptr [a],1   ;a是vs转换后的结果,方便我们查看,实际上a为[ebp-8]</span><br><span class="line">int b = 2;</span><br><span class="line">00041DDC  mov         dword ptr [b],2   ;实际上b为[ebp-14h]</span><br><span class="line">int c = add(1, 2);</span><br><span class="line">00041DE3  push        2                 ;压入形参</span><br><span class="line">00041DE5  push        1  </span><br><span class="line">00041DE7  call        _add (04139Dh)    </span><br><span class="line">00041DEC  add         esp,8             ;外平栈</span><br><span class="line">00041DEF  mov         dword ptr [c],eax ;将返回值赋值给c,c实际为[ebp-20h]</span><br><span class="line">return 0;</span><br><span class="line">00041DF2  xor         eax,eax           ;返回值为0</span><br><span class="line">&#125;</span><br><span class="line">000A17E4  pop         edi  </span><br><span class="line">000A17E5  pop         esi  </span><br><span class="line">000A17E6  pop         ebx  </span><br><span class="line">000A17E7  add         esp,0E4h  </span><br><span class="line">000A17ED  cmp         ebp,esp  </span><br><span class="line">000A17EF  call        __RTC_CheckEsp (0A1235h)  </span><br><span class="line">000A17F4  mov         esp,ebp  </span><br><span class="line">000A17F6  pop         ebp  </span><br><span class="line">000A17F7  ret  </span><br><span class="line">;=============================================================</span><br><span class="line">int add(int a, int b)                   ;与上类似，不再注释</span><br><span class="line">&#123;</span><br><span class="line">00FB1750  push        ebp  </span><br><span class="line">00FB1751  mov         ebp,esp  </span><br><span class="line">00FB1753  sub         esp,0C0h  </span><br><span class="line">00FB1759  push        ebx  </span><br><span class="line">00FB175A  push        esi  </span><br><span class="line">00FB175B  push        edi  </span><br><span class="line">00FB175C  mov         edi,ebp  </span><br><span class="line">00FB175E  xor         ecx,ecx  </span><br><span class="line">00FB1760  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FB1765  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FB1767  mov         ecx,offset _206B94B3_源@c (0FBC000h)  </span><br><span class="line">00FB176C  call        @__CheckForDebuggerJustMyCode@4 (0FB130Ch)  </span><br><span class="line">return a + b;</span><br><span class="line">00FB1771  mov         eax,dword ptr [a]  ;[ebp+8]</span><br><span class="line">00FB1774  add         eax,dword ptr [b]  ;[ebp+0Ch]</span><br><span class="line">&#125;</span><br><span class="line">00FB1777  pop         edi  </span><br><span class="line">00FB1778  pop         esi  </span><br><span class="line">00FB1779  pop         ebx  </span><br><span class="line">00FB177A  add         esp,0C0h  </span><br><span class="line">00FB1780  cmp         ebp,esp  </span><br><span class="line">00FB1782  call        __RTC_CheckEsp (0FB1235h)  ;上行和本行，检查堆栈平衡(ebp==esp)</span><br><span class="line">00FB1787  mov         esp,ebp  </span><br><span class="line">00FB1789  pop         ebp  </span><br><span class="line">00FB178A  ret  </span><br></pre></td></tr></table></figure><p>分析：</p><ol><li><p>虽然开辟了 0xe4 的空间，但仅初始化了 0x24 个字节的内存。</p></li><li><p>为什么要用 0xcc 初始化内存？</p><blockquote><p>x86系列处理器从其第一代产品英特尔8086开始就提供了一条专门用来支持调试的指令，即 INT 3,其机器码就是我们熟悉的0XCC，转换成十进制为-858993460，转换成汉字就是“烫”。简单地说，这条指令的目的就是使CPU中断（break）到调试器，以供调试者对执行现场进行各种分析。<strong>如果因为缓冲区或堆栈溢出时程序指针意外指向了这些区域，那么便会因为遇到INT 3指令而马上中断到调试器</strong> 。<strong>debug 模式才会用 0xcc 初始化内存</strong> 。</p></blockquote></li><li><p>第 9 行 lea 指令比 mov 指令更方便。以下两种方式等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea   edi,[ebp-24h]</span><br><span class="line">;=================================</span><br><span class="line">sub   ebp,24h</span><br><span class="line">mov   edi,ebp</span><br></pre></td></tr></table></figure></li><li><p>第 12 行：stos指令，它的功能是将 eax 中的数据放入的 edi 所指的地址中 ，同时，edi 会增加 4 个字节，rep 使指令重复执行 ecx 中填写的次数。</p></li><li><p>第 59 行，<strong><font color='gree'>eax 寄存器通常用来装载返回值</font></strong> 。</p></li><li><p>第 10 行用到了 ecx，那么为啥保存现场时没 push ecx 呢？这涉及到 ABI 规则，参见另一篇文章<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C和汇编混合编程</a>。</p></li><li><p>第 26 行，由于之前 push 了两个参数，<strong>现在要恢复栈状态以保持堆栈平衡，所以必须平栈</strong> ，此处 __cdecl 采用外平栈。内平栈方式见文末。</p></li><li><p>第 19，21，56，57 行代码，可以看出编译器 <strong><font color='gree'>通过 EBP 来访问形参和创建局部变量</font></strong> 。  为啥用 EBP 定位？因为 EBP 指向栈底，固定不动，而 ESP 指向栈顶，会发生浮动，所以 EBP 才能作为基准。</p></li><li><p><strong>第 36 行的 <code>__RTC_CheckEsp</code> 函数是用来检测堆栈平衡的，即是否有 ESP=EBP</strong> 。</p></li></ol><p>结合上面代码及其注释，给出如下堆栈图（绿色箭头为 ESP，红色箭头为 EBP）：<br><img src="/2022/img/未命名绘图-1667179108102-1.png" style="zoom:67%;" /><br>可见，EBP 永远指向当前(被调)函数的栈底，而当前栈底保存的永远是调用函数栈底。</p><h3 id="font-color-red-调用约定-font"><font color='red'>调用约定</font></h3><p>C/C++ 调用约定和平台相关，不同平台有不同调用方式，常见有如下几种：</p><table><thead><tr><th>调用方式</th><th>平台</th><th>传参方式</th><th>平栈方</th></tr></thead><tbody><tr><td>__stdcall (pascal)</td><td>Windows API</td><td>压栈传参，从右向左</td><td>内平栈（被调用者）</td></tr><tr><td>__cdel</td><td>C/C++默认方式；<br />可变参函数必须使用此方式</td><td>压栈传参，从右向左</td><td>外平栈（调用者）</td></tr><tr><td>__fastcall</td><td>Linux 下默认</td><td>32位：用 ECX 和 EDX 传送右两个参数，其余栈传递<br />64位：右六个参数用寄存器传参，其他用栈传。<br />栈传递仍从右向左。</td><td>Linux:外平栈<br />Windows:内平栈</td></tr><tr><td>__thiscall</td><td>C++ 成员函数</td><td>参数个数确定：this指针通过通过 ECX 传递给被调用者；<br />如果参数个数不确定：this指针在所有参数压栈后被压入堆栈</td><td>参数个数确定：内平栈<br />参数个数不定：外平栈</td></tr></tbody></table><blockquote><p>使用 C/C++ 语言开发软件的程序员经常碰到这样的问题：有时候是程序编译没有问题，但是链接的时候总是报告函数不存在（经典的LNK 2001错误），有时候是程序编译和链接都没有错误，但是只要调用库中的函数就会出现堆栈异常。这些现象通常是出现在 C 和 C++ 的代码混合使用的情况下或在 C++ 程序中使用第三方的库的情况下（不是用C++语言开发的），其实这都是函数调用约定（Calling Convention）和函数名修饰（Decorated Name）规则惹的祸。函数调用方式决定了函数参数入栈的顺序，是由调用者函数还是被调用函数负责清除栈中的参数等问题，而函数名修饰规则决定了编译器使用何种名字修饰方式来区分不同的函数，如果函数之间的调用约定不匹配或者名字修饰不匹配就会产生以上的问题。具体场景请参考<a href="https://jyx-fyh.github.io/2022/11/16/%E6%B5%85%E6%9E%90C%E5%92%8C%E6%B1%87%E7%BC%96%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">C和汇编混合编程</a> 。</p></blockquote><p><strong><mark class="hl-label blue">C语言编译时函数名修饰约定规则</mark> </strong></p><table><thead><tr><th>调用惯例</th><th>名字修饰</th></tr></thead><tbody><tr><td>cdecl</td><td>下划线+函数名， 如函数 max() 的修饰名为 <code>_max</code></td></tr><tr><td>stdcall</td><td>下划线+函数名+@+参数的字节数， 如函数 int max(int m, int n) 的修饰名为 <code>_max@8</code></td></tr><tr><td>fastcall</td><td>@+函数名+@+参数的字节数，如 int add(int c,int b,int c) 的修饰名为 <code>@add@12</code></td></tr></tbody></table><p><strong><mark class="hl-label blue">C++编译时非成员函数函数名修饰约定规则</mark> </strong><br>C++的函数名修饰规则有些复杂，但是信息更充分，通过分析修饰名不仅能够知道函数的调用方式，返回值类型，参数个数甚至参数类型。<strong><font color='gree'>在 Visual C++ 下</font></strong> ，不管_cdecl，_fastcall还是_stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。对于_stdcall方式，参数表的开始标识是 <code>@@YG</code>，对于_cdecl方式则是 <code>@@YA</code> ，对于_fastcall方式则是 <code>@@YI</code> 。参数表后以 <code>@Z</code> 标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。参数表的拼写代号如下所示：</p><table><thead><tr><th>X</th><th>D</th><th>E</th><th>F</th><th>H</th><th>I</th><th>J</th><th>K</th><th>M</th><th>N</th><th>_N</th><th>U</th></tr></thead><tbody><tr><td>void</td><td>char</td><td>unsigned char</td><td>short</td><td>int</td><td>unsigned int</td><td>long</td><td>unsigned long</td><td>float</td><td>double</td><td>bool</td><td>struct</td></tr></tbody></table><p><strong>函数参数表的第一项实际上是表示函数的返回值类型</strong> 。举例如下：</p><table><thead><tr><th>函数原型</th><th>生成函数名</th></tr></thead><tbody><tr><td><strong>int __cdecl add(int a, int b)</strong></td><td><strong>?mul@@YGHHH@Z</strong></td></tr><tr><td><strong>int __fastcall sub(int a, int b)</strong></td><td><strong>?sub@@YIHHH@Z</strong></td></tr><tr><td><strong>int __stdcall mul(int a, int b)</strong></td><td><strong>?add@@YAHHH@Z</strong></td></tr></tbody></table><p><strong><code>HHH</code></strong> ：第 1 个 H 表示返回值为 int，第 2、3 个 H 表示两个参数的类型为 int。</p><p><strong>指针的方式有些特别，用 PA 表示指针，用 PB 表示 const 类型的指针</strong> 。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。如下：</p><table><thead><tr><th>函数原型</th><th>生成函数名</th></tr></thead><tbody><tr><td><em><em>int __cdecl add(int</em> a, int</em> b)**</td><td><strong>?sub@@YIHPBH0@Z</strong></td></tr><tr><td><em><em>int __fastcall sub(const int</em> a,const int</em> b)**</td><td><strong>?add@@YAHPAH0@Z</strong></td></tr></tbody></table><p><strong>U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束</strong> ，如果相同类型的结构体连续出现，以“0”代替，一个“0”代表一次重复，如下：</p><table><thead><tr><th>函数原型</th><th><strong>生成函数名</strong></th></tr></thead><tbody><tr><td><strong>int __cdecl add(stu a, stu b)</strong></td><td><strong>?add@@YAHUstu@@0@Z</strong></td></tr></tbody></table><p><strong><mark class="hl-label blue">C++编译时成员函数函数名修饰约定规则</mark> </strong><br>函数名字和参数表之间插入以“@”字符引导的类名；其次是参数表的开始标识不同，公有（public）成员函数的标识是 <code>@@QAE</code> ，保护（protected）成员函数的标识是 <code>@@IAE</code> ，私有（private）成员函数的标识是 <code>@@AAE</code>，如果函数声明使用了 const 关键字，则相应的标识应分为 <code>@@QBE</code> ，<code>@@IBE</code> 和 <code>@@ABE</code> 。如果参数类型是实例的引用，则使用 <code>AAH</code> ，对于 const 类型的引用，则使用 <code>ABH</code> 。</p><blockquote><p>注意，以上仅是 Visual C++ 编译器下的修饰规则，gcc 则是另一套规则。记是记不住的，这辈子都记不住，只需大概了解即可。</p></blockquote><h3 id="font-color-red-平栈方式-font"><font color='red'>平栈方式</font></h3><p>平栈方式分为内平栈(被调用者平栈)和外平栈(调用栈平栈)。内平栈已在上述代码中分析过，下面我们观察外平栈的方式。之前的代码默认采用的 __cdecl ，下面代码显式采用 __stdcall，其他代码不变，汇编如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00611750</span>  push        ebp  </span><br><span class="line"><span class="number">00611751</span>  mov         ebp,esp  </span><br><span class="line"><span class="number">00611753</span>  sub         esp,<span class="number">0</span>C0h  </span><br><span class="line"><span class="number">00611759</span>  push        ebx  </span><br><span class="line"><span class="number">0061175</span>A  push        esi  </span><br><span class="line"><span class="number">0061175B</span>  push        edi  </span><br><span class="line"><span class="number">0061175</span>C  mov         edi,ebp  </span><br><span class="line"><span class="number">0061175</span>E  xor         ecx,ecx  </span><br><span class="line"><span class="number">00611760</span>  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">00611765</span>  rep stos    dword ptr es:[edi]  </span><br><span class="line"><span class="number">00611767</span>  mov         ecx,offset _206B94B3_源@c (<span class="number">061</span>C000h)  </span><br><span class="line"><span class="number">0061176</span>C  call        @__CheckForDebuggerJustMyCode@<span class="number">4</span> (<span class="number">061130</span>Ch)  </span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="number">00611771</span>  mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00611774</span>  add         eax,dword ptr [b]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00611777</span>  pop         edi  </span><br><span class="line"><span class="number">00611778</span>  pop         esi  </span><br><span class="line"><span class="number">00611779</span>  pop         ebx  </span><br><span class="line"><span class="number">0061177</span>A  add         esp,<span class="number">0</span>C0h  </span><br><span class="line"><span class="number">00611780</span>  cmp         ebp,esp  </span><br><span class="line"><span class="number">00611782</span>  call        __RTC_CheckEsp (<span class="number">0611235</span>h)  </span><br><span class="line"><span class="number">00611787</span>  mov         esp,ebp  </span><br><span class="line"><span class="number">00611789</span>  pop         ebp  </span><br><span class="line"><span class="number">0061178</span>A  ret         <span class="number">8</span>  </span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">006117</span>A0  push        ebp  </span><br><span class="line"><span class="number">006117</span>A1  mov         ebp,esp  </span><br><span class="line"><span class="number">006117</span>A3  sub         esp,<span class="number">0E4</span>h  </span><br><span class="line"><span class="number">006117</span>A9  push        ebx  </span><br><span class="line"><span class="number">006117</span>AA  push        esi  </span><br><span class="line"><span class="number">006117</span>AB  push        edi  </span><br><span class="line"><span class="number">006117</span>AC  lea         edi,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">006117</span>AF  mov         ecx,<span class="number">9</span>  </span><br><span class="line"><span class="number">006117B</span>4  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">006117B</span>9  rep stos    dword ptr es:[edi]  </span><br><span class="line"><span class="number">006117B</span>B  mov         ecx,offset _206B94B3_源@c (<span class="number">061</span>C000h)  </span><br><span class="line"><span class="number">006117</span>C0  call        @__CheckForDebuggerJustMyCode@<span class="number">4</span> (<span class="number">061130</span>Ch)  </span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="number">006117</span>C5  mov         dword ptr [a],<span class="number">1</span>  </span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="number">006117</span>CC  mov         dword ptr [b],<span class="number">2</span>  </span><br><span class="line"><span class="type">int</span> c = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">006117</span>D3  push        <span class="number">2</span>  </span><br><span class="line"><span class="number">006117</span>D5  push        <span class="number">1</span>  </span><br><span class="line"><span class="number">006117</span>D7  call        _add@<span class="number">8</span> (<span class="number">0611104</span>h)  </span><br><span class="line"><span class="number">006117</span>DC  mov         dword ptr [c],eax  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">006117</span>DF  xor         eax,eax  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">006117E1</span>  pop         edi  </span><br><span class="line"><span class="number">006117E2</span>  pop         esi  </span><br><span class="line"><span class="number">006117E3</span>  pop         ebx  </span><br><span class="line"><span class="number">006117E4</span>  add         esp,<span class="number">0E4</span>h  </span><br><span class="line"><span class="number">006117</span>EA  cmp         ebp,esp  </span><br><span class="line"><span class="number">006117</span>EC  call        __RTC_CheckEsp (<span class="number">0611235</span>h)  </span><br><span class="line"><span class="number">006117F</span>1  mov         esp,ebp  </span><br><span class="line"><span class="number">006117F</span>3  pop         ebp  </span><br><span class="line"><span class="number">006117F</span>4  ret  </span><br></pre></td></tr></table></figure><p>观察到第 27 行，<code>ret 8</code> ，这条指令很奇怪，因为我们以前都是直接 <code>ret</code> ，怎么这个 ret 后面还有数字？这其实就是内平栈，该指令的作用相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop  eip </span><br><span class="line">pop  cs</span><br><span class="line">add  esp,8</span><br></pre></td></tr></table></figure><p>最后的 <code>add esp,8</code> 就起到了平栈的作用。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言, 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析重定位——程序加载器/vstart解析</title>
      <link href="/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文通过汇编来阐述重定位的原理，不了解汇编的同学请先移步 <a href="https://jyx_aha.gitee.io/hexo/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">汇编语言入门指南</a> 。<br>本文参考李忠先生的《x86汇编语言：从实模式到保护模式》，若需了解详情，可移步本书（书上的例子较难，本文例子经过了简化）。<br>另外，本文仅在实模式下，通过汇编来描述重定位的基本过程，实际程序的重定位肯定更加复杂，如果想深刻了解程序的加载过程，请阅读神书《链接，装载与库》。<br>本文参考：《操作系统真相还原》《汇编语言第四版》《x86汇编语言：从实模式到保护模式》，<a href="https://blog.csdn.net/m0_37570820/article/details/79403382">程序的加载</a></p></blockquote><p>需要注意的是，编译软件必须使用 nasm，不可使用 masm。原因是 nasm 可以生成 .bin 文件，.bin 文件是纯二进制文件，可以直接输入到 CPU 运行，不像 elf 或 pe 文件那样有许多描述信息。 <strong>可执行文件中包含描述信息和指令</strong> ，这些描述信息就是我们重点要说的内容，而 masm 会自动生成描述信息，掩盖了这样过程，不利于我们探究重定位；相反，nasm 可以由我们自己来规划描述信息。废话不多说，让我们开始吧。</p><h3 id="font-color-red-vstart-和-section-xxx-start-究竟是什么？-font"><font color='red'>vstart 和 section.xxx.start 究竟是什么？</font></h3><p><strong><mark class="hl-label blue">前置结论</mark> </strong><br>很多朋友学习 nasm 时，都会对这两个关键词产生疑惑，最大的原因在于没有实际的应用场景，无法仔细体会其中的用处。后面当我们手写加载器和用户程序头部时，大家就会明白其中的奥秘。现在先让我们大概理解这两个关键词的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#代码没有意义，仅作演示</span><br><span class="line">section code1 align=16</span><br><span class="line">mov ax,bx</span><br><span class="line">section code2 align=16</span><br><span class="line">mov bx,ax</span><br><span class="line">section data align=16</span><br><span class="line">db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>使用 <code>align=16</code> 使 section 以 16 位对齐。以上代码生成的二进制文件如下：<br><img src="/2022/img/image-20221031090603921.png" alt=""></p><p>接着，我们交换 <code>code1</code> 段和 <code>code2</code> 段的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code2 align=16</span><br><span class="line">mov bx,ax</span><br><span class="line">section code1 align=16</span><br><span class="line">mov ax,bx</span><br><span class="line">section data align=16</span><br><span class="line">db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应二进制代码如下：<br><img src="/2022/img/image-20221031090709540.png" alt=""><br>可以发现，第一行二进制代码和第二行互换了位置。由此我们知道， <strong><font color='orange'>.asm 汇编文件和其生成的 .bin 二进制文件是完全一一对应的关系，.bin 中的代码在内存的布局和 .asm 中的代码布局相同</font></strong> 。这是我们得到的第一个结论。下面继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">mov ax,s</span><br><span class="line">section data align=16</span><br><span class="line">s:db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应代码如下：<br><img src="/2022/img/image-20221031090803933.png" alt=""></p><p>由 <code>B8 10</code> 可知，标号 S 的地址为 <code>0x10</code> ，恰好能和第二行代码的地址对应。由此我们得到第二个结论： <strong><font color='orange'>编译器给 .bin 程序中各符号分配的地址，就是各符号相对于 .asm 文件开头的偏移量</font></strong> 。</p><p><strong><mark class="hl-label blue">vstart</mark> </strong><br>对代码做如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section code1 align=16</span><br><span class="line">mov ax,s</span><br><span class="line">section data align=16 vstart=0</span><br><span class="line">s:db &#x27;hello&#x27;</span><br></pre></td></tr></table></figure><p>对应二进制代码如下：<br><img src="/2022/img/image-20221031090858316.png" alt=""><br><code>B8 10</code> 变成了 <code>B8 00</code> ，可见，<code>vstart</code> 关键字改变了 S 标号的汇编地址，原本 S 标号的地址是此标号相对于文件开头的偏移量，而现在 S 标号的地址是以 data 段为起点的偏移量。换句话说， <strong><font color='red'><code>vstart</code> 能够使段内所有标号的汇编地址都以此段的开头处计算，而非以整个程序的开头(即.asm文件开头)计算！</font></strong></p><p>注意！听完上述 vstart 的作用后，我们很容易认为 vstart 能够告诉编译器将程序加载到某个固定的 <strong>偏移</strong> 地址，这么一看，编译器似乎具备了加载器的功能。其实不然，vstart 的作用仅仅是告诉编译器：“嘿，老兄，请你把我后面定义的 <strong>标号地址</strong> 从xxx为起点开始编址吧”，别无他用。它只负责编址，不负责加载，加载程序是加载器的事。 <strong><font color='orange'>所以，用 vstart 的时机是：我预先知道我的程序将来会被加载到某个偏移地址处</font></strong> 。拿确切的例子来说，BIOS(加载器)会将 MBR 引导程序加载到 <code>0000:7c00</code> 处，所以 MBR 程序段必须用 <code>vstart=7c00</code> 修饰（不用管段地址，段地址由加载器决定，<u>即使是加载到 1100:7c00，一样可以执行</u>）。 <strong>一般情况下使用 <code>vstart=0</code> (利于重定位)，这是因为段在内存中都以 16 位对齐，所以进入段时，偏移地址总是从零开始，如果标号的汇编地址和内存中的偏移地址不一致，就会发生错误</strong>  。来看个简单的例子吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section code align=16 vstart=8</span><br><span class="line">s:</span><br><span class="line">push cs</span><br><span class="line">push s</span><br><span class="line">mov bp,sp</span><br><span class="line">jmp dword [bp]  ;ret</span><br></pre></td></tr></table></figure><p>其二进制代码为：<code>0E 68 08 00 89 E5 66 FF 66 00</code> 。将这段程序加载到物理地址 <code>10000</code> 处，内存映像如下图：<br><img src="/2022/img/image-20221025162254596-1667178594381-1.png" alt=""></p><p>由于 <code>vstart=8</code> ，所以标号 S 代表的偏移地址也为 8，这就导致第 6 行代码 jmp 到错误位置 <code>1000:8</code> 处，然而实际应该 jmp 到 <code>1000:0</code> 处。这就是汇编地址与段内偏移地址不对应的后果。还一头雾水，不急，这个的确很绕，咋们继续，相信看完后面你就可以理解了。</p><blockquote><p>另外，<code>vstart=xxx</code> 与 <code>org xxx</code> 功能相同。</p></blockquote><p><strong><mark class="hl-label blue">section.xxx.start</mark> </strong><br><code>section.xxx.start</code> 是某段相对于程序开头的偏移量。举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">section data align=16 vstart=0</span><br><span class="line">msgdb&#x27;hello world&#x27;</span><br><span class="line">section code align=16 vstart=0</span><br><span class="line">mov ax,section.code.start</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20221031091035242.png" alt=""><br>可见，<code>section.code.start=0x10</code> ，这就是 code 段相对于文件开头的偏移量。你一定会问，这玩意儿有啥用？唯一作用就是用来重定位。怎么个玩法？请继续阅读下文。</p><h3 id="font-color-red-什么是程序加载器？-font"><font color='red'>什么是程序加载器？</font></h3><p>一个编译好的用户程序，放到磁盘中，是如何被加载到内存并运行的呢？大概的流程是加载器先把磁盘中的应用程序加载到内存并把执行权移交给应用程序。分为以下几个步骤：</p><ol><li>从磁盘读取应用程序并装入内存（加载器的作用1）。</li><li>应用程序被装入内存后需要加载器对内存中的应用程序部分地址进行重定位（加载器的作用2）。</li><li>加载器将执行权移交应用程序（加载器的作用3）。</li></ol><p>一般来说，加载器和用户程序对彼此而言都是黑盒子，它们不了解对方的功能和结构。那加载器如何启动用户程序呢？这就需要加载器和用户程序在事先协商一个接口，加载器通过接口去启动用户程序。实际的做法是，将这个接口放在每个用户程序的开头，即用户程序头部，加载器按约定从头部提取信息并完成加载。 <strong>用户程序头部在源程序中以一个段的形式出现。</strong> 用户程序头部至少要包含如下信息：</p><ol><li><strong>用户程序的尺寸</strong> ，以字节为单位。加载器需要根据其尺寸来决定读取多少个逻辑扇区。</li><li><strong>用户程序的入口</strong> ，包括段地址和偏移地址。注意，这里的段地址并不是真正的段地址，而是 <code>section.xxx.start</code> ，加载器通过这个段地址来计算出内存中真正的逻辑段地址。</li><li><strong>段重定位表及其表项个数</strong> 。用户程序中的所有段都会被重定位，并将位置记录在表中。</li></ol><h3 id="font-color-red-程序加载器的工作流程-font"><font color='red'>程序加载器的工作流程</font></h3><p>下面我们以 MBR（加载器） 加载 OBR（用户程序）为例展开讨论。</p><blockquote><p>MBR 和 OBR 和操作系统相关，概念不难，自行百度。注意，加载器和用户程序是相对概念，对于 BIOS 和 MBR，前者是加载器，后者是用户程序；对于 MBR 和 OBR，前者是加载器，后者是用户程序。可见，这是一种链式加载，各自完成指定的任务，不断交接接力棒。</p></blockquote><p><strong><mark class="hl-label blue">1.初始化和决定加载位置</mark> </strong><br>要加载一个程序，需要决定两个事情：1）从哪取：用户程序位于硬盘上的哪个逻辑扇区(<code>START_SECTOR</code>)。2）放在哪：内存中什么地方是空闲的(<code>BASE_ADDR</code>)。</p><p>将程序放在哪由操作系统决定；如何知道程序所在扇区，这个笔者暂时不清楚，暂且认为加载器能够通过某种方式获得用户程序所在扇区，我们暂不纠结这个问题，将注意力放在加载过程中。</p><p><strong><mark class="hl-label blue">2.将程序加载进内存</mark> </strong><br>知道用户程序所在硬盘中的位置后，加载器访问硬盘，将用户程序读到内存中指定的位置。不过此时程序还无法运行，因为程序中可能有多个段（代码段或数据段），要从 code_A 段跳转到 code_B 段，或在 code_A 段访问 data_C 段的数据，就必须知道相应段的段地址，这必须经过段的重定位后才能确定。</p><p><strong><mark class="hl-label blue">3.重定位</mark> </strong></p><p>重定位的操作者是加载器，提供重定位信息的是用户程序。段重定位信息由 <code>section.xxx.start</code> 和 <code>BASE_ADDR</code> 确定。加载器利用此二者计算出各个段在内存中的逻辑段地址，并将其回填到用户程序头部。</p><p><strong><mark class="hl-label blue">4.将控制权移交给用户程序</mark> </strong><br>用户程序取得控制权，接下来便可利用头部中的重定位表跳转于各个段之间。</p><p>以上是程序加载器的简单概述，下面我们结合代码来进行说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">;===============文件说明：用户程序==================================================</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    header_end:                </span><br><span class="line"> ;===============================================================================</span><br><span class="line"> ;code1——清屏并打印hello</span><br><span class="line">SECTION code_1 align=16 vstart=0</span><br><span class="line">printh:           ;打印hello    </span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ax,0xb800 ;彩色字符模式视频缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,0</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">start: ;程序入口</span><br><span class="line">mov ax,ds</span><br><span class="line">mov es,ax                  ;es作header基准,ds作用户数据段</span><br><span class="line">mov ax,es:[stack_segment]  ;设置用户的堆栈！</span><br><span class="line">mov ss,ax                    </span><br><span class="line">mov sp,stack_end   </span><br><span class="line"></span><br><span class="line">mov ax,es:[data_1_segment] ;设置用户的数据段！</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">mov ax,0x600  </span><br><span class="line">mov bx,0x700  </span><br><span class="line">mov cx,0  </span><br><span class="line">mov dx,0x184f    </span><br><span class="line">int 0x10  </span><br><span class="line">call printh    ;打印hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push word es:[code_2_segment] ;注意，是word而非dword</span><br><span class="line">push printw   </span><br><span class="line">retf                     ;转移到code_2</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">jmp $          ;在此处循环</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line"> ;code2——打印&#x27;world&#x27;</span><br><span class="line">SECTION code_2 align=16 vstart=0</span><br><span class="line">printw:</span><br><span class="line"></span><br><span class="line">mov ax,es:[data_2_segment]</span><br><span class="line">mov ds,ax </span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,80;打印world</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">push word es:[code_1_segment]</span><br><span class="line">push stop</span><br><span class="line">retf           ;返回code_1</span><br><span class="line"></span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_1 align=16 vstart=0 </span><br><span class="line">db &#x27;h&#x27;,00000111B</span><br><span class="line">db &#x27;e&#x27;,00000111B</span><br><span class="line">db &#x27;l&#x27;,00000111B</span><br><span class="line">db &#x27;l&#x27;,00000111B</span><br><span class="line">db &#x27;o&#x27;,00000111B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION data_2 align=16 vstart=0 </span><br><span class="line">db &#x27;w&#x27;,11000010B</span><br><span class="line">db &#x27;o&#x27;,11000010B</span><br><span class="line">db &#x27;r&#x27;,11000010B</span><br><span class="line">db &#x27;l&#x27;,11000010B</span><br><span class="line">db &#x27;d&#x27;,11000010B</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">times 256 db 0</span><br><span class="line">stack_end:</span><br><span class="line"> ;===============================================================================</span><br><span class="line">SECTION trail align=16 </span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">         BASE_ADDR     equ 0x10000       ;将用户程序加载到物理位置BASE_ADDR处</span><br><span class="line">         START_SECTOR  equ 100           ;BASE_ADDR的末位必须为0</span><br><span class="line">                                         ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">                                         ;常数的声明不会占用汇编地址                                    </span><br><span class="line">SECTION mbr align=16 vstart=0x7c00                                     </span><br><span class="line">         ;设置堆栈段和栈指针 </span><br><span class="line">         mov ax,0      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,ax</span><br><span class="line">         </span><br><span class="line">         mov eax,BASE_ADDR               ;eax低4位一定为0</span><br><span class="line">         mov cl ,4                       ;移动多位，必须使用cl</span><br><span class="line">         shr eax,cl                      </span><br><span class="line">         mov ds,ax                       ;令DS和ES指向该段以进行操作</span><br><span class="line">         mov es,ax                        </span><br><span class="line">    </span><br><span class="line">         ;以下读取程序的起始部分 </span><br><span class="line">         xor di,di</span><br><span class="line">         mov si,START_SECTOR             ;程序在硬盘上的起始逻辑扇区号 </span><br><span class="line">         xor bx,bx                       ;加载到DS:0x0000处 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">      </span><br><span class="line">         ;以下判断整个程序有多大</span><br><span class="line">         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 </span><br><span class="line">         mov ax,[0]</span><br><span class="line">         mov bx,512                      ;512字节每扇区</span><br><span class="line">         div bx</span><br><span class="line">         cmp dx,0</span><br><span class="line">         jnz @1                          ;未除尽，因此结果比实际扇区数少1 </span><br><span class="line">         dec ax                          ;已经读了一个扇区，扇区总数减1 </span><br><span class="line">   @1:</span><br><span class="line">         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">         jz direct</span><br><span class="line">         </span><br><span class="line">         ;读取剩余的扇区</span><br><span class="line">         push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">         mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line">   @2:</span><br><span class="line">         mov ax,ds</span><br><span class="line">         add ax,0x20                     ;得到下一个以512字节为边界的段地址</span><br><span class="line">         mov ds,ax  </span><br><span class="line">                              </span><br><span class="line">         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 </span><br><span class="line">         inc si                          ;下一个逻辑扇区 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">         loop @2                         ;循环读，直到读完整个功能程序 </span><br><span class="line"></span><br><span class="line">         pop ds                          ;恢复数据段基址到用户程序头部段 </span><br><span class="line">      </span><br><span class="line">         ;计算入口点代码段基址 </span><br><span class="line">   direct:</span><br><span class="line">         mov eax,[0x06]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [0x06],ax                   ;回填修正后的入口点代码段基址 </span><br><span class="line">      </span><br><span class="line">         ;开始处理段重定位表</span><br><span class="line">         mov cx,[0x0a]                   ;需要重定位的项目数量</span><br><span class="line">     cmp cx,0</span><br><span class="line">     jz  jmpToLoader                 ;如果为0项，直接跳转</span><br><span class="line">         mov bx,0x0c                     ;重定位表首地址</span><br><span class="line">          </span><br><span class="line"> realloc:</span><br><span class="line">         mov eax,[bx]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [bx],ax                     ;回填段的基址</span><br><span class="line">         add bx,4                        ;下一个重定位项（每项占4个字节） </span><br><span class="line">         loop realloc </span><br><span class="line"></span><br><span class="line"> jmpToLoader:     </span><br><span class="line">         jmp far [0x04]                  ;转移到用户程序  </span><br><span class="line"> </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;      DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line"></span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base:                       ;计算16位段地址</span><br><span class="line">                                         ;输入：eax低20位有效,最低4位为0</span><br><span class="line">                                         ;返回：AX=16位段基地址 </span><br><span class="line">         add eax,BASE_ADDR</span><br><span class="line">     mov cl,4</span><br><span class="line">     shr eax,cl</span><br><span class="line">         ret</span><br><span class="line">;-------------------------------------------------------------------------------         </span><br><span class="line"> times 510-($-$$) db 0</span><br><span class="line"> db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">用户程序剖析</mark> </strong></p><blockquote><p>建议读者赋值粘贴代码到 notepad++，文件格式为 .asm，这样方便代码阅读和定位（双击标号即可定位）。</p></blockquote><ul><li>头部是用户程序和加载器之间的接口，它们遵循事先规定好的约定。头部必须为单独一个 section。</li><li>第 4 行，通过 <code>program_end</code> 确定了用户程序的大小。这是如何做到的呢？注意 102 行，段定义没有 <code>vstart=0</code> ，所以该段内标号的汇编地址是从文件头开始算的，所以该标号就是文件尾相对文件的的偏移量，即文件的大小。</li><li>第 39 行是易错的地方，务必要将 ds 备份，此时 ds 是用户程序被载入内存的位置，<strong>之后访问头部时，都必须使用此值作为段基址</strong> 。用 es 保存此值，而后 ds 用来充当 data 段的段基址(比如 45 行)。</li><li>58 行，分别将 code_2 的段基址和偏移地址压栈后，使用 retf 远转移到 code_2。谁说函数调用必须用 call 或 jmp 的？这里使用 retf 的好处是跳转后不用手动清理栈。</li><li><strong><font color='gree'>注意，除了最后一个段外，每个段都必须用 <code>vstart=0</code> 修饰！这样利于段在内存中的浮动装配（重定位），这点非常重要！</font></strong></li><li><strong><font color='gree'>为什么段重定位表的表项大小为 dd，即四个字节呢？段寄存器不是才两个字节大小吗？是这样的：还没重定位的时候，这里装的就是 <code>section.xxx.start</code> ，它是 xxx 段相对于文件开头的偏移量，这个偏移量可能大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> ，所以要用 4 个字节，32 位来装。需要注意的是，<code>section.xxx.start</code> 的最低 4 位（二进制下）一定是 0，这是因为我们的每个段都使用 <code>align=16</code> 对齐，所以每个段相对于文件开头的偏移量一定是 16 的整数倍，故最低四位一定是 0。</font></strong></li></ul><p>其他内容不在赘述，注释已经比较详尽了。</p><p><strong><mark class="hl-label blue">加载器剖析</mark> </strong></p><ul><li>整个文件自成一段。mbr 段使用 <code>vstart=0x7c00</code> 修饰，原因是它知道 BIOS(MBR的加载器) 会将其加载到偏移地址为 0x7c00 的地方(0000:7c00)。</li><li>第 2，3 行相当于 C 语言中的宏定义，使用 <code>equ</code> 来进行赋值。可以将这两句放在 <code>boot.inc</code> 文件中，然后在第一行引入该文件：<code>%include 'boot.inc'</code> 。不过引入头文件这用法似乎只有在 linux 下才行。</li><li>第 24 行，简单举个例子：用户程序大小为 520 字节，除以 512，商 1 余 8，则该程序仍占用两个扇区。</li><li>第 34 行，直接将段地址加上 0x20，即向后移动 512 字节。为什么不用偏移地址加上 512 字节呢？要知道，读取硬盘的数据一般是相对较大的，很多时候都超过了 64KB，一旦超过 64KB，偏移地址就会回卷，将之前的内存覆盖。</li><li>第 11 行，实模式下可以使用 32 位寄存器，原因参见 <a href="https://jyx-fyh.github.io/2022/10/31/32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/">保护模式概览</a></li><li>第 12 行，左移或右移多位，必须将位数用 cl 装载，不能直接 <code>shr eax,4</code> 。</li></ul><p>本文对硬盘的读取不展开描述，详细请参考《x86汇编：从实模式到保护模式》第137页，《操作系统真相还原》第 131 页。</p><h3 id="font-color-red-运行-font"><font color='red'>运行</font></h3><blockquote><p>不想折腾的同学请使用 windows 平台完成运行。硬盘文件下载：<a href="https://pan.baidu.com/s/1ycMfrsJCeKlMTki0yAagnA?pwd=gzwb">链接</a>，提取码：gzwb</p></blockquote><p><strong><mark class="hl-label blue">Windows</mark> </strong><br>1）将上面的两份代码分别写入 “loader.asm” 和 “app.asm” 中。<br>2）使用 nasm 生成 .bin 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.asm -o app.bin</span><br><span class="line">nasm -f bin loader.asm -o loader.bin</span><br></pre></td></tr></table></figure><p>3）将 .bin 文件写入硬盘。通过上面的链接获取硬盘文件及其写入工具，打开 <code>fixvhdwt</code> ，硬盘选择 <code>LEECHUNG.vhd</code> ，数据文件选择 <code>loader.bin</code> ，然后写入逻辑第 0 扇区即可。重复以上步骤，将 <code>app.bin</code> 写入第 100 扇区。<br>4）在 bochs 安装目录下找到 bochsdbg.exe，打开后按下图顺序操作：<br><img src="/2022/img/image-20221031091508919.png" alt=""><br>第 7 步点击 Boot Option 后，将 boot Drive1 改成 disk 即可。<br>5)运行。点击菜单界面右上方的 start，然后在命令行输入 <code>c</code> ，虚拟机屏幕出现 hello world 即成功。</p><p><strong><mark class="hl-label blue">Linux</mark> </strong></p><p>1）先下载 bochs，参见配置过程参见 <a href="https://jyx-fyh.github.io/2022/10/27/bochs%E4%BD%BF%E7%94%A8/">bochs使用</a>。在 bochs 文件夹中打开终端，输入以下命令创建硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat ./build/hd.img</span><br></pre></td></tr></table></figure><p>2）接着在 <code>bochsrc</code> 中修改如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;./build/hd.img&quot;</span>, mode=flat</span><br></pre></td></tr></table></figure><p>3）在 bochs-2.7/build 目录下，将之前的两份代码分别写入 <code>loader.s</code> 和 <code>app.s</code> ，然后使用如下命令分别生成 .bin 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f bin app.s -o app.bin</span><br><span class="line">nasm -f bin loader.s -o loader.bin</span><br></pre></td></tr></table></figure><p>注意，可能会报错，提示 <code>app.s</code> 中有五行错误，只需将 <code>es:[xxx_segment]</code> 改为 <code>[es:xxx_segment]</code> 即可，这是 nasm 在 LInux 和 Windows 的小差别。<br>4）使用如下命令将.bin 文件写入硬盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./loader.bin of=./hd.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./app.bin of=./hd.img bs=512 count=1 seek=100 conv=notrunc  //将app写入100扇区</span><br></pre></td></tr></table></figure><p>5）在 bochs-2.7 目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc</span><br></pre></td></tr></table></figure><p>两次回车，出现如下界面：<br><img src="/2022/img/image-20221031091633667.png" alt=""><br>点击左上方的 continue，出现以下界面即为成功：<br><img src="/2022/img/image-20221031091711096.png" alt=""><br>world 后面的 F 哪来的我也很懵逼。。。</p>]]></content>
      
      
      <categories>
          
          <category> 自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自制操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make clean的必要性&amp;&amp;自动找寻头文件</title>
      <link href="/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
      <url>/2022/10/09/make-clean%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本人初学 makefile，对此问题有认识不足之处，烦请在评论区指出错误或补充您的观点，谢谢。</p></blockquote><p><strong>什么时候必须 <code>make clean</code> ？</strong><br><strong><font color='orange'>当依赖文件中没有显式写出头文件时，如果仅改动了头文件，那么必须 <code>make clean</code></font></strong> 。否则不会重新编译，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################mekefile</span></span><br><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">gcc -c ./src/add.c -o add.o</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o</span><br><span class="line"><span class="comment">#######################main.c</span></span><br><span class="line"><span class="comment">#include &quot;../header/add.h&quot;</span></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a=0;</span><br><span class="line">    int b=1;</span><br><span class="line">    int c=add(a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#######################add.c</span></span><br><span class="line"><span class="comment">#include &quot;../header/add.h&quot;</span></span><br><span class="line">int add(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#######################add.h</span></span><br><span class="line"><span class="comment">#ifndef UNTITLED_ADD_H</span></span><br><span class="line"><span class="comment">#define UNTITLED_ADD_H</span></span><br><span class="line">int add(int a,int b);</span><br><span class="line"><span class="comment">#endif //UNTITLED_ADD_H</span></span><br></pre></td></tr></table></figure><p>先 <code>make</code> 依次，成功。在 <code>make</code> 一次，提示：<code>make: 'calc.exe' is up to date.</code> 。然后将 add.h 改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNTITLED_ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNTITLED_ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNTITLED_ADD_H</span></span></span><br></pre></td></tr></table></figure><p>然后再 <code>make</code> ，仍然提示：<code>make: 'calc.exe' is up to date.</code> ，说明 make 没有检测 add.h 的变动。此时 <code>make clean</code> ，接着 <code>make</code> ，就会报错，提示函数定义和函数原型对不上号：<br><img src="../../public/2022/img/image-20221009185915392.png" alt=""></p><p>以上情况就体现了 <code>make clean</code> 的必要性。</p><p>如果想及时追踪到头文件的改动，就必须把头文件纳入依赖：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="keyword">vpath</span> %.h ./header</span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c add.h</span></span><br><span class="line">gcc -c ./src/add.c -o add.o</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o</span><br></pre></td></tr></table></figure><p>但这又会引入另一个新的问题：如果是一个比较大型的工程，你必需清楚哪些 C 文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。所以，我们可以让 make 自动找寻源文件中包含的头文件，并生成一个依赖关系。gcc/g++ 编译器有命令：<code>gcc -MM file</code> ，可以生成 <code>file</code> 文件中使用的头文件的路径，还是拿上面的例子说明：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ gcc -MM ./src/main.c</span></span><br><span class="line"><span class="section">main.o: src/main.c  src/../header/add.h</span></span><br></pre></td></tr></table></figure><p>还没学完，后续补充。。。。<br>详细内容：<a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile入门</title>
      <link href="/2022/10/09/makefile%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/09/makefile%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章参考：[陈浩-和我一起学makefile](<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">makefile介绍 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a>) ，<a href="https://pan.baidu.com/s/1JezArDcTcYFUP8_XNXFYLg?pwd=gzwb">makefile手册</a></p></blockquote><h3 id="font-color-red-什么是makefile？-font"><font color='red'>什么是makefile？</font></h3><p>想必你还听说过 <code>make</code> ，<code>cmake</code> ，<code>gcc</code> 等名词吧？我们先将这些概念区分清楚。</p><ul><li><code>gcc</code> 原本是 <code>GNU C Compiler</code> ，即 GNU 计划下诞生的 C 语言编译器，随着 gcc 支持的语言越来越多，便将其定义为 <code>GNU Compiler Collection</code> ，即 GNU 编译套件。当程序只有一个或少量的源文件时，我们可以直接使用 gcc 逐个编译。一旦源文件较多，逐个编译就显得异常麻烦了，此时就需要用到 <code>make</code> 。</li><li><code>make</code> 是一个命令工具，是一个解释 <code>makefile</code> 中指令的命令工具,它本身并没有编译和链接的功能。<code>make</code> 根据 <code>makefile</code> 中的命令调用 gcc（也可以是别的编译器）去编译指定的源文件。换一句话说，<strong>make 就是一个 gcc/g++ 的调度器，通过读入 Makefile(makefile），执行一组以 gcc/g++ 为主的命令序列，相当于一个智能的批处理工具。</strong></li><li><code>makefile</code> 文件中包含了各种源文件的依赖关系和 gcc 编译指令。<code>makefile</code> 是建筑图纸，而 <code>make</code> 是负责调度的包工头，<code>gcc</code> 则是干实事的建筑工人。<code>makefile</code> 在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写 <code>makefile</code> 也是非常麻烦的，如果换了个平台 <code>makefile</code> 又要重新修改，这时候就出现了 <code>cmake</code> 。</li><li><code>cmake</code> 可以更加简单的生成 <code>makefile</code> 文件给 <code>make</code> 用。当然 <code>cmake</code> 还有其他更牛X功能，就是可以 <strong>跨平台</strong> 生成对应平台能用的 <code>makefile</code>，我们就不用再自己去修改了。</li><li>cmake根据 <code>CMakeLists.txt</code> 生成 <code>makefile</code> 。<code>CMakeLists.txt</code> 由程序员编写。</li></ul><p><img src="/2022/img/v2-497f031761c929e5c036138f938508c6_1440w.webp" alt="概念关系图"></p><h3 id="font-color-red-书写语法-font"><font color='red'>书写语法</font></h3><p>makefile 中的一个条目称为一个“规则”。<strong>一个规则告诉“make”两件事： 1. 目标在什么情况下已经过期； 2. 如果需要重建目标时，如何去重建这个目标。</strong><br>规则的书写语法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure><ul><li><p>command是命令，它说明了如何生成 targets 文件。如果其不与 <code>target:prerequisites</code> 在一行，那么，必须以 <code>Tab</code> 键开头。<strong>Makefile 中第一个规则之后的所有以 [Tab] 开始的的行， make 程序都会将其交给系统 shell 程序去解释执行</strong> 。</p><blockquote><p>如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>prerequisites 是 targets 文件的依赖文件，也就是说，要生成 targets 文件，则前提是必须有哪些文件。</p></li><li><p>如果依赖文件或命令较多，则可以使用 <code>\</code> 作为换行符。</p></li><li><p>targets 可以是目标文件，也可以是伪目标。伪目标后续再谈。</p></li><li><p>makefile 的注释符为 <code>#</code> ，只有单行注释，没有多行注释。注意，<strong>书写 Makefile 时务必将注释作为一个独立的行，而不要和 Makefile 的有效行放在一行中书写，这将避免很多莫名其妙的错误</strong> 。<strong>另外，以[Tab]字符开始的注释行也会被交给 shell 来处理</strong> 。</p></li></ul><p>举例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">calc.exe:add.o sub.o calc.c</span></span><br><span class="line">gcc add.o sub.o calc.c -o calc.exe</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br></pre></td></tr></table></figure><h3 id="font-color-red-默认makefile文件-font"><font color='red'>默认makefile文件</font></h3><p>默认的情况下， make 会在工作目录（执行 make 的目录）下按照文件名顺序寻找 makefile 文件读取并执行，查找的文件名顺序为：“GNUmakefile”、“ makefile”、“ Makefile”。不推荐 “GNUmakefile”，因为以此命名的文件只有“ GNU make”才可以识别。推荐使用“Mkefile”，其首大写字母比较突出。<strong>当 makefile 文件的命名不是这三个任何一个时，需要通过 make 的“ -f”或者“ --file”选项来指定 make 读取的 makefile 文件</strong> 。</p><h3 id="font-color-red-执行顺序-font"><font color='red'>执行顺序</font></h3><ol><li>依次读取变量“MAKEFILES”定义的 makefile 文件列表</li><li>读取工作目录下的 makefile 文件（根据命名的查找顺序“ GNUmakefile”，“ makefile”，“ Makefile”，首先找到那个就读取那个）</li><li>依次读取工作目录 makefile 文件中使用指示符“ include”包含的文件</li><li>查找重建所有已读取的 makefile 文件的规则（如果存在一个目标是当前读取的某一个 makefile 文件，则执行此规则重建此 makefile 文件，完成以后从第一步开始重新执行）</li><li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li><li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li><li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</li><li>执行“终极目标”所在的规则</li></ol><p><strong>7,8点的含义：如果某个依赖文件（或依赖文件的依赖，一直到依赖链的底层）发生更新，那么执行 make时，目标文件就会被重新编译(执行对应的command)</strong> 。拿上面的例子来说：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make</span></span><br><span class="line">gcc  main.c add.o -o main.exe</span><br><span class="line"><span class="comment">#######改动add.c后</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc  main.c add.o -o main.exe</span><br></pre></td></tr></table></figure><p>可见，即使 <code>add.o</code> 没有变动，而 <code>add.o</code> 的依赖文件 <code>add.c</code> 发生变动，最终 <code>calc.exe</code> 也会重新编译。需要注意的是，由于 <code>sub.c</code> 没有改变，所以 <code>sub.o</code> 并不会重新编译。<strong>这样能够保证每次只编译有改动的代码，从而做到第一次编译两小时，第二次编译五分钟。否则的话，仅仅只做小改动，每次也必须要编译两小时，那就太麻烦了。</strong></p><h3 id="font-color-red-伪目标-font"><font color='red'>伪目标</font></h3><p>最典型的伪目标便是 <code>clean</code> ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf sub.o add.o </span><br></pre></td></tr></table></figure><p>若当前目录下没有 clean 这个文件，则 make clean 将正常执行。如果在当前工作目录下存在文件“clean”，情况就不一样了，同样我们输入 make clean，<strong><font color='orange'>由于这个规则没有任何依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令</font></strong>，因此命令“rm”将不会被执行。<br>伪目标仅仅只是一个标签，代表着一个动作，它无需依赖关系。“伪目标”的取名不能和文件名重名，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显式地指明一个目标是伪目标，向 make 说明，<strong>不管是否有这个文件，这个目标就是伪目标。</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanObj cleanDiff</span><br><span class="line"></span><br><span class="line">cleanObj :</span><br><span class="line">    rm -rf *.o</span><br><span class="line">cleanDiff :</span><br><span class="line">rm -rf *.diff</span><br></pre></td></tr></table></figure><p>当执行 <code>make clean</code> 时，不管 makefile 中有没有 clean 这个目标，都执行如上的伪目标。<strong>注意，依赖可以是目标，也可以是伪目标；伪目标也可以有依赖</strong> 。<strong><font color='orange'>执行伪目标时，不论伪目标是否有依赖，总是强制执行</font></strong> 。</p><blockquote><p>一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则时伪目标所定义的命令都会被执行；伪目标可以作其他伪目标的依赖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">rm -f program</span><br><span class="line">cleanobj :</span><br><span class="line">rm -f *.o</span><br><span class="line">cleandiff :</span><br><span class="line">rm -f *.diff</span><br></pre></td></tr></table></figure></blockquote><p><strong><font color='orange'>另外，当一个目标被声明为伪目标后， make 在执行此规则时不会去试图去查找隐含规则来创建它，这样也提高了 make 的执行效率</font></strong> 。</p><h3 id="font-color-red-强制目标-font"><font color='red'>强制目标</font></h3><p><strong>如果一个规则 (rule_A) 既没有依赖也没有命令，仅有目标 (Targe_A)，并且目标名不冲突，那么，在执行这个规则的时候，目标总被认为是更新过的</strong> 。如果这个目标 (Target_A) 作为另一个规则 (rule_B) 的依赖时，因为依赖总被认为更新过，那么依赖所在的规则中的命令总会被执行，即规则 (rule_B) 中的命令总会被执行。示例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: FORCE</span></span><br><span class="line">    gcc force.c -o target</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm target</span><br><span class="line"></span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure><p><code>FORCE</code> 即为强制目标（目标名不一定为 ‘FORCE’ ，习惯而已），每次执行 target，总会重新编译。</p><blockquote><p>在使用 GNU make 时，一般使用伪目标来代替这种方式。</p></blockquote><h3 id="font-color-red-终极目标-font"><font color='red'>终极目标</font></h3><p>终极目标就是当没有使用 make 命令行指定具体目标时，make 默认的更新的那一个目标，<strong>即 makefile 文件中第一个规则的目标</strong> 。“终极目标”是执行 make 的唯一目的，其所在的规则作为第一个被执行的规则。而其它的规则是在完成重建“终极目标”的过程中被连带出来的。<strong>所以这些目标所在规则在 Makefile 中的顺序无关紧要</strong> 。可以在命令行指定终极目标，如 <code>make clean</code></p><h3 id="font-color-red-通配符-font"><font color='red'>通配符</font></h3><p>gcc 支持三种通配符：<code>*</code> ，<code>?</code> ，<code>~</code> 。使用最多的是 <code>*</code> 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line">rm -rf *.o</span><br></pre></td></tr></table></figure><p>但注意，当通配符应用在 makefile 的变量(后续会讲)中时，情况有所不同：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure><p>变量 objects 并不代表所有后缀为 <code>.o</code> 的文件。objects的值就是 <code>*.o</code> (在某些情况下没有意义)！因为 Makefile 中的变量其实相当于 C/C++ 中的宏，仅仅只会在调用处展开。</p><p>Makefile 中统配符可以出现在以下两种场合：</p><ol><li><strong>可以用在规则的目标、依赖中</strong> ， make 在读取 Makefile 时会自动对其进行匹配处理（通配符展开）</li><li><strong>可出现在规则的命令中</strong> ，通配符的通配处理是在 shell 在执行此命令时完成的。</li></ol><p><strong><font color='orange'>除这两种情况之外的其它上下文中(比如定义变量)，不能直接使用通配符 ，而是需要通过函数 wildcard 来实现</font></strong> 。比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects=<span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"><span class="comment">#而objects=*.o 则表示变量“objects”的值是字符串“*.o”</span></span><br></pre></td></tr></table></figure><h3 id="font-color-red-文件搜索-font"><font color='red'>文件搜索</font></h3><p>一般情况下，我们会将各个文件分类存放，比如 <code>.h</code> ，<code>.c</code> 文件等，会分别放在 header 目录和 src 目录下。而 makefile 默认只在当前目录中寻找，所以我们需要在文件名前加上路径。但更好的方式是把这些路径告诉 make，让 make 自动去找。</p><p><strong><mark class="hl-label blue">VPATH</mark> </strong><br>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，<strong>那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件</strong>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH=src:header</span><br></pre></td></tr></table></figure><ul><li><strong>注意，<code>VPATH</code> 是大写，它是变量！。</strong></li><li><strong>目录之间由 <code>:</code> 分隔。</strong></li><li><strong>make 会从左往右依次搜寻。</strong></li><li><strong>当前目录永远是最高优先搜索的地方</strong></li></ul><p><strong><mark class="hl-label blue">vpath</mark> </strong><br>另一个设置文件搜索路径的方法是使用 make 的 “vpath” 关键字（ <strong>注意，它是全小写的</strong> ），<strong>这不是变量，这是一个make的关键字</strong> 。与 VPATH 相比，它更为灵活。它可以指定不同的文件在不同的搜索目录中。它的使用方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure><p>上述方式，优先级依次降低。比如，foo 和 bar 中都有 hello.c ，但只采用 foo 中的 hello.c。也可以像下面这种方式，更清楚明了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意，<code>vpath</code> 后没有冒号或等号，它是关键字！</strong></p></li><li><p><code>*</code> 号是 gcc 的通配符，<code>%</code> 是 makefile 下的模式符（将在模式匹配中说到）。</p></li><li><p><strong><font color='orange'>虽然已经设置了搜索路径，但这仅针对对 command 以外的其他地方，gcc 指令中仍然要加上路径</font></strong> ，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"><span class="keyword">vpath</span> %.h ./header</span><br><span class="line"></span><br><span class="line"><span class="section">calc.exe: main.c add.o</span></span><br><span class="line">gcc  ./src/main.c add.o -o calc.exe</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">gcc -c ./src/add.c -o add.o</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>依赖文件无需加路径，但 gcc 命令中必须加路径，因为 make 最后是调用的 gcc 来完成这些操作，而 vpath 仅对 make 有效，对 gcc 无效。</font></strong> 显然，这样是很繁琐的，后面我们将用自动变量来解决这个问题。</p></li></ul><h3 id="font-color-red-命令回显-font"><font color='red'>命令回显</font></h3><p>当我们执行命令时，一般会回显命令内容：<br><img src="/2022/img/image-20221009192826370.png" alt=""><br>如果不想回显命令内容，则需要在命令前加上抑制符 <code>@</code> ：<br><img src="/2022/img/image-20221009193001941.png" alt=""><br>此后执行命令就不会再回显。</p><p>如果只想看命令的内容，而不执行，带上参数 <code>-n</code> 即可：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make -n clean</span></span><br><span class="line">rm -rf *.o</span><br></pre></td></tr></table></figure><h3 id="font-color-red-命令并发-font"><font color='red'>命令并发</font></h3><p><strong>如果你要让<font color='orange'>上一条命令的结果应用在下一条命令时</font>，你应该使用分号分隔这两条命令，而不能将两个命令分别写在两行：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误写法：</span></span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen</span><br><span class="line">    pwd</span><br><span class="line"><span class="comment">#正确写法：</span></span><br><span class="line">exec:</span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure><img src="/2022/img/image-20221009200032211.png" style="zoom:67%;" /><p>可见，pwd 打印的路径并非在 header 中。为啥会这样呢？<strong><font color='orange'>这是因为：每行命令在一个单独的shell中执行，两行命令在两个不同的进程执行，这些Shell之间没有继承关系。</font></strong> 同时发现，即使执行 test 后进入了 <code>./header</code> ，但最后命令提示符仍表明我们在 <code>untitiled</code> 目录中！这说明每个命令都是单独开的一个进程来运行的，并不会影响当前进程。如果要用一个 shell 进程实现多条命令，则应该把这两条命令写在一行上，用分号分隔；如果希望把一个完整的 shell 命令行书写在多行上，需要使用反斜杠（ \）来对处于多行的命令进行连接：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo : bar/lose</span><br><span class="line">cd bar; \</span><br><span class="line">gobble lose &gt; ../foo</span><br></pre></td></tr></table></figure><h3 id="font-color-red-命令并行-font"><font color='red'>命令并行</font></h3><p>通常情况下，同一时刻只有一个命令在执行，下一个命令只有在当前命令执行完成之后才能够开始执行。不过可以通过 make 的命令行选项 <code>-j</code> 或者 <code>--job</code> 来告诉 make 在同一时刻可以允许多条命令同时被执行。比如在一台双核的机器上，完全可以用 make -j4，让 make 最多允许4个编译命令同时执行，这样可以更有效的利用CPU资源。<br>命令并行有如下风险：</p><ol><li>在同一时刻可能会存在多个命令执行进程同时读取标准输入，但是对于标准输入设备来说，在同一时刻只能存在一个进程访问它。因此在一时刻多个执行命令的进程中只能有一个进程获得标准输入，而其它需要读取标准输入流的进程由于输入流无效而导致致命错误。</li><li>会导致make的递归调用出现问题。</li></ol><h3 id="font-color-red-命令出错-font"><font color='red'>命令出错</font></h3><p>每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），<strong>那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行！</strong> 然而，<strong>有些时候，命令的出错并不表示就是错误的</strong> 。例如 mkdir 命令，我们一定需要建立一个目录，如果目录不存在，那么 mkdir 就成功执行，如果目录存在，那么就出错了。我们使用 mkdir 的目的是保证一定要有这样的一个目录，如果已经存在，那么就忽略它的创建。为了做到这一点，忽略命令的出错，我们可以在 Makefile 的命令行前加一个减号 <code>-</code> （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test2: test1</span></span><br><span class="line">touch demo/calc</span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">mkdir demo</span><br></pre></td></tr></table></figure><p>我们先执行 test1，在执行 test2，得到结果为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test2</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">mkdir: 无法创建目录&quot;demo&quot;: 文件已存在</span></span><br><span class="line"><span class="section">makefile:15: recipe for target &#x27;test1&#x27; failed</span></span><br><span class="line"><span class="section">make: *** [test1] Error 1</span></span><br></pre></td></tr></table></figure><p>同时发现 demo 文件夹中没有 calc 文件。将 <code>mkdir</code> 改为 <code>-mkdir</code> ，再执行 test2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test2</span></span><br><span class="line">mkdir demo</span><br><span class="line"><span class="section">mkdir: 无法创建目录&quot;demo&quot;: 文件已存在</span></span><br><span class="line"><span class="section">makefile:15: recipe for target &#x27;test1&#x27; failed</span></span><br><span class="line"><span class="section">make: [test1] Error 1 (ignored)</span></span><br><span class="line">touch demo/</span><br></pre></td></tr></table></figure><p>此时虽然提示 demo 目录已经创建，但命令没有终止，test2 继续执行，最后发现 demo 中已有 calc。</p><h3 id="font-color-red-override指示符-font"><font color='red'>override指示符</font></h3><p>如果定义变量时，用 override 修饰，则通过命令行修改此变量的行为将被忽视：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line">v=world</span><br><span class="line"></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo <span class="variable">$(v)</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1 v=123</span></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line"><span class="keyword">override</span> v=world</span><br><span class="line"></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo <span class="variable">$(v)</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1 v=123</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><p><strong>注意，v=123 相当于给make传的参数，并不会实际影响 makefile，且参数不会保存</strong> 。</p><h3 id="font-color-red-变量基础-font"><font color='red'>变量基础</font></h3><p>当有如下规则时：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">gcc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>在这个规则中.o 文件列表出现了两次；第一次：作为目标“ edit”的依赖文件列表出现，第二次：规则命令行中作为“ cc”的参数列表。这样做所带来的问题是：如果我们需要为目标“edit”增加一个的依赖文件，我们就需要在两个地方添加（依赖文件列表和规则的命令中）。添加时可能在“ edit”的依赖列表中加入了、但却忘记了给命令行中添加，或者相反。这就给后期的维护和修改带来了很多不方便，添加或修改时出现遗漏。此时，我们就需要用变量来代替这些文件列表。</p><p><strong>变量规则如下：</strong></p><ul><li><p><strong><font color='orange'>makefile 中的变量完全是文本展开，与 C 语言中的宏定义无差别。</font></strong></p></li><li><p><strong>Makefile 中，变量可以使用在“目标”，“依赖目标”， “命令”或是 Makefile 的其它部分中。</strong></p></li><li><p><strong>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是<font color='orange'>尾空字符（空格、回车等，前导空格会被忽略）</font>，这点对于路径名尤其重要</strong> ，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur=.build <span class="comment">#build后有空格</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">rm <span class="variable">$(cur)</span>/mbr.bin</span><br></pre></td></tr></table></figure><p>命令行将被展开为：<code>rm build /mbr.bin</code> ，中间的空格也被插进去了，从而导致错误！</p></li><li><p><strong>变量是大小写敏感的。命名时，推荐首字母大写，以便与系统变量区分。</strong></p></li><li><p><strong>变量在声明时需要给予初值，而在使用时，<font color='orange'>需要给在变量名前加上 <code>$</code> 符号( <code>$</code> 代表引用)，且变量名必须用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 包括起来，因为 <code>$</code> 只会引用其后第一个字母：</font></strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误用法</span></span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ cat makefile</span></span><br><span class="line">var=hello</span><br><span class="line">v=world</span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">        @echo $var</span><br><span class="line"><span class="section">ziya@ubuntu:~/CLionProjects/untitled$ make test1</span></span><br><span class="line">worldar</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正确用法</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o program <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>命令或者文件名中需要使用 <code>$</code> 时则应该用 <code>$$</code> 来表示。</p></li><li><p>定义变量时，可以用其他变量来构造，其实就是一个文本展开，不论递归多少层，依次展开便可。<strong><font color='orange'>注意，使用 <code>=</code> 时(此时为延时变量)，前面的变量定义可以用到后面的变量，只有用到该变量时才确定其值</font></strong> 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br><span class="line"><span class="comment">#最后echo的值为Huh</span></span><br></pre></td></tr></table></figure><p>这种方式会导致两个潜在问题：<br>1）出现变量的递归定义而导致 make 陷入到无限的变量展开过程中。比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = <span class="variable">$(x)</span> <span class="variable">$(z)</span></span><br></pre></td></tr></table></figure><p>2）这种风格的变量定义中如果使用了函数，那么包含在变量值中的函数总会在变量被引用的地方执行，这导致 make 的效率降低。<br><strong>尽量避免使用延时变量。</strong></p></li><li><p><strong><font color='orange'>为了避免循环定义，可以使用 <code>:=</code> (此时为即时变量)，这样，定义变量时，就只能用到之前已经定义过的变量，定义时就已经确定其值</font></strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure></li><li><p>定义空格变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure><p><code>$(nullstring)</code> 后有一个空格。<strong><font color='orange'>make 忽略前导空格，但不会忽略后置空格，这在路径变量中尤其重要</font></strong>！所以不建议将注释写在 makefile 语句后，因为我们往往会用空格将注释和语句分开。</p></li><li><p><strong><code>A?=B</code> 运算符表示：如果之前没定义过 A，则 A 的值设为 B；如果之前定义过 A，则什么也不做。</strong></p></li><li><p><code>+=</code> 可以为变量追加值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure></li><li><p>当引用一个没有定义的变量时， make 默认它的值为空。</p></li></ul><h3 id="font-color-red-变量值替换-font"><font color='red'>变量值替换</font></h3><p><code>$(var:a=b)</code> 含义是：将变量 var 中所有的以 a 结尾的部分换成 b，比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure><p>bar 的值为：a.c  b.c  c.c</p><h3 id="font-color-red-环境变量-font"><font color='red'>环境变量</font></h3><p>如果 Makefile  中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。如果 make 指定了 “-e” 参数，那么，系统环境变量将覆盖 Makefile 中定义的变量。注意，系统环境变量对 make 可见，<strong>在 Makefile 中，可以引用任何已定义的系统环境变量</strong> 。这里我们需要区分系统环境变量和 make 的环境变量，系统环境变量是这个系统所有用户所拥有的，而 make 的环境变量只是对于 make 的一次执行过程有效。</p><h3 id="font-color-red-目标变量-font"><font color='red'>目标变量</font></h3><p>目标变量作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效，而不会影响规则链以外的全局变量的值。因此，目标变量可以与全局变量同名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br></pre></td></tr></table></figure><p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在 prog 目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code> 。为了理解它的便利性，我们再来看个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.c</span><br><span class="line">foo : CFLAGS+=-O2</span><br><span class="line">bar : bar.c</span><br><span class="line">bar : CFLAGS+=-g</span><br><span class="line"><span class="variable">$(EXEF)</span> : debug.h</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(<span class="built_in">addsuffix</span> .c,<span class="variable">$@</span>)</span> –o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>这个 Makefile 文件实现了在编译程序 foo 使用优化选项 <code>-O2</code> 但不使用调试选项 <code>-g</code> ，而在编译 bar 时采用了 -g 但没有 <code>-O2</code> 。这就是目标指定变量的灵活之处。</p><h3 id="font-color-red-内置变量-font"><font color='red'>内置变量</font></h3><p>Make命令提供一系列内置变量，比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性。</p><h3 id="font-color-red-条件判断-font"><font color='red'>条件判断</font></h3><p>主要关键字有这几个：<code>ifeq</code> (if equal)，<code>ifneq</code>，<code>ifdef</code>，<code>ifndef</code> ，<code>endif</code>，<code>else</code> 。</p><ul><li><p><code>ifeq</code> ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############语法</span></span><br><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)<span class="comment">#如果arg1与arg2相等，则执行</span></span><br><span class="line">command</span><br><span class="line"><span class="comment">#############示例</span></span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure><p>可见，使用这种方式可移植性更强。</p></li><li><p><code>ifneq</code> 与 <code>ifeq</code> 相反，不相等才执行。</p></li><li><p><code>ifdef</code> ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############语法</span></span><br><span class="line"><span class="keyword">ifdef</span> &lt;variable/return&gt;<span class="comment">#参数可以为变量，也可以为函数返回值</span></span><br><span class="line"><span class="comment">############示例1</span></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">############示例2</span></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>注意，<code>ifdef</code> 是用来检测参数的值是否为空，而不是检测参数是否定义过，和 C 语言中的 <code>#IFDEF</code> 不一样！示例 1 输出 yes，示例 2 则输出 no。</p></li><li><p><code>ifndef</code> 与 <code>ifdef</code> 相反，不再赘述</p></li><li><p><strong><font color='orange'>特别注意的是，make是在读取Makefile时(第一阶段)就计算条件表达式的值，并根据条件表达式的值来选择语句(相当于预编译)，所以，你最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时(第二阶段)才有的。</font></strong></p></li></ul><h3 id="font-color-red-包含其他-makefile-文件-font"><font color='red'>包含其他 makefile 文件</font></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> FILENAMES</span><br></pre></td></tr></table></figure><ul><li>可以同时引入多个文件，文件名用空格隔开；文件名支持通配符。</li><li>可使用“ -include”来代替“ include”，来忽略由于包含文件不存在或者无法创建时的错误提示。</li><li>include 通常用在以下场合：<ol><li>有多个不同的程序，由不同目录下的几个独立的Makefile来描述其重建规则。 <strong>它们需要使用一组通用的变量定义或者模式规则</strong> 。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，在需要使用的 Makefile 中使用指示符“include”来包含此文件。</li><li>当根据源文件自动产生依赖文件时；我们可以将自动产生的依赖关系保存在另外一个文件中，主Makefile使用指示符“include”包含这些文件。<strong>这样的做法比直接在主Makefile中追加依赖文件的方法要明智的多</strong> 。</li></ol></li></ul><h3 id="font-color-red-make如何解析makefile文件-font"><font color='red'>make如何解析makefile文件</font></h3><p><strong><font color='gree'>第一阶段</font></strong> ：读取所有的 makefile 文件（包括“ MAKIFILES”变量指定的、指示符“include”指定的、以及命令行选项“ -f(–file)”指定的 makefile 文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。<br><strong><font color='gree'>第二阶段</font></strong> ：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</p><p>理解 make 执行过程的两个阶段是很重要的，它能帮助我们更深入的了解执行过程中变量以及函数是如何被展开的。首先，明确以下基本的概念：<strong><font color='orange'>在 make 执行的第一阶段中如果变量和函数被展开，那么称此展开是“立即”的，此时所有的变量和函数被展开在需要构建的结构链表的对应规则中（此规则在建立链表是需要使用）。其他的展开称之为“延后”的，这些变量和函数不会被“立即”展开，而是直到后续某些规则须要使用时或者在 make 处理的第二阶段它们才会被展开。</font></strong> <strong>规则中目标和依赖如果引用其他的变量，则被立即展开，而规则的命令行中的变量引用会被延后展开</strong> 。</p><h3 id="font-color-red-read-only依赖-font"><font color='red'>read-only依赖</font></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBS = libtest.a</span><br><span class="line"><span class="section">foo:foo.c | <span class="variable">$(LIBS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure><p>make在执行这个规则时，如果目标文件 foo 已经存在，当 foo.c 被修改以后，目标“foo”将会被重建，但是当 libtest.a 被修改以后，将不执行规则的命令来重建目标 foo 。就是说，规则中依赖文件 $(LIBS) 只有在目标文件不存在的情况下，才会参与规则的执行，当目标文件存在时此依赖不会参与规则的执行过程。</p><h3 id="font-color-red-目录搜索机制-font"><font color='red'>目录搜索机制</font></h3><h3 id="font-color-red-空文件目标-font"><font color='red'>空文件目标</font></h3><h3 id="font-color-red-多目标规则-font"><font color='red'>多目标规则</font></h3><p>一个具有多目标的规则相当于多个规则，规则的命令对不同的目标的执行效果不同，因为在规则的命令中可能使用了自动变量 <code>$@</code> :</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mbr.bin loader.bin : common.s</span><br><span class="line">nasm -f bin common.s -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line"><span class="section">mbr.bin: common.s</span></span><br><span class="line">nasm -f bin common.s -o mbr.bin</span><br><span class="line"><span class="section">loader.bin: common.s</span></span><br><span class="line">nasm -f bin common.s -o loader.bin</span><br></pre></td></tr></table></figure><p>注意，多目标规则下，每个目标都有相同的依赖，所以遇到以下情况就不好使了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbr.bin loader.bin : mbr.s loader.s</span><br><span class="line">nasm -f bin <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>以上代码的意思是，mbr.bin 和 loader.bin 的依赖文件都同时是 mbr.s 和 loader.s，而我们想表达的意思为 mbr.bin 的依赖文件为 mbr.s，loader.bin 的依赖文件为 loader.s 。要解决这个问题，需要用到后面的静态模式。</p><blockquote><p>虽然在多目标的规则中，可以根据不同的目标使用不同的命令（在命令行中使用自动化变量<code>$@</code> ）；但是，<strong><font color='orange'>多目标规则并不能做到根据目标文件自动改变依赖文件</font></strong> 。</p></blockquote><h3 id="font-color-red-多规则目标-font"><font color='red'>多规则目标</font></h3><p>一个文件可以作为多个规则的目标（多个规则中只能有一个规则定义命令）。<strong>这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标的一个依赖文件列表</strong> ，当其中任何一个依赖文件比目标新时， make 将会执行特定的命令来重建这个目标。</p><p><strong><font color='orange'>对于一个多规则的目标，重建此目标的命令只能出现在一个规则中（可以是多条命令）</font></strong> 。<strong>如果多个规则同时给出重建此目标的命令， make将使用最后一个规则中所定义的命令，同时提示错误信息</strong> 。若要对相同的目标使用不同的规则中所定义的命令，则须使用另外一种方式——“双冒号”规则来实现。</p><h3 id="font-color-red-双冒号规则-font"><font color='red'>双冒号规则</font></h3><p>Makefile 中，一个目标可以出现在多个规则中。<strong>但是这些规则必须是同一类型的规则，要么都是普通规则， 要么都是双冒号规则</strong> ，而不允许一个目<br>标同时出现在两种不同类型的规则中。双冒号规则的处理和普通规则的处理过程完全不同，表现在以下几个方面：</p><ol><li>双冒号规则中，当依赖文件比目标更新时，规则将会被执行；<strong><font color='orange'>对于一个没有依赖而只有命令行的双冒号规则，当引用此目标时，规则的命令将会被无条件执行</font>。而普通规则，当规则的目标文件存在时，此规则的命令永远不会被执行（目标文件永远是最新的）</strong> 。</li><li>当同一个文件作为多个双冒号规则的目标时，这些不同的规则会被独立的处理，而不是像普通规则那样合并所有的依赖到一个目标文件。<strong><font color='orange'>多个双冒号规则中的某一个的依赖文件被改变之后， make 只执行此规则定义的命令，而其它的以这个文件作为目标的双冒号规则将不会被执行</font></strong> 。</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Newprog :: foo.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">Newprog :: bar.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="font-color-red-静态模式-font"><font color='red'>静态模式</font></h3><p>静态模式规则是这样一个规则：<strong><font color='orange'>规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件</font></strong> 。静态模式规则比多目标规则更通用，它不需要多个目标具有相同的依赖。<strong>但是静态模式规则中的依赖文件必须是相类似的而不是完全相同的</strong> 。</p><p>静态模式的语法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGETS... : TARGET-PATTERN:PREREQ-PATTERNS</span><br><span class="line">COMMANDS</span><br></pre></td></tr></table></figure><p><code>TAGET-PATTERN</code> 和 <code>PREREQ-PATTERNS</code> 说明了如何为每一个目标文件生成依赖文件。<strong>从目标模式 <code>TAGET-PATTERN</code> 的目标名字(hello.o)中抽取文件名(hello)，称为“茎”；使用“茎”替代依赖模式 <code>PREREQ-PATTERNS</code> 中的相应部分来产生对应目标的依赖文件</strong> 。举例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#相当于如下：</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure><blockquote><p>在模式规则的依赖列表中使用不包含模式字符“ %”也是合法的，代表这个文件是所有目标的依赖文件。</p></blockquote><p>需要强调的是，在使用静态模式规则时，指定的目标必须和目标模式相匹配，否则执行 make 时将会得到一个错误提示。如果存在一个文件列表，其中一部分符合某一种模式而另外一部分符合另外一种模式，这种情况下我们可以使用 filter 函数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><blockquote><p>静态模式规则对一个较大工程的管理非常有用，它可以对整个工程的同一类文件的重建规则进行一次定义，而实现对整个工程中此类文件指定相同的重建规则。比如，可以用来描述整个工程中所有的 .o 文件的依赖规则和编译命令。通常的做法是将生成同一类目标的模式定义在一个 make.rules 的文件中，然后在工程各个模块的 Makefile 中包含此文件。</p></blockquote><h3 id="font-color-red-模式规则-font"><font color='red'>模式规则</font></h3><p>模式规则的格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c </span><br><span class="line">COMMAND</span><br></pre></td></tr></table></figure><p>对于模式规则 <code>%.o : %.c</code> ，它表示的含义是：所有的 .o 文件依赖于 <strong>对应的</strong> .c 文件。模式规则中依赖文件也可以不包含模式字符“%”。当依赖文件名中不包含模式字符“%”时，其含义是所有符合目标模式的目标文件都依赖于一个指定的文件（例如：%.o : debug.h，表示所有的.o文件都依赖于头文件“debug.h”）。</p><blockquote><p>要注意的是：模式字符“%”的匹配和替换发生在规则中所有变量和函数引用展开之后，变量和函数的展开一般发生在make读取Makefile时，而模式规则中的 “%” 的匹配和替换则发生在make执行时。</p></blockquote><p>可以有多个目标模式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.bin %.o:%.s</span><br><span class="line">nasm -f bin <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li>模式规则在 Makefile 中的顺序需要注意，当一个目标文件同时符合多个目标模式时， make 将会把第一个目标匹配的模式规则作为重建它的规则。</li><li>Makefile中明确指定的模式规则会覆盖隐含模式规则。<strong><font color='orange'>就是说如果在 Makefile 中出现了一个对目标文件合适可用的模式规则，那么 make 就不再为这个目标文件寻找其它隐含规则</font></strong> 。<strong>明确规则永远优先于隐含规则</strong> 。</li></ul><h3 id="font-color-red-模式匹配-font"><font color='red'>模式匹配</font></h3><p>模式规则中依赖文件名的确定过程是：首先根据规则定义的目标模式匹配实际的目标文件，确定“茎”(模式“%.o”所匹配的文件“ test.c”中“ test”就是“茎”)，之后使用“茎”替代规则依赖文件名中的模式字符“%”，生成依赖文件名，这样就产生了一个明确指定了目标和依赖文件的规则。<strong><font color='orange'>注意，当目标模式中包含斜杠（目录部分），在进行目标文件匹配时，文件名中包含的目录字符串在匹配之前被移除，只进行基本文件名的匹配；匹配成功后，再将目录部分加入到匹配之后的字符串之前形成“茎”</font></strong> 。例如目标模式为“e%t”，文件“src/eat”匹配这个模式，那么“茎”就是“src/a”。</p><h3 id="font-color-red-隐含规则-font"><font color='red'>隐含规则</font></h3><p>某些情况下，make 会自动根据已存在(或者可以被创建)的源文件类型来启动相应的隐含规则，最常见的隐含规则即 .c 文件生成 .o 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">cc -o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure><p>即使不给出 foo.o, bar.o 的创建规则，makefile 也会自动根据隐含规则(%.c --&gt; %.o)来创建这些依赖文件。</p><p><strong><font color='orange'>每一个内嵌的隐含规则中都存在一个目标模式和依赖模式，而且同一个目标模式可以对应多个依赖模式</font></strong>。例如：一个.o 文件可以由 c 编译器编译对应的.c 源文件得到，也可以由 Pascal 编译器编译 .p 的源文件得到。当一个隐含规则的目标是另外一个隐含规则的依赖时，我们称它们是一个<a href="#%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E9%93%BE">隐含规则链</a>。</p><p><strong><font color='orange'>注意：给目标文件指定明确的依赖文件并不会影响隐含规则的搜索！</font></strong> 举个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.p</span></span><br><span class="line"><span class="comment">#此规则只说明依赖关系，没有指定命令</span></span><br></pre></td></tr></table></figure><p>这个规则指定了 foo 的依赖文件是 foo.p 。但是如果在工作目录下存在同名 .c 源文件 foo.c，执行 make 的结果就不是用 pc 编译 foo.p 来生成 foo ，而是用 cc 编译 foo.c 来生成目标文件。<strong>这是因为在隐含规则列表中对 .c 文件的隐含规则处于 .p 文件隐含规则之前</strong> 。当需要给目标指定明确的重建规则时，规则描述中就不能省略命令行，<strong>这个规则必须提供明确的重建命令来说明目标需要重建所需要的动作</strong> 。为了能够在存在 .c 文件的情况下编译 foo.p ，需要使用如下命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.p</span></span><br><span class="line">pc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong><font color='orange'>这一点在多语言实现的工程编译中，需要特别注意！否则编译出来的可能就不是你想要得程序。</font></strong></p><p>另外，当我们不想让 make 为一个没有命令行的规则中的目标搜索隐含规则时，我们需要使用 <strong>空命令</strong> 来实现：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#空命令格式： </span></span><br><span class="line"><span class="comment">#target: ;</span></span><br><span class="line"><span class="section">foo.o: foo.p ;</span></span><br></pre></td></tr></table></figure><h3 id="font-color-red-隐含规则一览-font"><font color='red'>隐含规则一览</font></h3><ol><li><p><strong>编译C程序</strong> ：<code>N.o</code> 自动由 <code>N.c</code> 生成，执行命令为 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></p></li><li><p><strong>编译C++程序</strong> ：<code>N.o</code> 自动由 <code>N.cc</code> 或者 <code>N.cpp</code> 生成，执行命令为 <code>$(CXX) -c $(CPPFLAGS)$(CFLAGS)</code> 。</p></li><li><p><strong>汇编程序</strong> ：<code>N.o</code> 可自动由 <code>N.s</code> 生成，执行命令是：<code>$(AS) $(ASFLAGS)</code> ；<br><code>N.s</code> 可由 <code>N.S</code> 生成， C预编译器 <code>cpp</code> ，执行命令是： <code>$(CPP) $(CPPFLAGS)</code> 。</p><blockquote><p>N.s 是不需要预处理的汇编源文件，N.S 是需要预处理的汇编源文件。</p></blockquote></li><li><p><strong>链接单一的object文件</strong> ：<code>N</code> 自动由 <code>N.o</code> 生成，通过 C 编译器使用链接器（GUN ld），执行命令是：<br><code>$(CC) $(LDFLAGS) N.o $(LOADLIBES) $(LDLIBS)</code> 。<br><strong>注意，此规则仅适用于由一个源文件直接产生可执行文件的情况</strong> 。当需要有多个源文件共同来创建一个可执行文件时，需要在 Makefile 中增加隐含规则的依赖文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x : y.o z.o <span class="comment">#x和x.c对应，因此隐含规则在进行链接时，自动将x.c作为其依赖文件</span></span><br><span class="line"><span class="comment">#当x.c、y.c和z.c都存在时，规则执行如下命令：</span></span><br><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o y.o z.o</span><br></pre></td></tr></table></figure></li></ol><p>以上规则按顺序排列，<strong>make 查找隐含规则时也是按以上顺序进行</strong> 。其他规则不常用，不再阐述。</p><h3 id="font-color-red-隐含变量-font"><font color='red'>隐含变量</font></h3><p><strong>隐含变量分为两类：1. 代表一个程序的名字（例如：<code>CC</code> 代表了编译器这个可执行程序）；2. 代表执行这个程序使用的参数（例如：CFLAGS）</strong> 。</p><p>我们可以对隐含变量重定义。对这些变量重定义后如果需要整个工程的各个子目录有效，需要使用关键字 <code>export</code> 将他们导出，否则目录间编译命令可能出现不一致。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS=nasm</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">代表命令的变量</mark> </strong></p><ul><li><strong>AR</strong>：函数库打包程序，可创建静态库.a文档。默认是ar。</li><li><strong>AS</strong> ：汇编程序。默认是as。</li><li><strong>CC</strong> ：C编译程序。默认是cc。</li><li><strong>CXX</strong> ：C++编译程序。默认是g++。</li><li><strong>CPP</strong> ：C程序的预处理器（输出是标准输出设备）。默认是 $(CC) -E。</li><li><strong>RM</strong> ：删除命令。默认是 <code>rm -f</code></li></ul><p><strong><mark class="hl-label blue">代表参数的变量</mark> </strong></p><ul><li>ARFLAGS：执行 AR 命令的命令行参数。默认值是 rv。</li><li>ASFLAGS：执行汇编语器 AS 的命令行参数（明确指定 .s 或 .S 文件时）</li><li>CFLAGS：执行 CC 编译器的命令行参数（编译.c源文件的选项）。</li><li>CXXFLAGS：执行 g++ 编译器的命令行参数（编译.cc源文件的选项）。</li><li>CPPFLAGS：执行C预处理器 cc -E 的命令行参数（ C 编译器会用到）。</li><li>LDFLAGS：链接器（ld）参数</li></ul><h3 id="font-color-red-隐含规则链-font"><font color='red'>隐含规则链</font></h3><p>创建 .o 文件<u>可能</u>经过如下步骤：N.c → N.s → N.o ；这个过程有两种情况：</p><ol><li>如果 N.s 存在：make 可以确定出 N.o 可由 N.s 创建；之后 make 试图使用隐含规则来重建 N.s，它会寻找 N.c 这个文件，如果 N.c 存在，则执行隐含规则来重建 N.s 这个文件，之后再由 N.s 重建 N.o 。当不存在 N.c 文件时，直接编译 N.s 生成 N.o 。</li><li>如果 N.s 不存在：只要存在 N.c 这个文件，那么 make 也会经过这两个步骤来重建 N.o (N.c → N.s → N.o)；此时，N.s 作为中间文件存在，命令结束将被删除。</li></ol><h3 id="font-color-red-定义命令包-font"><font color='red'>定义命令包</font></h3><p>书写 Makefile 时，可能有多个规则会使用相同的一组命令。为了提高效率，我们想到了将这组命令封装，在要执行的地方进行调用。在 GNU make中，可以使用指示符 <code>define</code> 来完成这个功能：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> frobnicate</span><br><span class="line">@echo <span class="string">&quot;frobnicating target <span class="variable">$@</span>&quot;</span></span><br><span class="line">frob-step-1 <span class="variable">$&lt;</span> -o <span class="variable">$@</span>-step-1</span><br><span class="line">frob-step-2 <span class="variable">$@</span>-step-1 -o <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="comment">#像使用变量一样调用它：</span></span><br><span class="line"><span class="section">frob.out: frob.in</span></span><br><span class="line"><span class="variable">$(frobnicate)</span></span><br></pre></td></tr></table></figure><p>注意，命令前必须有 [Tap] 键。</p><h3 id="font-color-red-自动变量-font"><font color='red'>自动变量</font></h3><p>从前面的学习中我们能够发现，自动变量是在模式规则的命令行中使用的。自动变量类型如下：</p><ul><li><p><code>$^</code> ：代表所有通过目录搜索得到的 <strong>依赖文件</strong> 的完整路径名(目录+文件名)列表。<code>$</code> 会去掉重复的依赖文件。</p></li><li><p><code>$@</code> ：表示规则的目标文件名(而非目标列表)。在多目标模式规则中，它代表的是哪个触发规则被执行的目标文件名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEF := foo bar</span><br><span class="line"><span class="variable">$(EXEF)</span> : debug.h <span class="comment">#目标变量</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(<span class="built_in">addsuffix</span> .c,<span class="variable">$@</span>)</span> –o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p><code>$&lt;</code> ：规则的第一个依赖文件名。为什么需要第一个依赖？似乎是个很奇怪的需求。如下例子便可解释：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c defs.h hack.h</span><br><span class="line">cc -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li><p><code>$?</code> ：所有比目标文件更新的依赖文件列表，空格分割。这个规则也比较常用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态库文件libN.a，它由一些.o文件组成。这个规</span></span><br><span class="line"><span class="comment">#则实现了只将更新后的.o文件加入到库中：</span></span><br><span class="line"><span class="section">lib: foo.o bar.o lose.o win.o</span></span><br><span class="line">ar r lib $</span><br></pre></td></tr></table></figure></li></ul><p>以上为常用自动变量，其他自动变量见手册。</p><h3 id="font-color-red-头文件自动产生依赖-font"><font color='red'>头文件自动产生依赖</font></h3><h3 id="font-color-red-嵌套执行make-font"><font color='red'>嵌套执行make</font></h3><h3 id="font-color-red-函数-font"><font color='red'>函数</font></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数格式</span></span><br><span class="line"><span class="variable">$(FunName ARG)</span></span><br><span class="line"><span class="comment">#比如</span></span><br><span class="line"><span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(x)</span>)</span></span><br></pre></td></tr></table></figure><ul><li>调用语法格式中 FUNCTION 是需要调用的函数名，它应该是 make 内嵌的函数名。对于用户自己的函数需要通过 make 的 call 函数来间接调用。</li><li>参数和函数名之间使用空格隔开，存在多个参数时，参数之间使用 <code>,</code> 隔开。<strong>注意，一个参数中可能有多个变量或文本</strong> 。</li></ul><h3 id="font-color-red-动态库-font"><font color='red'>动态库</font></h3>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解前缀树(字典树)</title>
      <link href="/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/10/06/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前缀树又叫字典树，通常用来高效地查询字符串，比如查询库中是否有以某个子字符串为前缀的字符串，某个字符串出现的次数等。前缀树是 N 叉树的一种特殊形式，每一个节点会有多个子节点，通往不同子节点的 <strong>路径上</strong> 有着不同的字符，子节点中包含两种信息：pass(经过此字符的次数)，end(以此字符结尾的次数)。说多了没用，直接上图：<br><img src="../../public/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1665450930848-1.png" alt=""></p><p>0-‘a’，1-’b’，2-‘c’，每个节点对应的下标即代表相应字母，除 root 外的其他节点中包含着该字母的信息。<br>细心的同学应该发现，root 的 end 域只可能为 0，因为这代表着插入了一个空字符串，这是不被允许的。所以我们似乎可以利用这个 end 域做些坏事。容易知道，root 的 pass 域代表着此前缀树中一共有<font color='orange'>多少个</font>字符串（相同字符串会被重复计数），那么，我如果想知道一共有<font color='orange'>多少种</font>字符串呢？此时，就要利用 root 的 end 域来记录了。详细注释已在代码给出，不在赘述。代码如下(仅支持小写字母)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">preNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pass;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">preNode* arr[<span class="number">26</span>];</span><br><span class="line"><span class="built_in">preNode</span>() :<span class="built_in">pass</span>(<span class="number">0</span>), <span class="built_in">end</span>(<span class="number">0</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">arr[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trieTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">preNode  root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">trieTree</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span>;<span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string str)</span></span>;<span class="comment">//返回某个字符串出现的个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delOnce</span><span class="params">(string str)</span></span>;<span class="comment">//只删一次，如果删除失败，返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delAll</span><span class="params">(string str)</span></span>;<span class="comment">//删除所有str，如果删除失败，返回false</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefixSearch</span><span class="params">(string str)</span></span>;<span class="comment">//返回以str为前缀的字符串的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">counts</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.pass; &#125;<span class="comment">//所有单词总个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nonRepeatCounts</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root.end; &#125;<span class="comment">//不重复单词的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trieTree root;</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdc&quot;</span>);</span><br><span class="line">root.<span class="built_in">insert</span>(<span class="string">&quot;ahcdx&quot;</span>);</span><br><span class="line">root.<span class="built_in">delAll</span>(<span class="string">&quot;ahc&quot;</span>);</span><br><span class="line"><span class="type">int</span> r = root.<span class="built_in">counts</span>();</span><br><span class="line"><span class="type">int</span> n = root.<span class="built_in">nonRepeatCounts</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不重复单词个数：&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;总单词个数：&quot;</span> &lt;&lt; r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trieTree::insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">preNode *tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;pass++;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;arr[p]==<span class="literal">NULL</span>)</span><br><span class="line">tmp-&gt;arr[p] = <span class="keyword">new</span> preNode;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;end == <span class="number">0</span>)<span class="comment">//插入重复字符串，root-&gt;end不计数</span></span><br><span class="line">root.end++;</span><br><span class="line">tmp-&gt;end++;</span><br><span class="line">tmp-&gt;pass++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trieTree::search</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp-&gt;end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trieTree::delOnce</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line">tmp-&gt;pass--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>()<span class="number">-1</span>; i++)<span class="comment">//遍历到str的倒数第二个字符</span></span><br><span class="line">&#123;                                     <span class="comment">//因为如果最后一个字符的end=0</span></span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;             <span class="comment">//就必须delete该节点，然后将指向</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)          <span class="comment">//该节点的指针赋值为NULL</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">tmp-&gt;pass--;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;end--;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass--;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trieTree::delAll</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line">root.end--;</span><br><span class="line"><span class="type">int</span> cnt = tmp-&gt;end;</span><br><span class="line">tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;pass -= cnt;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass == cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;pass -= cnt;</span><br><span class="line">tmp-&gt;arr[str.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;end -= cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trieTree::prefixSearch</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">preNode* tmp = &amp;root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;arr[p] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">tmp = tmp-&gt;arr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp-&gt;pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是链式实现，当字符种类很多时，一般就采用哈希实现，此方式后面有时间再给出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言入门</title>
      <link href="/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-什么是汇编语言？-font"><font color='red'>什么是汇编语言？</font></h3><p>我们最初学习编程时，一般都是学习高级语言，诸如 C++，Java，Python 等，通过一定语法编写代码，然后运行，代码就能够顺利地在电脑中跑起来。但是，计算机实际上并不认识高级语言，它只认识如 <code>01011001</code> 这样的二进制数字。0，1 虽然简单，但无数个代表着高低电平的 0 和 1 组合却能指挥计算机完成几乎所有你能想到的任务。<br>早期的程序是由科学家们手工编写二级制代码完成的，面对巨量的，毫无规律的 0 和 1，其工作量可想而知。为了解决这一窘况，汇编语言应运而生。其实， <strong><font color='orange'>汇编语言严格来说并不是一门语言，而仅仅只是一套助记符，它与二进制代码一一对应</font></strong> 。如下图，汇编语言与人类语言更为接近，便于阅读和记忆。<br><img src="/2022/img/image-20221001232413430.png" alt="左边是二进制代码的十六进制格式，右边是对应的汇编代码" style="zoom:67%;" /><br><strong>汇编语言直接运行于硬件之上</strong> 。<strong>由于 CPU 硬件设计和内部架构的不同，其对应的指令集（机器语言）也不同，每一种 CPU 都有自己的汇编指令集</strong> 。 <strong><font color='orange'>所以，汇编语言依赖于硬件体系，不便于移植</font></strong> 。对于同一个程序，如果在这台机器上可以运行，而到另一台机器上就必须重新改写某些代码以适应机器，那这样就太麻烦了。再之，汇编代码只比机器代码容易阅读了一点而已，理解起来还是很困难。</p><h3 id="font-color-red-汇编语言的种类-font"><font color='red'>汇编语言的种类</font></h3><p><strong>从汇编格式上：</strong> 分为 <strong>Intel</strong> 和 <strong>AT&amp;T</strong> 两种风格，两者是 X86 架构的不同写法。<strong>Intel 格式和 AT&amp;T 格式的区别只是符号系统的区别</strong> 。前者常见于 Windows，masm 仅支持 Intel；而 AT&amp;T 在 Unix 中更常见，GNU 汇编器的默认格式就是 AT&amp;T。<br><strong>从架构体系上：</strong> 分为 <strong>复杂指令集(CISC)</strong> 和 <strong>精简指令集(RISC)</strong> ，前者的代表是 <strong>X86架构</strong> ，后者代表是 <strong>ARM</strong> 架构。RISC 多用于移动端，全世界超过95%的智能手机和平板电脑都采用 ARM 架构；CISC 多用于 PC 端和服务器端，苹果的 PC 机使用的 CPU(M1) 是 ARM 架构。</p><h3 id="font-color-red-汇编语言的组成-font"><font color='red'>汇编语言的组成</font></h3><ol><li><strong>汇编指令</strong> ，如 <code>mov</code> ，有对应的机器码。</li><li><strong>伪指令</strong> ，如 <code>segment</code> 和 <code>end</code> ，由汇编器识别，没用机器码，计算机不执行。</li><li><strong>其他符号</strong> ，如 <code>+</code> 、 <code>-</code> 等，由汇编器识别，没有机器码。</li></ol><p><strong>汇编指令是汇编语言的核心。</strong> 其中，伪指令根据编译器的不同而有所变化。</p><h3 id="font-color-red-CPU总线-font"><font color='red'>CPU总线</font></h3><p>CPU 读写硬件中的数据时，必须经过下面三类信息的交互：</p><ol><li><strong>地址信息</strong> ：储存单元的地址</li><li><strong>控制信息</strong> ：选择器件，读或写的命令.</li><li><strong>数据信息</strong> ：读或写的内容。</li></ol><p>以上三种信息分别由 <strong>地址总线、控制总线、数据总线</strong> 传递。总线将 CPU 与其他芯片连接起来。以下是 CPU 从地址为 3 的内存中读取数据的过程：<br><img src="/2022/img/IMG_0463(20221012-154228).PNG" style="zoom:67%;" /></p><ol><li>CPU 通过地址线将位置信息发送给内存</li><li>CPU 通过控制线向内存发送读命令，选中储存器芯片，并通知它将从内存读取数据。</li><li>储存器将相应位置的数据通过数据线传送给 CPU。</li></ol><p><strong>总线的宽度：</strong> 一根导线上只能传送两种状态：低电平与高电平，对应着 0 和 1；那么 32 根导线一次传送的最大数据为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 。总线所包含的导线数目即为总线宽度。<br><strong><font color='orange'>地址总线的宽度代表着 CPU 的寻址能力，即最多能用多少内存；数据总线的宽度决定了 CPU 对数据的读写能力，平时我们说的 32/64 位机器，指的就是机器的数据总线宽度(寄存器的宽度)；控制总线的宽度决定了 CPU 对外部器件的控制能力。</font></strong></p><p><strong>8080，8088，80286，80386 的地址总线宽度分别为 16，20，24，32，则它们的寻址能力分别为：64KB，1MB，16MB，4GB</strong> 。</p><h3 id="font-color-red-硬件概览-font"><font color='red'>硬件概览</font></h3><p><strong><mark class="hl-label blue">主板</mark> </strong><br>主板上有核心器件（CPU，储存器等）和一些主要器件（外围芯片组，扩展插槽等），这些器件通过总线相连。</p><p><strong><mark class="hl-label blue">接口卡</mark> </strong><br>所有可被程序控制的硬件设备都必须受到 CPU 控制。但 CPU 不能直接控制这些设备，直接控制设备的是接口卡，而 CPU 通过总线与接口卡相连，利用接口卡来间接控制设备。简单来说，CPU 通过总线向接口卡发送命令，接口卡根据收到的命令来指挥设备工作。<br><strong><mark class="hl-label blue">储存器芯片</mark> </strong><br>从读写属性上分为两类：</p><ol><li><strong>ROM (Read Only Memory)</strong> ，随机储存器可写可读，但必须带电储存，关机后数据丢失；</li><li><strong>RAM (Random Access Memory)</strong>  ，只读储存器只可读，关机后内容不丢失；</li></ol><p>从功能上大概分为以下几类：</p><ol><li><strong><font color='gree'>随机储存器</font></strong> ：用于存放供 CPU 使用的绝大部分程序和数据。<strong>主随机储存器一般由主板上的 RAM 和扩展插槽上的 RAM 组成。</strong></li><li><strong><font color='gree'>装有 BIOS (Basic IO System) 的 ROM</font></strong> ：<font color='orange'>BIOS 是由主板和各类插口卡（网卡、显卡等）厂商提供的系统软件，通过它来利用该设备进行最基本的输入输出。主板上的 ROM 存储着系统 BIOS ；显卡上的 ROM 中储存着显卡的 BIOS；网卡中的 ROM 存储着网卡的 BIOS</font>。<strong>机器加电后，启动 BIOS 程序进行一系列的机器初始化动作，然后装入操作系统的初始文件，引导操作系统启动</strong> 。<strong>BIOS是固化在硬件的一种程序</strong> 。BIOS 中包含以下内容：<ul><li>硬件系统的检测和初始化程序。</li><li>外部中断和内部中断的中断例程。</li><li>对硬件设备进行 I/O 的中断例程。</li><li>其他和硬件系统相关的中断例程。</li></ul></li><li><strong><font color='gree'>接口卡</font></strong> ：某些接口卡需要对大批量的输入输出进行储存，其上就会装有 RAM。最典型的就是显卡上的 RAM (显存)。显卡随时将显存中的数据向显示器输出，所以我们才能看见屏幕上的内容。</li></ol><img src="/2022/img/IMG_0465(20221012-172337).PNG" alt="各类储存器的逻辑连接" style="zoom: 67%;" /><h3 id="font-color-red-工作模式-font"><font color='red'>工作模式</font></h3><p>8086/8088 CPU 为单任务操作系统，可以直接操控内存，是不安全的。Intel 进而推出 80286，具备了对多任务系统的支持，首次提出了保护模式的概念。80286 拥有 24 根地址线，可访问 16 MB 的内存，其 16 位段寄存器中也不再存放段地址，而是存放段选择子，真正的段地址位于描述符高速缓存中；其偏移地址最大仍为 64 KB，这是很大的缺陷。而后来的 80386 是划时代的，拥有 32 根地址线，可访问 4 GB 内存；其段偏移量也是 32 位的，在最典型的情况下，可以将 4GB 当作一个段来使用，即平坦模型。它支持以下三个模式：</p><ol><li>实模式：相当于一个 8086</li><li>保护模式：多任务环境，建立保护机制。</li><li>虚拟 8086 模式：可以从保护模式切换到实模式，这种方式方便用户在保护模式下运行 8086 程序。</li></ol><p>80286 CPU 的缺陷在于，它只提供实模式和保护模式，没有提供虚拟模式，这很不利于用户的工作。</p><h3 id="font-color-red-内存地址空间-font"><font color='red'>内存地址空间</font></h3><p><strong><font color='red'>利用接口卡与主储存器，CPU 便能够将所有硬件抽象成内存，通过修改内存来完成对各类硬件的控制！</font></strong> 将所有储存器看作一个由若干储存单元组成的逻辑储存器，这个逻辑储存器就是我们常说的内存地址空间。<br><img src="/2022/img/IMG_0466(20221012-173407).PNG" style="zoom:67%;" /></p><p><strong>每个物理储存器都在这个地址空间中占有一定位置，CPU 在这个位置上读写数据，实际上就在对应的物理储存器中读写数据。</strong></p><p>实模式内存分布如下：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70.png" alt=""></p><p>一般而言，如果需要向内存空间写入数据的话,要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元向里面写入，这可能导致程序的崩溃。<strong>注意，我们在纯DOS方式(实模式)下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在CPU实模式下的DOS没有能力对硬件系统进行全面、严格的管理。但在Windows 2000、Unix这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操根本不可能的，硬件已被这些操作系统利用CPU保护模式所提供的功能全面而严格地管控</strong> 。<br><strong><font color='orange'>在DOS中，<code>0:0200~0:02FF</code> 这段 256 字节的空间一般为空闲，可随意使用。</font></strong></p><h3 id="font-color-red-数据表示-font"><font color='red'>数据表示</font></h3><ul><li>字节：8 bits；字节是计算机的最小操作单元，比特是最小存储单元。</li><li>字：2 字节，即 16 bits；由高位字节和低位字节组成，高低位指的是数据的高低位，而非地址的高低。</li><li>常用表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16}=64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">64</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20}=1MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{24}=16MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span></li><li>一个两位十六进制数可以使用一个字节储存，一个四位十六进制数可以用两个字节存储，以此类推。比如 AX 中存放 0XFFEE，那么 AH 中为 0XFF，AL 中为 0XEE。这种方式可以很容易地看出数据的组成，利于直观分析。</li><li>在小端机器中，低地址存放字型数据的低位数据，高地址存放字型数据的高位数据。</li></ul><h3 id="font-color-red-8086寻址方案-font"><font color='red'>8086寻址方案</font></h3><p><strong>8086 CPU有 20 位地址总线，达到 1 MB寻址能力，所以内存空间也只有 1MB</strong> 。但 8086 CPU是 16 位结构，即，其寄存器最大宽度为 16 位 (或者说，其运算器一次最多可以处理16位数据，寄存器和运算器之间的通路为16位) ，所以如果只是简单发出地址，那么只能一次性处理或存储 16 位地址。所以，<strong>8086 使用两个 16 位地址合成一个 20 位物理地址</strong> ，即 <strong><font color='orange'>物理地址=段地址×16+偏移地址，其中，段地址×16又叫做基础地址</font></strong> 。<br><img src="/2022/img/IMG_0467(20221012-193401).PNG" style="zoom:67%;" /><br>有几点需要注意：</p><ol><li>乘 16 即右移 4 位。</li><li>段地址×16 必然是 16 的倍数，所以段起点必然也为 16 的倍数，比如 10010H。</li><li>一个物理地址可能由多种运算得到，比如，10010H 可能由 1001H×16+0 得到，也可能由 1000H×16+0010H得到。</li><li><strong>由于偏移地址为 16 位，所以一个段的最大长度为 64KB</strong></li><li><strong>段始终以 16 字节对齐</strong> ，如果 data 段只有 14 字节，范围为 1001:0 ~ 10001:D，code 段也会从 1002:0 开始。</li></ol><h3 id="font-color-red-内存定位的多种方式-font"><font color='red'>内存定位的多种方式</font></h3><img src="/2022/img/IMG_0471(20221013-163812).PNG" style="zoom:80%;" />注意：<ol><li><p><strong>在 [ ] 中，BX/SI/DI/BP 可以分别单独出现；</strong></p></li><li><p><strong>或只能以四种组合出现：BX 与 SI，BX 与 DI，BP 与 SI，BP 与 DI；</strong></p><blockquote><p>这样理解：BX 与 BP 为基址寄存器，DI 与 SI 为变址寄存器。</p></blockquote></li><li><p><strong>只要含 BP，默认段寄存器就为 SS</strong> ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#错误方式：</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-指令的执行过程-font"><font color='red'>指令的执行过程</font></h3><ol><li><p>从 CS : IP 指向的内存单元读取指令，将指令送入指令缓冲器。</p><blockquote><p>指令缓冲器<strong>可防止高速处理器在数据传输序列期间被锁定到慢速 I/O 设备，或减少较快和较慢设备之间的速度不匹配</strong> 。</p></blockquote></li><li><p>IP = IP + 所读指令的长度，从而指向下一条指令。</p><blockquote><p>容易发现，指令的长度是可变的，那么 CPU 如何判断指令的长度呢？对于可变长编码，我们应该可以想到一条思路：每个指令的机器码都不可能是其他机器码的前缀。</p></blockquote></li><li><p>执行指令。然后转到步骤一，重复以上过程。</p></li></ol><p>指令从低到高地址依次执行。</p><h3 id="font-color-red-中断-font"><font color='red'>中断</font></h3><h4 id="font-color-gree-内中断-font"><font color='gree'>内中断</font></h4><p><strong>内中断分为软中断和异常</strong> ，指的是 CPU 本身执行当前指令时所发生的中断。内中断具体分为： <strong>1）由软中断指令 int 启动的中断；2）在一定条件下由 CPU 自身启动的中断(异常)</strong> 。当 CPU 内部发生以下情况时，会发出中断信息：</p><ol><li><p>除法错误</p></li><li><p>单步执行</p></li><li><p>执行 into 指令</p><blockquote><p>本指令检测 OF 标志位,当 OF=1 时,说明已发生溢出，立即产生一个<u>中断类型为 4 的中断</u>,当 OF＝0 时，本指令不起作用。本指令可用于溢出处理，影响 TF 和 IF 标志位。</p></blockquote></li><li><p>执行 int 指令</p><blockquote><p>指令格式为 int N，N 是字节型立即数，为中断码。</p></blockquote></li></ol><p><strong><mark class="hl-label blue">中断向量表</mark> </strong><br>CPU 用中断类型码来标识中断信息，中断码长度为 1 字节，可表示 256 中断信息。<br>CPU 侦测到中断码后，根据 <strong>中断向量表</strong> ( <strong>IVT</strong> ) 找到中断码对应的中断处理程序入口地址，并放入 CS:IP 中，执行程序。 <strong><font color='orange'>中断向量表在开机时由 BIOS 程序加载进内存，并放在 <code>0000:0000 ~ 0000:03ff</code> 这 1024 个字节中，其中 <code>0000:0200~0000:02ff这256字节一般为空闲</code></font></strong> 。中断向量表是PC系统中最重要的内存区。中断向量表每个表项长 4 字节，所以中断向量表最多有 256 个中断信息。</p><blockquote><p>DOS 也提供中断例程。BIOS 完成硬件检测和初始化后，调用 int 19h 进行操作系统的引导，从此将计算机交给操作系统。DOS 启动后，将自己提供的中断例程载入内存，并建立响应中断向量表项。<strong>DOS 只有 int 21h 一个例程，但可以根据 ah 中的功能号调用子功能，这就是为什么程序返回指令为 <code>mov ax,4c00和int 21h</code></strong>  。</p></blockquote><p><strong><mark class="hl-label blue">中断过程</mark> </strong><br><strong>用中断码 N 找到中断向量，并用它设置 CS:IP，这个过程由 CPU 硬件自动完成</strong> ，此过程被称为中断过程。由于处理完中断后，之前的程序应该恢复，所以执行中断前需要保存 CPU 现场（保存标志寄存器即可，其他寄存器会在中断处理内部保存）。中断过程如下：</p><ol><li>取得中断码 N</li><li>pushf</li><li>TF=0，IF=0</li><li>push CS</li><li>push IP</li><li>IP=N×4，CS=N×4+2</li></ol><p>以上过程由 cpu 硬件自动完成，无需人为干预。</p><p><strong><mark class="hl-label blue">中断处理程序规范</mark> </strong></p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>iret</li></ol><p><strong><mark class="hl-label blue">响应中断的特殊情况</mark> </strong><br>有些情况下，CPU 执行完当前指令后，即使发生中断，也不会响应。比如，向 SS 寄存器传送数据后，就算发生单步中断，CPU 也不会响应。原因是 SS:SP 联合指向栈顶，对它们的赋值应该连续完成，即，向 SS 赋值后，应立即向 SP 赋值，否则一旦 SS 赋值后发生中断， SS:SP 就指向了错误的栈顶，将引起错误。</p><p><strong><mark class="hl-label blue">int中断</mark> </strong><br><code>int n</code> 调用中断码为 n 的中断过程。int 和 call 类似，都是调用一段程序。系统将某些子程序以 int 中断的方式提供给应用程序调用。比如程序返回指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><h4 id="font-color-gree-外中断-font"><font color='gree'>外中断</font></h4><p>CPU 通过外中断来处理外设引发的事件。 <strong><font color='orange'>外中断分为可屏蔽中断和不可屏蔽中断，IF 只对外中断有效</font></strong> ：当 IF=1，进入中断程序后，允许转向可屏蔽中断；IF=0则不可。遇上不可屏蔽中断，无论 IF 为多少，都转向不可屏蔽中断。几乎所有外中断都是可屏蔽中断，电源断电等引起不可屏蔽中断。</p><h3 id="font-color-red-端口-font"><font color='red'>端口</font></h3><p><strong><mark class="hl-label blue">什么是端口</mark> </strong><br><strong>CPU 可以直接从以下三个地方直接读取数据：</strong></p><ol><li><strong>CPU 内部寄存器</strong></li><li><strong>内存单元</strong></li><li><strong>端口</strong></li></ol><p>前两者我们已经很清楚，那么端口是什么呢？端口是各种接口芯片上可供 CPU 读写的寄存器。CPU 将不同接口芯片的寄存器映射在内存中，形成统一的端口地址空间，这样就方便了对端口的读写。CPU 通过<font color='orange'>读写端口或内存映射</font>来间接访问硬件。关于端口更详细的讨论，见 <a href="https://blog.ours1984.top/posts/iomp/#%E8%BE%B9%E9%99%85%E6%95%88%E5%BA%94">端口详解</a> 。</p><p><strong><mark class="hl-label blue">读写端口</mark> </strong><br>使用 <code>in</code> 和 <code>out</code> 指令读写端口，且只能使用 AX 或 AL 存放从端口读入或要输出到端口的指令，访问 8 位端口用 AL，16 位端口用 AX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#从60h号端口读数据，传送给al寄存器</span><br><span class="line">in al,60h</span><br><span class="line">#向20h号端口输入数据。</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure><h3 id="font-color-red-寄存器用法总结-font"><font color='red'>寄存器用法总结</font></h3><p>8086 CPU 中所有寄存器都是 16 位，而 8086 上一代 CPU 中寄存器都为 8 位， <strong><font color='orange'>为了保证兼容，使基于上一代 CPU 编写的程序稍加修改就能运行于 8086 之上，8086 CPU 中的通用寄存器（AX, BX, CX, DX）都可以分为两个可独立使用的 8 位寄存器。</font></strong></p><p><strong><mark class="hl-label blue">通用寄存器</mark> </strong></p><p><strong>8 个通用寄存器：<font color='gree'>AX、BX、CX、DX、SI、DI、SP、BP</font></strong> ；下面列出这几个寄存器的名字，以展现其常见用途：<br><strong>AX</strong> ：累加器(Accumulator)；<br><strong>BX</strong> ：基地址寄存器(Base Register)；<br><strong>CX</strong> ：计数寄存器（Count Register）；<br><strong>DX</strong> ：数据寄存器（Data Register）；<br><strong>SI</strong>  ： 源索引寄存器(Source Index Register)；<br><strong>DI</strong>  ：目标索引寄存器(Destination Index Register)；<br><strong>BP</strong> ：基址针寄存器(Base Pointer Register)；<br><strong>SP</strong> ：栈指针寄存器(Stack Pointer Register)；</p><p><strong><font color='gree'>AX , BX , CX , DX</font></strong> 常用来存放一般性数据。<strong>它们可以分为两个独立的寄存器</strong> ，比如 AX 可分为 AH 和 AL，BX 可分为 BH 和 BL，其他同理。<strong>注意，H 指数据高位，L 指数据低位，而非地址的高低</strong> ，实际上寄存器也没有什么地址高低一说。<strong>当数据溢出时，舍弃高位。</strong></p><p><strong><font color='gree'>SI , DI , SP , BP</font></strong> 常用于寻址操作。<strong>它们不可分为两个独立的寄存器</strong> 。</p><p>其中寄存器的专门用法为：</p><ol><li>AX：<ul><li><strong>存放被除数</strong> ：如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，<font color='orange'>高位放在 DX 中，低位放在 AX 中</font>。</li><li><strong>存放商</strong> ：如果除数为 8 位，则将<font color='orange'>商放入 AL，余数放入 AH</font>；如果除数为 16 位，<font color='orange'>则将商放入 AX，余数放入 DX</font>。</li><li><strong>存放乘数与积</strong> ：若为 8 位乘法，其中一个乘数放在 AL 中，结果放在 AX 中；若为 16 位，其中一个乘数放在 AX 中，<font color='orange'>结果高位放在 DX 中，低位放在 AX 中</font>。</li><li><strong>常用作累加器和返回值</strong> 。</li></ul></li><li>BX：<strong>[ ] 中只能为立即数、BX、SI 、DI 或 BP</strong> 。利用 Loop 和 [BX/SI/DI/BP] 可以方便地完成对内存的连续操作。 <strong><font color='orange'>但注意 [BX/SI/DI] 的默认段寄存器为 DS；[BP] 默认的段寄存器为 SS；</font></strong></li><li>CX：大多与循环或者条件判断相关，比如：<ul><li>Loop 的循环计数器</li><li><code>jcxz</code> 指令的条件判断寄存器。</li><li>控制 <code>rep</code> 指令的循环次数。</li><li>CL 存放 shl 和 shr 的位移。</li></ul></li><li>DX：被用来放整数除法产生的余数，见 AX；</li><li>SI ：见 BX；在很多字符串操作指令中, DS:SI 指向源串,而 ES:DI 指向目标串。</li><li>DI ：见 BX，SI；用 DI 与 SI 可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</li><li>BP：见 BX； <strong>BP 的作用之一就是在栈中找到函数的形参，栈中的局部变量也是通过 BP 来定位的</strong> ；</li><li>SP：[SP] 永远指向栈顶， <strong>[SP] 的默认段寄存器为 SS</strong> ；BP 和 SP 都和栈相关。</li></ol><p><strong><mark class="hl-label blue">段寄存器</mark> </strong><br><strong><font color='gree'>CS , DS , SS , ES</font></strong></p><ul><li><p>CS：代码段寄存器，配合 IP 寄存器使用。</p></li><li><p>DS：数据段寄存器，其偏址寄存器只能为：BX，BP，SI，DI。 <strong><font color='orange'>[BX/SI/DI] 的默认段寄存器为 DS</font></strong> ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure></li><li><p>SS：栈段寄存器，配合 SP 寄存器使用。<strong>任意时刻，SS : SP 指向栈顶元素</strong> 。</p></li><li><p>ES：附加段寄存器。作用与 DS 差不多，<strong>DS 偏指数据来源段，ES 偏指数据输出段</strong> ，比如源字符串和目标字符串，详见 movsb 的使用。</p></li></ul><p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器；也不能直接在段寄存器上做运算</font></strong> ；</p><p><strong><mark class="hl-label blue">标志寄存器</mark> </strong><br>flag 寄存器是按位起作用的，其中每一位都有不同的含义：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-1665748273693-1.png" alt=""></p><ul><li>ZF：零标志位。它记录相关指令（ add、sub、mul、div、inc、or、and 操作）执行后，结果是否为0 。ZF = 1结果不为0，ZF = 0结果为0。</li><li>PF：奇偶标志位。它记录指令执行后，结果的所有二进制位中 1 的个数是否为偶数，如果为偶数则 PF = 1，为奇数，PF = 0。</li><li>SF：符号标志位。它记录指令执行后，结果是否为负（就是看它二进制的第一位是不是1），如果为负数则SF = 1，结果为正，SF = 0。</li><li>CF：进位标志位。在进行 <strong><font color='orange'>无符号数运算</font></strong> 的时候，它记录了运算结果的最高有效位是否向更高位进位，或从更高位借位。</li><li>OF：溢出标志位。OF记录了 <strong><font color='orange'>有符号数运算</font></strong> 的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。</li><li>DF：方向标志位。配合串传送指令 movsb，movsw 等使用。<strong>cld 指令将 DF 置为 0，则正向传送；std 将其置为 1，则反向传送</strong> 。详见后续 movsb 指令的使用。</li><li>IF ：用于中断，<strong>仅对可屏蔽中断有效</strong> 。当前中断进行时，若碰上其他可屏蔽中断，如果此时 IF=1，则暂停当前中断，转向其他中断；如果 IF=0，则必须执行完当前中断后，才能执行其他中断。若碰上不可屏蔽中断，则无论 IF 为多少，当前中断暂定，转向其他中断。<strong>sti 指令设置 IF=1，cli 设置 IF=0。</strong></li><li>TF：TF=1，机器进入单步工作方式，每条机器指令执行后，显示结果及寄存器状态，若TF=0，则机器处在连续工作方式。此标志为调试机器或调试程序发现故障而设置。</li><li>AF：辅助进位标志。在进行算术运算的时候，当两个字节相加减时，如果从第 3 位向第 4 位(从第0位算起)形成了进位或借位，则AF=1，否则AF=0；</li></ul><p><strong>mov、push、pop等传送指令不修改标志寄存器的信息。</strong> 如何在 debug 中查看标志寄存器，请移步<a href="#%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">工具使用</a>   。</p><p><strong><mark class="hl-label blue">指令指针寄存器</mark> </strong><br>IP 配合 CS 使用，<strong>IP 永远指向<font color='orange'>下一条指令</font>的偏移地址</strong>。任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。</p><h3 id="font-color-red-汇编指令用法总结-font"><font color='red'>汇编指令用法总结</font></h3><p><strong><mark class="hl-label blue">mov</mark> </strong><br><code>mov</code> 指令被称为传送指令，用于修改内存或寄存器的值。 <strong><font color='orange'>注意，<code>mov</code> 指令无法用来设置 CS，IP 的值</font></strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br></pre></td></tr></table></figure><p>注意，<code>mov</code> 只能有如下几种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,立即数</span><br><span class="line">mov 寄存器,寄存器</span><br><span class="line">mov 寄存器,内存单元</span><br><span class="line">mov 内存单元,寄存器</span><br><span class="line">mov 段寄存器,寄存器</span><br><span class="line">mov 内存单元,立即数</span><br></pre></td></tr></table></figure><p>不能 <code>mov 内存单元,内存单元</code> 和 <code>mov 段寄存器,立即数</code> 。 <strong><font color='orange'>需要说明的是，<code>mov 内存单元,立即数</code> 时，必须指明其数据类型是字还是字节：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr[0],12h</span><br><span class="line">mov word ptr[0],1234h</span><br></pre></td></tr></table></figure><p>其中，<code>ptr</code> 不可省略。以上规则同样适用于 <code>sub</code> ，<code>add</code> 指令。</p><p><strong><mark class="hl-label blue">jmp</mark> </strong></p><p><code>jmp</code> 指令用于指令的跳转，有以下几种用法：</p><ul><li><p><code>jmp 段:偏移</code> ：同时修改 CS : IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 1000:0012</span><br><span class="line">#5</span><br><span class="line">mov cs,1000h</span><br><span class="line">mov ip,0012h</span><br></pre></td></tr></table></figure></li><li><p><code>jmp reg</code> ： 修改 IP 为 reg 寄存器中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp ax</span><br><span class="line">#效果等价于</span><br><span class="line">mov ip,ax</span><br></pre></td></tr></table></figure></li><li><p><code>jmp short 标号/数值</code> ：执行段内短转移，对 IP 的修改范围为 -128~127；此方式是利用<font color='orange'>当前 jmp 指令的下一条指令</font>到标号的偏移量来跳转的，而非利用标号的绝对地址来跳转。实际上 <code>jmp short 标号</code> 的功能为 <code>IP=IP+8位位移</code> ；位移在汇编时期算出，用补码表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">stack segment</span><br><span class="line">db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,1</span><br><span class="line">    inc ax</span><br><span class="line">jmp short start</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p><code>jmp near 标号/数值/寄存器/内存</code> 执行段内近转移；同 <code>jmp short 标号</code> 类似，利用相对移位进行跳转，但对 IP 的修改范围为 -32768~32767，为 16 位位移。</p></li><li><p><code>jmp far 内存/数值</code> 执行段间转移，又称远转移。与前两者不同，此方式利用的是 CS:IP 绝对地址。</p></li><li><p><code>jmp word ptr 内存单元</code> 段内转移。</p></li><li><p><code>jmp dword ptr 内存单元</code> 段间转移，<strong>内存单元中高地址的字存放段地址，低地址的字存放偏移地址。</strong></p></li></ul><p><strong><mark class="hl-label blue">add与sub</mark> </strong><br><code>add</code> 与 <code>sub</code> 分别执行加法和减法。所支持格式和 <code>mov</code> 相同。</p><p><strong><mark class="hl-label blue">pop与push</mark> </strong><br><code>push ax</code> ：（1）<code>SP = SP - 2</code>       （2）<code>mov SS:[SP],ax</code> ；</p><p><code>pop ax</code>   ：（1）<code>mov ax,SS:[SP]</code> （2）<code>SP = SP + 2</code> ；</p><p><strong>注意以下几点：</strong></p><ol><li><strong><font color='orange'>8086 的入栈出栈必须以字为单位进行操作</font></strong></li><li><strong><font color='orange'>操作数只能为内存或寄存器，不能为立即数，比如：<code>push 12</code> </font></strong></li><li><strong><font color='orange'>SS:SP 指向栈顶，没有寄存器自动指向栈底(一般用BP手动指向栈底)，所以必须自己操心栈顶超界的问题，栈顶 SS:SP 超界会导致严重后果。</font></strong></li><li><strong>栈顶的变化范围为 0~FFFF，栈满时如果仍继续压栈，会循环覆盖之前的内容。</strong></li></ol><img src="/2022/img/未命名绘图-1665624319178-11.png" style="zoom:67%;" /><p><strong><mark class="hl-label blue">pusha与popa</mark> </strong><br><code>pusha</code> 指令的作用是把通用寄存器压栈。寄存器的入栈顺序依次是：AX,CX,DX,BX,SP,BP,SI,DI。<code>popa</code> 指令按照相反顺序将同样的寄存器弹出堆栈。<strong>过程用一个或多个寄存器来返回结果时，不应使用 PUSHA 和 POPA，因为其值会被 POPA 覆盖</strong> 。</p><p><strong><mark class="hl-label blue">inc与dec</mark> </strong></p><p><code>inc</code> 对寄存器自增 1，<code>dec</code> 对寄存器自减 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inc ax</span><br><span class="line">dec bx</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">dec byte ptr [bx]</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">Loop</mark> </strong><br><code>loop</code> 的格式为：<code>loop 标号</code> ；进行 Loop 操作时进行如下两步操作：</p><ol><li><p><code>cx = cx - 1</code></p></li><li><p>判断 CX 中的值，不为零则跳转到标号继续循环，为零则往下运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,5</span><br><span class="line">s:  </span><br><span class="line">inc ax</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure></li></ol><p>注意，是先减再判断！ <strong>循环指令都是短转移。</strong></p><p><strong><mark class="hl-label blue">and与or</mark> </strong><br>分别是按位与和按位或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10010010B</span><br><span class="line">and al,11101111B</span><br><span class="line">or  al,11101110B</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">test</mark> </strong><br>Test 对两个参数 (目标，源) 执行 AND 逻辑操作（&amp;&amp;而非&amp;），并根据结果设置标志寄存器，<strong>结果本身不会保存</strong> 。</p><p><code>TEST AX,BX</code> 与 <code>AND AX,BX</code> 命令有相同效果，只是 Test 指令不改变 AX 和 BX 的内容，而 AND 指令会把结果保存到 AX 中。</p><p><strong><mark class="hl-label blue">div</mark> </strong><br><strong><code>div</code> 指令进行无符号除法操作，<code>idiv</code> 执行有符号除法</strong> 。如果除数为 8 位，则被除数须为 16 位，放在 AX 中；如果除数为 16 位，则被除数须为 32 位，高位放在 DX 中，低位放在 AX 中。<strong>存放商</strong> ：如果除数为 8 位，则将商放入 AL，余数放入 AH；如果除数为 16 位，则将商放入 AX，余数放入 DX。有以下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div 十六位/八位寄存器</span><br><span class="line">div word/byte ptr 内存地址</span><br></pre></td></tr></table></figure><p>计算 100001 ÷ 100（186A1H ÷ 64H）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1H</span><br><span class="line">mov dx,186AH</span><br><span class="line">mov cx,64H</span><br><span class="line">div cx</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">mul</mark> </strong><br><strong><code>mul</code> 为无符号数乘法，<code>imul</code> 为有符号数乘法</strong> 。相乘的数，要么都是 8 位，要么都是 16 位。<br>8 位：一个默认放在 AL 中，另一个由操作数给出，放在 8 位寄存器或内存中(<u>不能为立即数</u>)；结果默认放在 AX中。</p><p>16 位：一个默认放在 AX 中，另一个由操作数给出，放在 16 位寄存器或内存中(<u>不能为立即数</u>)；结果高位放在 DX 中，低位放在 AX 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#8位</span><br><span class="line">mov al,5h</span><br><span class="line">mov bl,15h</span><br><span class="line">mul bl</span><br><span class="line">#16位</span><br><span class="line">mov ax,0fffh</span><br><span class="line">mov dx,1111h</span><br><span class="line">mul dx</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">jcxz</mark> </strong><br><code>jcxz</code> 指令为有条件转移指令， <strong><font color='orange'>所有的有条件转移指令都为短转移</font></strong> 。当 CX=0 ，则进行跳转。另外，根据</p><p><strong><mark class="hl-label blue">ret与retf</mark> </strong><br><code>ret</code>   ：（1）IP = SS:[SP]；（2）SP = SP+2；相当于POP IP；<br><code>ret imm</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）SP = SP+imm；相当于 POP IP，SP+=imm；通常用于内平栈。</p><p><code>retf</code> ：（1）IP = SS:[SP]；（2）SP = SP+2；（3）CS = SS:[SP]；（4）SP = SP+2；</p><p><strong><mark class="hl-label blue">call</mark> </strong><br><code>call 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）jmp near 标号；<strong>实现段内转移</strong><br><code>call far 标号</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）jmp far 标号；<strong>实现段间转移</strong><br><code>call 16位reg</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = reg；<strong>实现段内转移</strong></p><p><code>call word ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = IP；（3）IP = 内存单元中的值；<br><code>call dword ptr 内存单元</code> ：（1）SP = SP-2；（2）SS:[SP] = CS；（3）SP = SP-2；（4）SS:[SP] = IP；（5）CS = 内存中高地址的字；（6）IP = 内存中低地址的字</p><p><strong><mark class="hl-label blue">adc</mark> </strong><br>带进位加法指令。指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc operand1,operand2</span><br></pre></td></tr></table></figure><p>功能：oprand1 = operand1 + operand2 + CF<br>这个指令的作用看上去比较鸡肋，但实际上对于大数运算很有帮助。首先我们知道这样一个常识：<br><strong>加法分两步执行：1）低位相加；2）高位相加再加上低位相加的进位值。</strong> 例如下面的指令与 <code>add ax,bx</code> 有完全相同的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br><span class="line">#结果储存在ax中</span><br></pre></td></tr></table></figure><p>16 位 CPU 如何计算 32 位数的运算？比如 <code>11FF89FF33420010</code> + <code>12983476FFAAB444</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,11FF89FF #ax存第一个加数的高位</span><br><span class="line">mov bx,33420010 #bx存第一个加数的低位</span><br><span class="line">add bx,FFAAB444</span><br><span class="line">adc ax,12983476</span><br><span class="line">#结果在ax与bx中，ax存高位，bx见低位</span><br></pre></td></tr></table></figure><blockquote><p>这个指令是字长还只有8位时发明的，当时八位寄存器经常难以承担运算任务，所以 adc 必不可少。现在已经进入 32/64 位时代，除了科学计算，一般都够用了。</p></blockquote><p><strong><mark class="hl-label blue">sbb</mark> </strong><br>带位减法指令，原理和 adc 相同，不再解释。</p><p><strong><mark class="hl-label blue">cmp</mark> </strong><br>cmp 指令用来比较大小，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp operand1,operand2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##对于无符号数，通过zf,cf来判断：</span><br><span class="line">如果(ax)=(bx)则(ax)-(bx)=0,所以: zf=1;</span><br><span class="line">如果(ax)≠(bx)则(ax)-(bx)≠0,所以: zf=0;</span><br><span class="line">如果(ax)&lt;(bx)则(ax)-(bx)将产生借位,所以: cf=1;</span><br><span class="line">如果(ax)&gt;=(bx)则(ax)-(bx)不必借位,所以: cf=0;</span><br><span class="line">如果(ax)&gt;(bx)则(ax)-(bx)既不必借位,结果又不为0,所以: cf=0并且zf=0;</span><br><span class="line">如果(ax)&lt;=(bx)则(ax)-(bx)既可能借位,结果可能为0,所以: cf=1或zf=1。</span><br><span class="line">##对于有符号数：通过zf,sf,cf来判断</span><br><span class="line">如果ax&lt;bx则ax-bx&lt;0,所以: (sf=1并且of=0)或(sf=0,of=1)</span><br><span class="line">如果ax=bx则ax-bx=0,所以: zf=1</span><br><span class="line">如果ax&gt;=bx则ax-bx&gt;=0,所以: sf=0并且zf=0</span><br><span class="line">如果ax&gt;bx则ax-bx&gt;0,所以: sf=1并且of=1</span><br></pre></td></tr></table></figure><p>要理解这种工作机制背后的思想。</p><p><strong><mark class="hl-label blue">根据比较结果进行跳转</mark> </strong><br><strong>无符号比较：</strong></p><table><thead><tr><th>指令</th><th>含义</th><th>检测标志位</th><th>助记</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf=1</td><td>jump if equal</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf=0</td><td>jump if not equal</td></tr><tr><td>jb</td><td>小于则转移</td><td>cf=1</td><td>jump if blow</td></tr><tr><td>jnb</td><td>不小于则转移</td><td>cf=0</td><td>jump if not blow</td></tr><tr><td>ja</td><td>大于则转移</td><td>cf=0且zf=0</td><td>jump if above</td></tr><tr><td>jna</td><td>不大于则转移</td><td>cf=1或zf=1</td><td>jump if not above</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx</span><br><span class="line">jne start</span><br></pre></td></tr></table></figure><p>其他根据比较结果进行跳转的指令参考<a href="http://c.biancheng.net/view/3567.html">跳转指令汇总</a></p><p><strong><mark class="hl-label blue">movsx</mark> </strong></p><p>常用的有 movsb，movsw，movsd 。<br>将源字符串高效地传送到目的地，movsb 相当于以下几步操作：<br>1）<code>ES:[DI]=DS:[SI]</code><br>2）如果 DF=0，则 <code>SI++,DI++</code> ；如果 DF=1，则 <code>SI--,DI--</code> ；<br>movsw 类似，只是每次移动两个字节：如果 DF=0，则 <code>SI+=2,DI+=2</code> ；如果 DF=1，则 <code>SI-=2,DI-=2</code> ；<br>movsd 则每次移动四个字节。</p><p>cld 指令将 DF 置为 0，std 将其置为 1。<br>movsb 与 movsw 通常和 rep 指令搭配使用，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">###等价于</span><br><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>可见，rep 的功能就是根据 CX 中的值重复循环后面的指令。程序演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db 11h,22h,33h,44h,55h,66h,77h,88h</span><br><span class="line">db 8 dup(0)</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,8</span><br><span class="line">mov cx,8</span><br><span class="line">rep movsb</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">pushf与popf</mark> </strong></p><p>pushf 的功能是<font color='orange'>标志寄存器</font>的值压栈，popf 从栈中弹出数据，送入标志寄存器中。该指令与中断有关，详见 <a href="#%E4%B8%AD%E6%96%AD">中断</a></p><p><strong><mark class="hl-label blue">iret</mark> </strong><br>功能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>该指令用于中断程序的返回。</p><p><strong><mark class="hl-label blue">shl与shr</mark> </strong><br><code>shl</code> 逻辑左移，<code>shr</code> 逻辑右移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shl ax,1</span><br><span class="line">mov cl,4</span><br><span class="line">shl ax,cl</span><br></pre></td></tr></table></figure><p>当移动位数大于 1 时，必须将移动位数放入 CL；<strong>以上指令将最后移出的一位写入 CF 中</strong> 。</p><p><strong><mark class="hl-label blue">seg</mark> </strong></p><p>取得某一标号的段地址。</p><p><strong><mark class="hl-label blue">程序返回</mark> </strong><br>使用如下命令进行程序返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>此指令相当于 main() 函数中的 <code>return 0</code> 语句。</p><h3 id="font-color-red-伪指令总结-font"><font color='red'>伪指令总结</font></h3><blockquote><p><strong>以下伪指令为 masm 的格式</strong> ，nasm 与 masm 格式的区别见文末。</p></blockquote><p>伪指令由汇编器识别并进行相关汇编工作，没有对应的机器码。 <strong><font color='red'>可执行文件由描述信息和程序组成，程序来源于源程序( .asm文件 )中定义的指令和数据；描述信息则来自于 .asm 文件中的伪指令，比如程序入口地址就由伪指令 end 提供</font></strong> 。 <strong><font color='gree'>注意，伪指令的类型随汇编器的种类不同而不同，比如 masm 和 nasm 就不一样，以下伪指令为 masm 的格式。</font></strong><br>常见伪指令如下：</p><ol><li><p><code>segment</code> 和 <code>ends</code> 是成对出现的伪指令，用来定义一个段；前者说明段的开始，后者说明段的结束。</p></li><li><p><code>end</code> （注意不是 <code>ends</code> ）用来标记整个汇编程序的结束，<strong>其后可以跟标号，指明程序的入口</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,ds:[0]</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>end start</code> 指明程序入口为第八行的 <code>start</code> 。</p></li><li><p><code>assume</code> 用来假设某一段寄存器和程序中某个用 <code>segment</code> 和 <code>ends</code> 定义的段相关联。</p></li><li><p><code>+</code> 、<code>-</code> 号等，只能用立即数，在汇编时期就会算出结果。如：<code>mov ax,90-4</code></p></li><li><p><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明段内存空间，即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack1 segment</span><br><span class="line">dw 0FFFF,0FFFF,0FFFF</span><br><span class="line">stack1 ends</span><br><span class="line"></span><br><span class="line">stack2 segment</span><br><span class="line">db 11,22,33,44</span><br><span class="line">stack2 ends</span><br></pre></td></tr></table></figure></li><li><p><code>dup</code> 指令用来声明装载重复数据的内存空间，比如上面代码中第 2 行可以写作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   stack1 segment</span><br><span class="line">   dw 3 dup(0FFFF)</span><br><span class="line">   stack1 ends</span><br><span class="line"></span><br><span class="line">7. `offset` 用来取得标号到段首的偏移量，如下：</span><br><span class="line"></span><br><span class="line">   ```assembly</span><br><span class="line">   codesg segment</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">   start:</span><br><span class="line">   mov bx,offset start</span><br><span class="line">   code ends</span><br></pre></td></tr></table></figure><p>bx 中即取得 start 标号地址（实际就是第五行 <code>mov</code> 的地址）到 codesg （第二行 <code>mov</code> 的地址）的偏移量。可以用 offset 求某段的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov bx,45h</span><br><span class="line">mov cx,8</span><br><span class="line">push cx</span><br><span class="line">push bx</span><br><span class="line">mov dx,offset s - offset start</span><br><span class="line">s:nop</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure></li><li><p>汇编中除了汇编指令和伪指令外，还有标号，例如 <code>codesg segment</code> 中的 <code>codesg</code> 。标号是地址的助记符，标号本身即代表地址。如下代码第 9 行。<strong>注意，<code>:</code> 只能在代码段使用</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">dw 0FFFF,0EEEE</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p>数据标号：带有单元长度的标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a dw 0FFFFh,0EEEEh</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">inc b[0] ##无需word ptr</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-汇编规则总结-font"><font color='red'>汇编规则总结</font></h3><ul><li><p>注释以分号 <code>;</code> 开头。</p></li><li><p>指令的两个操作对象的位数必须一致，以下是不正确的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bl</span><br><span class="line">add bh,1000</span><br></pre></td></tr></table></figure></li><li><p>AH 与 AL 是两个独立的寄存器，不要错误地认为 <code>add al,93H</code> 指令产生的进位会储存在 AH 中。</p></li><li><p>数据在内存 21F60 单元中，专业说法应该为：2000:1F60 单元中。</p></li><li><p><strong><font color='orange'>8086 CPU 不支持将数据直接送入段寄存器，必须通过寄存器将数据送入段寄存器，也不允许直接在段寄存器上做运算</font></strong> ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">mov ss,1100</span><br><span class="line">#正确</span><br><span class="line">mov ax,1100</span><br><span class="line">mov ss,ax</span><br></pre></td></tr></table></figure></li><li><p>mov 指令中给出 16 位寄存器，就进行 16 位数据传送；若给出 8 位寄存器，则进行 8 位数据传送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure><p><strong>对于没有寄存器参与的内存单元操作指令中，必须要用 <code>word ptr</code> 和 <code>byte ptr</code> 指明操作长度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [0],0fffh</span><br><span class="line">inc byte [0]</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>注意，在编写汇编代码时，如果数字后没H或没有前缀0x，则视为十进制数，汇编过程中自动再转为十六进制。</font></strong></p></li><li><p>为了使程序更加清晰合理，一般将数据、代码、栈放在不同的段中。由于寄存器最大为 16 位，所以一个段的容量最大也为 64KB</p></li><li><p><strong>8086 CPU 的转移指令分为以下几类：1）无条件转移指令(jmp)；2）条件转移指令(jcxz)；3）循环指令(loop)；4）call 与 ret；5）中断</strong></p></li><li><p>如前所述，<code>jmp short 标号</code> ，<code>jmp near 标号</code> ，<code>jcxz 标号</code> ，<code>loop 标号</code> 都是根据相对位移来进行转移的。这样做的好处是方便了程序的整体移动。比如我把这段程序中的某段代码移植到其他程序中，就只需要更改段寄存器。</p></li><li><p>设置 SS 后必须紧接着设置 SP！！！原因见内中断。</p></li></ul><h3 id="font-color-red-程序设计规范-font"><font color='red'>程序设计规范</font></h3><p>后续补充、、、先列个目录：</p><ul><li>10.10 参数和结果的传递</li><li>10.11批量数据的传递</li><li>10.12寄存器冲突</li><li>在子程序内部保存用到的寄存器。</li></ul><h3 id="font-color-red-代码实验-font"><font color='red'>代码实验</font></h3><p>一. 往屏幕中间输出 hello（masm下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;h&#x27;,11000010b,&#x27;e&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;l&#x27;,11000010b,&#x27;o&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,1660</span><br><span class="line">mov cx,10</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>彩色模式详见王爽《汇编语言第四版》第188页。</p><h3 id="font-color-red-工具使用-font"><font color='red'>工具使用</font></h3><blockquote><p>汇编工具下载链接：<a href="https://pan.baidu.com/s/19TWArrfgDA06_IOYwUUDlg?pwd=gzwb">汇编工具</a><br>提取码：gzwb</p></blockquote><p><strong><mark class="hl-label blue">工具的安装和配置</mark> </strong></p><p>Debug 是 Dos 和 Windows 都提供的 <strong>实模式 (8086方式)</strong> 程序的调试工具，它可以查看 CPU 中各种寄存器的值和内存的使用情况，并能够在机器码级跟踪程序的运行。参见 <a href="https://blog.csdn.net/plus_re/article/details/60761467">DosBox安装</a> 。DosBox 安装好后直接将 LINK.exe 、masm.exe 和 Debug.exe 放入 DosBox 的根目录中。</p><p><strong><mark class="hl-label blue">Debug指令</mark> </strong></p><ul><li><p>R：查看或改变寄存器的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r</span><br><span class="line">AX=0000 BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC 073F:0100  0000ADD[BX+SI],ALDS:0000=CD</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改</span></span><br><span class="line">D:\&gt;debug</span><br><span class="line">-r AX</span><br><span class="line">AX 0000</span><br><span class="line">:FFFF</span><br><span class="line">-r </span><br><span class="line">AX=FFFF BX=0000 CX=0000 DX=0000 SP=00FD BP=0000 SI=0000 </span><br><span class="line">DI=0000 DS=073F ES=073F SS=073F CS=073F IP=0100 NU UP EI PL NZ NA PO NC </span><br><span class="line">073F:0100  0000  ADD[BX+SI],ALDS:0000=CD #下一次要执行的指令</span><br></pre></td></tr></table></figure><p>第二行最后八对字母是标志寄存器的状态，含义如下：</p><table><thead><tr><th>标志</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>OF</td><td>OV</td><td>NV</td></tr><tr><td>SF</td><td>NG</td><td>PL</td></tr><tr><td>ZF</td><td>ZR</td><td>NZ</td></tr><tr><td>PF</td><td>PE</td><td>PO</td></tr><tr><td>DF</td><td>DN</td><td>UP</td></tr><tr><td>AF</td><td>AC</td><td>NA</td></tr><tr><td>IF</td><td>EI</td><td>DI</td></tr></tbody></table></li><li><p>D：查看内存中的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>E：修改内存中的值；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;debug</span><br><span class="line">-e 1000:0</span><br><span class="line">1000:0000   00.FF   00.11 #按空格继续修改，回车终止</span><br><span class="line">-d 1000:0</span><br><span class="line">1000:0   FF 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li><li><p>U：将内存中的指令翻译成汇编指令。</p></li><li><p>T：执行一条机器指令。</p></li><li><p>A：以汇编指令的形式向内存写入机器指令；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br><span class="line">073F:0100 MOV AX,FF</span><br><span class="line">073F:0103 ADD BX,EE</span><br><span class="line">-u 073F:0100</span><br><span class="line">073F:0100  BBFF00    MOV AX,FF</span><br><span class="line">073F:Θ103  81C3EE00  ADD BX,ΕΕ</span><br></pre></td></tr></table></figure></li><li><p>P：执行指令，不过遇到子程序代码时，直接完成子程序的执行，类似于 VS 调试时使用 F10，而 T 相当于 F11；遇到循环时，直接执行到 CX=0；</p></li><li><p>G： 该命令后面可以跟地址和断点，运行到内存指定位置的代码后暂停，如果不加参数默认是从当前IP运行到程序结束。</p></li></ul><p><strong><font color='orange'>注意，在debug中所有数据被视为十六进制，不能在数据后再加H；而在编写汇编代码时，如果数字后没H，则视为十进制数，汇编过程中再转为十六进制。</font></strong></p><p><strong><mark class="hl-label blue">生成可执行文件</mark> </strong><br>编写 test.asm 后保存，在 DosBox 中输入 <code>masm</code> ，然后输入 <code>test.asm</code> ，连续回车；接着输入 <code>test.obj</code> ，连续回车；最后 <code>debug test.exe</code> 即可。</p><h3 id="font-color-red-Dos下exe文件加载过程-font"><font color='red'>Dos下exe文件加载过程</font></h3><img src="/2022/img/IMG_0468(20221013-103739).PNG" style="zoom:80%;" /><p>程序加载后，DS 指向 PSP 的起点，CS 指向程序的入口。PSP 的作用和程序加载器差不多，关于程序加载器，见另一篇文章：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p><h3 id="font-color-red-补充：nasm-的使用-font"><font color='red'>补充：nasm 的使用</font></h3><p>后续学习操作系统的过程中我们都会在 Linux 下采用 nasm 。原因 nasm 可以直接生成纯二进制文件，不夹杂其他的文件信息，而 masm 则会自动生成文件信息（利用 assume, start, end 等伪指令生成信息），不利于我们探究其中的细节。</p><p><strong><mark class="hl-label blue">命令行语法</mark> </strong><br>1）将文件进行汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将myfile.s生成bin文件，生成的文件名为myfile</span></span><br><span class="line">nasm -f bin myfile.s</span><br><span class="line"><span class="comment">#将myfile.s生成bin文件，指定生成的文件名为myfile.bin</span></span><br><span class="line">nasm -f bin myfile.s -o myfile.bin</span><br></pre></td></tr></table></figure><blockquote><ul><li>汇编文件后缀在 Linux 下以 <code>.s</code> 为主，在 Windows 下以 <code>.asm</code> 为主。</li><li><code>.bin</code> 文件是纯二进制文件，其中只包含汇编指令，可以直接给 CPU 使用。而 ELF 或 PE 文件是二进制可执行文件，除了指令外还包含很多文件信息，用来给程序加载器使用。</li></ul></blockquote><p>2）生成列表文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f coff myfile.s -l myfile.lst</span><br></pre></td></tr></table></figure><p>列表文件很方便我们对照阅读汇编代码和其对应的二进制代码：<br><img src="/2022/img/image-20221030102024363.png" alt=""></p><p>3）预包含文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm myfile.s -p myinc.inc</span><br></pre></td></tr></table></figure><p>跟在源文件开头写上 <code>%include &quot;myinc.inc&quot;</code> 是等效的。这种包含头文件的方式将在后面我们写加载器时带来很大的方便。</p><p><strong><mark class="hl-label blue">伪指令</mark> </strong><br><strong>1）段定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section .data [vstart] [align]</span><br></pre></td></tr></table></figure><p>masm 的段定义格式为 <code>data segment</code> 。关键字 vstart 很不好理解，关于 vstart 和 align 的详细讨论参见：<a href="https://jyx-fyh.github.io/2022/10/23/%E5%89%96%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/">程序加载器</a> 。</p><blockquote><p><code>.data</code> ，<code>.code</code> ，<code>.bss</code> ，<code>.text</code> 是标准的段名。<br><code>.data</code> ：用来存放程序中已初始化的全局变量的一块内存区域；<br><code>.bss</code>   ：用来存放程序中未初始化的全局变量的一块内存区域；<br><code>.code\.text</code> ：用来存放程序代码</p></blockquote><p><strong>2）$ 和 $$</strong><br>此二者常用来计算偏移量或文件大小。$ 表示当前行的汇编地址， $$ 表示本 section 的起始汇编地址， 它们两都受 vstart 影响。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section .data vstart=0x100</span><br><span class="line">db &quot;hello&quot;</span><br><span class="line">db $-$$</span><br></pre></td></tr></table></figure><p>以上 $ 的值为 <code>0x100+5=0x105</code> ，$$ 的值为 0x100 。</p><p><strong>3）声明重复内存单元</strong><br>masm 中使用如下格式声明重复的零内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw 100 dup(0)</span><br></pre></td></tr></table></figure><p>nasm 则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 100 db 0</span><br></pre></td></tr></table></figure><p><strong>4）段前缀</strong><br>在 masm 下可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[1000]</span><br></pre></td></tr></table></figure><p>在 nasm 下则必须这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[ds:1000]</span><br></pre></td></tr></table></figure><p><strong>5）指明内存操作数的大小</strong><br>在 masm 中必须使用 <code>size ptr</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte ptr [1000]</span><br></pre></td></tr></table></figure><p>在 nasm 中不需要加 <code>ptr</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte [1000]</span><br></pre></td></tr></table></figure><p><strong>6）equ 定义宏</strong><br>equ 用来为标识符定义一个整型常量，它的作用类似 C 语言中的宏。equ 不占任何内存，编译时会自动替换成相应值。</p><p><strong>7）定义数据</strong></p><ul><li><code>dw</code> ，<code>db</code> ，<code>dd</code> ，<code>dq</code> 用来声明初始化内存空间（用于 .data 段），即“define word”，“define byte”，“define double word”，“define quadword”(8 字节)；</li><li><code>resw</code> ，<code>resb</code> ，<code>resd</code> ，<code>resq</code> 用来声明非初始化内存空间（用于 .bss 段）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写加强堆</title>
      <link href="/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/"/>
      <url>/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>不了解堆结构的同学请先移步《<a href="https://jyxcpp.netlify.app/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/">堆与堆排序</a>》</p></blockquote><p><strong><mark class="hl-label blue">什么是加强堆？</mark> </strong><br>我们现在知道，堆结构主要用来处理海量数据下的动态优先级问题，需要频繁入队和频繁把优先级最高的元素出队。但有一种情形是普通堆结构难以高效处理的：一旦堆中的数据发生改变，如果不维护，此堆将作废无法使用；如果维护，那么定位发生变动的元素所需要的时间复杂度就为 O(N) ，其性能变得低效。为了应对堆中数据可能发生改变的情况，加强堆闪亮登场。</p><p>加强堆与普通堆的不同之处在于：加强堆使用了一张哈希表来记录元素及其所在位置。当元素发生变动时，可以由这张表快速定位到所在位置，从而进行相应调整。注意，哈希表的键为元素，值为其对应的位置，即数组下标；而数组本身也是算一张索引表，数组下标是索引，数组内容则是元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">heapGreater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">unordered_multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; indexMap;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">tmp = indexMap.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap.<span class="built_in">find</span>(a)-&gt;second = indexMap.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap.<span class="built_in">find</span>(b)-&gt;second = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (heap[(cur - <span class="number">1</span>) / <span class="number">2</span>] &lt; heap[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[(cur - <span class="number">1</span>) / <span class="number">2</span>], heap[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>((cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; ((<span class="type">int</span>)heap.<span class="built_in">size</span>() - <span class="number">1</span>))<span class="comment">//heap.size()返回的是无符号数size_t，若返回0，减1后为最大正数</span></span><br><span class="line"><span class="keyword">return</span>;                          <span class="comment">//所以必须要强制转为int</span></span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; (<span class="type">int</span>)heap.<span class="built_in">size</span>() &amp;&amp; heap[leftChd + <span class="number">1</span>] &gt; heap[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (heap[largest] &gt; heap[cur])<span class="comment">//大堆顶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[largest], heap[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (indexMap.<span class="built_in">find</span>(var) != indexMap.<span class="built_in">end</span>())<span class="comment">//不能加重复值！这是本实现的局限性</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">heap.<span class="built_in">push_back</span>(var);</span><br><span class="line">indexMap.<span class="built_in">emplace</span>(var,heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">heapInsert</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[<span class="number">0</span>], heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">heap.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> var)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> index = indexMap.<span class="built_in">find</span>(var)-&gt;second;</span><br><span class="line"><span class="built_in">swap</span>(heap[index], heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);<span class="comment">//参数可以直接写var</span></span><br><span class="line">heap.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span> (index != heap.<span class="built_in">size</span>())<span class="comment">//！当要删除的元素位于堆末尾时，pop后不再做以下操作，否则越界。注意此处是已经pop后的，易错写为heap.size()-1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heaplify</span>(index);</span><br><span class="line"><span class="built_in">heapInsert</span>(index);<span class="comment">//两个只会执行其中一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> var1, <span class="type">int</span> var2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (var1 == var2)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> index = indexMap.<span class="built_in">find</span>(var1)-&gt;second;</span><br><span class="line">heap[index] = var2;</span><br><span class="line">indexMap.<span class="built_in">emplace</span>(var2, index);</span><br><span class="line">indexMap.<span class="built_in">erase</span>(var1);</span><br><span class="line"><span class="built_in">heaplify</span>(index);</span><br><span class="line"><span class="built_in">heapInsert</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heapGreater shit;</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">32</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line">shit.<span class="built_in">push</span>(<span class="number">60</span>);</span><br><span class="line">shit.<span class="built_in">modify</span>(<span class="number">10</span>, <span class="number">121</span>);</span><br><span class="line">shit.<span class="built_in">remove</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">while</span> (shit.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; shit.<span class="built_in">peek</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">shit.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础-约束</title>
      <link href="/2022/09/28/Mysql%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/"/>
      <url>/2022/09/28/Mysql%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>约束用来保证数据库中数据的有效性和正确性。</strong></p><h3 id="font-color-red-主键约束-font"><font color='red'>主键约束</font></h3><p>主键（PRIMARY KEY）的完整称呼是“主键约束”，是 MySQL 中使用最为频繁的约束。一般情况下，为了便于 DBMS 更快的查找到表中的记录，都会在表中设置一个主键。使用主键应注意以下几点：</p><ul><li><strong>每个表只能定义一个主键。</strong></li><li><strong>创建主键时，自动创建主键索引</strong></li><li><strong>主键值必须唯一标识表中的每一行，且不能为 NULL</strong> ，即表中不可能存在有相同主键值的两行数据。这是唯一性原则。</li><li>一个字段名只能在联合主键字段表中出现一次。</li><li><strong>联合主键不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则。</strong></li></ul><p><strong><mark class="hl-label blue">创建主键</mark> </strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大线段重合问题， TopK问题</title>
      <link href="/2022/09/24/%E5%8A%A0%E5%BC%BA%E5%A0%86%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/09/24/%E5%8A%A0%E5%BC%BA%E5%A0%86%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-最大线段重合问题-font"><font color='red'>最大线段重合问题</font></h3><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定很多线段,每个线段都有两个数 [start, end] ，表示线段开始位置和结束位置，左右都是闭区间规定：1）线段的开始和结束位置一定都是整数值；2）线段重合区域的长度必须&gt;=1，也就是说仅顶点重合并不算重合区域。返回线段最多重合区域中,包含了几条线段。</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong></p><p>我们一步一步分析。<br>首先，怎么判断两条线段不重合？容易想到，当 <code>line1.left &gt;= line2.right</code> 或 <code>line1.right&lt;=line2.left</code> 时，就可以判定这两条线段不重合了。如下，<code>line1.right&lt;line2.left</code> ，<code>line3.left&gt;line2.right</code> 所以 line2 与 line1、line3 都不重合。<br><img src="/2022/img/未命名绘图-16641125875741.png" alt="" style="zoom:80%;" /></p><p>接着，如何判断两条线段不重合？仔细分析后可以发现，当 <code>line1.left&lt;=line2.left&lt;line1.right</code> 时，line1 与 line2 就发生重合(无需考虑 line2.right )，如下图：<br><img src="/2022/img/未命名绘图-16641133105063.png" style="zoom:80%;" /></p><p><strong>有读者一定会疑问，当 <code>line2.left&lt;=line1.left&lt;line2.right</code> 时，不也能重合吗？</strong> <strong><font color='red'>注意，这种情况和上面的情况是相同的，只不过 line1 与 line2 互换了名字而已，这点很重要</font></strong> 。为了避免出现这两种情况的混淆，<strong>我们有必要先根据线段左端点的位置给所有线段排个序</strong> ，如下图：<br><img src="/2022/img/未命名绘图-16641151643545.png" style="zoom:80%;" /><br>排好序后，我们判断是否重合时，就只需要考虑后面线段的左端点是否大于 <strong>前面线段的右端点（<font color='orange'>基准</font>）</strong> ，即只用考虑 <code>line2.left&lt;line1.right</code> ，因为排序后必有 <code>line1.left&lt;=line2.left</code> 。<br>接着，我们来分析上图中的三条线段。<code>line2.left&lt;line1.right</code> ，故 line2 与 line1 重合；<code>line3.left=line1.right</code> ，故 line3 与 line1 不重合；<code>line3.left&lt;line2.right</code> ，故 line3 与 line2 重合，即现在有两种情况重合，且重合数都为 2。那么问题来了，我们该记录哪种情况的重合数呢？都记录？有必要吗？实际上，只需要记录 line2 与 line3 的重合数即可，这是因为后续加入的线段的左端点不可能小于 3（因为之前我们已经对所有线段完成了排序），所以后续线段不可能再与 line1 发生重合，故可以直接将 line1 丢弃（标记为绿色）；如下图：<br><img src="/2022/img/未命名绘图-16641610218953.png" style="zoom:80%;" /></p><p>引入 line4，可见现在的最大重合数为 3，但这只是我们看出来的，还需要有一个固定的逻辑比较流程。如何得到最大重合数为 3？<code>line4.left&lt;line2.right</code> 且 <code>line4.left&lt;line3.right</code> ，所以得到重合数为 3？嗯，思路大致没错，聪明的你可能还会继续优化：只需要有 <code>line4.left&lt;line3.right</code> 就可以直接得到 3，你给出的理由是：既然 <code>line3.right&lt;line2.right</code> ，又因为 <code>line4.left&lt;line3.right</code> ，所以一定有 <code>line4.left&lt;line2.right</code> ，即不等式的传递性。果真是这样吗？那如果是下图情况呢：<br><img src="/2022/img/未命名绘图-16641621240717.png" style="zoom:80%;" /></p><p>显然，<code>line4.left&lt;=line3.right</code> ，重合数只有 2。但请注意，上图出现了我们之前讨论过的情况：后续线段左节点&gt;=前面线段右节点，即<code>line4.left&gt;=line2.right</code> 。按照之前的方案，我们将先 line2 丢弃：<br><img src="/2022/img/未命名绘图-16641624724099.png" style="zoom:80%;" /><br>继续，由于 <code>line4.left&lt;line3.right</code> ，所以得到重合数为 2。</p><p>由上分析，可知大致比较过程为：<strong>当加入新线段 lineN 时，依次丢弃之前的右端点小于等于 lineN.left 的线段，剩下的线段数即为最大重合数。</strong></p><p>啊？不对呀？万一碰到下面情况：<br><img src="/2022/img/未命名绘图-166416373697811.png" style="zoom:80%;" /><br>line4 将之前所有线段都弹出了，只剩 line4 一条线段了，但最大重合数不是 1，而是 2 呀！没错，所以我们还需要一个变量 max 来记录最大重合数，若当前重合数 <code>cur&gt;=max</code> ,则 <code>max=cur</code> ；若 <code>cur&lt;max</code> 则 <code>max=max</code> ，即 <code>max=cur&gt;max?cur:max;</code> 。就上图而言，加入 line4 时，max=2；加入 line4 ，弹出之前的线段后，cur=1；cur&lt;max，所以 max 仍然为 2。</p><p>下面给出全过程图示：<br><img src="/2022/img/未命名绘图-166416692487213.png" style="zoom:80%;" /></p><p>注意：左边灰色大框是堆结构，栈顶为堆中右端点最小的 right。</p><p>其实本算法中，堆结构并不关键，堆只是提供了取集合中最小值的便捷，难的还是其过程分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//sort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(line* arr, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[(cur - <span class="number">1</span>) / <span class="number">2</span>].end &gt; arr[cur].end)<span class="comment">//小顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur - <span class="number">1</span>) / <span class="number">2</span>], arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, (cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(line* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> smallest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>].end &lt; arr[leftChd].end ? leftChd + <span class="number">1</span> : leftChd;<span class="comment">//取出左右子树中最小的</span></span><br><span class="line"><span class="keyword">if</span> (arr[smallest].end &lt; arr[cur].end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[smallest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, smallest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapPop</span><span class="params">(line* arr, <span class="type">int</span>&amp; heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[heapSize - <span class="number">1</span>]);</span><br><span class="line">heapSize--;</span><br><span class="line"><span class="built_in">heaplify</span>(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//====================================================================================================</span></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function">line* <span class="title">generateRandomline</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">line* arr = <span class="keyword">new</span> line[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i].start = <span class="built_in">rand</span>() % max;</span><br><span class="line">arr[i].end = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">if</span> (arr[i].start == arr[i].end)</span><br><span class="line">arr[i].end += (<span class="built_in">rand</span>() % max / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[i].start &gt; arr[i].end)</span><br><span class="line"><span class="built_in">swap</span>(arr[i].start, arr[i].end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">line* <span class="title">cpyArr</span><span class="params">(line* src, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">line* des = <span class="keyword">new</span> line[size];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, size * <span class="built_in">sizeof</span>(line));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCover2</span><span class="params">(line* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> minStart = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.start &lt; b.start; &#125;);</span><br><span class="line">minStart = arr[<span class="number">0</span>].start;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.end &gt; b.end; &#125;);</span><br><span class="line">maxEnd = arr[<span class="number">0</span>].end;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxEnd - minStart; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> point = (<span class="type">double</span>)minStart + (<span class="type">double</span>)i + <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">double</span>)arr[k].start&lt;point &amp;&amp; (<span class="type">double</span>)arr[k].end&gt;point)</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">count = count &gt; tmp ? count : tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCover</span><span class="params">(line* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heapSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(&amp;arr[<span class="number">0</span>], &amp;arr[size], [](line a, line b) &#123;<span class="keyword">return</span> a.start &lt; b.start; &#125;);</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].end &lt;= arr[i].start &amp;&amp; heapSize &gt; <span class="number">0</span>)<span class="comment">//&lt;=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heapPop</span>(arr, heapSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">heapSize++;</span><br><span class="line">arr[heapSize - <span class="number">1</span>].end = arr[i].end;</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, heapSize<span class="number">-1</span>);</span><br><span class="line">max = max &gt; heapSize ? max : heapSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">1000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">10000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000</span>;<span class="comment">//线段终点最大位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line">line* arr_1 = <span class="built_in">generateRandomline</span>(max, arrLen);</span><br><span class="line">line* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="type">int</span> count_1 = <span class="built_in">maxCover</span>(arr_1, arrLen);</span><br><span class="line"><span class="type">int</span> count_2 = <span class="built_in">maxCover2</span>(arr_2, arrLen);</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count_1 = &quot;</span> &lt;&lt; count_1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count_2 = &quot;</span> &lt;&lt; count_2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; arr_2[i].start &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; arr_2[i].end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  success&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">line* arr = <span class="keyword">new</span> line[<span class="number">8</span>];</span><br><span class="line">arr[<span class="number">0</span>].start = <span class="number">0</span>, arr[<span class="number">0</span>].end = <span class="number">8</span>;</span><br><span class="line">arr[<span class="number">1</span>].start = <span class="number">2</span>, arr[<span class="number">1</span>].end = <span class="number">6</span>;</span><br><span class="line">arr[<span class="number">2</span>].start = <span class="number">1</span>, arr[<span class="number">2</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">3</span>].start = <span class="number">3</span>, arr[<span class="number">3</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">4</span>].start = <span class="number">4</span>, arr[<span class="number">4</span>].end = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">5</span>].start = <span class="number">3</span>, arr[<span class="number">5</span>].end = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">6</span>].start = <span class="number">0</span>, arr[<span class="number">6</span>].end = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">7</span>].start = <span class="number">0</span>, arr[<span class="number">7</span>].end = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">maxCover</span>(arr, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-TopK问题-font"><font color='red'>TopK问题</font></h3><blockquote><p>进行下面问题的探讨之前，请先移步《<a href="https://jyxcpp.netlify.app/2022/09/30/%E5%8A%A0%E5%BC%BA%E5%A0%86/">加强堆</a>》 ，而后此问题将迎刃而解。</p></blockquote><h3 id="font-color-red-TopK实际应用-font"><font color='red'>TopK实际应用</font></h3><p><strong><mark class="hl-label blue">应用情形</mark> </strong><br>某大型电商举办促销活动，从早上 8 点开始到晚上 12 点结束，这段时间内购买商品最多的前 K 位用户可以获得奖励，最终结果以 12 点的统计情况为准。为了提高用户参与活动的积极性，电商希望在平台官网实时更新并显示当前的得奖区用户（前K位用户）。排名具体规则如下：<br>1）得奖系统分为得奖区和候选区，任何用户只要购买数&gt;0，一定在这两个区域中的一个；<br>2）某用户发生购买商品事件，购买商品数+1；发生退货事件，购买商品数-1；如果购买数不足以进入得奖区的用户，进入候选区；<br>3）每次都是最多 K 个用户得奖，K 也为传入的参数如果根据全部规则，得奖人数确实不够 K 个，那就以不够的情况输出结果；<br>4）如果某个用户购买商品数为 0，但是又发生了退货事件，则认为该事件无效，得奖、候选名单和上一个事件发生后一致；<br>5）购买数最大的前 K 名用户进入得奖区，<strong>在最初时如果得奖区没有到达 K 个用户，那么新来的用户直接进入得奖区；</strong><br>6）当前事件发生的时间是指该操作对应的数组下标，比如下面代码中，5 对应的时间为其下标，即 6；<br>7）如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（ <strong>大于才能替换</strong> ）；<strong>如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户；如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户；</strong><br>8）<strong>从得奖区出来进入候选区的用户，进入候选区的时间就是当前事件的时间；从候选区出来进入得奖区的用户，进入得奖区的时间就是当前事件的时间；</strong><br>其实上述规则虽然很多，但并不复杂，反而非常贴切实际生活，尤其是第 7、8 点，这些规则能够促使你不仅要买的多，也必须买的早。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">3</span> , <span class="number">3</span> , <span class="number">1</span> , <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"> op = [T , T , T , T, F, T, F]</span><br></pre></td></tr></table></figure><p>以上代码中 arr[ ] 表示客户编号，op[ ] 表示客户操作；数组内容依次表示：3 用户购买了一件商品，3 用户购买了一件商品，1 用户购买了一件商品，2 用户购买了一件商品，1 用户退货了一件商品，2 用户购买了一件商品，5 用户退货了一件商品…</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong><br><font color='orange'>注意字眼：“大型电商”——海量数据，“实时更新”——动态插入，“前K位”——优先级队列</font> 。<strong>显然，这是一类海量数据+动态插入的优先级队列问题，首先考虑用堆来解决。容易想到，候选区与得奖区应该使用两个堆分别进行维护。又观察到同一个用户可以在多个时间段进行加购和退货操作，所以必须动态调整该用户在堆中的位置，所以考虑使用加强堆</strong> 。具体过程如下：<br><img src="/2022/img/未命名绘图-16648848835431.png" style="zoom: 67%;" /></p><p>可别忘了规则中提到的几点：</p><ol><li>heap1是候选堆，heap2是得奖区。</li><li>候选区的堆顶是该堆中购买商品最多的用户，如果多个用户购买商品的数量相同，则时间点早的用户优先。得奖区的堆顶是该堆中购买商品最少的用户，如果多个用户购买商品的数量相同，则时间点早的用户优先。</li><li>当得奖区用户数没达到 K 时，新用户直接进入得奖区。</li><li>交换堆顶时，两个用户的时间点都会更新为当前的时间。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> buy;</span><br><span class="line"><span class="type">int</span> time;</span><br><span class="line"><span class="built_in">client</span>(<span class="type">int</span> _id, <span class="type">int</span> _buy, <span class="type">int</span> _time) :<span class="built_in">id</span>(_id), <span class="built_in">buy</span>(_buy), <span class="built_in">time</span>(_time) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myKey</span><span class="comment">//自定义哈希规则，注意const不能少</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> client&amp; a)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(a.id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isEqual</span><span class="comment">//自定义判断键是否相等规则，注意const不能少</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> client&amp; a, <span class="type">const</span> client&amp; b)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.id == b.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">topK</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">hp</span> &#123; cnd, win &#125;;<span class="comment">//cnd为candidate侯选区，win为得奖区</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">batchRank</span><span class="params">()</span></span>;<span class="comment">//批量排名，数据一次性交付时使用此方法1</span></span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">bool</span> buy)</span></span>;<span class="comment">//数据动态加入，边加边维护</span></span><br><span class="line"><span class="built_in">topK</span>(<span class="type">int</span>*user,<span class="type">bool</span>*buy,<span class="type">int</span> size,<span class="type">int</span> k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(client&amp; a, client&amp; b, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> cur, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span> cur, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comparator</span><span class="params">(<span class="type">const</span> client&amp; cur, <span class="type">const</span> client&amp; dad, hp p)</span></span>;<span class="comment">//比较器，减少了代码量。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapHeapTops</span><span class="params">()</span></span>;<span class="comment">//交换两个堆的堆顶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//解决流程</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;client&gt;&gt; heap;<span class="comment">//二维动态数组，heap[cnd]是候选堆，heap[win]是得奖堆</span></span><br><span class="line">unordered_multimap &lt; client, <span class="type">int</span>, myKey, isEqual&gt; indexMap1;<span class="comment">//候选堆的反向索引表</span></span><br><span class="line">unordered_multimap&lt;client, <span class="type">int</span>, myKey, isEqual&gt; indexMap2;<span class="comment">//得奖堆的反向索引表</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;user;<span class="comment">//用户id</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;buy;<span class="comment">//用户购买情况</span></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">topK::batchRank</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= <span class="number">0</span>||user.<span class="built_in">size</span>()==<span class="number">0</span>||buy.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;client&gt;();<span class="comment">//返回空数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; user.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solution</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;client&gt;tops;<span class="comment">//注意不能直接在得奖堆上排序，否则后续无法add，所以另开数组进行排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap[hp::win].<span class="built_in">end</span>() - heap[hp::win].<span class="built_in">begin</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tops.<span class="built_in">push_back</span>(heap[hp::win][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(tops.<span class="built_in">begin</span>(), tops.<span class="built_in">end</span>(), [](client a, client b) &#123; </span><br><span class="line"><span class="keyword">return</span> a.buy != b.buy ? a.buy &gt; b.buy:a.time &lt; b.time; &#125;);<span class="comment">//购买商品多的排前面，如果一样多，买的早的排前面</span></span><br><span class="line"><span class="keyword">return</span> tops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;client&gt; <span class="title">topK::add</span><span class="params">(<span class="type">int</span> id, <span class="type">bool</span> buy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;user.<span class="built_in">push_back</span>(id);</span><br><span class="line"><span class="keyword">this</span>-&gt;buy.<span class="built_in">push_back</span>(buy);</span><br><span class="line"><span class="built_in">solution</span>(user.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">vector&lt;client&gt;tops;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap[hp::win].<span class="built_in">end</span>() - heap[hp::win].<span class="built_in">begin</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tops.<span class="built_in">push_back</span>(heap[hp::win][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(tops.<span class="built_in">begin</span>(), tops.<span class="built_in">end</span>(), [](client a, client b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.buy != b.buy ? a.buy &gt; b.buy:a.time &lt; b.time; &#125;);</span><br><span class="line"><span class="keyword">return</span> tops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topK::<span class="built_in">topK</span>(<span class="type">int</span>* user,<span class="type">bool</span>* buy,<span class="type">int</span> size,<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;client&gt;heapCnd;</span><br><span class="line">vector&lt;client&gt;heapWin;</span><br><span class="line">heap.<span class="built_in">push_back</span>(heapCnd);</span><br><span class="line">heap.<span class="built_in">push_back</span>(heapWin);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;user.<span class="built_in">push_back</span>(user[i]);</span><br><span class="line"><span class="keyword">this</span>-&gt;buy.<span class="built_in">push_back</span>(buy[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::swap</span><span class="params">(client&amp; a, client&amp; b,hp p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//互换两用户在堆内的位置</span></span><br><span class="line">    client tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">    <span class="comment">//索引表中的位置信息也要互换</span></span><br><span class="line"><span class="keyword">if</span> (p == hp::cnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = indexMap1.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap1.<span class="built_in">find</span>(a)-&gt;second = indexMap1.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap1.<span class="built_in">find</span>(b)-&gt;second = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = indexMap2.<span class="built_in">find</span>(a)-&gt;second;</span><br><span class="line">indexMap2.<span class="built_in">find</span>(a)-&gt;second = indexMap2.<span class="built_in">find</span>(b)-&gt;second;</span><br><span class="line">indexMap2.<span class="built_in">find</span>(b)-&gt;second = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::heapInsert</span><span class="params">(<span class="type">int</span> cur,hp p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comparator</span>(heap[p][cur],heap[p][(cur<span class="number">-1</span>)/<span class="number">2</span>],p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][(cur - <span class="number">1</span>) / <span class="number">2</span>], heap[p][cur], p);</span><br><span class="line"><span class="built_in">heapInsert</span>((cur - <span class="number">1</span>) / <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::heaplify</span><span class="params">(<span class="type">int</span> cur,hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; (<span class="type">int</span>)heap[p].<span class="built_in">size</span>() - <span class="number">1</span>)<span class="comment">//int!!!!</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> tar = leftChd + <span class="number">1</span> &lt; heap[p].<span class="built_in">size</span>() &amp;&amp; <span class="built_in">comparator</span>(heap[p][leftChd + <span class="number">1</span>], heap[p][leftChd],p) ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comparator</span>(heap[p][tar] , heap[p][cur],p))<span class="comment">//注意位置不能换！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][tar], heap[p][cur],p);</span><br><span class="line"><span class="built_in">heaplify</span>(tar,p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topK::comparator</span><span class="params">(<span class="type">const</span> client&amp; cur, <span class="type">const</span> client&amp; dad,hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==hp::cnd)</span><br><span class="line"><span class="keyword">return</span> cur.buy != dad.buy ? cur.buy &gt; dad.buy:cur.time &lt; dad.time;</span><br><span class="line"><span class="keyword">if</span>(p==hp::win)</span><br><span class="line"><span class="keyword">return</span> cur.buy != dad.buy ? cur.buy &lt; dad.buy : cur.time &lt; dad.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::remove</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pos = p == hp::cnd ? indexMap1.<span class="built_in">find</span>(usr)-&gt;second : indexMap2.<span class="built_in">find</span>(usr)-&gt;second;</span><br><span class="line"><span class="built_in">swap</span>(heap[p][heap[p].<span class="built_in">size</span>() - <span class="number">1</span>], heap[p][pos], p);</span><br><span class="line">heap[p].<span class="built_in">pop_back</span>();</span><br><span class="line">p == hp::cnd ? indexMap1.<span class="built_in">erase</span>(usr) : indexMap2.<span class="built_in">erase</span>(usr);</span><br><span class="line"><span class="keyword">if</span> (pos != heap[p].<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, p);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::push</span><span class="params">(<span class="type">const</span> client&amp; usr, hp p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[p].<span class="built_in">push_back</span>(usr);</span><br><span class="line">p == hp::cnd ? indexMap1.<span class="built_in">emplace</span>(usr, heap[p].<span class="built_in">size</span>() - <span class="number">1</span>) : indexMap2.<span class="built_in">emplace</span>(usr, heap[p].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">heapInsert</span>(heap[p].<span class="built_in">size</span>() - <span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::swapHeapTops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">indexMap1.<span class="built_in">erase</span>(heap[hp::cnd][<span class="number">0</span>]);</span><br><span class="line">indexMap2.<span class="built_in">erase</span>(heap[hp::win][<span class="number">0</span>]);</span><br><span class="line">indexMap1.<span class="built_in">emplace</span>(heap[hp::win][<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">indexMap2.<span class="built_in">emplace</span>(heap[hp::cnd][<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">client tmp = heap[hp::cnd][<span class="number">0</span>];</span><br><span class="line">heap[hp::cnd][<span class="number">0</span>] = heap[hp::win][<span class="number">0</span>];</span><br><span class="line">heap[hp::win][<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topK::solution</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">client <span class="title">tmp</span><span class="params">(user[i], <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (indexMap1.<span class="built_in">find</span>(tmp) != indexMap1.<span class="built_in">end</span>())<span class="comment">//若usr在候选堆中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos = indexMap1.<span class="built_in">find</span>(tmp)-&gt;second;</span><br><span class="line">client&amp; usr = heap[hp::cnd][pos];</span><br><span class="line">buy[i] ? usr.buy++ : usr.buy--;</span><br><span class="line">usr.time = i;</span><br><span class="line"><span class="keyword">if</span> (usr.buy &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">remove</span>(usr, hp::cnd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, hp::cnd);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, hp::cnd);</span><br><span class="line"><span class="keyword">if</span> (heap[hp::cnd][<span class="number">0</span>].buy &gt; heap[hp::win][<span class="number">0</span>].buy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swapHeapTops</span>();</span><br><span class="line">heap[hp::cnd][<span class="number">0</span>].time = i;</span><br><span class="line">heap[hp::win][<span class="number">0</span>].time = i;<span class="comment">//更新时间</span></span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>, hp::win);<span class="comment">//交换堆顶后，需要下沉</span></span><br><span class="line"><span class="built_in">heaplify</span>(<span class="number">0</span>, hp::cnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexMap2.<span class="built_in">find</span>(tmp) != indexMap2.<span class="built_in">end</span>())<span class="comment">//若usr在得奖区中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos = indexMap2.<span class="built_in">find</span>(tmp)-&gt;second;</span><br><span class="line">client&amp; usr = heap[hp::win][pos];</span><br><span class="line">buy[i] ? usr.buy++ : usr.buy--;</span><br><span class="line">usr.time = i;</span><br><span class="line"><span class="keyword">if</span> (usr.buy &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">remove</span>(usr, hp::win);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">heapInsert</span>(pos, hp::win);</span><br><span class="line"><span class="built_in">heaplify</span>(pos, hp::win);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//若是新参与者</span></span><br><span class="line">&#123;</span><br><span class="line">buy[i] ? tmp.buy++ : tmp.buy--;</span><br><span class="line">tmp.time = i;</span><br><span class="line"><span class="keyword">if</span> (tmp.buy &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (heap[win].<span class="built_in">size</span>() &lt; k)</span><br><span class="line"><span class="built_in">push</span>(tmp, hp::win);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">push</span>(tmp, hp::cnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> user[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">bool</span> buy[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="function">topK <span class="title">issue</span><span class="params">(user, buy, <span class="keyword">sizeof</span>(user) / <span class="keyword">sizeof</span>(<span class="type">int</span>), k)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> res = issue.<span class="built_in">batchRank</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : res)</span><br><span class="line">cout &lt;&lt; i.id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">    issue.<span class="built_in">add</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">res = issue.<span class="built_in">add</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : res)</span><br><span class="line">cout &lt;&lt; i.id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关细节在注释中，除此外还需要强调：</p><ol><li>开辟二维vector是为了减少判断哪个堆的代码量，比如在 heaplify() 和 heapInsert() 中，直接使用 hp 对某个堆进行操作，无需判断是哪个堆，减少了代码量。</li><li>比较器也在本算法中发挥了较大作用，减少了代码量，提高可读性，同时便于维护。关于比较器，详细参见：<a href="https://jyxcpp.netlify.app/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/">仿函数与比较器</a> 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较器与仿函数</title>
      <link href="/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/"/>
      <url>/2022/09/23/%E5%88%9D%E8%AF%86%E6%AF%94%E8%BE%83%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-比较器-font"><font color='red'>比较器</font></h3><p>比较器用于自定义数据类型的比较，主要有三种方式：</p><ol><li><p>基于运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//也可以写作operator&lt;(const client c)const，没有任何区别</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> client c)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;id &lt; c.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>operator&gt;函数最后的 const 不能删</strong> ；当 <code>return this-&gt;id&lt;c.id</code> 中 <code>&lt;</code> 改为 <code>&gt;</code> ，就变为升序。为对象写好自带的比较器后，就无需再传比较器。</p></li><li><p>基于函数的比较器<br><strong>C++用模板实现十分方便，而且这种方式不仅能够传函数比较器，还可以传结构体比较器以及仿函数</strong> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> _age,string _name):<span class="built_in">age</span>(_age),<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> stu&amp; a, <span class="type">const</span> stu&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> stu&amp; a,<span class="type">const</span> stu&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator c=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(arr[k], arr[k + <span class="number">1</span>]))#使用比较器</span><br><span class="line"><span class="built_in">mySwap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu arr[] = &#123; <span class="built_in">stu</span>(<span class="number">22</span>,<span class="string">&quot;xuan&quot;</span>),<span class="built_in">stu</span>(<span class="number">15</span>,<span class="string">&quot;han&quot;</span>),<span class="built_in">stu</span>(<span class="number">18</span>,<span class="string">&quot;shan&quot;</span>) &#125;;</span><br><span class="line"><span class="built_in">mySort</span>&lt;stu&gt;(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(stu),cmp1);</span><br><span class="line">    <span class="comment">//mySort&lt;stu&gt;(arr, sizeof(arr) / sizeof(stu),cmp2());#传结构体必须传实例，所以要加括号</span></span><br><span class="line">    <span class="comment">//mySort&lt;stu&gt;(arr, sizeof(arr) / sizeof(stu),[](const stu&amp; a,const stu&amp;b)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a.age&lt;b.age;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">cout &lt;&lt; i.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 C 语言，也可以利用回调函数，即函数的参数为函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mySwap</span><span class="params">(<span class="keyword">struct</span> stu* a, <span class="keyword">struct</span> stu* b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">tmp</span> =</span> *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp1</span><span class="params">(<span class="keyword">struct</span> stu* a, <span class="keyword">struct</span> stu* b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b-&gt;age - a-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mySort</span><span class="params">(<span class="keyword">struct</span> stu* arr, <span class="type">int</span> size, <span class="type">int</span> (*cmp)(<span class="keyword">struct</span> stu*, <span class="keyword">struct</span> stu*))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cmp(&amp;arr[k], &amp;arr[k + <span class="number">1</span>])&gt;<span class="number">0</span>)</span><br><span class="line">mySwap(&amp;arr[k], &amp;arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">arr</span>[] =</span> &#123; &#123;.age=<span class="number">22</span>,.name=<span class="string">&quot;xuan&quot;</span>&#125;,&#123;.age=<span class="number">45</span>,.name=<span class="string">&quot;han&quot;</span>&#125;,&#123;.age=<span class="number">18</span>,.name=<span class="string">&quot;shan&quot;</span>&#125; &#125;;</span><br><span class="line">mySort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu), cmp1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>, arr[i].name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于仿函数的比较器，见上。</p></li><li><p>基于结构体的比较器，见上。当然也可以不用模板，但显然没有上面方式灵活。</p></li></ol><h3 id="font-color-red-仿函数-font"><font color='red'>仿函数</font></h3><p><strong>仿函数 (functor) 并非函数，其本质就是重载了 () 操作符 的 struct 或 class</strong> ，由于重载了（）操作符，所以使用它的时候就像在调用函数一样，于是就被称为“仿”函数啦。<br>仿函数使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> _age,string _name):<span class="built_in">age</span>(_age),<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> stu&amp; a,<span class="type">const</span> stu&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator c=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>(arr[k], arr[k + <span class="number">1</span>]))#使用比较器</span><br><span class="line"><span class="built_in">mySwap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu arr[] = &#123; <span class="built_in">stu</span>(<span class="number">22</span>,<span class="string">&quot;xuan&quot;</span>),<span class="built_in">stu</span>(<span class="number">15</span>,<span class="string">&quot;han&quot;</span>),<span class="built_in">stu</span>(<span class="number">18</span>,<span class="string">&quot;shan&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">mySort</span>&lt;stu&gt;(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(stu),<span class="built_in">cmp2</span>());#传结构体必须传实例，所以要加括号</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">cout &lt;&lt; i.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆与堆排序</title>
      <link href="/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/22/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-完全二叉树-font"><font color='red'>完全二叉树</font></h3><p><strong><mark class="hl-label blue">什么是完全二叉树？</mark> </strong><br>如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是 <strong><font color='orange'>满二叉树</font></strong> ；也可以这样解释：如果二叉树中除了叶子结点，每个结点都有左右两个子树，则此二叉树称为满二叉树。如下两个树都是满二叉树：<br><img src="/2022/img/未命名绘图-16638463052091.png" style="zoom:80%;" /></p><p>而 <strong><font color='orange'>完全二叉树</font></strong> 的定义为：<u>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树</u>。也可以这么定义：<u>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树</u>。如下两棵树就是完全二叉树：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638465286303.png" alt=""></p><p><strong><mark class="hl-label blue">完全二叉树的表示</mark> </strong><br>二叉树]的存储结构有两种，分别为顺序存储和链式存储。这里我们采用顺序存储。<strong>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</strong> 图示如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638474045907.png" alt=""></p><p>以数组下标 i 表示节点的位置，可得以下公式：</p><ul><li><code>节点i的父节点=[(i-1)/2]</code> ，[ ] 表示向下取整。比如上图中值为 9 的节点，其下标为 4，[ (4-1) / 2 ] = 1，所以其父节点位置为 1，值为 6。</li><li><code>节点i的左孩子=2*i+1</code> ，<code>节点i的右孩子=2*i+2</code> 。</li></ul><h3 id="font-color-red-堆-font"><font color='red'>堆</font></h3><p><strong><mark class="hl-label blue">堆的定义</mark> </strong><br>定义1：堆是一种特殊的完全二叉树，其每一个节点的值都是在以该节点为根节点的树中最大(小)的值。定义2：堆中某个结点的值总是不大于或不小于其父结点的值；如下图：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16638493337779.png" alt=""></p><p><strong><mark class="hl-label blue">堆的作用</mark> </strong></p><p><strong>堆的重要作用是用来实现<font color='orange'>优先级队列</font></strong> 。什么是优先级队列呢？优先级队列（priority queue） 是多个元素的集合，每个元素都有一个优先权；对优先级队列执行的操作有 <strong>（1）查找（2）插入一个新元素 （3）删除</strong> ； <u>一般情况下，查找操作用来搜索优先权最大（即数值最大或最小）的元素，删除操作用来删除该元素 。</u>  <strong><font color='orange'>优先级队列是用来处理动态问题的</font>，需要频繁入队和频繁把优先级最高的元素出队。</strong><br>小伙伴们一定会产生这样一个疑问：既然堆是用来动态提取集合中的最大值或最小值，那为什么不直接排序呢？排序后不也能很快找到最大或最小值吗？没错，当数据量小时，可以直接使用排序。但当数据量很大时，数组中每次进来一个新的数据，你难道得全部重新排序一下吗？显然不合适，此时就需要用到堆。建好堆后，<u>数据 <strong>动态</strong> 的插入和删除，时间复杂度都为O(logn)；查询最大/小值，时间复杂度为O(1)</u>，具体分析见后文。</p><blockquote><p>笔者在知乎看见一个很好的类比：<br>题主不愿意洗袜子，又不想穿臭袜子，期望穿臭了就扔。但是穿一次就扔太浪费，而且有时候天气热，有时候凉，袜子穿的次数不定，比较环保标准是拿起袜子来闻一下，如果臭得受不了了就扔掉它。又假设题主期望批量买袜子，避免麻烦，一次性买了三百只袜子，以每只袜子至少可以穿两次论够穿两年。扔的时候也希望一起扔，不要一只只地扔以免麻烦。</p><p>计划开始执行的前半年里是轻松的，基本上早上起床随手抓来袜子都可以穿，但慢慢的局势开始恶化，起床后闻了十双袜子都臭不可闻，费半天劲才能找到一双可以穿的袜子。</p><p>在这种场景下，把所有的袜子排成一个按味道排列的小顶堆就是个优化解法。我们假设题主从最开始就有建堆，这样每天离家时，穿堆顶最不臭的那双袜子走人，回家时袜子脱下来重新插入到堆中，插入过程最多闻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 次袜子；明天直接就可以穿堆顶的袜子。当堆顶的袜子臭不可闻时，就全部扔掉重买一批。</p><p>如上，堆排序对现实生活也有巨大的指导意义。<br>其他关于堆的详细介绍，参见：<a href="https://www.zhihu.com/question/466078026">堆的意义？</a></p></blockquote><p><strong><mark class="hl-label blue">堆的构建</mark> </strong><br>堆的构建有两种方式：</p><ol><li><strong>从上往下构建</strong> ，当数据不是一次性交付时（比如每次只输入一个数)，采用此方式；该方法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>从下往上构建</strong> ，当数据一次性交付时，采用此方式构建；该方法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。复杂度分析见后文。</li></ol><p><strong><mark class="hl-label red">1.从上往下构建</mark> </strong><br>核心为 heapInsert() 方法。以构建大堆为例：</p><ol><li>当加入一个新数字时，heapSize++，将该数字放入数组堆末尾，即 arr[heapSize-1]位置；</li><li>接着将 arr[heapSize] 与其父节点进行比较，如果 arr[heapSize] 大于父节点的值，则 swap 此二节点；否则重复 1。</li><li>swap 后继续比较该节点与其新的父节点，如果前者大于后者，则再次 swap，如此反复，直到该节点不再大于其父节点。</li></ol><p>过程图示如下：<br><img src="/2022/img/未命名绘图-166390312717915.png" style="zoom:67%;" /><br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[(cur<span class="number">-1</span>)/<span class="number">2</span>] &lt; arr[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur<span class="number">-1</span>)/<span class="number">2</span>],arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr,(cur<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本方法采用递归实现，也可迭代实现。</li><li>如果要改为小顶堆，将第 3 行的 &lt; 改为 &gt; 即可。</li><li><strong>注意：第 3 行的 &lt; 不能改为 &lt;=，否则当 <code>cur = 0</code> 时，将会一直重复。</strong></li><li>heapInsert() 无需 heapSize，因为是从当前位置往前 swap，而不是往后 swap。</li></ul><p><strong><mark class="hl-label red">2.从下往上构建</mark> </strong><br>核心为 heaplify() 方法，以构建大顶堆为例：<br><img src="/2022/img/未命名绘图-166390135670413.png" style="zoom:80%;" /><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>] &gt; arr[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (arr[largest] &gt; arr[cur])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[largest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, largest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="built_in">heaplify</span>(arr, i, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size</code> 和 <code>heapSize</code> 在建堆时没有用处，在后续删除堆顶时才会体现其用处。</li><li>注意第 6 行代码的作用：如果没有右孩子，那么直接选择左孩子为比较对象；如果有右孩子，则选出左右孩子中最大的那个作为比较对象。</li></ul><p><strong><mark class="hl-label blue">删除堆顶</mark> </strong><br>删除堆顶的步骤很简单：</p><ol><li><p>交换堆顶和堆中最后一个节点。</p></li><li><p>删除最后一个节点，即缩小堆的大小（heapSize–）</p><blockquote><p>注意，数组 arr 是堆 heap 的物理结构，arr 的大小应大于 heapSize；<strong>堆通过 heapSize 的加减进行伸缩。</strong><br>另外需要注意的是，由于是排序，一次性交付整个待排序的数组，所以堆可以直接在数组首部构建，无需额外空间复杂度；但在其他很多情况下，堆一般可直接由可变长数组（vector）实现；两者原理是一样的。</p></blockquote></li><li><p>堆顶调用 heaplify()；</p></li></ol><p>图示如下：<br><img src="/2022/img/未命名绘图-166390433704719.png" style="zoom:80%;" /></p><h3 id="font-color-red-堆排序-font"><font color='red'>堆排序</font></h3><p>堆排序就是不断删除堆顶的过程，每次堆顶都移到数组的 heapSize-1 的位置，所以对于大顶堆，排序结果就应该为升序；对于小顶堆，排序结果就为降序。<br>代码如下（附带对数器）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===================================================================================================</span></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[(cur - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[cur])<span class="comment">//大顶堆</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[(cur - <span class="number">1</span>) / <span class="number">2</span>], arr[cur]);</span><br><span class="line"><span class="built_in">heapInsert</span>(arr, (cur - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heaplify</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> cur, <span class="type">int</span> heapSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> leftChd = cur * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (leftChd &gt; heapSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> largest = leftChd + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[leftChd + <span class="number">1</span>] &gt; arr[leftChd] ? leftChd + <span class="number">1</span> : leftChd;</span><br><span class="line"><span class="keyword">if</span> (arr[largest] &gt; arr[cur])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[largest], arr[cur]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, largest, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heaplify</span>(arr, i, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt;= size; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//heapInsert(arr, i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[size - <span class="number">1</span> - i]);</span><br><span class="line"><span class="built_in">heaplify</span>(arr, <span class="number">0</span>, size - i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; arr[k + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[k];</span><br><span class="line">arr[k] = arr[k + <span class="number">1</span>];</span><br><span class="line">arr[k + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====================================================================================================</span></span><br><span class="line"><span class="comment">//对数器</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==================================================================================================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">10000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">100000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">heapSort</span>(arr_2, arrLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, arrLen) == <span class="literal">false</span>) &#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fuck!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout &lt;&lt; arr_1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;success   &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-复杂度分析-font"><font color='red'>复杂度分析</font></h3><p><strong>从上向下建堆的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，原因如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>1</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>&lt;</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">log1+log2+log3+...+logN&lt;NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，即复杂度上限为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>&lt;</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi><mo>&lt;</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN&lt;log(N+1)+log(N+2)+log(N+3)+...+log2N&lt;Nlog2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，即当 <strong>数据倍增</strong> 后，复杂度下限仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，故复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>  。</p><p><strong>从下向上建堆的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，原因如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>×</mo><mn>0</mn><mo>+</mo><mfrac><mi>N</mi><mn>4</mn></mfrac><mo>×</mo><mn>1</mn><mo>+</mo><mfrac><mi>N</mi><mn>8</mn></mfrac><mo>×</mo><mn>2</mn><mo>+</mo><mfrac><mi>N</mi><mn>16</mn></mfrac><mo>×</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mrow><mn>1</mn><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow></msup></mfrac><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">M=\frac{N}{2}×0+\frac{N}{4}×1+\frac{N}{8}×2+\frac{N}{16}×3+...+\frac{N}{2^{1+logN}}×logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2298em;vertical-align:-0.3574em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.6426em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.782em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>最终可证得 M 收敛于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；<br><strong>heapInsert 与 heaplify 的复杂度都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ；</p><p><strong>删除堆顶的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ，其证明同从上向下建堆。故最后算法整体的时间复杂度也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。<br><strong>堆排序的额外空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong> ，在原数组中就能完成排序，<strong>heapSize 起到了关键作用</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
          <category> 堆结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引</title>
      <link href="/2022/09/18/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/09/18/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-索引简介-font"><font color='red'>索引简介</font></h3><p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p><ol><li><strong>顺序访问</strong></li></ol><p>顺序访问是在表中实行 <strong>全表扫描</strong> ，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。顺序访问实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。</p><ol start="2"><li><strong>索引访问</strong></li></ol><p>索引访问是通过遍历索引来访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引之所以快，是因为其底层采用 B+ 树，详细内容见：<a href="https://zhuanlan.zhihu.com/p/77383599">Mysql索引</a> .</p><p>索引最大的优点就是在海量数据下能够大幅提高查询速度。当然，索引也有缺点：1）索引需要占磁盘空间；2）当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。<strong>索引可以提高查询速度，但是会影响插入记录的速度</strong> 。因为，<strong>向有索引的表中插入记录时，数据库系统会按照索引进行排序</strong> ，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。<strong>这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> ID       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> ID          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> score    <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> score       <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">4</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> score<span class="operator">=</span><span class="number">149</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> score         <span class="operator">|</span> score <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+-------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>使用 EXPLAIN 分析查询情况，使用 score 索引查找时，扫描的行数为 1；使用 name 无索引查找时，扫描的行数为 4，为全表扫描。</p><h3 id="font-color-red-索引类型-font"><font color='red'>索引类型</font></h3><h4 id="font-color-gree-按逻辑划分-font"><font color='gree'>按逻辑划分</font></h4><ol><li><p><strong>普通索引</strong> 。<br>普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。<strong>普通索引允许在定义索引的列中插入重复值和空值。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_id <span class="keyword">ON</span> tb_student(id);</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引</strong> 。<br>创建唯一性索引的目的不是为了提高访问速度，<strong>而是为了避免数据出现重复</strong> 。<strong>唯一索引列的值必须唯一，允许有空值，且允许存在多个空值</strong> 。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_id <span class="keyword">ON</span> tb_student(id);</span><br></pre></td></tr></table></figure></li><li><p><strong>主键索引</strong> 。<br>创建主键时，自动成为索引。主键索引是一种特殊的唯一索引，<strong>不允许值重复或者值为空</strong> 。创建主键索引通常使用 <code>PRIMARY KEY</code> 关键字，不能使用 <code>CREATE INDEX</code> 语句创建主键索引。</p></li><li><p><strong>空间索引</strong> 。<br>空间索引主要用于地理空间数据类型 GEOMETRY，不常用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SPATIAL INDEX index_line <span class="keyword">ON</span> tb_student(line);</span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引</strong> 。<br>全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。<strong>在 MySQL 中只有 MyISAM 存储引擎支持全文索引。</strong> 实际开发中，不采用 mysql 自带的全文索引（其效率不高），而使用全文搜索框架 Solr 和 ElasticSearch。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_info <span class="keyword">ON</span> tb_student(info);</span><br></pre></td></tr></table></figure></li></ol><h4 id="font-color-gree-按实现划分-font"><font color='gree'>按实现划分</font></h4><ol><li><p><strong>BTREE索引</strong> 。<br>目前大部分的索引都是采用 B-树索引来存储的。B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：</p><ul><li>查询必须从索引的最左边的列开始。</li><li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li><li>存储引擎不能使用索引中范围条件右边的列。</li></ul></li><li><p><strong>哈希索引</strong><br>又叫散列索引。仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。哈希速度比 BTREE 更快，但缺点也很明显：</p><ul><li>相对于 B-树索引来说，建立哈希索引会耗费更多的时间。</li><li>只支持等值比较，如 “=” ，“IN()” 或 “&lt;=&gt;”。</li><li>不能使用 HASH 索引排序</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的.</li></ul><table><thead><tr><th><strong>存储引擎</strong></th><th><strong>允许的索引类型</strong></th></tr></thead><tbody><tr><td>MyISAM</td><td>BTREE</td></tr><tr><td>InnoDB</td><td>BTREE</td></tr><tr><td>MEMORY/HEAP</td><td>HASH, BTREE</td></tr></tbody></table></li></ol><h4 id="font-color-gree-按数量划分-font"><font color='gree'>按数量划分</font></h4><ol><li><p><strong>单列索引</strong> 。<br>单列索引就是索引只包含原表的一个列。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。</p></li><li><p><strong>多列索引</strong> 。<br>也称为复合索引或组合索引。相对于单列索引来说，<strong>组合索引是将原表的多个列共同组成一个索引</strong> 。多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。<strong>但是，只有查询条件中使用了这些字段中<u>第一个字段</u>时，索引才会被使用。</strong> 例如，在表中的 id、name 和 sex 字段上建立一个多列索引，那么，只有查询条件使用了 id 字段时，该索引才会被使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_na <span class="keyword">ON</span> tb_student(id,name,sex);</span><br></pre></td></tr></table></figure></li></ol><h3 id="font-color-red-创建索引-font"><font color='red'>创建索引</font></h3><p><strong><mark class="hl-label blue">使用 CREATE INDEX 语句</mark> </strong><br>可以使用专门用于创建索引的 CREATE INDEX 语句在一个已有的表上创建索引，<strong>但该语句不能创建主键</strong> 。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>长度<span class="operator">&gt;</span>] [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;长度&gt;</code> ：可选项。指定使用列前的 length 个字符来创建索引。<strong>使用列的一部分创建索引有利于减小索引文件的大小</strong> ，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，<strong>BLOB 或 TEXT 类型的列也必须使用前缀索引</strong> 。</p><blockquote><p>前缀最长为255字节。对于 MyISAM 和 InnoDB 表，前缀最长为1000字节。注意前缀的限长以字节计，而CREATE  INDEX语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。<br>另外，当查询条件的前缀与索引前缀相同时，索引也起不到作用。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> ID       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> ID          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> ID<span class="operator">=</span><span class="string">&#x27;12134&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> ID            <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span>    <span class="number">80.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info <span class="keyword">WHERE</span> ID<span class="operator">=</span><span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> stu_info <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> ID            <span class="operator">|</span> ID   <span class="operator">|</span> <span class="number">15</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+---------------+------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，ID 索引长度为 4。</p></blockquote></li><li><p><code>ASC|DESC</code> ：可选项。<code>ASC</code> 指定索引按照升序来排列，<code>DESC</code> 指定索引按照降序来排列，默认为 <code>ASC</code> 。</p><blockquote><p>目前(2005年)，<code>ASC|DESC</code>  关键词被分析，但是被忽略；索引值均以递增顺序存储。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> ID    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12134</span> <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12135</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12136</span> <span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12137</span> <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX ID <span class="keyword">ON</span> stu_info(ID);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">使用 CREATE TABLE 语句</mark> </strong> 索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###指定主键索引</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY [索引类型] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###创建普通索引</span><br><span class="line">KEY <span class="operator">|</span> INDEX [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###创建唯一索引</span><br><span class="line"><span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ID <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ID <span class="type">VARCHAR</span>(<span class="number">8</span>) ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY(ID,`name`));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> staff (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `mgr`  <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id     <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNIQUE</span>(id));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>在使用 CREATE TABLE 语句定义列选项的时候，可以通过直接在某个列定义后面添加 PRIMARY KEY 的方式创建主键。而当主键是由多个列组成的多列索引时，则不能使用这种方法，只能用在语句的最后加上一个 PRIMARY KRY(&lt;列名&gt;，…) 子句的方式来实现。</p></blockquote><p><strong><mark class="hl-label blue">使用 ALTER TABLE 语句</mark> </strong><br>使用 ALTER TABLE 语句向已有的表添加索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###添加普通索引，一般用INDEX不用KEY</span><br><span class="line"><span class="keyword">ADD</span> INDEX<span class="operator">|</span>KEY [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###添加主键</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br><span class="line">###添加唯一索引</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu_info <span class="keyword">ADD</span> INDEX (score);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意，以上创建索引时，不指定索引名则索引名同列名。</strong> 同一张表中，索引名不能重复。</p></blockquote><h3 id="font-color-red-查看索引-font"><font color='red'>查看索引</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> no1sc.staff;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> staff <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> id       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Table</td><td>表示创建索引的数据表名，这里是 tb_stu_info2 数据表。</td></tr><tr><td>Non_unique</td><td>表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td></tr><tr><td>Key_name</td><td>表示索引的名称。</td></tr><tr><td>Seq_in_index</td><td>表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td></tr><tr><td>Column_name</td><td>表示定义索引的列字段。</td></tr><tr><td>Collation</td><td>表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</td></tr><tr><td>Cardinality</td><td>索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</td></tr><tr><td>Sub_part</td><td>表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。</td></tr><tr><td>Packed</td><td>指示关键字如何被压缩。若没有被压缩，值为 NULL。</td></tr><tr><td>Null</td><td>用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。</td></tr><tr><td>Index_type</td><td>显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</td></tr><tr><td>Comment</td><td>显示评注。</td></tr></tbody></table><h3 id="font-color-red-删除索引-font"><font color='red'>删除索引</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> staff;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> staff <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> id       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX id <span class="keyword">ON</span> staff;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> staff;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-注意事项-font"><font color='red'>注意事项</font></h3><p><strong><mark class="hl-label blue">索引在什么时候会失效</mark> </strong></p><ol><li><strong>LIKE 关键字配置的字符串不能以“%”开头；</strong></li><li><strong>使用多列索引时，查询条件必须要使用这个索引的第一个字段；</strong></li><li><strong>使用 OR 关键字时，OR 关键字连接的所有条件都必须使用索引</strong> 。</li></ol><p><strong><mark class="hl-label blue">提高索引效率</mark> </strong></p><ol><li><p><strong>选择唯一性索引</strong><br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p></li><li><p><strong>为经常需要排序、分组和联合操作的字段建立索引</strong><br>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p></li><li><p><strong>为常作为查询条件的字段建立索引</strong><br>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</p></li><li><p><strong>限制索引的数目</strong><br>索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。</p></li><li><p><strong>尽量使用数据量少的索引如果索引的值很长，那么查询的速度会受到影响。</strong><br>例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。</p></li><li><p><strong>数据量小的表最好不要使用索引</strong><br>.由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p></li><li><p><strong>尽量使用前缀来索引</strong><br>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p></li><li><p><strong>删除不再使用或者很少使用的索引</strong><br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-视图</title>
      <link href="/2022/09/16/MySQL-%E8%A7%86%E5%9B%BE/"/>
      <url>/2022/09/16/MySQL-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-视图是什么-font"><font color='red'>视图是什么</font></h3><p><strong>MySQL 视图（View）</strong> 是一种虚拟存在的表，同真实表一样，视图也由列和行构成，<strong>但视图并不实际存在于数据库中</strong> 。行和列的数据来自于定义视图的查询中所使用的表（ <strong>基表</strong> ），并且还是在使用视图时动态生成的。<strong>数据库中只存放了视图的定义（.frm文件），并没有存放视图中的数据</strong> ，这些数据都存放在定义视图查询所引用的基表中。使用视图查询数据时，数据库会从基表表中取出对应的数据。因此，视图中的数据是依赖于基表表中的数据的。<strong>一旦基表中的数据发生改变，显示在视图中的数据也会发生改变；在视图中修改数据，基表中的数据也会发生改变。</strong><br>从下图可见，创建视图后，只生成了视图的 <code>.frm</code> 文件，没有 <code>.ibd</code> 文件，这是因为 <code>customer_info.frm</code> 与 <code>customer_view.frm</code> 的数据都是由 <code>customer_info.ibd</code> 提供。<br><img src="/2022/img/image-20220917103106816.png" alt=""></p><h3 id="font-color-red-视图的作用-font"><font color='red'>视图的作用</font></h3><p><strong><mark class="hl-label blue">保密</mark> </strong><br>看这样一个需求：公司职员表的信息很多（姓名、薪水、部门、上级、工号、电话等），而其中有些信息属于个人隐私（薪水、电话），我们希望将此表下放到某管理员时，他只能看到其中的部分信息（姓名、部门、上级、工号），此时，就需要生成原表的一张视图，视图中只包含这一部分信息，然后再将此视图下放给该管理员。不恰当地说，“视图相对于对原表的封装”，对用户有部分不可见性。<br><strong><mark class="hl-label blue">性能</mark> </strong><br>关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这时，数据库查询通常会用到连接(JOIN)。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起,就可以避免使用JOIN查询数据。<br><strong><mark class="hl-label blue">灵活性</mark> </strong><br>如果系统中有一张旧的表,这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。</p><p>值得一提的是，长期以来，大多数互联网公司的《<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>开发规范》中都有一条规范：在MySQL中禁止（或建议不要）使用视图。究其原因，主要是由于在MySQL中视图的查询性能不好，同时带来了管理维护上的高成本。</p><h3 id="font-color-red-视图的用法-font"><font color='red'>视图的用法</font></h3><h4 id="font-color-gree-创建视图-font"><font color='gree'>创建视图</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> <span class="keyword">AS</span> <span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>创建视图前，先给出下面基本数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> room_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> location <span class="operator">|</span> state <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-1</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-2</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-3</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">003</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-4</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">004</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">10</span><span class="number">-5</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">005</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">11</span><span class="number">-6</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">006</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">11</span><span class="number">-7</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">007</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">12</span><span class="number">-8</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">008</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">12</span><span class="number">-9</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">009</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">13</span><span class="number">-10</span>    <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span> <span class="number">10</span><span class="number">-11</span>    <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> ID     <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">511323</span> <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">18990889826</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">511345</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> <span class="number">17390199497</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">532435</span> <span class="operator">|</span>   <span class="number">45</span> <span class="operator">|</span> <span class="number">18932981949</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">343234</span> <span class="operator">|</span>   <span class="number">34</span> <span class="operator">|</span> <span class="number">14342324323</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">343323</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> <span class="number">32232123343</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>1）创建基于单表的视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name`, room_id <span class="keyword">FROM</span> customer_info;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>2）创建基于多表的视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, room_info.room_id, room_info.type</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> customer_info,  room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> customer_info.room_id<span class="operator">=</span>room_info.room_id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span> type         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span> 标准间         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span> 总统套房       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+--------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>3）基于视图创建视图（视图嵌套）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_view3</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> customer_view2;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view3;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure><p><strong>不建议视图嵌套创建，不仅影响效率，也会提高后期维护成本。</strong> <strong>视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。</strong></p><p>另外，对于创建视图中的 SELECT 语句的指定存在以下限制：</p><ul><li><strong>用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基表和其他视图的相关权限。</strong></li><li>SELECT 语句不能引用系统或用户变量。</li><li>SELECT 语句不能包含 FROM 子句中的子查询。</li><li>SELECT 语句不能引用预处理语句参数。</li></ul><h4 id="font-color-gree-删除视图-font"><font color='gree'>删除视图</font></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="number">1</span><span class="operator">&gt;</span> [ , <span class="operator">&lt;</span>视图名<span class="number">2</span><span class="operator">&gt;</span> …]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">VIEW</span> customer_view2;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，删除视图后，建立在本视图上的视图也将不可用；比如将 <code>customer_view2</code> 删掉，<code>customer_view3</code> 将不可用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view3;</span><br><span class="line">ERROR <span class="number">1356</span> (HY000): <span class="keyword">View</span> <span class="string">&#x27;custom_info.customer_view3&#x27;</span> <span class="keyword">references</span> invalid <span class="keyword">table</span>(s) <span class="keyword">or</span> <span class="keyword">column</span>(s) <span class="keyword">or</span> <span class="keyword">function</span>(s) <span class="keyword">or</span> definer<span class="operator">/</span>invoker <span class="keyword">of</span> <span class="keyword">view</span> lack rights <span class="keyword">to</span> use them</span><br></pre></td></tr></table></figure><p>可以使用 <code>CHECK TABLE</code> 来检查此类问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> customer_view3 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">   <span class="keyword">Table</span>: custom_info.customer_view3</span><br><span class="line">      Op: <span class="keyword">check</span></span><br><span class="line">Msg_type: Error</span><br><span class="line">Msg_text: <span class="keyword">Table</span> <span class="string">&#x27;custom_info.customer_view2&#x27;</span> doesn<span class="string">&#x27;t exist</span></span><br><span class="line"><span class="string">*************************** 2. row ***************************</span></span><br><span class="line"><span class="string">   Table: custom_info.customer_view3</span></span><br><span class="line"><span class="string">      Op: check</span></span><br><span class="line"><span class="string">Msg_type: Error</span></span><br><span class="line"><span class="string">Msg_text: View &#x27;</span>custom_info.customer_view3<span class="string">&#x27; references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them</span></span><br><span class="line"><span class="string">*************************** 3. row ***************************</span></span><br><span class="line"><span class="string">   Table: custom_info.customer_view3</span></span><br><span class="line"><span class="string">      Op: check</span></span><br><span class="line"><span class="string">Msg_type: error</span></span><br><span class="line"><span class="string">Msg_text: Corrupt</span></span><br><span class="line"><span class="string">3 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p>第 6 行表明，其基表 <code>customer_view2</code> 不存在。</p><h4 id="font-color-gree-查看视图-font"><font color='gree'>查看视图</font></h4><p>1）查看结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>2）查看定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_view1 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                <span class="keyword">View</span>: demo_view1</span><br><span class="line">         <span class="keyword">Create</span> <span class="keyword">View</span>: <span class="keyword">CREATE</span> ALGORITHM<span class="operator">=</span>UNDEFINED DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `demo_view1` <span class="keyword">AS</span> <span class="keyword">select</span> `stuinfo`.`name` <span class="keyword">AS</span> `name`,`stuinfo`.`age` <span class="keyword">AS</span> `age` <span class="keyword">from</span> `stuinfo` <span class="keyword">order</span> <span class="keyword">by</span> `stuinfo`.`age`</span><br><span class="line">character_set_client: utf8</span><br><span class="line">collation_connection: utf8_general_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">######或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> demo_view1 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                <span class="keyword">View</span>: demo_view1</span><br><span class="line">         <span class="keyword">Create</span> <span class="keyword">View</span>: <span class="keyword">CREATE</span> ALGORITHM<span class="operator">=</span>UNDEFINED DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `demo_view1` <span class="keyword">AS</span> <span class="keyword">select</span> `stuinfo`.`name` <span class="keyword">AS</span> `name`,`stuinfo`.`age` <span class="keyword">AS</span> `age` <span class="keyword">from</span> `stuinfo` <span class="keyword">order</span> <span class="keyword">by</span> `stuinfo`.`age`</span><br><span class="line">character_set_client: utf8</span><br><span class="line">collation_connection: utf8_general_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>3）查看状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: demo_view1</span><br><span class="line">         Engine: <span class="keyword">NULL</span></span><br><span class="line">        Version: <span class="keyword">NULL</span></span><br><span class="line">     Row_format: <span class="keyword">NULL</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="keyword">NULL</span></span><br><span class="line"> Avg_row_length: <span class="keyword">NULL</span></span><br><span class="line">    Data_length: <span class="keyword">NULL</span></span><br><span class="line">Max_data_length: <span class="keyword">NULL</span></span><br><span class="line">   Index_length: <span class="keyword">NULL</span></span><br><span class="line">      Data_free: <span class="keyword">NULL</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="keyword">NULL</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: <span class="keyword">NULL</span></span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: <span class="keyword">NULL</span></span><br><span class="line">        Comment: <span class="keyword">VIEW</span></span><br></pre></td></tr></table></figure><h4 id="font-color-gree-修改视图-font"><font color='gree'>修改视图</font></h4><p><strong><mark class="hl-label blue">修改结构</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> demo_view1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> age</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> stuinfo;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_view1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type       <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意，只能从头修改视图的结构，无法仅添加列。</p><p><strong><mark class="hl-label blue">修改内容</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> customer_view</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> room_id<span class="operator">=</span><span class="string">&#x27;011&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;李华&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_view;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。</strong><br><strong><font color='orange'>某些结构会使得视图不可更新</font></strong> 。如果视图包含以下结构中的任何一种，它就是不可更新的：</p><ul><li>聚合函数 SUM()、MIN()、MAX()、COUNT() 等。</li><li>DISTINCT 关键字。</li><li>GROUP BY 子句。</li><li>HAVING 子句。</li><li>UNION 或 UNION ALL 运算符。</li><li>位于选择列表中的子查询。</li><li>FROM 子句中的不可更新视图或包含多个表。</li><li>WHERE 子句中的子查询，引用 FROM 子句中的表。</li><li>ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。</li><li><strong>若视图是由两个以上基本表导出的，则此视图不允许更新</strong></li></ul><p>使用视图的时候，还应该注意以下两点：</p><ul><li><strong>视图不能索引，也不能有关联的触发器、默认值或规则。</strong></li><li>视图不包含数据，<strong>所以每次使用视图时，都必须执行查询中所需的任何一个检索操作</strong> 。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解快速排序</title>
      <link href="/2022/09/15/%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/15/%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-荷兰国旗问题-font"><font color='red'>荷兰国旗问题</font></h3><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>拿破仑席卷欧洲大陆之后，代表自由，平等，博爱的竖色三色旗也风靡一时。荷兰国旗就是一面三色旗（只不过是横向的），自上而下为红白蓝三色。该问题本身是关于三色球排序和分类的，由荷兰科学家 Dijkstra 提出。由于问题中的三色小球有序排列后正好分为三类，Dijkstra 就想象成他母国的国旗，于是问题也就被命名为荷兰旗问题（Dutch National Flag Problem）。下面是问题的正规描述： 现有 n 个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。<strong>在算法中，更多这样描述：如何通过两两交换，将一个数组中小于 N 的数放在靠左边，等于 N 的数放在靠中间，大于 N 的数放在靠右边</strong> ；比如，数组 arr[1, 14, 5, 16, 8, 7], N=8, 则两两交换后得到[1, 7, 5, 8, 16, 14]。<strong>注意，左右两边内部不一定有序</strong> 。</p><p><strong><mark class="hl-label blue">问题分析</mark> </strong><br>设计一个大(右)小(左)区间，通过不断扩展区间达到 <strong>分区(partition)</strong> 的效果。过程图示如下：<br><img src="/2022/img/未命名绘图-16632545470111.png" alt="" style="zoom:80%;" /></p><p>有以下几点需要注意：</p><ol><li><strong>左区间的初始位置为 L=0，右区间的初始位置为 R=size；</strong></li><li>当指针(下标为T)指向的数<ul><li>小于 N 时：交换 arr[T] 和 arr[L+1] ，T++ ，L++；</li><li>等于 N 时，T++；</li><li>大于 N 时，交换 arr[T] 与 arr[R-1]，R–；</li></ul></li><li>T &gt;= R 时，过程结束。注意，结束条件不能设置为 T==R，因为 R–，T++，可能有 T-R=1</li><li><strong><font color='orange'>区间内部不保证有序</font></strong></li></ol><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">netherLandFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> R = size;</span><br><span class="line"><span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[T] &lt; N)</span><br><span class="line"><span class="built_in">swap</span>(arr[T++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[T] = N)</span><br><span class="line">T++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[T], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-快速排序1-0-font"><font color='red'>快速排序1.0</font></h3><p><strong><font color='orange'>快速排序的核心就是递归调用荷兰国旗方法</font></strong> 。<strong>由于一旦完成 partition，中间区间(等于N的数)就不会再移动，所以就能通过不断在左右区间内部继续划分区间，直到无法划分为止(满足基线条件)，最终达到排序的效果</strong> 。在快速排序中，N 并不是上述那样人为指定的，<strong>而是固定为当前区间中最右边的那个数</strong> 。如下图：<br><img src="/2022/img/未命名绘图-16632931991463.png" alt="" style="zoom:80%;" /><br>注意：</p><ol><li><strong>不同于之前 R=size，这里 R = size-1；</strong></li><li><strong>最后需要指定交换 arr[R] 与 arr[size-1]；</strong></li></ol><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意第 21 行的 swap，容易忽略；</li><li>基线条件是 lower&gt;=upper，而不是 lower==upper；</li><li><strong>第 29 行，右边界下标为 R+1 而非 R</strong> ；</li></ul><h3 id="font-color-red-快速排序2-0——随机快排-font"><font color='red'>快速排序2.0——随机快排</font></h3><p>阅读上文后，读者也许能敏锐地发现，区间的划分情况和 N 息息相关。我们希望，N 总是可以打到数组的中间(数值, 而非位置)，这样每次划分就可以达到类似于二分的效果；而一旦数组偏有序，那么划分次数就会大大增加，如下：<br><img src="/2022/img/未命名绘图-16632988093595.png" alt="" style="zoom:80%;" /></p><p>第 K 层比较次数为 N-K 次，笼统记为 N 次( <strong>只要与 N 相关，都记为 N</strong> )；一共 N-1 层，笼统记为 N 层；所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p><p>如果每次打到中间，就可以产生二分效果，减少划分次数，如下：<br><img src="/2022/img/未命名绘图-166330129553810.png" alt="上图中比较5次更正为6次" style="zoom:80%;" /></p><p>第 K 层比较次数为 N-K 次，笼统记为 N 次；一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 层( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>7</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">log_27=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> )，笼统记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> ，故时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。</p><p>那么如何使 N 刚好打到数组的数值正中间呢？遗憾的是，无法做到，只能随机取值。但好消息是，将 N 随机取值(其值必须为数组中的数)后，该算法的长期期望也可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 。<strong>期望归期望，实践时，可能运气很差，所以随即快排是不稳定的</strong> 。</p><p><strong><mark class="hl-label blue">代码实现</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;<span class="comment">//生成随机数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">swap</span>(arr[upper], arr[<span class="built_in">rand</span>() % (upper - lower + <span class="number">1</span>) + lower]);</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 58 行，随机交换数组最后和其他某位置的数。</li></ul><h3 id="font-color-red-效率比较-font"><font color='red'>效率比较</font></h3><p><code>测试次数time=10000</code> ，<code>最大值max=1000000000</code> ，<code>最大长度size=1000000</code> ，快速排序 1.0 反而快于随机快排 <code>0.6203 ms</code> ：</p><img src="/2022/img/image-20220920231457291.png" alt="image-20220920231457291" style="zoom:67%;" /><p>这稍显离谱。。。。。原因咱不知晓，后续探究。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;<span class="comment">//生成随机数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">loc <span class="title">netherLandsFlag</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">loc bound;</span><br><span class="line"><span class="keyword">if</span> (lower == upper)</span><br><span class="line">&#123;</span><br><span class="line">bound.left = bound.right = lower;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L = lower - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> R = upper;</span><br><span class="line"><span class="type">int</span> index = lower;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt; arr[upper])</span><br><span class="line"><span class="built_in">swap</span>(arr[index++], arr[++L]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[index] == arr[upper])</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">swap</span>(arr[index], arr[--R]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[R], arr[upper]);</span><br><span class="line">bound.left = L;</span><br><span class="line">bound.right = R + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_1</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process_1</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process_1</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort_1</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process_1</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lower &gt;= upper)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">swap</span>(arr[upper], arr[<span class="built_in">rand</span>() % (upper - lower + <span class="number">1</span>) + lower]);</span><br><span class="line">loc bound = <span class="built_in">netherLandsFlag</span>(arr, lower, upper);</span><br><span class="line"><span class="built_in">process_2</span>(arr, lower, bound.left);</span><br><span class="line"><span class="built_in">process_2</span>(arr, bound.right, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort_2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">process_2</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">clock_t</span> start_1, end_1,start_2,end_2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">int</span> maxSize = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> times = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> arg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">rand</span>() % maxSize + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, size);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, size);</span><br><span class="line">start_1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quickSort_1</span>(arr_1, size);</span><br><span class="line">end_1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">start_2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">quickSort_2</span>(arr_2, size);</span><br><span class="line">end_2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, size) == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;排序出错!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;一般快速排序：&quot;</span> &lt;&lt; end_1 - start_1 &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;随机快速排序：&quot;</span> &lt;&lt; end_2 - start_2 &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;后者快于前者：&quot;</span> &lt;&lt; end_1 - start_1 - (end_2 - start_2) &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">arg += end_1 - start_1 - (end_2 - start_2);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;==========================================&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;平均快于&quot;</span> &lt;&lt; (<span class="type">double</span>)arg/times &lt;&lt; <span class="string">&quot; ms&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序变式-区间和计数</title>
      <link href="/2022/09/14/%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F%E5%8F%98%E5%BC%8F-%E5%8C%BA%E9%97%B4%E5%92%8C%E8%AE%A1%E6%95%B0/"/>
      <url>/2022/09/14/%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F%E5%8F%98%E5%BC%8F-%E5%8C%BA%E9%97%B4%E5%92%8C%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定一个数组 arr，两个整数 lower 和 upper，返回 arr 中有多少个子数组的累加和在 [lower, upper] (左闭右闭)范围上。<strong>注意，子数组是连续的，单独一个元素也是子数组</strong> 。</p><p><strong><mark class="hl-label blue">重要工具 — 前缀和数组</mark> </strong></p><p>当我们需要 <strong>频繁计算</strong> 数组中 [l, r] 范围中元素的累加和时，如果每次都要遍历子区间的元素，就显得十分低效，此时前缀和数组就有大用处了。前缀和数组的元素是原数组从 0 下标开始到当前位置所有元素的累加和，比如：arr[4, 8, 6, 10, 12] ，其对应的前缀和数组为：presum[4, 12, 18, 28, 40]；当需要计算 arr 的区间 [2, 4] 中的累加和时，只需要用 presum[4] - presum[2-1] 就可得到对应的累加和。原理很好理解，不再过多阐述。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>在不使用前缀和数组的情况下，此问题的复杂度将达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ：从下标 0 遍历 N 次 -&gt; 从下标 1 遍历 N-1 次 -&gt;从下标 2 遍历 N-2 次 …每次遍历时，都还需要遍历该范围内的元素以计算累加和。如果使用前缀和数组，就可以将复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。能不能进一步优化呢？且听下文分析。<br><img src="/2022/img/未命名绘图.png" alt=""  /><br>经上图分析，我们成功地将 <strong>求累加和在某区间内的子数组个数</strong> 转变为了 <strong>求前缀和在某区间内的子数组个数</strong> 。各位可能仍有疑惑：这与归并排序有什么关系呢？看过博主之前的文章《<a href="https://jyxcpp.netlify.app/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/">归并排序及其加强</a> 》的读者也许就会上图中的红色字体有一丝丝感觉。没错，<strong><font color='red'>当涉及到一个数组中某个数左(右)边的数与此数的关系时，往往就可以采用归并排序</font></strong> ，而 <strong><font color='red'>必然条件:K&lt;N</font></strong> 就提供了这样一种关系。下面我们再来剖析这个过程(目标区间[10, 30])：<br><img src="/2022/img/未命名绘图-16631419576573-16631425474895.png"  /><br>有几个点需要注意：</p><ol><li><strong><font color='red'>当左边指针指向的数字大于前缀和区间的右边界时，左指针就无需再向右移动，因为其后的数字比当前数字更大，更不可能会落入前缀和区间，所以直接归位到第一个位置。当左边指针指向的数字小于前缀和区间的左边界时，左指针就必须继续向右移动了，这点在图中并未体现，需要留心！</font></strong></li><li>此方式下，右边指针始终右移，左边指针则可能回退，所以无法边操作边 merge，只有等到操作结束后统一 merge；类似的还有《<a href="https://jyxcpp.netlify.app/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/">归并排序及其加强</a> 》中提到的二倍大问题。</li><li>由于左指针发生回退，所以此方式复杂度最好情况下才为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，而最坏情况下可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong><font color='red'>为什么能使用归并？因为此方法只关心两个前缀和的相对位置，并不关心它们的具体位置和相距距离。</font></strong></li><li><strong>上图的过程中，没有验证某个前缀和本身否落在指定范围，即不能验证 arr 数组从 0 位置到 N 的累加和，而只能验证从 K(K≠0) 到 N 的累加和(即presum[N]-presum[K])。所以还必须单独验证这些前缀和自身是否落在指定范围，此操作在下面代码的 63 行给出。</strong></li></ol><p>下面给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> upper, lower;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span>(rp&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prel = arr[rp] - upper;<span class="comment">//presum left</span></span><br><span class="line"><span class="type">int</span> prer = arr[rp] - lower;<span class="comment">//presum right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lp &gt; m)</span><br><span class="line">&#123;</span><br><span class="line">rp++;</span><br><span class="line">lp = l;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &lt; prel)</span><br><span class="line">lp++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[lp] &gt; prer)</span><br><span class="line">&#123;</span><br><span class="line">rp++;</span><br><span class="line">lp = l;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">lp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;           </span><br><span class="line">rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &gt;= lower &amp;&amp; arr[r] &lt;= upper)</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lower = <span class="number">10</span>;</span><br><span class="line">upper = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>&#125;; </span><br><span class="line"><span class="type">int</span> presum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//10 11 12 22</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">presum[i] += arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergeSort</span>(presum,<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">进一步优化</mark> </strong><br>细心观察，我们可以发现，前缀和的上限 prel 与下线 prer 一定是不断增加的，这是因为 prel = arr[rp] - upper，prer = arr[rp] - lower ，而 arr[rp] 是递增的，所以 prel 与 prer 只会增加。所以，[prel, prer] 区间是持续向右移动的，不会回退，我们只需要每次将 [prel, prer] 区间内的数字个数算入 count 即可。过程如下：<br><img src="/2022/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-16631662112261.png" alt=""></p><ul><li><strong>注意，l 与 r 是 presum 数组的下标。</strong></li><li><strong>presum[l] 必须紧靠前缀和区间的左边界，presum[r] 必须紧靠前缀和区间的右边界</strong></li><li><strong>和上一种方式相同，上图并没有验证某个前缀和本身否落在指定范围，需要单独验证。</strong></li><li><strong>count = r + l - 1</strong></li><li><strong>可见，指针不回退，所以此方法复杂度稳在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</strong></li><li>仍然先操作完，再统一 merge，否则不好操作；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> upper, lower;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;            </span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="type">int</span> wl = l - <span class="number">1</span>;   <span class="comment">//window left;  wl即图中的l</span></span><br><span class="line"><span class="type">int</span> wr = l - <span class="number">1</span>;  <span class="comment">//window right; wp即图中的r</span></span><br><span class="line"><span class="keyword">while</span>(rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prel = arr[rp] - upper;<span class="comment">//presum left</span></span><br><span class="line"><span class="type">int</span> prer = arr[rp] - lower;<span class="comment">//presum right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (wl &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[wl] &lt; prel)</span><br><span class="line">wl++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wl &gt; m)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span> (wr &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[wr + <span class="number">1</span>] &lt;= prer &amp;&amp; wr!=m)</span><br><span class="line">wr++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wl != l<span class="number">-1</span> &amp;&amp; wr != l<span class="number">-1</span>)</span><br><span class="line">cnt += wr - wl + <span class="number">1</span>;</span><br><span class="line">rp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;           </span><br><span class="line">rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &gt;= lower &amp;&amp; arr[r] &lt;= upper)</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lower = <span class="number">10</span>;</span><br><span class="line">upper = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;; </span><br><span class="line"><span class="type">int</span> presum[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//10 20 30 40</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">presum[i] += arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergeSort</span>(presum,<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>14、15 行为什么设置为 l-1？这是和第 36 行的 if 语句搭配使用的；因为如果 wr 与 wl 初始就指向 l 位置，那么即使 presum[l] 没有落在指定区间，最后也会直接 cnt += wr - wl + 1；这很难把握。</li><li>21，27，29，31的边界为什么如此设置，留给读者思考，博主仅写此算法就用了一整天，，筋疲力竭。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种排序算法总结</title>
      <link href="/2022/09/13/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/13/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在看算法图解的过程中，看到书中说时间复杂度同为O(nlogn)，快排比归并排序快的原因是快排查找的常量要比归并小。</p><p>看完还不是很理解，去网上查了下资料，看了几种回答，还是《数据结构与算法分析：C++描述》中说的比较清楚，主要是因为：</p><p>1.C++模板有很强的inline优化机制，比较操作相对于赋值（移动）操作要快的多（尤其是元素较大时）</p><p>2.另一方面，一般情况下，归并排序的比较次数小于快速排序的比较次数，而移动次数一般多于快速排序的移动次数，二者大约都是2~3倍的差距。</p><p>因为这样，在C++中快排要比归并排序更快，但其实在java中恰恰相反，移动（赋值）一般比较快。</p><p><a href="https://blog.csdn.net/qq_39521554/article/details/79364718">快速排序 Vs. 归并排序 Vs. 堆排序——谁才是最强的排序算法_图灵的猫i的博客-CSDN博客_快速排序和归并排序哪个好</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:Xenia and Weights</title>
      <link href="/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95-Xenia-and-Weights/"/>
      <url>/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95-Xenia-and-Weights/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述</mark> </strong><br>给定 n 种砝码,重量位于区间 [1,10] ，不同种类砖码重量互不相同,且每种砝码的数量不限。轮流在天平两侧放砖码，要求：<strong>每次所使用的砝码与前一次不同(第一次可以为任意重量)，且当前放置砝码的一侧放置砝码后比另一侧重</strong> 。问能否进行 m 次操作，如果能，输出任意一种方案，如果不能，输出NO。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>思路大致和之前回溯法章节相同，只是需要左右两边分开处理。process() 的参数较多，这是因为笔者个人偏好 <strong><font color='orange'>利用函数栈自动完成回溯法所需要的撤销操作，所以必须用参数（而且必须为值传递）；也可以用全局变量，然后再递归后手动撤销。</font></strong> 详细过程不再阐述，代码注释已经解释清楚：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">turn</span>&#123;LEFT,RIGHT&#125;;</span><br><span class="line"><span class="type">int</span> weights[<span class="number">2</span>][<span class="number">10</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125; <span class="comment">//砝码种类</span></span><br><span class="line">  ,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//1代表有此种类</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//设定的操作次数</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    lw:左盘总重 rw:右盘总重 m:当前操作的次数 temp:记录每次放下的砝码重量  t:轮到哪边放*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> lw,<span class="type">int</span> rw,<span class="type">int</span> w, <span class="type">int</span> m,std::vector&lt;<span class="type">int</span>&gt; temp,turn t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (m == count)</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">-1</span>;<span class="comment">//将count设置为1，后续不再dfs，直接返回</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : temp)</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t == turn::LEFT)<span class="comment">//本次在左盘放置砝码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lw + w &lt;= rw)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lw += w;</span><br><span class="line">m++;</span><br><span class="line">temp.<span class="built_in">push_back</span>(w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span> || w == i+<span class="number">1</span>)<span class="comment">//w==i+1代表如果本次放下的重量等于上次的重量,则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(lw, rw, weights[<span class="number">0</span>][i], m, temp, turn::RIGHT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == turn::RIGHT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rw + w &lt;= lw)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">rw += w;</span><br><span class="line">m++;</span><br><span class="line">temp.<span class="built_in">push_back</span>(w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span> || w == i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(lw, rw, weights[<span class="number">0</span>][i], m, temp, turn::LEFT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> count)</span><span class="comment">//启动子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (weights[<span class="number">1</span>][i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">process</span>(<span class="number">0</span>, <span class="number">0</span>, weights[<span class="number">0</span>][i], <span class="number">0</span>, temp, turn::LEFT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">put</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是采用 dfs 完成的，dp 放在后续文章了解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:超级幸运数</title>
      <link href="/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
      <url>/2022/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>幸运数为 4 和 7，超级幸运数则是指因数只有 4 和 7 的数，比如 28，16，49 等。给出一个个数为 N 的数列，求其中幸运数的个数；数据范围：num&gt;1, N&gt;1；</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>暴力破解不难，直接给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count_2++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">7</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中，第 3、5、12 行代码是容易忽略的地方。</strong></p><p>那么，如何用回溯法解决此问题？不同于暴力破解对 num 的 <strong>拆分</strong> (除、模)，回溯法是对 num 进行 <strong>拼凑</strong> ，比如，对于数字 18，会尝试用 4*4，4*7 去拼凑，如果拼凑的结果大于 num，则回溯到上一层进行下一次尝试。图示如下：<br><img src="/2022/img/image-20220913105139956.png" style="zoom:80%;" /><br>根据图示，易得以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num是需要检验的数字，luck是当前所在节点的累积数值，即紫色框中的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lucky</span><span class="params">(<span class="type">int</span>&amp; num, <span class="type">int</span> luck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&lt;luck*<span class="number">4</span>)<span class="comment">//即图示中的比大小，如果左子树进不去(luck*4)，则右子树也不可能进(luck*7)</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//回溯</span></span><br><span class="line"><span class="keyword">if</span> (num == luck * <span class="number">4</span> || num == luck * <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;<span class="comment">//标记已成功</span></span><br><span class="line">count_1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">4</span>);<span class="comment">//先进左子树</span></span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">7</span>);<span class="comment">//如果未标记成功，则继续进入右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意第 8、13 行代码，作用如图示：<br><img src="/2022/img/image-20220913110716725.png" style="zoom:67%;" /><br>可见，如果不标记检测成功，28 就被 count++了两次，实际上 count++ 一次后就应该停止回溯。所以需要在成功后将 num 设置为 0（也可以采用其他标记方式）以标记成功，后续不再进入右子树。</p><p>附上对数器，所有代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count_1;</span><br><span class="line"><span class="type">int</span> count_2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lucky</span><span class="params">(<span class="type">int</span>&amp; num, <span class="type">int</span> luck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&lt;luck*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (num == luck * <span class="number">4</span> || num == luck * <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line">count_1++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">lucky</span>(num, luck*<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">count_2++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> != <span class="number">0</span> &amp;&amp; num % <span class="number">7</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">num /= <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">1000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">100000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line">count_1 = <span class="number">0</span>;</span><br><span class="line">count_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">lucky</span>(arr_1[i], <span class="number">1</span>);</span><br><span class="line"><span class="built_in">comparator</span>(arr_2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;go wrong&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">std::cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; count_1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; count_2 &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡、选择、插入、希尔排序</title>
      <link href="/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/11/%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-冒泡排序-font"><font color='red'>冒泡排序</font></h3><p>冒泡排序网上有很多资料，只想强调几点：</p><ol><li>固定往哪个方向冒泡，个人喜欢从左向右冒泡，不要一会向左一会向右，思绪易乱。</li><li>泡泡到达右边后，相应位置就固定住了，所以下一次无需再经过此处，于是内层循环还要减去外层循环已进行的次数。</li><li>冒泡时是第 K 个与第 K+1 个元素相比较，所以外层循环次数为 size-1 次即可，最后一个位置无需单独比较。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator cmp=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)<span class="comment">//注意-1！！！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size - i - <span class="number">1</span>; k++)<span class="comment">//注意-i-1！！！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(arr[k], arr[k + <span class="number">1</span>]))<span class="comment">//使用比较器</span></span><br><span class="line"><span class="built_in">mySwap</span>(arr[k], arr[k + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="font-color-red-选择排序-font"><font color='red'>选择排序</font></h3><p>选择排序也只须注意以下几个小坑：</p><ol><li>外层目标位置 K 确定后，内层从 K+1 位置开始遍历。</li><li>初始 max/min 值必须等于外层目标。</li><li>由于第 1 点，所以外层 i&lt;size-1，内层 k &lt;size；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> comparator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T* arr, <span class="type">int</span> size,comparator cmp=cmp1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i++)<span class="comment">//注意-1!</span></span><br><span class="line">&#123;</span><br><span class="line">m = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i+<span class="number">1</span>; k &lt; size; k++)</span><br><span class="line">&#123;</span><br><span class="line">m = <span class="built_in">cmp</span>(m, arr[k]) ? m : (index = k,arr[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mySwap</span>(arr[i], arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-插入排序-font"><font color='red'>插入排序</font></h3><p>注意以下几点：</p><ol><li>由于是 arr[k] 与 arr[k-1] 比较，所以外层从 i=1 开始。当然这只是个人偏好，也可以 arr[k] 与 arr[k+1] 比较。</li><li>内层从 i 开始。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">NULL</span> || size &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &lt; arr[k - <span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(arr[k], arr[k - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">32</span>,<span class="number">12</span>,<span class="number">54</span>,<span class="number">42</span>,<span class="number">64</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">insertSort</span>(arr, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序及其三道加强习题</title>
      <link href="/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/"/>
      <url>/2022/09/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%BC%BA%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>归并排序(Merge Sort)</strong> 是利用归并的思想实现的排序方法，该算法采用经典的 <strong>分治(divide-and-conquer)</strong> 策略将问题分成一些小的问题然后递归求解，即分而治之。</p><h3 id="font-color-red-递归实现-font"><font color='red'>递归实现</font></h3><p>图解：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhYmJjYzEzMg==,size_16,color_FFFFFF,t_70.png" alt="" style="zoom: 50%;" /></p><p>先递归将数组一分为二，直到不可再分；然后自下向上地将两边 <strong>合并(merge)</strong> ，合并的图解如下：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhYmJjYzEzMg==,size_16,color_FFFFFF,t_70-16628687498517.png" style="zoom:50%;" /></p><p>可见，我们需要 new 一个辅助数组来存放左右两边比较后的结果；注意，当 i 移到 7 位置时，7&gt;6，将6放入辅助数组，然后 j++，于是 j 超出数组范围，<strong>此时就直接将左半边余下的 7、8 放入辅助数组</strong> ，结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">51</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">27</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">43</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">86</span> &#125;;</span><br><span class="line"><span class="built_in">mergeSort</span>(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码作如下分析：</p><ul><li>归并排序的边界条件很巧妙：<strong><font color='red'>[L，M]，[M+1，R]</font></strong> ，分到最后只剩一个元素时，就会有 L=M，从而结束递归，比如所在区间：[0, 1]，L=0，R=1，M=(0+1)/2=0，左边进入递归 [0, 0]，右边进入递归 [1, 1]，自然就会满足基线条件(base case)，从而 return。对其他区间也同样如此。<strong><font color='orange'>未来考虑某些边界条件时，这是一个很好的参考</font></strong></li><li><strong><font color='red'>为什么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这么 low ？因为它大量浪费了比较行为，前一次比较丝毫不能为以后的比较做出贡献。归并排序为什么好？因为它将每一次的比较结果都往后进行了传递，使后续的递归能够利用之前的比较成果。</font></strong></li><li><strong>归并排序的复杂度为什么是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></strong> ：因为最坏情况下，每一个数(即 N 个数)都会被比较 logN 次（由算法过程就可以看出）</li><li>个人认为，写代码时最容易弄混第 23、24、25 行代码（易弄错顺序）。其实这问题很好解决，我们也只需要考虑 [0,1] 的递归过程即可：进入[0,0]，碰到基线，返回；进入[1,1]，碰到基线，返回；于是 merge[0,1]；</li><li>当使用对数器(后文给出)，将测试数组的长度调小(0~1000左右)时，执行几百次就会发生栈溢出，而调大数组长度到几万时，反而不会栈溢出，具体原因不明。按理说，应该数组长度过大，递归次数太多时，才会栈溢出啊？</li></ul><h3 id="font-color-red-迭代实现-font"><font color='red'>迭代实现</font></h3><p>归并排序的迭代实现也有较复杂的边界条件，笔者会用代码和示意图对应着解释这些边界。先上图：<br><img src="/2022/img/image-20220911173802954.png" alt=""><br><img src="/2022/img/image-20220911174107803.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lp = l;</span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)         <span class="comment">//第9行和第10行的while只会进入其中一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || N == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mergeSize = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (mergeSize &lt; N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (M &gt;= N<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> R = (M + mergeSize) &lt; (N - <span class="number">1</span>) ? M + mergeSize : N - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">L = R + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>)<span class="comment">//防止整形溢出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mergeSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">51</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">27</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">43</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">86</span> &#125;;</span><br><span class="line"><span class="built_in">mergeSort</span>(arr, <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代实现的 merge() 与递归实现的 merge() 相同</li><li>重点要讨论的边界处理，即第 23、26、29 行代码，其理由已经在图中详细阐述。</li><li>第 35 行代码十分容易忽略。当 N 靠近整形边界时，mergeSize×2 就可能发生溢出成为负数，然后回到第 23 行进行比较，又重新进入 while 循环！<strong><font color='orange'>所以未来在这种作了增加运算后还要和其他数进行比较时，须特别注意这类情况！</font></strong></li></ul><h3 id="font-color-red-对数器检验-font"><font color='red'>对数器检验</font></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span><span class="comment">//迭代版</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lp = l;</span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)</span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void process(int* arr, int l, int r)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (l == r)</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//int m = l + ((r - l)&gt;&gt;1);</span></span><br><span class="line"><span class="comment">//process(arr, l, m);</span></span><br><span class="line"><span class="comment">//process(arr, m + 1, r);</span></span><br><span class="line"><span class="comment">//merge(arr, l, m, r);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void mergeSort(int* arr, int size)//递归版</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (size == 1)</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//int r = size - 1;</span></span><br><span class="line"><span class="comment">//process(arr, 0, r);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || length == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (mergeSize &lt; length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (M &gt;= length<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> R = (M + mergeSize) &lt; (length - <span class="number">1</span>) ? M + mergeSize : length - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">L = R + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt; length / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mergeSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len - i - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &lt; arr[k + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[k];</span><br><span class="line">arr[k] = arr[k + <span class="number">1</span>];</span><br><span class="line">arr[k + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1, <span class="type">int</span>* arr_2, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">1000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1, arrLen);  </span><br><span class="line"><span class="built_in">mergeSort</span>(arr_2, arrLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEqual</span>(arr_1, arr_2, arrLen) == <span class="literal">false</span>) &#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fuck!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout &lt;&lt; arr_1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;success   &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-归并排序变式：三道面试题-font"><font color='red'>归并排序变式：三道面试题</font></h3><h4 id="font-color-gree-小和问题-font"><font color='gree'>小和问题</font></h4><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>在一个给定的数组中，计算出每一个数左边的所有比其小的数的和，并将这些和相加，即得这个数组的小和。距离：对于数组 <code>[6,3,8,9]</code> ，6 的左边没有比 6 小的数；3 的左边没有比 3 小的数；8 的左边，6 和 3 小于 8，其和为 6+3=9；9 的左边，6，3，8 小于 9，其和为 17；故数组的小和为 26。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br>显然，本问题可以很容易地被暴力破解，对每一个数，遍历之前的所有数，算法复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。在暴力破解的基础上，我们会很容易地想到一些优化的方法，比如，当前数字为 7 时，往前挨个比较，当碰上数字 6 时，我们就可以停止遍历，直接将 6 和 6 的小和相加即可，如下图：<br><img src="/2022/img/image-20220912172534459.png" style="zoom: 50%;" /><br>可见，当数字 N 左边紧挨着 N-1 时，此方式的效率就能达到最高；但如果碰上 <code>[7,6,5,4,3,2,1]</code> 这样从大到小的数列，复杂度也会回归到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。那么，如何进一步优化？从以上过程可以隐约感受到，如果在求小和的过程中能够将之前比较过的数字由小到大进行排序，也许就可以充分利用上述优化方式。进一步，我们尝试引入归并排序（别问为什么，问就是不知道，呜呜呜）。仍然拿前文例子进行说明：<br><img src="/2022/img/image-20220912181635790.png" alt="" style="zoom:67%;" /></p><p>取出中间状态，分析步骤：<br><img src="/2022/img/image-20220912182236325.png" alt="" style="zoom:80%;" /></p><ul><li>当有小和时，<strong>sum += 左边指向数 × (1 + 右边指向数的右边所有数字的个数)</strong> ，<strong><font color='red'>也即：sum += arr[lp] * (R - rp + 1)</font></strong> ；具体原因见上文的优化。<strong>这是排序的最终用处。</strong></li><li><strong><font color='orange'>此算法关键问题在于，为什么排序没有影响这些数字的小和？</font></strong> <strong>这是因为，在归并(merge)前，左组中的每一个数仍然在右组中每一个数的左边，这种状态并没有因为之前的排序而改变，直到本次merge才结束这种状态</strong> 。</li><li>此算法的代码实现，仅仅只改变了 merge() 函数（下面代码的第17-20行）</li></ul><p><strong><font color='orange'>另外需要注意，当左边指针指向的数等于右边指针指向的数时，必须先将右边的数放入辅助数组！</font></strong> 拿如下情况举例讲解：<br><img src="/2022/img/image-20220912190912493.png" alt="" style="zoom: 67%;" /></p><p>小和问题分析大致如此，如有补充，请在评论区提出，谢谢。代码如下（附带对数器）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &lt; arr[rp])</span><br><span class="line">&#123;</span><br><span class="line">count_1 += (r - rp + <span class="number">1</span>) * arr[lp];<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">help[p++] = arr[lp] &lt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)<span class="comment">//base case</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">process</span>(arr, l, m);</span><br><span class="line"><span class="built_in">process</span>(arr, m + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> r = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(arr, <span class="number">0</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &lt; arr[p])</span><br><span class="line">count_2 += arr[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des, src, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">100000</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span>* arr_1 = <span class="built_in">generateRandomArr</span>(max, arrLen);</span><br><span class="line"><span class="type">int</span>* arr_2 = <span class="built_in">cpyArr</span>(arr_1, arrLen);</span><br><span class="line">        count_1 = <span class="number">0</span>;</span><br><span class="line">count_2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(arr_1, arrLen);</span><br><span class="line"><span class="built_in">comparator</span>(arr_2, arrLen);</span><br><span class="line"><span class="keyword">if</span> (count_1 != count_2)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;go wrong&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++)</span><br><span class="line">std::cout &lt;&lt; arr_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">delete</span> arr_1, arr_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-gree-逆序对问题-font"><font color='gree'>逆序对问题</font></h4><p><strong><mark class="hl-label blue">问题阐述</mark> </strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>输入: [7,5,6,4]<br>输出: 5<br>逆序对：&lt;7,5&gt;,&lt;7,6&gt;,&lt;7,4&gt;,&lt;5,4&gt;,&lt;6,4&gt;</p><p><strong><mark class="hl-label blue">分析</mark> </strong></p><p>同小和问题类似，都是左边的数比较右边的数，解决思路几乎相同，<strong><font color='orange'>唯一不同是，需要从大到小排序！</font></strong></p><img src="/2022/img/image-20220912202305683.png" alt="" style="zoom:67%;" />对 merge() 稍作修改即可：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line"><span class="type">int</span> lp = l;            <span class="comment">//left pointer</span></span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &gt; arr[rp])</span><br><span class="line">&#123;</span><br><span class="line">count_1 += r - rp + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较器也需要稍作修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &gt; arr[p])</span><br><span class="line">count_2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-red-两倍大问题-font"><font color='red'>两倍大问题</font></h4><p>给定一个数组，计算出每个数右侧比自身要小两倍还多的数的累计个数。如数组 [9,5,4,2] ，9 -&gt; 4，9 -&gt;2，5 -&gt; 2，结果为 3。</p><p><strong><mark class="hl-label blue">分析</mark> </strong><br><strong><font color='orange'>同逆序对类似，也是关于前面数字大于后面数字的问题，所以也最好使用归并算法的降序方式。</font></strong> 不同的是，<strong>此时需要先完成全部计算，然后统一直接merge</strong> 。如果仍按之前的方式边计算边 merge，会出现如下逻辑问题：<br><img src="/2022/img/image-20220912222454570.png" style="zoom: 50%;" /><br><strong>所以应该先完成所有计算，再 merge：</strong><br><img src="/2022/img/image-20220912222911740.png" style="zoom:67%;" /><br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> lp = l;           </span><br><span class="line"><span class="type">int</span> rp = m + <span class="number">1</span>;       </span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r &amp;&amp; <span class="built_in">lp</span>&lt;=m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[lp] &gt; (arr[rp] * <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">count_1 += r - rp + <span class="number">1</span>;</span><br><span class="line">lp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;             <span class="comment">//help[]的pointer</span></span><br><span class="line">lp = l;            <span class="comment">//left pointer</span></span><br><span class="line">rp = m + <span class="number">1</span>;        <span class="comment">//right pointer</span></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m &amp;&amp; rp &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">help[p++] = arr[lp] &gt; arr[rp] ? arr[lp++] : arr[rp++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (lp &lt;= m)</span><br><span class="line">help[p++] = arr[lp++];</span><br><span class="line"><span class="keyword">while</span> (rp &lt;= r)           <span class="comment">//第9行和第11行的while只可能进入一个</span></span><br><span class="line">help[p++] = arr[rp++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++)</span><br><span class="line">arr[l + i] = help[i];</span><br><span class="line"><span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comparator</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt; size;p++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> tmp = <span class="number">0</span>; tmp &lt; p; tmp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[tmp] &gt; (arr[p]*<span class="number">2</span>))</span><br><span class="line">count_2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p><strong>数组中，某个数左边或右边，有多少个数比它大，类似的或者有相似子步骤的问题，都可以往递归上靠。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-表连接</title>
      <link href="/2022/09/10/MySQL-%E8%A1%A8%E8%BF%9E%E6%8E%A5/"/>
      <url>/2022/09/10/MySQL-%E8%A1%A8%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-交叉连接-font"><font color='red'>交叉连接</font></h3><p><strong>交叉连接（CROSS JOIN）一般用来直接返回连接表的笛卡尔积。</strong><br>交叉连接的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span>子句]</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span>子句] </span><br></pre></td></tr></table></figure><p><strong>注意，</strong></p><p><strong>笛卡尔积示例：第一种方式为官方指定写法，语义更加清晰；第二种写法默认为交叉连接，如果想指定为内连接和外连接，就需要显式指定。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span><span class="operator">*</span> <span class="keyword">FROM</span> course ;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br></pre></td></tr></table></figure><p>可见，笛卡尔积中大多数条目都没有意义，所以通过交叉连接的方式进行多表查询的这种方法并不常用，我们应该尽量避免这种查询。</p><h3 id="font-color-red-内连接-font"><font color='red'>内连接</font></h3><p>内连接使用 <strong>INNER JOIN</strong> 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。<br>内连接的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ON</span>子句]</span><br></pre></td></tr></table></figure><p>INNER JOIN 也可以使用 WHERE 子句指定连接条件，但是 INNER JOIN … ON 语法是官方的标准写法，而且 WHERE 子句在某些时候可能会影响查询的性能。</p><blockquote><p>有时以不同的方式编写查询可以提高速度，但多数情况下使用 WHERE 和 ON 实现的连接在底层的查询计划是相同的，理论上没有任何性能区别。</p><p>另一种说法是：ON 子句对每次笛卡儿积的中间结果进行过滤，而 WHERE 子句对最终结果进行过滤。该说法未查证真伪，但这似乎为采取社区的语法规范提供了理由：由该说法可得在外连接时，使用 ON 而不是 WHERE 来设置连接条件将提高效率</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> stuinfo.course_id<span class="operator">=</span>course.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-外连接-font"><font color='red'>外连接</font></h3><p><strong>外连接分为左连接和右连接</strong> 。在内连接中我们发现，当 ON 子句中的连接条件不成立时，就不会输出相应结果。但有时，我们也想输出未满足条件的那些记录，比如在上表中，我们以 stuinfo 和 course 表中的 id 为连接条件，只输出了满足条件的内容；但现在我们想查看所有参加了选课的同学，同时学生和所选课程也要在同一行，怎么办呢？这时就需要用到外连接。下面我们使用 <strong>左外连接</strong> 来完成这个需求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> course</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> stuinfo.course_id<span class="operator">=</span>course.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> course_id <span class="operator">|</span> sex  <span class="operator">|</span> subject <span class="operator">|</span> capacity <span class="operator">|</span> id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> M    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Judy  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">23</span> <span class="operator">|</span> W    <span class="operator">|</span> English <span class="operator">|</span>       <span class="number">32</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Frank <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> M    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Daney <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>        <span class="number">14</span> <span class="operator">|</span> W    <span class="operator">|</span> Math    <span class="operator">|</span>       <span class="number">18</span> <span class="operator">|</span>   <span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan  <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>        <span class="number">30</span> <span class="operator">|</span> W    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-----------+------+---------+----------+------+</span></span><br></pre></td></tr></table></figure><p>可见，Xuan 同学所选的课程号是不存在的。</p><p><strong>外连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN</strong> 。以上为左连接示例，右连接同理不再赘述。另外，MySQL 不支持全外连接，Oracle 支持全外连接。</p><h3 id="font-color-red-自连接-font"><font color='red'>自连接</font></h3><p>自连接是指在同一张表上的连接查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name  <span class="operator">|</span> mgn  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom   <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>现在我们有这样一个需求：打印出职员名和职员名对应的上级：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> worker.name <span class="keyword">AS</span> &quot;职员名&quot;,manager.name <span class="keyword">AS</span> &quot;上级名&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> emp <span class="keyword">AS</span> worker, emp <span class="keyword">AS</span> manager</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> worker.mgr<span class="operator">=</span>manager.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 职员名     <span class="operator">|</span> 上级名     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack      <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom       <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling     <span class="operator">|</span> Jack      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black     <span class="operator">|</span> Tom       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，如上，自连接必须指定别名以区分不同实例！</font></strong><br>同时可见，Han是总裁，没有上级员工，但现在我们也想让 Han 出现在上表中，咋办？使用左连接即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> worker.name <span class="keyword">AS</span> &quot;职员名&quot;,manager.name <span class="keyword">AS</span> &quot;上级名&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> emp <span class="keyword">AS</span> worker <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp <span class="keyword">AS</span> manager</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> worker.mgr<span class="operator">=</span>manager.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 职员名     <span class="operator">|</span> 上级名     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack      <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom       <span class="operator">|</span> Han       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling     <span class="operator">|</span> Jack      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black     <span class="operator">|</span> Tom       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han       <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法:填数字</title>
      <link href="/2022/09/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%A1%AB%E6%95%B0%E5%AD%97/"/>
      <url>/2022/09/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%80-%E5%A1%AB%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">问题描述：</mark> </strong><br>有 7 对数字:两个 1 ,两个 2 ,两个 3 ,…两个 7 ,把它们排成一行。要求,两个 1 间有 1 个其它数字,两个 2 间有 2 个其它数字,以此类推,两个 7 之间有 7 个其它数字。如下就是一个符合要求的排列:<br><code>1 7 1 2 6 4 2 5 3 7 4 6 3 5</code></p><p>请列出所有满足条件的排列。</p><p><strong><mark class="hl-label blue">问题分析：</mark> </strong></p><p>稍作分析我们就可以得到以下结论：</p><ol><li><p>放数字时，不仅要在当前位置放，还需要在关联位置上放：</p><img src="/2022/img/image-20220909104732262.png" style="zoom:50%;" />在 [4] 位置放置 3 时，也必须同时在 [8] 位置放置 3；</li><li><p>每放一个数字时，都需要将此数字标记为已放置。</p></li><li><p>放置数字时，必须在没有放置(未标记)的数字中 <strong>从小到大</strong> 试每个数字，直到能够放置或试完所有数字：<br><img src="/2022/img/image-20220909104746470.png" style="zoom:50%;" /></p><p>在 [9] 位置放置时，遍历 1,2,3,4,5 发现都已标记，于是尝试 6，不可；在尝试 7，不可；于是撤销上一步操作；</p></li><li><p>当发现某个空白位不能放任何数字时，说明之前的放置方式是错误的， <strong>需要撤回上一次的放置</strong> ，并放置其他数字，再重复以上过程：<br>在上图中，执行到第 6 步(箭头6)时陷入死路，于是撤回到第 5 步(箭头5)，并在此处尝试放置数字 6，可以：<br><img src="/2022/img/image-20220909105313901.png" style="zoom:50%;" /><br>然后在箭头 6 处放置数字；先考虑放置 5，不可；再考虑放置 7，不可；于是再次撤回到箭头 5，并在此放置数字 7，仍然不可；于是撤回到箭头 4，并在此处放置 5，可以：<br><img src="/2022/img/image-20220909105659357.png" style="zoom:50%;" /><br>然后在箭头 5 处考虑放置数字 4，不可([12]被 5 占了)；考虑数字 6，可以，于是放置 6…</p></li></ol><p><strong>从以上过程可见，核心有两点：</strong></p><ol><li><strong>从小到大依次放置数字</strong></li><li><strong>撤销操作的实现</strong></li></ol><p>实际上，这个过程可以抽象成如下动态变化的树：<br><img src="/2022/img/image-20220909111056021.png" style="zoom:67%;" /><br>执行到第 7 步时，只有数字 6 未标记，但无法放置，于是回退到第 6 步，之前放置的是数字 2，回退后就应该尝试放置数字 6，也无法放置；于是回退到第五步，之前放置的是数字 5，现在应该尝试放置数字 6，可以；重复以上步骤即可。下面给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> num[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">15</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPut</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!num[i] <span class="comment">//是否被标记为已放</span></span><br><span class="line">        &amp;&amp; pos + <span class="number">1</span> + i &lt;= <span class="number">14</span> &amp;&amp; arr[pos + <span class="number">1</span> + i] == <span class="number">0</span>)<span class="comment">//该空白处是否能放</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> pos)</span><span class="comment">//放置数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[pos] = k;</span><br><span class="line">arr[pos + <span class="number">1</span> + k] = k;</span><br><span class="line">num[k] = <span class="number">1</span>;<span class="comment">//标记该数字为已放true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&gt;<span class="number">14</span>)<span class="comment">//判断所有数字是否已经put</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[pos]!=<span class="number">0</span>)<span class="comment">//如果该位置有数字了，则再往前走一步</span></span><br><span class="line"><span class="built_in">go</span>(pos + <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">7</span>; k++)<span class="comment">//从小到大依次试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">canPut</span>(k, pos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">put</span>(k, pos);</span><br><span class="line"><span class="built_in">go</span>(pos + <span class="number">1</span>, k);<span class="comment">//进入下一层</span></span><br><span class="line">                <span class="comment">//以下三行是撤销操作！</span></span><br><span class="line">arr[pos + k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">arr[pos] = <span class="number">0</span>;</span><br><span class="line">num[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">go</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据操作(二)</title>
      <link href="/2022/09/06/MySQL-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/09/06/MySQL-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基本格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">[<span class="keyword">DISTINCT</span>]</span><br><span class="line">&#123;<span class="operator">*</span> <span class="operator">|</span> <span class="operator">&lt;</span>字段列名<span class="operator">&gt;</span>&#125;</span><br><span class="line">[    </span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表 <span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表 <span class="number">2</span><span class="operator">&gt;</span>…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">group</span> <span class="keyword">by</span> definition<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span> [&#123;<span class="operator">&lt;</span>operator<span class="operator">&gt;</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span>&#125;…]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">order</span> <span class="keyword">by</span> definition<span class="operator">&gt;</span>]</span><br><span class="line">[LIMIT[<span class="operator">&lt;</span><span class="keyword">offset</span><span class="operator">&gt;</span>,] <span class="operator">&lt;</span><span class="type">row</span> count<span class="operator">&gt;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意，以上指令的输入顺序不能乱！</font></strong></p><p>基础示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-去重-font"><font color='red'>去重</font></h3><p>DISTINCT 关键字的主要作用就是对数据表中一个或多个字段重复的数据进行过滤，只返回其中的一条数据给用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12398</span> <span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">21343</span> <span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。查询 student 表中对 name 和 age 字段去重之后记录的条数，SQL 语句和运行结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name,age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name,age) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span>                        <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-别名-font"><font color='red'>别名</font></h3><p><strong>给列起别名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 总分   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">397</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">388</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">436</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">352</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> 姓名 (数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line">ERROR <span class="number">1305</span> (<span class="number">42000</span>): <span class="keyword">FUNCTION</span> stuinfo.姓名 does <span class="keyword">not</span> exist</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> 姓名 ,(数学<span class="operator">+</span>语文<span class="operator">+</span>英语<span class="operator">+</span>物理<span class="operator">+</span>化学) <span class="keyword">AS</span> 总分 <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名    <span class="operator">|</span> 总分   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>    <span class="number">397</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>    <span class="number">388</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>    <span class="number">436</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>    <span class="number">352</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br></pre></td></tr></table></figure><p><strong>给表起别名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> stu.name ,stu.addr <span class="keyword">FROM</span> stu_info_table <span class="keyword">AS</span> stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han   <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：表的别名不能与该数据库的其它表同名。字段的别名不能与该表的其它字段同名。</strong><br>某些情况下必须使用别名，如自连接时需要给表取别名，详见：<a href="https://jyxcpp.netlify.app/2022/09/10/mysql-%E8%A1%A8%E8%BF%9E%E6%8E%A5/">表的连接</a></p><h3 id="font-color-red-限制查询的条数-font"><font color='red'>限制查询的条数</font></h3><p>当数据表中有上万条数据时，一次性查询出表中的全部数据会降低数据返回的速度，同时给数据库服务器造成很大的压力。这时就可以用 <code>LIMIT</code> 关键字来限制查询结果返回的条数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl LIMIT 初始位置,条数;</span><br></pre></td></tr></table></figure><p><strong>如果不加初始位置，则默认从<font color='orange'>第0条</font>开始。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info_table LIMIT <span class="number">3</span>,<span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack  <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Cling <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu_info_table LIMIT <span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> XUAN <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>每页显示 N 条，则公式为：<code>LIMIT (第几页-1)*N , N</code></p><h3 id="font-color-red-对查询结果排序-font"><font color='red'>对查询结果排序</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>其中， ASC 代表升序，DESC 代表降序；<strong>默认升序</strong> ；<br>单字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名   <span class="operator">|</span> 数学   <span class="operator">|</span> 语文   <span class="operator">|</span> 英语   <span class="operator">|</span> 物理   <span class="operator">|</span> 化学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">68</span> <span class="operator">|</span>     <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span>     <span class="number">97</span> <span class="operator">|</span>     <span class="number">96</span> <span class="operator">|</span>     <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span>     <span class="number">68</span> <span class="operator">|</span>     <span class="number">59</span> <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span>     <span class="number">57</span> <span class="operator">|</span>     <span class="number">86</span> <span class="operator">|</span>     <span class="number">58</span> <span class="operator">|</span>     <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+--------+--------+--------+</span></span><br></pre></td></tr></table></figure><p>多字段进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese, Math <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> Chinese ,Math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span> Math <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br></pre></td></tr></table></figure><p><strong><font color='orange'>注意：在对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese, Math <span class="keyword">FROM</span> demo_2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> Chinese <span class="keyword">DESC</span>,Math <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span> Math <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>DESC 关键字只对前面的列进行降序排列，在这里只对 height 字段进行降序。因此，height 按降序排序，而 name 仍按升序排序。如果想在多个列上进行降序排序，<strong><font color='orange'>必须对每个列指定 DESC 关键字</font></strong> 。</p><h3 id="font-color-red-条件查询-font"><font color='red'>条件查询</font></h3><p>查询条件可以是：</p><ul><li><p>带比较运算符：&gt; ，&lt;，&gt;=，&lt;=，!= ，= 等；</p></li><li><p>逻辑运算符：AND(&amp;&amp;) , NOT , OR(||) , XOR</p><blockquote><p>XOR：记录满足其中任意一个条件，并且不满足另一个条件时，才会被查询出来。</p></blockquote></li><li><p>带 <code>BETWEEN AND</code> 关键字的查询条件：等价于 <code>&gt;=L AND &lt;= R</code></p></li><li><p>带 <code>IS NULL</code> 关键字的查询条件：判断是否为空；**不能将 <code>IS</code> 换做 <code>=</code> **</p></li><li><p>带 <code>IN</code> 关键字的查询条件：显示在 IN 列表中的值，如 IN(98,87)；</p></li><li><p>带 <code>LIKE</code> ，<code>NOT LIKE</code> 关键字的查询条件</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">####<span class="keyword">IN</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Math <span class="keyword">IN</span>(<span class="number">98</span>,<span class="number">76</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>        <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>      <span class="number">59</span> <span class="operator">|</span>        <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####<span class="keyword">BETWEEN</span> <span class="keyword">AND</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Chinese <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Chinese <span class="keyword">BETWEEN</span> <span class="number">87</span> <span class="keyword">AND</span> <span class="number">98</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> Chinese <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line">####XOR</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> MATH <span class="operator">&gt;</span> <span class="number">70</span> XOR Physics <span class="operator">&lt;</span> <span class="number">70</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>      <span class="number">97</span> <span class="operator">|</span>      <span class="number">96</span> <span class="operator">|</span>        <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>      <span class="number">86</span> <span class="operator">|</span>      <span class="number">58</span> <span class="operator">|</span>        <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+---------+---------+---------+-----------+</span></span><br></pre></td></tr></table></figure><p><code>LIKE</code> 模糊查询：<code>%</code> 代表任何长度的字符串，字符串的长度可以为 0；<code>_</code> 只能代表单个字符，字符的长度不能为 0；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> &quot;%an%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> &quot;_a%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br></pre></td></tr></table></figure><p>默认情况下，<strong>LIKE 关键字匹配字符的时候是不区分大小写的</strong> 。如果需要区分大小写，可以加入 <code>BINARY</code> 关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="type">BINARY</span> &quot;han&quot;;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="type">BINARY</span> &quot;Han&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</strong><br><strong><font color='orange'>WHERE 查询条件中不可以使用字段别名</font></strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">AS</span> 姓名,Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;where clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">AS</span> 姓名,Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> 姓名   <span class="operator">|</span> 数学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> Jack   <span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han    <span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan   <span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-分组查询-font"><font color='red'>分组查询</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在数据统计时，GROUP BY 关键字经常和聚合函数一起使用。聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()等：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name <span class="operator">|</span> Math <span class="operator">|</span> Chinese <span class="operator">|</span> English <span class="operator">|</span> Physics <span class="operator">|</span> Chemistry <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">98</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>        <span class="number">57</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>      <span class="number">87</span> <span class="operator">|</span>      <span class="number">68</span> <span class="operator">|</span>      <span class="number">59</span> <span class="operator">|</span>        <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">87</span> <span class="operator">|</span>      <span class="number">98</span> <span class="operator">|</span>      <span class="number">97</span> <span class="operator">|</span>      <span class="number">96</span> <span class="operator">|</span>        <span class="number">58</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">67</span> <span class="operator">|</span>      <span class="number">57</span> <span class="operator">|</span>      <span class="number">86</span> <span class="operator">|</span>      <span class="number">58</span> <span class="operator">|</span>        <span class="number">84</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+---------+---------+---------+-----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX ,<span class="built_in">AVG</span>(Math) <span class="keyword">AS</span> 数学平均分 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> 数学平均分       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span>         <span class="number">77.0000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span>         <span class="number">87.0000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>GROUP BY 关键字可以和 GROUP_CONCAT() 函数一起使用。GROUP_CONCAT() 函数会把每个分组的字段值都显示出来：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> `name`, SEX <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line">ERROR <span class="number">1055</span> (<span class="number">42000</span>): Expression <span class="number">1</span> <span class="keyword">of</span> <span class="keyword">SELECT</span> list <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">and</span> <span class="keyword">contains</span> nonaggregated <span class="keyword">column</span> <span class="string">&#x27;stuinfo.demo_2.name&#x27;</span> which <span class="keyword">is</span> <span class="keyword">not</span> functionally dependent <span class="keyword">on</span> columns <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause; this <span class="keyword">is</span> incompatible <span class="keyword">with</span> sql_mode<span class="operator">=</span>only_full_group_by</span><br><span class="line">### 直接根据SEX分组打印信息会报错</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX, GROUP_CONCAT(name) <span class="keyword">AS</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han,Xuan  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack,Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="3"><li>WITH POLLUP 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SEX, GROUP_CONCAT(name) <span class="keyword">AS</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SEX <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> SEX  <span class="operator">|</span> name               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> 女   <span class="operator">|</span> Han,Xuan           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 男   <span class="operator">|</span> Jack,Mike          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Han,Xuan,Jack,Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-过滤分组-font"><font color='red'>过滤分组</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。但是 WHERE 和 HAVING 关键字也存在以下几点差异：</p><ol><li><strong><font color='orange'>一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。</font></strong></li><li><strong>WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。</strong></li><li><strong>WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 ，<font color='orange'>所以 HAVING 绝大多数时候应该搭配 GROUP BY 使用！</font></strong></li><li>WHERE 针对数据库文件进行过滤，而 HAVING 针对查询结果进行过滤。也就是说，<strong>WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面<font color='orange'>已经查询出的字段</font>进行过滤。</strong></li><li><strong><font color='red'>WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。</font></strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#对于第<span class="number">4</span>点</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> Math<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;Math&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;having clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> Math<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line">#对于第<span class="number">5</span>点</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line">ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;where clause&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Math <span class="keyword">AS</span> 数学 <span class="keyword">FROM</span> demo_2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> 数学<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 数学   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">76</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">87</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">67</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12398</span> <span class="operator">|</span> Jack  <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">21343</span> <span class="operator">|</span> Cling <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 深圳   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> GROUP_CONCAT(name) ,addr <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> addr</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> addr<span class="operator">!=</span>&quot;深圳&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> GROUP_CONCAT(name) <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Mike,XUAN,Han      <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jack               <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-red-子查询-font"><font color='red'>子查询</font></h3><p>子查询指将一个查询语句嵌套在另一个查询语句中。<strong>在 SELECT 语句中，子查询可以被嵌套在 SELECT 语句的列、表和查询条件中，即 SELECT 子句，FROM 子句、WHERE 子句、GROUP BY 子句和 HAVING 子句，而且可以进行多层嵌套。</strong> 子查询经常出现在 WHERE 子句中。使用子查询时，常用 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。</p><p>为方便演示，先给出以下酒店数据库的三张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">##房间类型</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line">##房间信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> room_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> location <span class="operator">|</span> state <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-1</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-2</span>     <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-3</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">003</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 标准间       <span class="operator">|</span> <span class="number">10</span><span class="number">-4</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">004</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">10</span><span class="number">-5</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">005</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span> <span class="number">11</span><span class="number">-6</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">006</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">11</span><span class="number">-7</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">007</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 大床房       <span class="operator">|</span> <span class="number">12</span><span class="number">-8</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">008</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">12</span><span class="number">-9</span>     <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">009</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 家庭套间     <span class="operator">|</span> <span class="number">13</span><span class="number">-10</span>    <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> <span class="number">010</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span> <span class="number">10</span><span class="number">-11</span>    <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+-------+---------+</span></span><br><span class="line">##客人信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customer_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> ID     <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span> room_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 李华   <span class="operator">|</span> <span class="number">511323</span> <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">18990889826</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 周建   <span class="operator">|</span> <span class="number">511345</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> <span class="number">17390199497</span> <span class="operator">|</span> <span class="number">011</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 王霸   <span class="operator">|</span> <span class="number">532435</span> <span class="operator">|</span>   <span class="number">45</span> <span class="operator">|</span> <span class="number">18932981949</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span> <span class="number">343234</span> <span class="operator">|</span>   <span class="number">34</span> <span class="operator">|</span> <span class="number">14342324323</span> <span class="operator">|</span> <span class="number">001</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 巴嘎   <span class="operator">|</span> <span class="number">343323</span> <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> <span class="number">32232123343</span> <span class="operator">|</span> <span class="number">002</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+-------------+---------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">单行子查询：</mark> </strong></p><p>1）查询和李华住在一个房间的人（单次嵌套）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> customer_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> room_id <span class="operator">=</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> room_id <span class="keyword">FROM</span> customer_info <span class="keyword">WHERE</span> `name`<span class="operator">=</span>&quot;李华&quot;)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AND</span> `name`<span class="operator">!=</span><span class="string">&#x27;李华&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 李斯   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure><p>2）查询李华住的房间的价格（多次嵌套，横跨三张表）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> price <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> type<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> type <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> room_id<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> room_id <span class="keyword">FROM</span> customer_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;李华&quot;));</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">多行子查询：</mark> </strong><br>1）查询状态为空的所有房间的价格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> price <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> type <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> type <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> state<span class="operator">=</span><span class="number">0</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p>2）打印出各 capacity 中的最高 price 的房型，输出列包含：type，price，capacity。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"></span><br><span class="line">#小白一般可能会这样：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type, <span class="built_in">MAX</span>(price), capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity;</span><br><span class="line">ERROR <span class="number">1055</span> (<span class="number">42000</span>): Expression #<span class="number">1</span> <span class="keyword">of</span> <span class="keyword">SELECT</span> list <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">and</span> <span class="keyword">contains</span> nonaggregated <span class="keyword">column</span> <span class="string">&#x27;custom_info.type_info.type&#x27;</span> which <span class="keyword">is</span> <span class="keyword">not</span> functionally dependent <span class="keyword">on</span> columns <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause; this <span class="keyword">is</span> incompatible <span class="keyword">with</span> sql_mode<span class="operator">=</span>only_full_group_by</span><br><span class="line">#报错是因为 “type 不依赖 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 子句中的列” </span><br></pre></td></tr></table></figure><p>如上，多行子查询常用 IN 和 NOT IN，同时也经常用到 EXISTS 关键字；<strong>EXISTS 用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回布尔值 true 或 false，EXISTS 指定一个子查询，检测行的存在</strong> 。</p><p>3）若还有空房，则打印所有房间类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> state <span class="keyword">FROM</span> room_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> state<span class="operator">=</span><span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 标准间       <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 大床房       <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 家庭套间     <span class="operator">|</span>   <span class="number">400</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+-------+----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>子查询的功能也可以通过表连接完成，但是子查询会使 SQL 语句更容易阅读和编写</strong> 。一般来说，表连接（内连接和外连接等）都可以用子查询替换，但反过来却不一定，有的子查询不能用表连接来替换。子查询比较灵活、方便、形式多样，适合作为查询的筛选条件，而表连接更适合于查看连接表的数据。<br>习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：<strong>先执行子查询，再执行父查询</strong> 。</p><h3 id="font-color-red-子查询临时表-font"><font color='red'>子查询临时表</font></h3><p>现在有这样一个需求：打印出各 capacity 中的最高 price 的房型，输出列包含：type，price，capacity。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type         <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房       <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 总统套房     <span class="operator">|</span>   <span class="number">600</span> <span class="operator">|</span> <span class="number">4</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#显示上述表中价格第二的条目，实际无需如此复杂</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> type,price,capacity <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> price <span class="keyword">IN</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> type_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> capacity)) temp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> temp.price <span class="keyword">DESC</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> type      <span class="operator">|</span> price <span class="operator">|</span> capacity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> 情侣房    <span class="operator">|</span>   <span class="number">210</span> <span class="operator">|</span> <span class="number">2</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+----------+</span></span><br></pre></td></tr></table></figure><p>嵌套在 SELECT 语句的 FROM 子句中的子查询语法格式如下：</p><p>SELECT  * FROM (子查询) AS 表的别名；<strong>注意：必须为表指定别名。</strong></p><h3 id="font-color-red-多列子查询-font"><font color='red'>多列子查询</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br></pre></td></tr></table></figure><p>需求：找到和 Jack 所在部门相同且上级也相同的人：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> (mgr,department)<span class="operator">=</span>(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> mgr,department <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>&quot;Jack&quot;)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">&amp;&amp;</span> name<span class="operator">!=</span>&quot;Jack&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>子查询语句返回多列结果，分别与等号前的 mgr 和 department 匹配。</p><h3 id="font-color-red-合并查询-font"><font color='red'>合并查询</font></h3><p>通常使用 <code>UNION ALL</code> 或 <code>UNION</code> 关键字合并多张表的查询结果。前者不会去重，后者会去重。比如有这样一个需求：NO.1 中学和 NO.2 中学联考，并混合排名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO1SC.stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Jack <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Dan  <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO2SC.stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> JayChou <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black   <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han     <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>   <span class="number">147</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO1SC.stu_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NO2SC.stu_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Jack    <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span>   <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Mike    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">149</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Han     <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span>   <span class="number">147</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Xuan    <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">141</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Dan     <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">130</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Black   <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JayChou <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span>   <span class="number">120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------+</span></span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="http://c.biancheng.net/">C语言中文网</a> ，<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=30&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平MYSQL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的起始下标为什么为0?</title>
      <link href="/2022/09/05/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BA0/"/>
      <url>/2022/09/05/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BA0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>x数组的起始下标为什么为0?</p><p>相信每一位初学者都曾吐槽过 C 语言的数组下标为什么从 0 开始，而不是从 1 开始，这样太不人性化了:smile: 。实际上，不仅是 C 语言，其他绝大多数语言的数组下标也是从 0 开始的，既然都如此设计，就必然有它的好处。下面我们就这个问题来进行粗略的讨论。</p><ul><li><p><strong><font color='orange'>首要目标：为了方便计算出每个元素的具体内存地址：</font></strong><br>a[0] 的内存地址  =  a的地址 + 0 * 4   (第一个元素的地址计算结果跟数组的首地址一样)<br>a[1] 的内存地址  =  a的地址 + 1 * 4   (下标是1,内存地址就就是首地址偏移 4 字节)<br>a[2] 的内存地址  =  a的地址 + 2 * 4   (下标是2,内存地址就首地址偏移 8 字节)<br>…<br>a[5]的内存地址  =  a的地址 + 5 * 4  (下标是5 内存地址就是首地址 偏移 20字节)<br>如果从 1 开始，每一步都要减去1,多一步运算,效率就相对较低；而从 0 开始，就无需减 1。</p></li><li><p><strong><font color='orange'>利于边界处理：</font></strong> 下面这张图胜过千言万语<br><img src="/2022/img/2025849-20200824195059390-1250153254.png" alt=""></p><p>将一个左闭右开区间“切割”时，其子区间也能很好的符合左闭右开的形式。例如：区间[x,y)可以分割为:[x,z)和[z,y)——无缝连接，没有重叠。假如是全闭区间的话，边界情况处理起来就比较麻烦。全开区间的话会丢掉端点，边界情况就要特判。</p></li><li><p>数组[1,3,4,7,8]的中间下标为 5/2 = 2，刚好在中间，对应数字为4；如果下标从 1 开始，那么下标 2 就对应数字3，实际并不是数组的中间位置。</p></li><li><p>有点植树问题的感觉，比如你要爬到第 15 楼，而实际上只需要爬 14 层；如果将第一层定义为 0 层，那么你去第 15 楼时，实际也只需要爬 15 楼；这使得描述更加统一。</p></li></ul><p><strong>你还有其他见解吗？欢迎在评论区提出。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识复杂度与对数器</title>
      <link href="/2022/09/05/%E5%88%9D%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8/"/>
      <url>/2022/09/05/%E5%88%9D%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-时间复杂度-font"><font color='red'>时间复杂度</font></h2><ul><li>务必细分过程，区别出常数操作和与 N 有关的操作。这也要求你对调用的 API 有一定熟悉程度！</li><li>对于插入排序这样会由于数据状态而影响到算法过程的，<strong><font color='orange'>一律按最差情况统计复杂度！</font></strong></li><li>冒泡和选择排序的算法性能是固定的，不受数据状态影响；而插入会受数据状态影响。后者性能大于前两者。</li><li>当两算法的复杂度都相等时(比如，冒泡和插入都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>) ，就需要比拼各自的常数项时间。如何比拼常数项时间：<br><strong>放弃理论分析,生成随机数据直接测</strong> 。为什么不去理论分析?不是不能纯分析,而是没必要。因为不同常数时间的操作,虽然都是固定时间,但还是有快慢之分的。<strong>比如,位运算的常数时间小于算术运算的常数时间,这两个运算的常数时间又小于数组寻址的时间</strong> 。所以如果纯理论分析,往往会需要非常多的分析过程（就比如，算术运算在某些时候可转为位运算，详见<a href="https://jyxcpp.netlify.app/2022/07/08/csapp/">csapp</a>）。常数时间不考虑在最优解范畴。</li><li>算法优劣：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mi>X</mi></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>X</mi><mi>N</mi></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&gt;O(logN)&gt;O(N)&gt;O(N×logN)&gt;O(N^X)&gt;O(X^N)&gt;O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!)</span></span></span></span> ，其中 X 为常数，N 为数据量；</li></ul><h2 id="font-color-red-对数器-font"><font color='red'>对数器</font></h2><p>网页上关于对数器的介绍基本都来自于算法讲师左程云，所以这里不再赘述其他内容，只提供几个关键点：</p><ol><li><strong>有一个你想要测的方法 a；</strong></li><li><strong>实现一个绝对正确(不管复杂度)的方法 b；</strong></li><li><strong>实现一个随机样本产生器；</strong></li><li><strong>实现对比算法 a 和 b 的方法；</strong></li><li><strong>把方法 a 和方法 b 比对多次来验证方法 a 是否正确；</strong></li><li><strong>如果有一个样本使得比对出错，则打印样本进行分析；</strong></li><li><strong>当样本数量很多时比对测试依然正确，可以确定方法 a 已经正确。</strong></li></ol><p>下面以冒泡排序为例来演示利用对数器进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span><span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//sort()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//memcpy()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;len-i<span class="number">-1</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[k]&lt;arr[k+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp=arr[k];</span><br><span class="line">arr[k]=arr[k+<span class="number">1</span>];</span><br><span class="line">arr[k+<span class="number">1</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">generateRandomArr</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> len)</span></span>&#123; </span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">arr[i] = <span class="built_in">rand</span>() % max;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">cpyArr</span><span class="params">(<span class="type">int</span>* src, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *des = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(des,src,len*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">int</span>* arr_1,<span class="type">int</span>* arr_2,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr_1[i] != arr_2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">int</span> testTimes = <span class="number">10000</span>;<span class="comment">//测试次数</span></span><br><span class="line"><span class="type">int</span> arrMaxLen = <span class="number">20</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">1000</span>;<span class="comment">//最大数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;testTimes;i++)&#123;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="built_in">rand</span>() % arrMaxLen;</span><br><span class="line"><span class="type">int</span> *arr_1 = <span class="built_in">generateRandomArr</span>(max,arrLen);</span><br><span class="line"><span class="type">int</span> *arr_2 = <span class="built_in">cpyArr</span>(arr_1,arrLen);</span><br><span class="line"><span class="built_in">bubbleSort</span>(arr_1,arrLen);  <span class="comment">//方法a</span></span><br><span class="line"><span class="built_in">sort</span>(arr_2,&amp;arr_2[arrLen],[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);<span class="comment">//方法b</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isEqual</span>(arr_1,arr_2,arrLen)==<span class="literal">false</span>)&#123;<span class="comment">//判断排序后的俩数组是否相等</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;fuck!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrLen;i++) <span class="comment">//打印出错误用例</span></span><br><span class="line">cout&lt;&lt;arr_1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrLen;i++)</span><br><span class="line">cout&lt;&lt;arr_2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;success&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> arr_1;</span><br><span class="line"><span class="keyword">delete</span> arr_2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据操作语言(一)</title>
      <link href="/2022/09/03/MySQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/03/MySQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>数据操作语句只适用于表，而无法作用于数据库，所以无需在操作关键词后添加 <code>TABLE</code> 关键字。</strong></p></blockquote><h2 id="font-color-red-INSERT-font"><font color='red'>INSERT</font></h2><p>INSERT 语句有三种语法形式：<br><strong><mark class="hl-label blue">INSERT...VALUES语句</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [ <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ , … <span class="operator">&lt;</span>列名n<span class="operator">&gt;</span>] ]</span><br><span class="line"><span class="keyword">VALUES</span> (&#123;expr<span class="operator">|</span><span class="keyword">DEFAULT</span>&#125;,...),(...),...</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_0(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id       <span class="type">CHAR</span>(<span class="number">12</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`   <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> age      TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> addr     <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (id, `name`, age, addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUE</span>(<span class="string">&#x27;12336&#x27;</span>, <span class="string">&#x27;QuanHa&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;四川&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li><p><strong>一次可插入多条记录：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (id, `name`, age, addr) <span class="keyword">VALUES</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="string">&#x27;13445&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;南京&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="string">&#x27;11234&#x27;</span>,<span class="string">&#x27;Mike&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>如<strong>果只向某些列插入值，那么其他未手动插入值的列被赋值为 NULL(若可以) 或 默认值。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0 (id,age,addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;成都&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure></li><li><p>当为所有列全部赋值时，可不指定列名，<strong>但 VALUES 中的列顺序必须和表定义时的列顺序相同</strong> ；如果不知道表的结构，使用 <code>DESC</code> 查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0 <span class="keyword">VALUES</span>(<span class="string">&#x27;111111&#x27;</span>,<span class="string">&#x27;XUAN&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;重庆&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong><mark class="hl-label blue">INSERT...SET语句</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="string">&#x27;12321&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;Han&#x27;</span>, age<span class="operator">=</span><span class="number">20</span>, addr<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span>  <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">INSERT...SELECT语句</mark> </strong></p><p><strong><font color='orange'>快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1(id, name, age, addr)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, name , age, addr</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12336</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 四川   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12321</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> 天津   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><blockquote><p>另外，还有 INSERT…DELAYDE 语句，其用法较复杂，笔者将在后续文章中详细阐述。INSERT…SELECT 语句也有相当多注意事项，详细请参考 MySQL 手册和博主后续其他文章。</p></blockquote><p><strong><mark class="hl-label blue">蠕虫复制</mark> </strong><br>有时为了测试某条语句的效率，我们需要海量的数据，蠕虫复制就是利用少量已有的数据进行自我复制，只需几次操作就能获得百万级的数据表。操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp<span class="operator">^</span>C</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">12</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">12</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">24</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">24</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">###</span><br></pre></td></tr></table></figure><p>重复以上复制十几次就可以达到百万行记录。</p><h2 id="font-color-red-UPDATE-font"><font color='red'>UPDATE</font></h2><p>使用 UPDATE 语句修改单个表，语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span> [,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>… ] [<span class="keyword">WHERE</span>子句]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句] [LIMIT子句]</span><br></pre></td></tr></table></figure><p>示例一，修改某行的多个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span>  <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">111111</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------+--------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">12213</span>, name<span class="operator">=</span><span class="keyword">NULL</span> #修改某行的多个字段</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111111</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12345</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12213</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><p>示例二，统一修改所有行的某个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> id<span class="operator">=</span>id<span class="operator">*</span><span class="number">3</span>, id<span class="operator">=</span>id<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如第二行所示，UPDATE 从左到右执行赋值操作，id先加 1 ，再乘 3 。</p><p>示例三，使用 LIMIT 限定更改的行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">23</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> addr<span class="operator">=</span>&quot;南京&quot;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">3</span>;  #限定修改三条</span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">3</span>  Changed: <span class="number">3</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37009</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">40336</span> <span class="operator">|</span> Jack   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37036</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 成都   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">21</span> <span class="operator">|</span> 上海   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-DELETE-font"><font color='red'>DELETE</font></h2><p>使用 DELETE 语句从单个表中删除数据，语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> 子句] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句] [LIMIT 子句]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37009</span> <span class="operator">|</span> QuanHa <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">40336</span> <span class="operator">|</span> Jack   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike   <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37036</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han    <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+--------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> demo_0</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> addr   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">33703</span> <span class="operator">|</span> Mike <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36640</span> <span class="operator">|</span> XUAN <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">36964</span> <span class="operator">|</span> Han  <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span> 南京   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>第 15 行中 <code>DESC</code> (descent) 指降序（从大到小），第 16 行的 LIMIT 为 3，故而本指令的含义为：依次删除 id 最大的三个条目。<br><strong><font color='orange'>注意：在不使用 WHERE 或 LIMIT 条件的时候，将删除所有数据。</font></strong></p><p><strong><mark class="hl-label blue">如何删除表中的重复数据？</mark> </strong></p><ol><li>创建一张新表，其结构和旧表相同。</li><li>在旧表中查重</li><li>将查重的内容复制到新表</li><li>删除旧表</li><li>将新表的名改为旧表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="number">48</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp <span class="keyword">LIKE</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">6</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> temp RENAME <span class="keyword">TO</span> emp;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name    <span class="operator">|</span> mgr  <span class="operator">|</span> department <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> Han     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> Jack    <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> Tom     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> Cling   <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> Black   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span> <span class="number">20</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> JayChou <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">12</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+------+------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="font-color-red-TRUNCATE-font"><font color='red'>TRUNCATE</font></h2><p><strong>TRUNCATE  TABLE 用于完全清空一个表</strong> 。从逻辑上说，该语句与用于删除所有行的 DELETE 语句等同，但是在有些情况下，两者在使用上有所不同：</p><ul><li><p>对于InnoDB表，如果有需要引用表的外键限制，则 TRUNCATE  TABLE 被映射到 DELETE 上；否则使用快速删减（取消和重新创建表）。使用TRUNCATE  TABLE 重新设置 AUTO_INCREMENT 计数器，设置时不考虑是否有外键限制。</p></li><li><p>对于其它存储引擎，在 MySQL 5.1 中，TRUNCATE TABLE 与 DELETE  FROM 有以下几处不同：</p><ul><li>删减操作会取消并重新创建表，这比一行一行的删除行要快很多</li><li>删减操作不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。</li><li>被删除的行的数目没有被返回。</li><li>只要表定义文件 tbl_name.frm 是合法的，则可以使用 TRUNCATE  TABLE 把表重新创建为一个空表，即使数据或索引文件已经被破坏。</li><li>表管理程序不记得最后被使用的 AUTO_INCREMENT 值，但是会从头开始计数。即使对于 MyISAM 和 InnoDB 也是如此。MyISAM 和InnoDB通常不再次使用序列值。</li><li>当被用于带分区的表时，TRUNCATE  TABLE 会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（.par）文件不受影响。</li></ul></li></ul><p>TRUNCATE TABLE 是在 MySQL 中采用的一个 Oracle  SQL 扩展。</p><h2 id="font-color-red-SELECT-font"><font color='red'>SELECT</font></h2><p>SELECT 内容较多，参见另一篇文章：<a href="https://jyxcpp.netlify.app/2022/09/06/mysql-%E8%AF%A6%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%9F%A5%E8%AF%A2/">MySQL-SELECT详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据定义语言(二)</title>
      <link href="/2022/09/02/MySQL-%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/02/MySQL-%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-表的创建-font"><font color='red'>表的创建</font></h2><p>有两种方式：1. 新创建一个表；2. 根据旧表结构创建新表；格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#################################################<span class="number">1.</span>自定义创建新表</span><br><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tbl_name</span><br><span class="line">    [(create_definition,...)]</span><br><span class="line">    [table_options] [select_statement]</span><br><span class="line">########示例<span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_0 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`   <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  age     TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  gender  <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `resume` TEXT);   #如果不指定字符集和校对规则，则采用默认对象</span><br><span class="line">########示例<span class="number">2</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name`  <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  age    TINYINT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `resume` TEXT)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_bin ENGINE INNODB;</span><br><span class="line">#################################################<span class="number">2.</span>模仿旧表结构创建新表</span><br><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tbl_name</span><br><span class="line">    [(] <span class="keyword">LIKE</span> old_tbl_name [)];</span><br><span class="line">########示例<span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> demo_2 <span class="keyword">LIKE</span> demo_1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>详尽的 <code>table_options</code> ， <code>select_statement</code> 与 <code>create_definition</code> 内容请查看<a href="https://jyxcpp.netlify.app/2022/08/31/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Mysql5.1手册</a> .</p></blockquote><ul><li><p>CREATE TABLE用于创建带给定名称的表。您必须拥有表 CREATE 权限。</p></li><li><p>第 7、10 行的 name 和 resume 加上了反引号 ` ，<strong>这是因为 name 和 resume 是 Mysql 的保留字，为了避免冲突，需要加反引号</strong> 。</p></li><li><p>创建表时默认在本数据库下创建，如果要在其他数据库中创建表，除了先切换到其他数据库再创建表，还可以使用以下方式：</p></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> staffInfo.demo_0 (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> `name` <span class="type">VARCHAR</span>(<span class="number">32</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> USE staffInfo;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_staffinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_0              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>表名称被指定为 <code>db_name.tbl_name</code> ，以便在特定的数据库中创建表。不论是否有当前数据库，都可以通过这种方式创建表。如果您使用加引号的识别名，则应对数据库和表名称分别加引号。例如，`mydb` . `mytbl`是合法的，但是 `mydb.mytbl` 不合法。</p><ul><li><p>在创建表格时，您可以使用 <code>TEMPORARY</code> 关键词。只有在当前连接情况下，TEMPORARY 表才是可见的。<strong>当连接关闭时，TEMPORARY 表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止</strong> ）您必须拥有 CREATE  TEMPORARY TABLES 权限，才能创建临时表。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `aha`(data <span class="type">INT</span>); #在stuinfo数据库中创建临时表</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> quit; #断开当前连接并重新登入</span><br><span class="line">Bye</span><br><span class="line">C:\Windows\system32<span class="operator">&gt;</span>mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">Enter password: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Welcome <span class="keyword">to</span> the MySQL monitor.</span><br><span class="line">mysql<span class="operator">&gt;</span> use stuinfo;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> test_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_2            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_5            <span class="operator">|</span>  #之前的临时表消失</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>要求某列不能为空，且指定默认值：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> country <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;China&quot;);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo <span class="keyword">VALUES</span>(); #未插入具体值</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> China   <span class="operator">|</span> #默认值为china</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br></pre></td></tr></table></figure><p>使用 <code>NOT NULL DEFAULT</code> 为某列指定默认值。</p></li></ul><h2 id="font-color-red-表的查看-font"><font color='red'>表的查看</font></h2><p><strong><mark class="hl-label blue">查看当前数据库下的表</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> demo_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_2            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_3            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test_5            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">查看表的结构</mark> </strong></p><ol><li>使用 <code>DESC</code> 或 <code>DESCRIBE</code> ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>SHOW CREATE TABLE</code> ：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                               <span class="comment">----------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1 <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `demo_1` (</span><br><span class="line">  `age` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resume` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>和 DESCRIBE 相比，SHOW CREATE TABLE 展示的内容更加丰富，它可以查看表的存储引擎和字符编码；在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加 <code>\g</code> 或者 <code>\G</code> 参数可以改变展示形式。</p><p><strong>&quot;<mark class="hl-label blue">查看表的状态</mark> </strong><br>使用 <code>SHOW TABLE STATUS</code> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: customer_info</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">5</span></span><br><span class="line"> Avg_row_length: <span class="number">3276</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2022</span><span class="number">-09</span><span class="number">-09</span> <span class="number">17</span>:<span class="number">03</span>:<span class="number">51</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: fuck</span><br><span class="line">         Engine: <span class="keyword">NULL</span></span><br><span class="line">        Version: <span class="keyword">NULL</span></span><br><span class="line">     Row_format: <span class="keyword">NULL</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="keyword">NULL</span></span><br><span class="line"> Avg_row_length: <span class="keyword">NULL</span></span><br><span class="line">    Data_length: <span class="keyword">NULL</span></span><br><span class="line">Max_data_length: <span class="keyword">NULL</span></span><br><span class="line">   Index_length: <span class="keyword">NULL</span></span><br><span class="line">      Data_free: <span class="keyword">NULL</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="keyword">NULL</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: <span class="keyword">NULL</span></span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: <span class="keyword">NULL</span></span><br><span class="line">        Comment: <span class="keyword">VIEW</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-表的修改-font"><font color='red'>表的修改</font></h2><p>其语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [修改选项]</span><br></pre></td></tr></table></figure><p>修改选项的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>旧列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> &#123; <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="operator">|</span> MODIFY <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> RENAME [<span class="keyword">TO</span>] <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> #或 CHARSET</span><br><span class="line"><span class="operator">|</span> <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更详细的选项参见<a href="https://jyxcpp.netlify.app/2022/08/31/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Mysql5.1手册</a></p></blockquote><p><strong><mark class="hl-label blue">修改表名</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_2 RENAME <span class="keyword">TO</span> demo_3;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><code>TO</code> 可加可不加。</p><p><strong><mark class="hl-label blue">修改字符集</mark> </strong></p><ol><li><strong>修改表的默认字符集</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">################修改表的字符集</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHARSET utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改列的字符集</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">################修改列的字符集</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_5 CHANGE country country <span class="type">CHAR</span>(<span class="number">10</span>) CHARSET ascii;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_5 \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: demo_5</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `demo_5` (</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country` <span class="type">char</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> ascii <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>修改列的字符集时，可以不改名和列类型，但必须写出更改后(未更改)的名字和类型，这是捆绑在一起的操作。</font></strong></p><p><strong><mark class="hl-label blue">添加列</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age    <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> address <span class="type">VARCHAR</span>(<span class="number">32</span>) </span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p>默认是添加到最后一行，可使用关键字 <code>AFTER</code> 和 <code>FIRST</code> 在指定位置插入新行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sex   <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_5 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> addr <span class="type">VARCHAR</span>(<span class="number">48</span>) AFTER age;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> addr  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">48</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sex   <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">修改列名</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHANGE <span class="keyword">COLUMN</span> `name` `tel` <span class="type">VARCHAR</span>(<span class="number">11</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.07</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> tel     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">11</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p>如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，<strong><font color='orange'>但数据类型不能为空</font></strong> 。</p><p><strong><mark class="hl-label blue">修改列类型</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 MODIFY <span class="keyword">COLUMN</span> tel <span class="type">VARCHAR</span>(<span class="number">32</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> tel     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>使用 MODIFY 来改变列的类型，此时不需要重命名。</strong> <strong>使用 CHANGE 修改列类型时，必须重命名(名字可相同)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHANGE <span class="keyword">COLUMN</span> `name` `name` <span class="type">VARCHAR</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">删除列</mark> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">DROP</span> tel;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> age     <span class="operator">|</span> tinyint(<span class="number">4</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-表的删除-font"><font color='red'>表的删除</font></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_0            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> demo_0;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_stuinfo <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> demo_1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-其他事项-font"><font color='red'>其他事项</font></h2><ul><li><p>如果您使用 ALTER TABLE 更改列规约，但是 DESCRIBE tbl_name 提示您列规约并没有改变，则可能是因为 MySQL 忽略了您所做的更改。例如，如果您试图把VARCHAR列更改为CHAR列，此时，如果表包含其它长度可变的列，则 MySQL 可能仍会使用VARCHAR。</p></li><li><p><strong><font color='orange'>ALTER TABLE 运行时会对原表进行临时复制( 除了 RENAME )，在副本上进行更改，然后删除原表，再对新表进行重命名</font></strong> 。在执行 ALTER  TABLE 时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。</p></li><li><p><strong><font color='orange'>要使用 ALTER TABLE，您需要获得表的 ALTER,  INSERT 和 CREATE 权限。</font></strong></p></li><li><p>您可以在一个 ALTER TABLE 语句里写入多个 ADD, ALTER,  DROP 和 CHANGE 子句，中间用逗号分开。这是 MySQL 相对于标准 SQL 的扩展。在标准 SQL 中，每个 ALTER  TABLE 语句中每个子句只允许使用一次。例如，在一个语句中取消多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type       <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> gender  <span class="operator">|</span> <span class="type">char</span>(<span class="number">1</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resume  <span class="operator">|</span> text       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">char</span>(<span class="number">8</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+------+-----+---------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 <span class="keyword">DROP</span> gender, <span class="keyword">DROP</span> resume;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field   <span class="operator">|</span> Type    <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> address <span class="operator">|</span> <span class="type">char</span>(<span class="number">8</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><code>COLUMN</code> 为可选关键字。<code>CHARSET</code> 与 <code>CHARACTER SET</code> 相同。</p></li><li><p><strong><font color='orange'>表中各列数据的字符集可以不同</font></strong> 。如果您在向表中添加一个新列时没有指定字符集，则此时使用表的默认字符集。注意，<strong>以下语句只改变了表的默认字符集：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> demo_1 CHARSET utf8;</span><br></pre></td></tr></table></figure><p><strong>如果您想要把表默认的字符集和所有字符列（CHAR, VARCHAR, TEXT）改为新的字符集，应使用如下语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> CHARSET utf8;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数与定点数</title>
      <link href="/2022/08/31/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/"/>
      <url>/2022/08/31/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据类型</title>
      <link href="/2022/08/31/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/08/31/MySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-概要-font"><font color='red'>概要</font></h2><p>MySQL 数据类型又叫 “列类型” 、“字段类型” 。数据类型定义了列中可以存储什么数据以及该数据怎样存储的规则。MySQL 数据类型大致分为 <strong><u>数值类型</u>，<u>字符串/文本类型</u>，<u>二进制类型</u>与<u>时间/日期类型</u></strong> ，如以下三张表所示：<br><strong><mark class="hl-label blue">数值类型</mark> </strong></p><table><thead><tr><th>类型</th><th>大小（字节）</th><th>范围（signed）</th><th>范围（unsigned）</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128  ~ 127</td><td>0 ~ 255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768 ~ 32767</td><td>0 ~ 65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608 ~ 8388607</td><td>0 ~ 16777215</td></tr><tr><td><font color='orange'>INT</font></td><td>4</td><td>-2147483648 ~ 2147483647</td><td>0 ~ 4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>0 ~ 18446744073709551615</td></tr><tr><td><font color='orange'>FLOAT</font></td><td>4</td><td></td><td></td></tr><tr><td><font color='orange'>DOUBLE</font></td><td>8</td><td></td><td></td></tr><tr><td><font color='orange'>DECIMAL</font></td><td>M+2</td><td>取决于M</td><td>依赖于M</td></tr></tbody></table><p><strong><mark class="hl-label blue">字符串类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td><font color='orange'>CHAR</font></td><td>固定长度非二进制字符串</td><td>取决于字符集类型和指定的字符数，最多 255 个<u>字符</u>。</td></tr><tr><td><font color='orange'>VARCHAR</font></td><td>变长非二进制字符串</td><td>取决于字符集类型和指定的字符数，最多 65532 个<u>字节</u>。</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>2^8 字节；</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>2^16 字节，约 64 KB</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>2^24 字节，约 16 MB</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>2^32 字节，约 4 GB</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><p><strong><mark class="hl-label blue">时间/日期类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td><font color='orange'>TIME</font></td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td><font color='orange'>DATE</font></td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td><font color='orange'>DATETIME</font></td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><p><strong><mark class="hl-label blue">二进制类型</mark> </strong></p><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><p>（橙色标记为常用类型）</p><h2 id="font-color-red-数值类型-font"><font color='red'>数值类型</font></h2><ul><li><p>整形类型都支持声明：<code>Type [(M)] [UNSIGNED] [ZEROFILL]</code> ；其中 M 指输出宽度，当数据长度大于宽度时，原样输出。当 M 和 ZEROFILL 同时指定时，才能看见 M 的效果。<br>浮点类型都支持声明：<code>Type [(M,D)] [UNSIGNED] [ZEROFILL]</code> ；其中 M 指小数总位数，D 指小数点后位数。如果<em>M</em>和<em>D</em>被省略，根据硬件允许的限制来保存值。<br>DECIMAL(定点)类型：<code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code> ，M 最大为 65，D 最大为 30，且 D 不得超过 M；如果<em>D</em>被省略，  默认是0。如果<em>M</em>被省略， 默认是10。DECIMAL 是定点数，不会像浮点数那样存在误差问题，广泛用于金融相关的计算中。关于 DECIMAL 定点数的讨论，参见笔者另一篇文章<a href="https://jyxcpp.netlify.app/2022/08/31/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/">定点数与浮点数</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###################################################整形测试</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_1(num <span class="type">INT</span>(<span class="number">5</span>) ZEROFILL );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1 <span class="keyword">VALUES</span>(<span class="number">34</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> num   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">00034</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_1 <span class="keyword">VALUES</span>(<span class="number">1234567</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> num     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">00034</span> <span class="operator">|</span>       # 输出宽度为<span class="number">5</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1234567</span> <span class="operator">|</span>       # 超过M则原样输出</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">#####################################################浮点测试</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_3 (dig <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">3</span>) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_3 <span class="keyword">VALUES</span>(<span class="number">12345.6789</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;dig&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #不能超过(<span class="number">7</span>,<span class="number">3</span>)范围</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_3 <span class="keyword">VALUES</span>(<span class="number">1235.679</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><code>FLOAT</code> 只能精确到小数点后大约 7 位；<code>DOUBLE</code> 可用精确到小数点后大约 15 位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_08(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dig <span class="type">FLOAT</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_08 <span class="keyword">VALUES</span>(<span class="number">0.123456789</span>);#输入<span class="number">9</span>位小数</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_08;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> dig      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.123457</span> <span class="operator">|</span> #输出<span class="number">6</span>位小数</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_09(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dig <span class="keyword">DOUBLE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_09 <span class="keyword">VALUES</span>(<span class="number">0.123456789123456789</span>);#输入<span class="number">18</span>位小数</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_09;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> dig                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.12345678912345678</span> <span class="operator">|</span> #输出<span class="number">17</span>位小数</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><strong><font color='orange'>MySQL 使用带符号的 BIGINT 或 DOUBLE 值进行所有运算</font></strong> ，因此除了位函数，不应使用大于 63位 的无符号的大整数！如果这样做，结果中的最后几位可能出错，这是由于将 BIGINT 值转换为 DOUBLE 进行四舍五入时造成的错误（BIGINT 与 DOUBLE 混合运算时）。<br><strong><font color='orange'>当两个操作数均为整数值时，-、+和*  操作符使用 BIGINT 运算</font></strong> 。这说明如果乘两个大整数，当结果大于 9223372036854775807(63位) 时，会得到意想不到的结果。</p></li></ul><h2 id="font-color-red-字符串类型-font"><font color='red'>字符串类型</font></h2><ul><li><p>CHAR 和 VARCHAR 类型声明的长度表示你想要保存的 <strong>最大字符数</strong> ，而非字节数。需要注意，<strong><font color='orange'>CHAR 的字符最大储存为 255 个；VARCHAR 的最大储存数量为 (65535-3)/3=21844 (utf8下)</font></strong> ，除以 3 可能是因为 Mysql 为 utf8 字符集设置的<u>平均</u>字节大小为 3（说“平均”是因为utf8是变长字符集，字符所占字节数从1-5都有）；VARCHAR 的最大有效长度由最大行大小和使用的字符集确定，整体最大长度是 65,532 字节，减 3 是因为 <strong>VARCHAR 是变长的，也就是说其按照实际占用空间来分配(但不可超过你指定的长度)</strong> ，所以需要 3 个字节来记录长度；相反，<strong>CHAR 是固定长度的，当保存CHAR值时，在它们的右边填充空格以达到指定的长度</strong> 。另外，<strong><font color='red'>MySQL中的所有CHAR 和 VARCHAR 值比较时不需要考虑任何尾部空格</font>；<font color='orange'>保存 VARCHAR 时，尾部的空格会保留。</font></strong> 如果分配给 CHAR 或 VARCHAR 列的值超过列的最大长度，则对值进行裁剪以使其适合，如果被裁掉的字符是空格，则会产生一条警告。如果裁剪非空格字符，则报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo4(data <span class="type">VARCHAR</span>(<span class="number">21845</span>));</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo4(data <span class="type">VARCHAR</span>(<span class="number">21844</span>));#utf8下，<span class="type">VARCHAR</span>最大字符数为<span class="number">21844</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)           #gbk下，<span class="type">VARCHAR</span>最大字符数为(<span class="number">65535</span><span class="number">-3</span>)<span class="operator">/</span><span class="number">2</span></span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo5(data <span class="type">CHAR</span>(<span class="number">5</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo5 <span class="keyword">VALUES</span>(&quot;year&quot;); #尾部填充一个空格</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo5 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;year&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> data <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">year</span> <span class="operator">|</span>     #仍然可查询到<span class="keyword">year</span>，说明<span class="type">CHAR</span>检索时忽略了尾部的空格</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo7(data <span class="type">VARCHAR</span>(<span class="number">8</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAY       &quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo7 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;DAY&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> data     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DAY</span>      <span class="operator">|</span> #仍然可查询到<span class="keyword">DAY</span>，说明<span class="type">VARCHAR</span>检索时忽略了尾部的空格</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+ #DAY后有一串空白，说明保存时保留了尾部的空格。</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">###################################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAY                &quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec) #超出长度的空格被裁剪，发出警告</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo7 <span class="keyword">VALUES</span>(&quot;DAYDAYHAPPY &quot;);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;data&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #超出长度的非空格被裁减，报错</span><br></pre></td></tr></table></figure></li><li><p>当数据是定长时，比如手机号，身份证等，推荐使用 CHAR；当数据不定长时，比如留言，文章等，推荐使用 VARCHAR。<strong>CHAR 的查询速度比 VARCHAR 快</strong> 。</p></li><li><p>与 CHAR 和 VARCHAR 不同，使用 TEXT 类型时无需指定存储长度。此外，当检索或插入文本数据时，MySQL 不会删除或填充空格。 <strong>请注意，TEXT 数据不存储在数据库服务器的内存中，因此，每当查询 TEXT 数据时，MySQL都必须从磁盘读取它，这与 CHAR 和 VARCHAR 相比要慢得多。</strong> 由于 TEXT 也是不定长类型，所以也需要记录长度：TINYTEXT 需要 1 个字节记录，TEXT 需要 2 个字节，MEDIUMTEXT 需要 3 个字节，LONGTEXT 则需要四个字节。</p></li></ul><h2 id="font-color-red-二进制类型-font"><font color='red'>二进制类型</font></h2><ul><li><p>BIT 数据类型可用来保存位字段值。BIT(<em>M</em>)类型允许存储<em>M</em>位值。<strong><em>M</em>范围为1到64</strong> 。</p></li><li><p><strong>与CHAR和VARCHAR不同，BINARY和VARBINARY的长度是字节长度而不是字符长度。</strong></p></li><li><p>BIT 以二进制方式输出，如下图：</p><p><img src="/2022/img/image-20220831213507973.png" alt=""></p><p>注意，在命令行中输出不可见：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_4 (dig BIT(<span class="number">8</span>) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_4 <span class="keyword">VALUES</span>(<span class="number">129</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_4;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> dig  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含的是 <strong>字节数组</strong> (类似于 Qt 中的 QByteArray) 。也就是说，它们包含字节字符串而不是字符字符串。<font color='orange'>这说明它们没有字符集，也不包含校对规则，并且排序和比较基于字节而非字符</font>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_5 (data <span class="type">BINARY</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_6 <span class="keyword">VALUES</span>(&quot;中国&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> data       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> 中国        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>额…翻车了…因为字节数组没有字符集，所以也不应该输出“中国”呀…暂且认为是 Mysql 太贴心了吧…在 Qt 中，输出中文的字节数组，只会显示字节数据：</p><img src="/2022/img/image-20220831223235303.png" alt="" style="zoom:67%;" /><p>当保存 <code>BINARY</code> 值时，<strong>在它们<u>右边</u>填充值以达到指定长度</strong> 。填充值是 0x00(\0)。插入值时在右侧添加 0x00 ，<u>并且选择时不删除尾部的字节</u>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_6 (data <span class="type">BINARY</span>(<span class="number">10</span>)); #大小<span class="number">10</span>个字节</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_6 <span class="keyword">VALUES</span>(&quot;hello&quot;); #前五个字节为hello，后五个字节为<span class="number">0x00</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6 <span class="keyword">WHERE</span> data <span class="operator">=</span> &quot;hello&quot;;#只有五个字节，hello</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   #匹配不到是因为匹配时后面的<span class="number">0x00</span>也要参与</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_6 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;hello\0\0\0\0\0&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> data       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> hello      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当保存 <code>VARBINARY</code> ,插入时不填充字符，选择时不裁剪字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo_7 (data <span class="type">VARBINARY</span>(<span class="number">10</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo_7 <span class="keyword">VALUES</span>(&quot;中国&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> demo_7 <span class="keyword">WHERE</span> data<span class="operator">=</span>&quot;中国&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> data   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 中国   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>在大多数方面，可以将 BLOB 列视为能够足够大的 VARBINARY，BLOB 列没有字符集，并且排序和比较基于列值字节的数值值。</p></li></ul><h2 id="font-color-red-时间-日期类型-font"><font color='red'>时间/日期类型</font></h2><ul><li><p>试图插入一个不合法的日期，MySQL将给出警告或错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_0(ddl <span class="type">DATE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;2022-11-31&quot;);</span><br><span class="line">ERROR <span class="number">1292</span> (<span class="number">22007</span>): Incorrect <span class="type">date</span> <span class="keyword">value</span>: <span class="string">&#x27;2022-11-31&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;ddl&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span> #<span class="number">11</span>月没有<span class="number">31</span>号</span><br></pre></td></tr></table></figure><p>可以使用 <code>ALLOW_INVALID_DATES</code> SQL 模式让 MySQL 接受某些日期，比如 2002-00-00，这在需要保存一个你不知道确切日期的生日时非常有用 。如果你不想在日期中出现零，可以使用 <code>NO_ZERO_IN_DATE</code> SQL模式。在严格模式，非法日期不被接受。</p></li><li><p>存储年份时，可以只输入后两位，比如 <code>2022</code> -&gt; <code>22</code> ； 但两位年值的日期会令人模糊，因为世纪不知道。MySQL使用以下规则解释两位年值：</p><ul><li><p>70-99 范围的年值转换为 1970-1999</p></li><li><p>00-69 范围的年值转换为 2000-2069</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;22-10-30&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;70-10-30&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-10</span><span class="number">-30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-10</span><span class="number">-30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>MySQL 以标准输出格式 <code>YYYY-MM-DD HH:MM:SS</code> 或 <code>YY-MM-DD HH:MM:SS</code> 检索给定日期或时间类型的值，但它尽力解释你指定的各种输入值格式：</p><ul><li>允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，<code>98-12-31  11:30:45</code> 、<code>98.12.31 11+30+45</code> 、<code>98/12/31  11*30*45</code> 和 <code>98@12@31 11^30^45</code> 是等价的。</li><li><code>YYYYMMDDHHMMSS</code> 或 <code>YYMMDDHHMMSS</code> 格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，<code>19970523091528</code> 和 <code>970523091528</code> 被解释为 <code>1997-05-23  09:15:28</code> ，但 <code>971122129015</code> 是不合法的(它有一个没有意义的分钟部分)，将报错或变为 <code>0000-00-00  00:00:00</code> 。<strong>强烈建议加入分隔符！</strong></li><li>对于包括日期部分间割符的字符串值，如果日和月的值小于 10，不需要指定两位数。<code>1979-6-9</code> 与 <code>1979-06-09</code> 是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于 10，不需要指定两位数。<code>1979-10-30 1:2:3</code> 与 <code>1979-10-30 01:02:03</code> 相同。</li></ul></li><li><p>在一定程度上，可以将一个日期类型的值分配给一个不同的日期类型。但是，值可能会更改或丢失一些信息：</p><ul><li>如果你为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 <code>00:00:00</code> ，因为 DATE 值未包含时间信息。</li><li>如果你为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因为 DATE 值未包含时间信息。</li><li>TIMESTAMP 值不能早于 <code>1970</code> 或晚于 <code>2037</code> 。这说明一个日期，例如 <code>1968-01-01</code> ，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP 值却无效，如果分配给这样一个对象将被转换为 0。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#####为一个 DATETIME 或 <span class="type">TIMESTAMP</span> 对象分配一个 <span class="type">DATE</span> 值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_0(ddl <span class="type">DATE</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_0 <span class="keyword">VALUE</span>(&quot;2021-12-29 11:30:49&quot;);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_0;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-12</span><span class="number">-29</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line">#####为一个 <span class="type">DATE</span> 对象分配一个 DATETIME 或 <span class="type">TIMESTAMP</span> 值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_1 (ddl DATETIME);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_1 <span class="keyword">VALUES</span>(&quot;2022-12-29&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> ddl                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line">#####</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_2(data <span class="type">TIMESTAMP</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_2 <span class="keyword">VALUES</span>(&quot;2022-12-29 12:43:49&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)     </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_2;  #<span class="number">1970</span><span class="operator">~</span><span class="number">2037</span>之间的日期可赋值给时间戳</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> data                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-29</span> <span class="number">12</span>:<span class="number">43</span>:<span class="number">49</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_2 <span class="keyword">VALUES</span>(&quot;2045-12-29 12:43:49&quot;);#<span class="number">1970</span><span class="operator">~</span><span class="number">2037</span>之外的日期不可赋值给时间戳</span><br><span class="line">ERROR <span class="number">1292</span> (<span class="number">22007</span>): Incorrect datetime <span class="keyword">value</span>: <span class="string">&#x27;2045-12-29 12:43:49&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;data&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>时间戳取值范围包含约 22 亿个数值，因此在 MySQL 内部使用 4 个字节 INT 类型来存放时间戳数据：</p><p>1、在存储时间戳数据时，先将本地时区时间转换为 UTC 时区时间，再将 UTC 时区时间转换为 INT 格式的毫秒值(使用UNIX_TIMESTAMP函数)，然后存放到数据库中。<br>2、在读取时间戳数据时，先将INT格式的毫秒值转换为 UTC 时区时间(使用 FROM_UNIXTIME 函数)，然后再转换为本地时区时间，最后返回给客户端。</p></li><li><p>时间戳自动将当前时间填入数据库(可用于登入时间的记录)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_5(ddl <span class="type">DATE</span>, log_time <span class="type">TIMESTAMP</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>);  #<span class="number">2</span>，<span class="number">3</span>行代码设置自动记录写入时间。</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_5(DDL) <span class="keyword">VALUES</span>(&quot;2023-11-11&quot;);#只手动写入ddl</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_5;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> ddl        <span class="operator">|</span> log_time            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2023</span><span class="number">-11</span><span class="number">-11</span> <span class="operator">|</span> <span class="number">2022</span><span class="number">-09</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">35</span>:<span class="number">45</span> <span class="operator">|</span> #写入时间自动被记录</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="font-color-red-其他-font"><font color='red'>其他</font></h2><p><strong><mark class="hl-label blue">ZEROFILL属性</mark> </strong></p><p><code>ZEROFILL</code> 属性只用于整形。在插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补 0 ；<strong>如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性</strong> 。<code>ZEROFILL</code> 仅仅只是显示属性，与内存无关。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_5(</span><br><span class="line">    id <span class="type">INT</span> ZEROFILL);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">7.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_5 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_5 ;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> id         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0000000001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">严格/非严格模式</mark> </strong></p><p>当要在一个数值列内保存一个超出该列允许范围的值时，MySQL 的操作取决于此时有效的 SQL 模式。如果模式未设置，MySQL 将值裁剪到范围的相应端点，并保存裁减好的值。但是，如果模式设置为 traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据 SQL 标准插入会失败。如果 INT 列是 UNSIGNED，列范围的大小相同，但其端点会变为到 0 和 4294967295。若此时你试图保存 -9999999999 和 9999999999，以非严格模式保存到列中的值是 0 和 4294967296。如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。</p><p>当MySQL没有工作在严格模式时，对于 ALTER  TABLE、LOAD DATA  INFILE、UPDATE 和多行 INSERT 语句，由于裁剪发生的转换将报告为警告。当 MySQL 工作在严格模式时，这些语句将失败，并且部分或全部值不会插入或更改，取决于是否表为事务表和其它因素。<strong>最近的 Mysql 都默认采用严格模式。</strong></p><blockquote><p>参考：<a href="https://jyxcpp.netlify.app/img/mysql5.1_zh_chm.rar">Mysql5.1手册(点此下载)</a>，<a href="https://www.yiibai.com/mysql/text.html">TEXT简介</a>，<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=17&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平Mysql</a>，<a href="http://c.biancheng.net/view/2426.html">C语言中文网</a>，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据定义语言(一)</title>
      <link href="/2022/08/30/MySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/08/30/MySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。绝大多数 DBMS(Datebase Management System) 都支持 SQL 语言，因此，学习 SQL 使你几乎能与所有数据库打交道。同时，许多 DBMS 厂商通过增加语句和指令对 SQL 进行了扩展，虽然各厂商之间的扩展并不兼容，但它们都支持标准 SQL（ANCI SQL），所以无需担心 SQL 不适用于某个 DBMS。</p></blockquote><h2 id="font-color-red-SQL组成-font"><font color='red'>SQL组成</font></h2><p>SQL 包含以下 4 部分：</p><ol><li><p><strong>数据定义语言（Data Definition Language，DDL）</strong></p><p>用来创建或删除数据库以及表等对象，<strong><font color='orange'>针对的是表的结构(列)</font></strong> 。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">DROP</mark> </strong> ：删除数据库和表等对象</li><li><strong><mark class="hl-label default">CREATE</mark> </strong> ：创建数据库和表等对象</li><li><strong><mark class="hl-label default">ALTER</mark> </strong> ：修改数据库和表等对象的结构</li></ul></li><li><p><strong>数据操作语言（Data Manipulation Language，DML）</strong></p><p>用来变更表中的记录，<strong><font color='orange'>针对的是表的内容(行)</font></strong> 。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">SELECT</mark> </strong> ：查询表中的数据</li><li><strong><mark class="hl-label default">INSERT</mark> </strong> ：向表中插入新数据</li><li><strong><mark class="hl-label default">UPDATE</mark> </strong> ：更新表中的数据</li><li><strong><mark class="hl-label default">DELETE</mark> </strong> ：删除表中的数据</li></ul></li><li><p><strong>数据查询语言（Data Query Language，DQL）</strong></p><p>用来查询表中的记录，主要包含 <strong><mark class="hl-label default">SELECT</mark> </strong>  命令，来查询表中的数据。</p></li><li><p><strong>数据控制语言（Data Control Language，DCL）</strong></p><p>用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令：</p><ul><li><strong><mark class="hl-label default">GRANT</mark> </strong> ：赋予用户操作权限</li><li><strong><mark class="hl-label default">REVOKE</mark> </strong> ：取消用户的操作权限</li><li><strong><mark class="hl-label default">COMMIT</mark> </strong> ：确认对数据库中的数据进行的变更</li><li><strong><mark class="hl-label default">ROLLBACK</mark> </strong> ：取消对数据库中的数据进行的变更</li></ul></li></ol><h2 id="font-color-red-SQL基本书写规则-font"><font color='red'>SQL基本书写规则</font></h2><ul><li><p><strong>SQL 语句要以分号 <code>;</code> 结尾</strong> 。一条 SQL 语句代表着数据库的一个操作。</p></li><li><p><strong>单词需要用半角空格或者换行来分隔</strong></p></li><li><p><strong>SQL 语句大小写规则：</strong></p><ul><li>SQL 关键字和函数名：一律不区分大小写。</li><li>数据库名、表名和视图名：<strong>MySQL 用服务器主机的底层文件系统所包含的目录和文件来表示数据库和表</strong> 。因此，<font color='orange'>数据库名和表名的默认大小写取决于服务器主机的操作系统在命名方面的规定</font>。比如 Windows 系统的文件名不区分大小写，所以运行在 Windows 系统上面的 MySQL 服务器也不用区分数据库名和表名的大小写。Linux 系统的文件名区分大小写，所以运行在 Linux 系统上的 MySQL 服务器需要区分数据库名和表名的大小写。</li><li>存储程序的名字：存储函数、存储过程和事件的名字都不区分大小写。触发器的名字要区分大小写，这一点与标准 SQL 的行为有所不同。</li><li>列名和索引名：一律不区分大小写。</li><li>别名：表的别名在 Linux 中区分大小写，在 Windows 中不区分；列名与列的别名一律忽略大小写；</li></ul><img src="/2022/img/image-20220830161650126.png" alt="" style="zoom:67%;" /><blockquote><p>需要注意的是，插入到表中的数据是否区分大小写由创建数据库时指定的 <strong>字符集校对规则( COLLATE )</strong> 决定，默认使用 <code>utf8_general_ci</code> (不区分大小写)，而 <code>utf8_bin</code> 则区分大小写。后面会详细阐述相关内容。</p></blockquote><p>在 Linux 服务器下创建数据库和表时，考虑到它们以后是否会迁移到 Windows 服务器上，应该认真对待大小写的问题。</p></li></ul><h2 id="font-color-red-数据库基本操作-font"><font color='red'>数据库基本操作</font></h2><h3 id="font-color-red-创建数据库-font"><font color='red'>创建数据库</font></h3><p>使用 <strong>CREATE DATABASE</strong> 语句创建数据库，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;</span><br><span class="line">[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] </span><br><span class="line">[[DEFAULT] COLLATE &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure><p>[ ]中的内容是可选的。语法说明如下：</p><ul><li><code>&lt;数据库名&gt;</code> ：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li><code>IF NOT EXISTS</code>：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li><code>[DEFAULT] CHARACTER SET</code> ：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集，即 <code>utf-8</code> 。</li><li><code>[DEFAULT] COLLATE</code> ：指定字符集的默认校对规则，即 <code>utf8_general_ci</code> 。</li><li>注意，不同于查看数据库的操作，<code>DATABASE</code> 后面没有 <code>S</code> ，数据库名不用加 <code>''</code> 。</li></ul><blockquote><p><strong>字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。</strong></p></blockquote><p><strong><mark class="hl-label blue">示例</mark> </strong></p><p><strong>直接创建数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test_db;</span><br><span class="line">Query OK, 1 row affected (0.12 sec);</span><br></pre></td></tr></table></figure><p>若再次输入<code>CREATE DATABASE test_db;</code> 语句，则系统会给出错误提示信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test_db;</span><br><span class="line">ERROR 1007 (HY000): Can&#x27;t create database &#x27;test_db&#x27;; database exists</span><br></pre></td></tr></table></figure><p>MySQL 不允许在同一系统下创建两个相同名称的数据库。可以加上 <code>IF NOT EXISTS</code> 从句，就可以避免类似错误，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE IF NOT EXISTS test_db;</span><br><span class="line">Query OK, 1 row affected (0.12 sec)</span><br></pre></td></tr></table></figure><p><strong>指定字符集和校对规则：</strong></p><p>使用 MySQL 命令行工具创建一个测试数据库，命名为 test_db_char，指定其默认字符集为 <code>utf8</code>，默认校对规则为 <code>utf8_chinese_ci</code>（简体中文，不区分大小写），输入的 SQL 语句与执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char</span><br><span class="line">    -&gt; DEFAULT CHARACTER SET utf8</span><br><span class="line">    -&gt; DEFAULT COLLATE utf8_chinese_ci;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>仅在最后一行末尾打上分号即可</font></strong> 。<code>DEFAULT</code> 可写可不写。<br>这时，可以使用 <code>SHOW CREATE DATABASE</code> 查看 test_db_char 数据库的定义声明，发现该数据库的指定字符集为 <code>utf8</code> ，运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE DATABASE test_db_char;</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| Database     | Create Database                                     |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| test_db_char | CREATE DATABASE `test_db_char` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-查看数据库-font"><font color='gree'>查看数据库</font></h3><p>在 MySQL 数据库中存在系统数据库和自定义数据库，系统数据库是在安装 MySQL 后系统自带的数据库，自定义数据库是由用户定义创建的数据库。在 MySQL 中，可使用 <strong><mark class="hl-label default">SHOW DATABASES</mark> </strong> 语句来查看或显示当前用户权限范围以内的数据库。查看数据库的语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES LIKE &#x27;数据库名&#x27;;</span><br></pre></td></tr></table></figure><ul><li>LIKE 从句是可选项，用于匹配指定的数据库名称；LIKE 从句可以部分匹配，也可以完全匹配。<ul><li>查看名字为 stuInfo 的数据库       ：<strong><code>SHOW DATABASES LIKE 'stuInfo';</code></strong></li><li>查看名字中包含 stuInfo 的数据库：<strong><code>SHOW DATABASES LIKE '%stuInfo%';</code></strong></li><li>查看名字以 stuInfo 开头的数据库：<strong><code>SHOW DATABASES LIKE '%stuInfo';</code></strong></li><li>查看名字以 stuInfo 结尾的数据库：<strong><code>SHOW DATABASES LIKE 'stuInfo%';</code></strong></li></ul></li><li>注意是 <code>DATABASES</code> ，可别忘了后面的 <code>S</code> 。</li><li>可用单引号也可以双引号。</li></ul><p><strong>系统数据库：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 row in set (0.22 sec)</span><br></pre></td></tr></table></figure><p>还未创建自定义数据库时，<code>SHOW DATABASES;</code> 列出的数据库即为系统数据库：</p><ul><li>information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。</li><li>mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。</li><li>performance_schema：主要用于收集数据库服务器性能参数。</li><li>sakila：MySQL 提供的样例数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。</li><li>sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。</li><li>world：world 数据库是 MySQL 自动创建的数据库，该数据库中只包括 3 张数据表，分别保存城市，国家和国家使用的语言等内容。</li></ul><p><strong>查看数据库的定义声明：</strong></p><p>使用 <code>SHOW CREATE DATABASE</code> 查看 test_db_char 数据库的定义声明，发现该数据库的指定字符集为 <code>utf8</code> ，运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE DATABASE test_db_char;</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| Database     | Create Database                                     |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">| test_db_char | CREATE DATABASE `test_db_char` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+--------------+-----------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>说明：第五行第二列中<code>test_db_char</code> 两旁的反引号 ` 是为了在创建数据库时规避关键字冲突，比如我脑壳烧坏了，想创建一个名为 CREATE 的数据库，就必须在创建时输入反引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE `CREATE`;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>查看当前所在数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line">############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test    <span class="operator">|</span>#数据库名</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> push_test         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ship_order_detail <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">############################</span><br><span class="line">mysql<span class="operator">&gt;</span> status;</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.7</span><span class="number">.19</span>, <span class="keyword">for</span> Win64 (x86_64)</span><br><span class="line"></span><br><span class="line">Connection id:          <span class="number">3</span></span><br><span class="line"><span class="keyword">Current</span> database:       no1sc  #当前数据库</span><br><span class="line"><span class="keyword">Current</span> <span class="keyword">user</span>:           root<span class="variable">@localhost</span></span><br><span class="line">SSL:                    <span class="keyword">Not</span> <span class="keyword">in</span> use</span><br><span class="line"><span class="keyword">Using</span> delimiter:        ;</span><br><span class="line">Server version:         <span class="number">5.7</span><span class="number">.19</span> MySQL Community Server (GPL)</span><br><span class="line">Protocol version:       <span class="number">10</span></span><br><span class="line">Connection:             localhost via TCP<span class="operator">/</span>IP</span><br><span class="line">Server characterset:    utf8</span><br><span class="line">Db     characterset:    utf8</span><br><span class="line">Client characterset:    utf8</span><br><span class="line">Conn.  characterset:    utf8</span><br><span class="line">TCP port:               <span class="number">3306</span></span><br><span class="line">Uptime:                 <span class="number">1</span> <span class="keyword">day</span> <span class="number">4</span> hours <span class="number">20</span> min <span class="number">58</span> sec</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-修改数据库-font"><font color='gree'>修改数据库</font></h3><p>在 MySQL 数据库中<u>只能对数据库使用的字符集和校对规则进行修改</u>，数据库的这些特性都储存在 db.opt 文件中。修改数据库的语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE [数据库名] &#123; </span><br><span class="line">[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |</span><br><span class="line">[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure><p>语法说明如下：</p><ul><li>ALTER DATABASE 用于更改数据库的全局特性。</li><li>使用 ALTER DATABASE 需要获得数据库 ALTER 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li></ul><p><strong><mark class="hl-label blue">示例：</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER DATABASE test_db</span><br><span class="line">    -&gt; DEFAULT CHARACTER SET gb2312</span><br><span class="line">    -&gt; DEFAULT COLLATE gb2312_chinese_ci;</span><br><span class="line">mysql&gt; SHOW CREATE DATABASE test_db;</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">| Database | ALTER Database                                        |</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">| test_db  | ALTER DATABASE `test_db` /*!40100 DEFAULT CHARACTER SET gb2312 */|</span><br><span class="line">+----------+--------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="font-color-gree-删除数据库-font"><font color='gree'>删除数据库</font></h3><p>Mysql 数据库中储存着一个或多个数据表，而数据表的本质仍是文件，这种文件有特殊的结构，非常方便数据的操作；数据库则体现为一个目录，如下图：</p><img src="/2022/img/image-20220830121356695.png" alt="stuinfo数据库" style="zoom:67%;" /><img src="/2022/img/image-20220830121414517.png" alt="table_1数据表" style="zoom:67%;" /><p>删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><ul><li>IF EXISTS：用于防止当数据库不存在时发生错误。</li><li>DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。</li></ul><p><strong><mark class="hl-label blue">示例：</mark> </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#删除stuInfo数据库</span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| stuinfo            |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DROP DATABASE stuInfo;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>另外，使用 MySQL 命令删除数据库后不可恢复，需谨慎操作；若直接删除数据库目录(将数据库目录放入回收站)，似乎也能够完成删除操作，但不建议如此，因为其他文件中相关的配置可能没有即时更改(个人猜测)。</p><h3 id="font-color-gree-选择数据库-font"><font color='gree'>选择数据库</font></h3><p>当用 CREATE DATABASE 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。其语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE &lt;数据库名&gt;</span><br></pre></td></tr></table></figure><p><strong>无需加 <code>DATABASE</code> !</strong> 该语句可以通知 MySQL 把 <code>&lt;数据库名&gt;</code> 所指示的数据库作为当前默认数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| stuinfo            |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use stuinfo;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-安装配置</title>
      <link href="/2022/08/29/MySQL-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/08/29/MySQL-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-MySQL下载-font"><font color='red'>MySQL下载</font></h2><p>进入到<a href="https://downloads.mysql.com/archives/community/">MySQL官网地址</a> ，选择常用的 <code>5.7.19</code> 版本，操作系统选择 <code>Microsoft Windows</code> ，然后点击 <code>Windows (x86, 64-bit), ZIP Archive</code> 所在行的 <code>Download</code> ，如下图：</p><p><img src="/2022/img/image-20220829185625160.png" alt=""></p><p>下载后得到 <code>.zip</code> 压缩包，单击右键解压到指定的路径，笔者选择的路径是 <code>D:\MySQL</code> ，解压好后如下：</p><p><img src="/2022/img/image-20220829194816430.png" alt=""></p><p><img src="/2022/img/image-20220829195010717.png" alt=""></p><h2 id="font-color-red-MySQL配置-font"><font color='red'>MySQL配置</font></h2><h3 id="font-color-orange-配置文件-font"><font color='orange'>配置文件</font></h3><p>在 <code>D:\MySQL\mysql-5.7.19-winx64</code> 目录下新建 <code>my.ini</code> 文件，创建后写入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">#  设置MySQL的安装目录</span><br><span class="line">basedir=D:\\MySQL\\mysql-5.7.19-winx64\\</span><br><span class="line">#  设置MySQL数据库的数据存放目录</span><br><span class="line">datadir=D:\\MySQL\\mysql-5.7.19-winx64\\data</span><br><span class="line">port=3306</span><br><span class="line">character-set-server=utf8</span><br><span class="line">#跳过安全检查，设置密码后才将其注释</span><br><span class="line">skip-grant-tables </span><br></pre></td></tr></table></figure><p><strong><font color='gree'>注意将代码中的路径更改为你自己设置的路径！</font></strong></p><h3 id="font-color-orange-配置环境变量-font"><font color='orange'>配置环境变量</font></h3><p>在桌面上右键单击 <code>我的电脑</code> -&gt; <code>属性</code> ，出现以下界面：</p><p><img src="/2022/img/image-20220829195720092.png" alt=""></p><p>然后单击 <code>高级系统设置</code> -&gt; <code>环境变量</code> -&gt; <code>PATH</code> -&gt; <code>编辑</code> -&gt; <code>新建</code> -&gt; 将路径 <code>D:\MySQL\mysql-5.7.19-winx64\bin</code> 粘贴进用户变量并确认保存即可。如果之前配置过其他版本的 MySQL ，则须将路径上移。过程如下：</p><img src="/2022/img/image-20220829200227747.png" alt="" style="zoom:50%;" /><img src="/2022/img/image-20220829200318095.png" alt="" style="zoom:67%;" /><img src="/2022/img/image-20220829200413903.png" alt="" style="zoom:67%;" />**注意，最好在admin用户下进行操作以获取最高权限** 。<blockquote><p>配置环境变量是为了可以在任意位置执行 MySQL 命令，否则每次登录 MySQL 服务器时就必须进入到 MySQL 的 bin 目录下，才能使用 MySQL 等其它命令工具，这样比较麻烦。</p></blockquote><h3 id="font-color-orange-命令行操作-font"><font color='orange'>命令行操作</font></h3><ol><li><strong><font color='gree'>务必以管理员身份打开命令行！不可直接cmd打开！</font></strong></li></ol><img src="/2022/img/image-20220829200909610.png" alt="" style="zoom:67%;" /><ol start="2"><li><p>切换到 <code>D:\MySQL\mysql-5.7.19-winx64\bin</code> 目录下：先输入 <code>D:</code> 并回车，再输入 <code>cd D:\MySQL\mysql-5.7.19-winx64\bin</code> 并回车：</p><p><img src="/2022/img/image-20220829201327011.png" alt=""></p></li><li><p>安装 MySQL：输入 <code>mysqld -install</code></p></li><li><p>初始化数据库：输入 <code>mysqld --initialize-insecure --user=mysql</code> 并回车。如果执行成功，会在 <code>D:\MySQL\mysql-5.7.19-winx64\</code> 目录下生成 <code>data</code> 目录。</p><img src="/2022/img/image-20220829201735873.png" style="zoom:67%;" /></li><li><p>启用 MySQL 服务：输入 <code>net start mysql</code></p><img src="/2022/img/image-20220829202122072.png" style="zoom:67%;" /><p>停止服务则输入 <code>net stop mysql</code> 即可。</p></li><li><p>连接到 MySQL 管理终端：输入 <code>mysql -u root -p</code> ，root 即为用户名，p 为 password ；回车后会要求输入密码，但目前密码为空，所以直接再次回车跳过即可。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\MySQL\mysql-5.7.19-winx64\bin&gt;mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure><p>注意：不写 <code>-h 主机IP</code> ，则默认为本机；不写 <code>-P 端口号</code> 则默认 3306 ；端口号是大写P，密码是小写p。</p></blockquote></li><li><p>修改 root 用户密码：首先输入 <code>use mysql;</code> ，<strong>勿忘分号！分号是SQL语句的终止符；</strong> 再输入 <code>update user set authentication_string=password('password') where user='root' and Host='localhost';</code> ，其中 <code>password</code> 是你要设置的密码；然后输入 <code>flush privileges</code> 刷新权限。</p></li><li><p>修改 <code>my.ini</code> 文件，将最后一行的 <code>skip-grant-tables </code> 注释掉，并保存文件。而后你可以在命令行输入 <code>quit</code> 退出 MySQL 终端并重新进入，此时就需要输入密码了。</p></li></ol><p>如果你在执行上述某一步操作时出错而导致后续无法推进，请先删除已安装好的 MySQL ，在命令行输入 <code>sc delete mysql</code> 即可。如果想删除某些文件却发现无法删除(文件已在另一处打开)，请先停止 <code>MySQL</code> 服务：输入 <code>net stop mysql</code> ，而后再进行删除。</p><blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1H64y1U7GJ?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f507850c724cff595de0e591730ebe9f">韩顺平MySQL</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-QMainWindown</title>
      <link href="/2022/08/26/Qt-QMainWindown/"/>
      <url>/2022/08/26/Qt-QMainWindown/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>默认结构最复杂的标准窗口</p><ul><li>提供了<code>菜单栏</code>, <code>工具栏</code>, <code>状态栏</code>, <code>停靠窗口</code></li><li>菜单栏: 只能有一个, 创建的最上方</li><li>工具栏: 可以有多个, 默认提供了一个, 窗口的上下左右都可以停靠</li><li>状态栏: 只能有一个, 窗口最下方</li><li>停靠窗口: 可以有多个, 默认没有提供, 窗口的上下左右都可以停靠</li></ul></blockquote><p><img src="/2022/img/1563061070230.png" alt=""></p><h2 id="font-color-red-菜单栏-font"><font color='red'>菜单栏</font></h2><h3 id="创建MenuBar">创建MenuBar</h3><ul><li>获取 QMainWindow 提供的菜单栏</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar* menubar = <span class="built_in">menuBar</span>();<span class="comment">//大小自适应主窗口</span></span><br></pre></td></tr></table></figure><ul><li>自己 new 一个，然后设置给窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar* menubar = <span class="keyword">new</span> QMenuBar;<span class="comment">//大小需要自己调节。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setMenuBar</span>(menubar);</span><br></pre></td></tr></table></figure><h3 id="添加Menu">添加Menu</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMenu* m = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">m-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">m-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="comment">//添加已有菜单，返回菜单关联的动作</span></span><br><span class="line">QAction* act = menubar-&gt;<span class="built_in">addMenu</span>(m);</span><br><span class="line"><span class="comment">//添加菜单时设置标题</span></span><br><span class="line">QMenu *editMenu = menubar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"><span class="comment">//添加菜单时设置标题和图标</span></span><br><span class="line">QMenu *buildMenu = menubar-&gt;<span class="built_in">addMenu</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/mm.png&quot;</span>),<span class="string">&quot;构建&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="添加Action">添加Action</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加action时设置图标和标题</span></span><br><span class="line">editMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::StandardPixmap::SP_FileIcon),<span class="string">&quot;redo&quot;</span>);</span><br><span class="line"><span class="comment">//添加action时设置标题和槽函数</span></span><br><span class="line">editMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;remove&quot;</span>,<span class="keyword">this</span>,[]()&#123; <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;remove&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//添加action时设置标题，槽函数和快捷键。</span></span><br><span class="line">editMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;剪切&quot;</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;剪切&quot;</span>;&#125;,<span class="built_in">QKeySequence</span>(<span class="string">&quot;ctrl+x&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接信号和槽函数方式：</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">QMenuBar *menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> menu_file = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>); </span><br><span class="line">    QAction *file_new = menu_file-&gt;<span class="built_in">addAction</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::StandardPixmap::SP_FileIcon) ,<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    QAction *file_save = menu_file-&gt;<span class="built_in">addAction</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::StandardPixmap::SP_DirIcon) ,<span class="string">&quot;保存&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(menu_file,menu_file-&gt;triggered,<span class="keyword">this</span>,[=](QAction *act)&#123;<span class="comment">//注意只能=捕获，不能&amp;捕获！！！</span></span><br><span class="line">        <span class="keyword">if</span>(act==file_new)</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;file_new&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(act==file_save)</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;file_save&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">editMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;remove&quot;</span>,<span class="keyword">this</span>,[]()&#123; <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;remove&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//当菜单和action很多时，使用方法二更方便，一次解决。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><font color=#3b8dfe>感觉 <code>QAction</code> 很抽象，它是什么？何时用？</font></strong></p><p><code>QAction</code> 从名字上来看，它偏指一种行为，而不像 <code>QPushButton</code> 、<code>QLineEdit</code> 等那样具象有实体；从它的多个具有槽函数的函数来看，也能说明它的使命就是完成某个行为，比如点击 Qt Creator 菜单栏中的【文件】后，会显示许多选项(“打开文件”,”保存文件“等)，这些选项就是最终的行为。<code>QAction</code> 常用作 Menu 和 ToolBar 的条目。</p></blockquote><h3 id="给菜单添加快捷键">给菜单添加快捷键</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">menubar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑(&amp;B)&quot;</span>);</span><br><span class="line">menubar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;&amp;File&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210811165146204-16614887186752.png" alt=""></p><blockquote><p>单击菜单项, 该对象会发出一个信号</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击QAction对象发出该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAction::triggered</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="font-color-red-工具栏-font"><font color='red'>工具栏</font></h2><h3 id="创建工具栏">创建工具栏</h3><ul><li>通过 MainWindow 获取，<strong>推荐使用此方式</strong> 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *toolbar =  <span class="built_in">addToolBar</span>(<span class="string">&quot;toolbar&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>自己 new 一个，而后加入到 MainWindow</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QToolBar* toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>();</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(toolBar);</span><br></pre></td></tr></table></figure><h3 id="添加Aciton">添加Aciton</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有图标就显示文字 (如下图)</span></span><br><span class="line">toolbar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;工具&quot;</span>);</span><br><span class="line"><span class="comment">//有图标就显示图标，文字作为提示(鼠标移上去会显示)</span></span><br><span class="line">toolbar-&gt;<span class="built_in">addAction</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span></span><br><span class="line">                    (QStyle::StandardPixmap::SP_ArrowBack),<span class="string">&quot;1213123&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210811225528440.png" alt=""></p><h3 id="添加Widget">添加Widget</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要是QWidget或者启子类都可以被添加</span></span><br><span class="line">toolbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Touch Me&quot;</span>));</span><br><span class="line"><span class="comment">//工具栏一般添加 QToolButton，且只要图标不要文字</span></span><br><span class="line">toolbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;...&quot;</span>)));</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210811225853232-16614887186755.png" alt=""></p><h2 id="font-color-red-状态栏-font"><font color='red'>状态栏</font></h2><blockquote><p>一般情况下, 需要在状态栏中添加某些控件, 显示某些属性, 使用最多的就是添加标签 QLabel</p></blockquote><h3 id="创建状态栏">创建状态栏</h3><ul><li>获取自带的状态栏，默认在窗口下方。<strong>推荐使用此方式</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar* statusbar = <span class="built_in">statusBar</span>();</span><br></pre></td></tr></table></figure><ul><li>new 一个，默认在窗口上方。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar* statusbar = <span class="keyword">new</span> QStatusBar;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStatusBar</span>(statusbar);</span><br></pre></td></tr></table></figure><h3 id="添加Widget-2">添加Widget</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左边</span></span><br><span class="line">statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;status&quot;</span>));</span><br><span class="line"><span class="comment">//右边(Permanent永久的)</span></span><br><span class="line">statusbar-&gt;<span class="built_in">addPermanentWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;permanent&quot;</span>));</span><br><span class="line">statusbar-&gt;<span class="built_in">addPermanentWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;per&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="显示状态信息">显示状态信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar *statusBar = <span class="keyword">this</span>-&gt;<span class="built_in">statusBar</span>();</span><br><span class="line">statusBar-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;已完成初始化&quot;</span>,<span class="number">2000</span>);<span class="comment">//只显示2000毫秒</span></span><br></pre></td></tr></table></figure><h2 id="font-color-red-浮动窗口-停靠窗口-font"><font color='red'>浮动窗口(停靠窗口)</font></h2><blockquote><p>默认没有, 需要手动添加，头文件&lt;QDockWidget&gt;</p></blockquote><h3 id="添加浮动窗口">添加浮动窗口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget* solveDock = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;解决方案管理器&quot;</span>);</span><br><span class="line">QDockWidget* teamDock = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;团队资源管理器&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addDockWidget</span>(Qt::DockWidgetArea::RightDockWidgetArea,solveDock);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addDockWidget</span>(Qt::DockWidgetArea::RightDockWidgetArea,teamDock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(<span class="keyword">new</span> QTextEdit);<span class="comment">//设置中心编辑窗口</span></span><br></pre></td></tr></table></figure><img src="/2022/img/image-20220827223625109.png" alt="" style="zoom: 33%;" /><h3 id="分割浮动窗口">分割浮动窗口</h3><ul><li>将第一个停靠小部件所覆盖的空间分成两部分，将第一个停靠小部件移动到第一部分，并将第二个停靠小部件移动到第二部分。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">splitDockWidget</span>(gitDock,solveDock,Qt::Orientation::Horizontal);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210812024601715-16614887186759.png" alt=""></p><h3 id="选项卡式停靠">选项卡式停靠</h3><ul><li>将第二个停靠小部件移动到第一个停靠小部件之上，在主窗口中创建一个选项卡式停靠区域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tabifyDockWidget</span>(solveDock,teamDock);</span><br><span class="line"><span class="built_in">tabifyDockWidget</span>(teamDock,resourceDock);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210812025619388-166148871867511.png" alt=""></p><h2 id="font-color-red-右键菜单-font"><font color='red'>右键菜单</font></h2><p>在桌面右击鼠标会出现菜单，这个我们一般叫做右键菜单，那么在Qt中我们如何使用右键菜单呢？</p><p>首先需要给控件设置上下文菜单策略 setContextMenuPolicy(Qt::CustomContextMenu) ；设置该策略后当我们右键点击控件时qt会发送一个信号 customContextMenuRequested(const QPoint &amp;pos) ，其中参数pos用来传递右键点击时的鼠标的坐标，这个坐标是相对于控件左上角而言的；最后给这个信号设置相应的槽函数，在槽函数中将菜单展示出来就行了。</p><ul><li>设置上下文菜单策略</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setContextMenuPolicy</span>(Qt::ContextMenuPolicy::CustomContextMenu);</span><br></pre></td></tr></table></figure><ul><li>连接上下文菜单触发的信号</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::customContextMenuRequested,<span class="keyword">this</span>,[=](<span class="type">const</span> QPoint&amp;pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在指定位置弹出菜单,有两种方式：</span></span><br><span class="line">    <span class="comment">//1.contextMenu-&gt;popup(btn-&gt;mapToParent(this-&gt;mapToParent(pos)));//pos坐标是相对于控件左上角而言，但popup()的实参是相对于屏幕左上角而言，所以需要使用mapToParent()转换坐标系</span></span><br><span class="line">    <span class="comment">//2.contextMenu-&gt;popup(QCursor::pos());//直接使用绝对坐标系(相对于屏幕左上角)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>创建上下文菜单，一般作为成员变量使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMenu contextMenu = <span class="keyword">new</span> QMenu;</span><br><span class="line">QAction* copyAct = contextMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">QAction* pasteAct= contextMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;粘贴&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="font-color-red-托盘菜单-font"><font color='red'>托盘菜单</font></h2><p>系统托盘就是在系统桌面底部特定的区域显示运行的程序。windows在任务栏状态区域，linux在布告栏区域。应用程序系统托盘功能，是比较普遍的功能。</p><p>演示Demo实现功能：</p><ol><li><p>应用启动后，任务栏，系统托盘可以看到该程序。</p></li><li><p>点击右上角×关闭窗口，自动隐藏窗口，托盘可以看到该程序。</p></li><li><p>鼠标在托盘图标上右键，弹出&quot;退出程序&quot;菜单栏，并带有图标。</p></li></ol><ul><li>创建系统托盘菜单图标</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须通过构造函数或者setIcon函数设置图标，否则在托盘看不到。trayIcon一般作为成员变量。</span></span><br><span class="line">trayIcon = <span class="keyword">new</span> <span class="built_in">QSystemTrayIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/trayIcon.png&quot;</span>),<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//trayIcon-&gt;setContextMenu(contextMenu);</span></span><br><span class="line">trayIcon-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><ul><li>设置菜单</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMenu* menu = <span class="keyword">new</span> QMenu;</span><br><span class="line">QAction*openMainWindow = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开主窗口&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction*quit = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;退出程序&quot;</span>);</span><br><span class="line"></span><br><span class="line">trayIcon-&gt;<span class="built_in">setContextMenu</span>(menu);</span><br></pre></td></tr></table></figure><ul><li>处理菜单消息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(openMainWindow,&amp;QAction::triggered,<span class="keyword">this</span>,&amp;QWidget::showNormal);</span><br><span class="line"><span class="built_in">connect</span>(quit,&amp;QAction::triggered,<span class="keyword">this</span>,&amp;QApplication::quit);</span><br><span class="line"><span class="comment">//隐藏窗口，任务栏也看不到图标，只能在托盘菜单看到</span></span><br><span class="line"><span class="comment">//connect(quit,&amp;QAction::triggered,this,&amp;Widget::hide);</span></span><br></pre></td></tr></table></figure><ul><li>根据托盘菜单激活原因进行处理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(trayIcon,&amp;QSystemTrayIcon::activated,<span class="keyword">this</span>,&amp;Widget::onActivated);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onActivated</span><span class="params">(QSystemTrayIcon::ActivationReason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (reason)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> QSystemTrayIcon::Unknown:      <span class="comment">//未知原因</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QSystemTrayIcon::Context:      <span class="comment">//右键请求菜单</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Context&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QSystemTrayIcon::DoubleClick:  <span class="comment">//系统托盘被双击</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">showNormal</span>();    </span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;DoubleClick&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QSystemTrayIcon::Trigger:      <span class="comment">//系统托盘被点击</span></span><br><span class="line">        <span class="built_in">bubbleMessage</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Trigger&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QSystemTrayIcon::MiddleClick:  <span class="comment">//系统托盘被鼠标中键点击</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;MiddleClick&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置工具提示</span></span><br><span class="line">trayIcon-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;maye的小托盘&quot;</span>);</span><br><span class="line"><span class="comment">//右下角气泡消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::bubbleMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果支持气泡消息</span></span><br><span class="line">    <span class="keyword">if</span>(QSystemTrayIcon::<span class="built_in">supportsMessages</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bubb&quot;</span>;</span><br><span class="line">        trayIcon-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;bubbleMessage&quot;</span>,<span class="string">&quot;I&#x27;m Maye,What&#x27;s your name?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//气泡消息被点击的处理</span></span><br><span class="line">    <span class="built_in">connect</span>(trayIcon,&amp;QSystemTrayIcon::messageClicked,<span class="keyword">this</span>,[]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;气泡消息被点击啦~&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-常用控件</title>
      <link href="/2022/08/26/Qt-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/"/>
      <url>/2022/08/26/Qt-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-按钮抽象基类-QAbstractButton-font"><font color='red'>按钮抽象基类(QAbstractButton)</font></h2><h3 id="简介"><strong>简介</strong></h3><p>QAbstractButton 类是按钮部件的抽象基类，提供了按钮所共有的功能。</p><p>QAbstractButton 类实现了一个抽象按钮，并且让它的子类来指定如何处理用户的动作，并指定如何绘制按钮。</p><p>QAbstractButton 提供了点击和勾选按钮。QRadioButton 和 QCheckBox 类只提供了勾选按钮，QPushButton 和 QToolButton 提供了点击按钮，如果需要的话，它们还可以提供切换行为。</p><p>任何按钮，都可以显示一个包含文本和图标的标签。</p><ul><li><p>setText(const QString&amp;) 设置文本</p></li><li><p>setIcon(const QIcon&amp;)    设置图标</p></li></ul><h3 id="信号与槽"><strong>信号与槽</strong></h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><ul><li><em>clicked，pressed，released信号</em></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Touch Me&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮按下释放之后会触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;clicked&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//按钮按下触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::pressed,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;pressed&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//按钮释放触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::released,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;released&quot;</span>;&#125;);</span><br></pre></td></tr></table></figure><ul><li><em>toggled信号</em>：每当切换按钮(toggleButton)改变其状态时，就会发出此信号。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);<span class="comment">//设置按钮可选中</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::toggled,<span class="keyword">this</span>,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;toggled&quot;</span>&lt;&lt;btn-&gt;<span class="built_in">isChecked</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label default">slots</mark> </strong></p><ul><li>void animateClick(int msec = 100)  定时自动点击按钮</li><li>void click()  自动点击按钮</li><li>void setIconSize(const QSize &amp;size)  设置图标大小，较小的图标可能会设置无效</li><li>void setChecked(bool) 设置是否选中按钮(checkable必须被启用)</li><li>void toggle()  切换按钮的选中状态</li></ul><h3 id="其他函数">其他函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><code>int void setAutoExclusive(bool)</code> 可选中按钮是否独占， 在独占按钮组(同一父对象为同一组)中，任何时候只能选中一个按钮</td></tr><tr><td style="text-align:center">2</td><td><code>void setAutoRepeat(bool)</code> 如果启用，按钮按下不松开，pressed()、released()和clicked()信号会定期发出。应用于射击游戏中的全自动开火模式。</td></tr><tr><td style="text-align:center">3</td><td><code>void setAutoRepeatDelay(int)</code> 如果启用了autoRepeat，那么autoRepeatDelay将定义自动重复生效前的初始延迟(以毫秒为单位)。</td></tr><tr><td style="text-align:center">4</td><td><code>void setAutoRepeatInterval(int)</code> 如果启用了autoRepeat，则autoRepeatInterval定义了自动重复间隔的长度，以毫秒为单位。</td></tr><tr><td style="text-align:center">5</td><td><code>void setCheckable(bool)</code> 设置按钮是否能够被选中，默认是不能被选中的</td></tr><tr><td style="text-align:center">6</td><td><code>void setDown(bool)</code> 设置按钮是否被按下</td></tr><tr><td style="text-align:center">7</td><td><code>void setIcon(const QIcon &amp;icon)</code> 设置图标</td></tr><tr><td style="text-align:center">8</td><td><code>void setShortcut(const QKeySequence &amp;key)</code> 设置快捷键</td></tr><tr><td style="text-align:center">9</td><td><code>void setText(const QString &amp;text)</code> 设置文本</td></tr></tbody></table><h2 id="font-color-red-按钮-PushButton-font"><font color='red'>按钮(PushButton)</font></h2><p>最常用的控件之一，应用场景十分广泛。</p><h3 id="信号与槽-2">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><p>Inherits:QAbstractButton 继承自父类</p><p><strong><mark class="hl-label default">slots</mark> </strong></p><p>void showMenu()如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</p><h3 id="常用函数">常用函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><code>int void setAutoDefault(bool)</code> 设为自动默认按钮，按下Enter键时会自动按下按钮</td></tr><tr><td style="text-align:center">2</td><td><code>void setDefault(bool)</code> 设为自动默认按钮，按下Enter键时会自动按下按钮</td></tr><tr><td style="text-align:center">3</td><td><code>void setFlat(bool)</code> 去掉按钮的边框，让PushButton按钮跟背景色融为一体，在点击按钮时，会出现原来按钮背景。</td></tr><tr><td style="text-align:center">4</td><td><code>void setMenu(QMenu *menu)</code> 设置菜单。 这将把按钮变成一个菜单按钮，在某些样式中，它将在按钮文本的右侧产生一个小三角形。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMenu* menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="string">&quot;Menu&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;大家好&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;我是顽石老师&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line"><span class="built_in">connect</span>(menu,&amp;QMenu::triggered,<span class="keyword">this</span>,[=](QAction*act)</span><br><span class="line">&#123;</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(act-&gt;<span class="built_in">text</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/btn_0-16615120033741.gif" alt=""></p><h2 id="font-color-red-工具按钮-ToolButton-font"><font color='red'>工具按钮(ToolButton)</font></h2><p>QToolButton是一个特殊的Button, 提供快速访问特定的命令或选项。与普通命令按钮不同, QToolButton通常不显示文本标签, 而是显示图标。一般用在toolBar上</p><h3 id="信号与槽-3">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><p><code>Inherits:QAbstractButton</code> 继承自父类</p><p><code>void triggered(QAction *action)</code> 按钮绑定的菜单动作被触发</p><p><strong><mark class="hl-label default">slots</mark> </strong></p><p><code>void setDefaultAction(QAction *action)</code>如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</p><p><code>void setToolButtonStyle(Qt::ToolButtonStyle style)</code> 设置工具按钮是否仅显示图标、仅显示文本，还是图标旁边/下面的文本。</p><p><code>void showMenu()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QToolButton*toolbtn = <span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">toolbtn-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">toolbtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//设置标准图标</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::StandardPixmap::SP_FileIcon));<span class="comment">//style是this的函数</span></span><br><span class="line"><span class="comment">//设置文字显示位置</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setToolButtonStyle</span></span><br><span class="line">    (Qt::ToolButtonStyle::ToolButtonTextUnderIcon);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210814134543856-16615120056623.png" alt=""></p><h3 id="常用函数-2">常用函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>int void setArrowType(Qt::ArrowType type) 此属性用于保存按钮是否显示箭头而不是普通图标<br /><img src="/2022/img/image-20210814134847896-16614803937363-16615120374837.png" alt=""></td></tr><tr><td style="text-align:center">2</td><td>void setAutoRaise(bool enable) 去掉边框和背景，鼠标在按钮上面时，显示选中效果，按下时有下沉效果<br /><img src="/2022/img/btn_1-16614803966775-16615120344595.gif" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">3</td><td>void setMenu(QMenu *menu) 设置弹出菜单</td></tr><tr><td style="text-align:center">4</td><td>void setPopupMode(QToolButton::ToolbuttonPopupMode mode) 描述如何将弹出菜单与工具按钮一起使用，默认设置为 <code>DelayedPopup</code> ，延迟弹出。</td></tr></tbody></table><h3 id="弹出菜单">弹出菜单</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMenu*menu = <span class="keyword">new</span> QMenu;</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;C语言&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line">toolbtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line"><span class="comment">//设置弹出模式，DelayedPopup延时弹出 MenuButtonPopup在右侧显示一个箭头  InstantPopup立即弹出</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::DelayedPopup);</span><br><span class="line"><span class="comment">//设置按钮菜单之后，右下角有一个小箭头，去掉箭头</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QToolButton::menu-indicator &#123;image: none;&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="font-color-red-单选按钮-RadioButton-font"><font color='red'>单选按钮(RadioButton)</font></h2><p>QRadioButton部件提供了一个带有文本标签的单选按钮。</p><p>QRadioButton是一个可以切换选中（checked）或未选中（unchecked）状态的选项按钮。单选框通常呈现给用户一个“多选一”的选择。也就是说，在一组单选框中，一次只能选中一个单选框。</p><h3 id="信号与槽-4">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><p><code>Inherits:QAbstractButton</code> 继承自父类</p><p><strong><mark class="hl-label default">slots</mark> </strong></p><p><code>Inherits:QAbstractButton</code> 继承自父类</p><h3 id="常用函数-3">常用函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>void setCheckState(Qt::CheckState state) 将复选框的复选状态设置为state。 如果不需要三状态支持，还可以使用QAbstractButton::setChecked()，它接受布尔值。</td></tr><tr><td style="text-align:center">2</td><td>void setTristate(bool)该属性保存复选框是否是三状态复选框，默认为false，即复选框只有两个状态</td></tr></tbody></table><h3 id="使用方法">使用方法</h3><ul><li>同一组(同一父对象)的单选按钮一次只能选中一个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton*radiobtn = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;男&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QRadioButton*radiobtn1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;女&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//设置默认选中</span></span><br><span class="line">radiobtn-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/btn_2-16615120408389.gif" alt=""></p><ul><li>同一组同时选中多个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QGroupBox* exampleGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;esample&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QLabel*label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;你喜欢以下哪些宠物？&quot;</span>);</span><br><span class="line">exampleGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">QRadioButton *dogbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">QRadioButton *catbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">QRadioButton *snakebtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;蛇&quot;</span>);</span><br><span class="line">QRadioButton *pigbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line"></span><br><span class="line">dogbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">catbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">snakebtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">pigbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">QVBoxLayout* layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(dogbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(catbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(snakebtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(pigbtn);</span><br><span class="line"></span><br><span class="line">exampleGroup-&gt;<span class="built_in">setLayout</span>(layout);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/btn_4-166151204273611.gif" alt=""></p><ul><li>不同组的单选按钮可以同时选中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QGroupBox* sexGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;性别&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QGroupBox* viewpointGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;观点&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">sexGroup-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line">viewpointGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">QRadioButton*radiobtn = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;男&quot;</span>,sexGroup);</span><br><span class="line">QRadioButton*radiobtn1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;女&quot;</span>,sexGroup);</span><br><span class="line"></span><br><span class="line">QRadioButton*radiobtn2 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;好&quot;</span>,viewpointGroup);</span><br><span class="line">QRadioButton*radiobtn3 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;坏&quot;</span>,viewpointGroup);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* sexLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">sexLayout-&gt;<span class="built_in">addWidget</span>(radiobtn);</span><br><span class="line">sexLayout-&gt;<span class="built_in">addWidget</span>(radiobtn1);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* viewpointLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">viewpointLayout-&gt;<span class="built_in">addWidget</span>(radiobtn2);</span><br><span class="line">viewpointLayout-&gt;<span class="built_in">addWidget</span>(radiobtn3);</span><br><span class="line"></span><br><span class="line">sexGroup-&gt;<span class="built_in">setLayout</span>(sexLayout);</span><br><span class="line">viewpointGroup-&gt;<span class="built_in">setLayout</span>(viewpointLayout);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/btn_3-166151204520113.gif" alt=""></p><h2 id="font-color-red-复选框-CheckBox-font"><font color='red'>复选框(CheckBox)</font></h2><p>QCheckBox提供了一个带文本标签的复选框。</p><p>QCheckBox（复选框）和QRadioButton（单选框）都是选项按钮。这是因为它们都可以在开（选中）或者关（未选中）之间切换。区别是对用户选择的限制：单选框定义了“多选一”的选择，而复选框提供的是“多选多”的选择。</p><p>尽管在技术上可以通过复选框来实现单选框的行为，反之亦然，但还是强烈建议使用众所周知的约定。</p><h3 id="信号与槽-5">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><p><code>Inherits:QAbstractButton</code> 继承自父类</p><p><code>void stateChanged(int state)</code> 当复选框的状态发生变化时，即当用户选中或取消选中它时，就会发出这个信号。</p><p><strong><mark class="hl-label default">slots</mark> </strong></p><p><code>Inherits:QAbstractButton</code> 继承自父类</p><h3 id="使用方法-2">使用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QGroupBox* exampleGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="keyword">this</span>);</span><br><span class="line">exampleGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">QLabel*label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;你喜欢以下哪些宠物？&quot;</span>);</span><br><span class="line">QCheckBox *dogbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">QCheckBox *catbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">QCheckBox *snakebtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;蛇&quot;</span>);</span><br><span class="line">QCheckBox *pigbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line"></span><br><span class="line">QVBoxLayout* layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(dogbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(catbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(snakebtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(pigbtn);</span><br><span class="line"></span><br><span class="line">exampleGroup-&gt;<span class="built_in">setLayout</span>(layout);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/btn_5-166151204962915.gif" alt=""></p><h2 id="font-color-red-行编辑器-LineEdit-font"><font color='red'>行编辑器(LineEdit)</font></h2><h3 id="信号与槽-6">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><p><code>Inherits:QAbstractButton 继承自父类</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span><span class="comment">//清除行编辑的内容</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span> <span class="type">const</span><span class="comment">//将选中的文本复制到剪贴板(如果有的话)，并且echoMode()是Normal</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span><span class="comment">//剪切</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paste</span><span class="params">()</span><span class="comment">//粘贴</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">redo</span><span class="params">()</span><span class="comment">//撤销</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectAll</span><span class="params">()</span><span class="comment">//选中所有</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span><span class="comment">//反撤销</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label default">slots</mark> </strong></p><p><code>void showMenu()</code>如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个信号在光标移动时发出。前一个位置由oldPos给出，新位置由newPos给出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cursorPositionChanged</span><span class="params">(<span class="type">int</span> oldPos, <span class="type">int</span> newPos)</span></span></span><br><span class="line"><span class="function"><span class="comment">//编辑完成，按下Return或Enter键或行编辑失去焦点时将发出此信号</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">editingFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//当用户按下一个不被认为是可接受输入的键时，就会发出这个信号。 例如，如果一个按键导致验证器的validate()调用返回Invalid。 另一种情况是试图输入超过行编辑的最大长度的字符。    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputRejected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//编不编辑，当按下Return或Enter键时都发出此信号，失去焦点不会发</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">returnPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//这个信号在选择改变时发出  </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//每当文本发生变化时，就会发出这个信号。与texttedited()不同，调用setText()改变文本，此信号也会发出。  </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">textChanged</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span></span><br><span class="line"><span class="function"><span class="comment">//只要文本被编辑，就会发出这个信号。     </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">textEdited</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span></span><br></pre></td></tr></table></figure><h3 id="占位符">占位符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入用户名&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20220825174629995-166148041458911-166151205294417.png" alt=""></p><h3 id="设置显示模式">设置显示模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::EchoMode::Password);</span><br><span class="line">QLineEdit::Normal<span class="comment">//显示输入的字符，这是默认值。  </span></span><br><span class="line">QLineEdit::NoEcho<span class="comment">//不要显示任何东西</span></span><br><span class="line">QLineEdit::Password<span class="comment">//显示与平台相关的密码掩码字符，而不是实际输入的字符。  </span></span><br><span class="line">QLineEdit::PasswordEchoOnEdit<span class="comment">//在编辑时显示已输入的字符，完成显示掩码字符</span></span><br><span class="line">    </span><br><span class="line">edit-&gt;<span class="built_in">setClearButtonEnabled</span>(<span class="literal">true</span>);<span class="comment">//启用清除按钮</span></span><br></pre></td></tr></table></figure><p><img src="/2022/img/lineedit_1-166151205502519.gif" alt=""></p><h3 id="设置输入掩码">设置输入掩码</h3><table><thead><tr><th>掩码字符</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>ASCII字母字符是必须的，A-Z，a-z</td></tr><tr><td>a</td><td>ASCII 字母字符是允许的但不是必须的</td></tr><tr><td>N</td><td>ASCII字母字符是必须的，A-Z，a-z， 0-9</td></tr><tr><td>n</td><td>ASCII 字母字符是允许的但不是必须的</td></tr><tr><td>X</td><td>任何字符都可以，是必须需要的</td></tr><tr><td>x</td><td>任何字符都允许的，但不是必须需要的</td></tr><tr><td>9</td><td>ASCII 数字是必须要的，0-9</td></tr><tr><td>0</td><td>ASCII 数字是允许的，但不是必须要的</td></tr><tr><td>D</td><td>ASCII  数字是必须要的，1-9</td></tr><tr><td>d</td><td>ASCII 数字是允许的，但不是必须要的</td></tr><tr><td>#</td><td>ASCII 数字是或加减符号允许的，但不是必须要的</td></tr><tr><td>H</td><td>十六进制数据字符是必须要的，A-F, a-f, 0-9</td></tr><tr><td>h</td><td>十六进制数据字符是允许的，但不是必须要的</td></tr><tr><td>B</td><td>二进制数据字符是必须要的，0-1</td></tr><tr><td>b</td><td>二进制数据字符是允许的，但不是必须要的</td></tr><tr><td>&gt;</td><td>所有的字符字母都都大写的</td></tr><tr><td>&lt;</td><td>所有的字符字幕都是小写的</td></tr><tr><td>!</td><td>关闭大小写</td></tr><tr><td>;c</td><td>终止输入掩码并将空白字符设置为c</td></tr><tr><td>\</td><td>使用 <code>\</code> 去转义上面的字符，如果再需要显示上述字符的时候</td></tr></tbody></table><ul><li>输入日期</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setText</span>(QDate::<span class="built_in">currentDate</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">edit-&gt;<span class="built_in">setInputMask</span>(<span class="string">&quot;9999-99-99&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>输入秘钥</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setInputMask</span>(<span class="string">&quot;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="设置验证器">设置验证器</h3><ul><li>只能输入整数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">-90</span>,<span class="number">90</span>,<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><ul><li>只能输入浮点数，但是浮点数验证器不能限制范围，可以随便输入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QDoubleValidator</span>(<span class="number">-90.0</span>,<span class="number">90.0</span>,<span class="number">3</span>,<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><h3 id="添加动作">添加动作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLineEdit::addAction</span><span class="params">(QAction *action, QLineEdit::ActionPosition position)</span></span></span><br><span class="line"><span class="function">QAction *<span class="title">QLineEdit::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, QLineEdit::ActionPosition position)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit *edit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">edit-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;://images/user.png&quot;</span>),QLineEdit::ActionPosition::LeadingPosition);</span><br><span class="line">QAction *delAct = edit-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;://images/delete.png&quot;</span>),QLineEdit::ActionPosition::TrailingPosition);</span><br><span class="line"><span class="built_in">connect</span>(delAct,&amp;QAction::triggered,[]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;delAct&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20210824162943231-166151205922121.png" alt=""></p><h3 id="完整示例">完整示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;w);</span><br><span class="line">   <span class="keyword">auto</span> *editBtn  = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;确认&quot;</span>,&amp;w);</span><br><span class="line">   lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入用户名&quot;</span>);</span><br><span class="line">   QAction *userSlider = lineEdit-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/img/craft.png&quot;</span>)</span><br><span class="line">                                             ,QLineEdit::ActionPosition::TrailingPosition);</span><br><span class="line">   QMenu   *userList   = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="string">&quot;User&quot;</span>,lineEdit);</span><br><span class="line">   userList-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">170</span>);</span><br><span class="line">   w.<span class="built_in">move</span>(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">   <span class="built_in">qDebug</span>()&lt;&lt;w.<span class="built_in">logicalDpiX</span>();</span><br><span class="line">   userList-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;1572676601&quot;</span>);</span><br><span class="line">   userList-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;1899088982&quot;</span>);</span><br><span class="line">   userSlider-&gt;<span class="built_in">setMenu</span>(userList);</span><br><span class="line">   QObject::<span class="built_in">connect</span>(userSlider,userSlider-&gt;triggered,userList,[&amp;w,&amp;userList]()&#123;</span><br><span class="line">       userList-&gt;<span class="built_in">move</span>(w.<span class="built_in">x</span>()+<span class="number">15</span>,w.<span class="built_in">y</span>()+<span class="number">70</span>);<span class="comment">//相对位置</span></span><br><span class="line">       userList-&gt;<span class="built_in">show</span>();</span><br><span class="line">   &#125;);</span><br><span class="line">   QObject::<span class="built_in">connect</span>(userList,userList-&gt;triggered,lineEdit,[&amp;lineEdit](QAction* act)&#123;</span><br><span class="line">       lineEdit-&gt;<span class="built_in">setText</span>(act-&gt;<span class="built_in">text</span>());</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p><img src="/2022/img/image-20220825224754166-166148042240015-166151206158023.png" alt=""></p><h2 id="font-color-red-标签-Label-font"><font color='red'>标签(Label)</font></h2><p>QLabel小部件提供文本或图像显示</p><h3 id="信号与槽-7">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当用户点击链接时会发出此信号。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkActivated</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当用户将鼠标悬停在链接上时会发出此信号。    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkHovered</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label default">slots</mark> </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMovie</span><span class="params">(QMovie *movie)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">double</span> num)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPicture</span><span class="params">(<span class="type">const</span> QPicture &amp;picture)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br></pre></td></tr></table></figure><h3 id="公有函数">公有函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>void setAlignment(<em>Qt::Alignment</em>)设置对齐方式</td></tr><tr><td style="text-align:center">2</td><td>void setBuddy(QWidget *<em>buddy</em>)将此标签的好友设置为buddy。当用户按下此标签指示的快捷键时，键盘焦点将转移到标签的好友小部件。伙伴机制仅适用于包含文本的 QLabel，其中一个字符以与号“&amp;”为前缀。</td></tr><tr><td style="text-align:center">3</td><td>void setIndent(<em>int</em>)设置label的文本缩进，以像素为单位</td></tr><tr><td style="text-align:center">4</td><td>void setMargin(<em>int</em>)设置边距</td></tr><tr><td style="text-align:center">5</td><td>void setOpenExtrenalLinks(<em>bool open</em>)设置是否自动打开超链接</td></tr><tr><td style="text-align:center">6</td><td>void setScaledContents(<em>bool</em>)设置内容缩放，确定标签是否将其内容缩放以填充所有可用空间。</td></tr><tr><td style="text-align:center">7</td><td>void setSelection(<em>int start,int len</em>)设置对齐方式</td></tr><tr><td style="text-align:center">8</td><td>void setTextFormat(<em>Qt::TextFormat</em>)设置标签文本格式</td></tr><tr><td style="text-align:center">9</td><td>void setTextInteractionFlags(<em>Qt::TextInteractionFlags flag</em>)设置对齐方式</td></tr><tr><td style="text-align:center">10</td><td>void setWordWrap(<em>bool on</em>)设置是否在需要时自动换行</td></tr></tbody></table><h3 id="Example">Example:</h3><ul><li>显示文本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;我是萌萌哒的小可爱&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignmentFlag::AlignCenter);</span><br><span class="line">label-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">100</span>);  <span class="comment">//设置固定的宽度</span></span><br><span class="line">label-&gt;<span class="built_in">setWordWrap</span>(<span class="literal">true</span>);   <span class="comment">//当文本超过固定的宽度之后，自动换行</span></span><br></pre></td></tr></table></figure><ul><li>设置超链接：QLabel 支持 html 文本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;a href=\&quot;www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(label,&amp;QLabel::linkHovered,<span class="keyword">this</span>,[=](<span class="type">const</span> QString&amp; link)&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;linkHovered&quot;</span>&lt;&lt;link;&#125;);    </span><br><span class="line"><span class="built_in">connect</span>(label,&amp;QLabel::linkActivated,<span class="keyword">this</span>,[=](<span class="type">const</span> QString&amp; link)&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;linkActivated&quot;</span>&lt;&lt;link;&#125;);</span><br><span class="line"><span class="comment">//设置自动打开超链接，而不是发出信号自己处理，这个设置之后会自动在浏览器打开连接</span></span><br><span class="line">label-&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li>设置伙伴</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QLabel* nameLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Name&quot;</span>,&amp;w);</span><br><span class="line">   QLineEdit * nameEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;w);</span><br><span class="line">   nameLabel-&gt;<span class="built_in">setBuddy</span>(nameEdit);</span><br><span class="line"></span><br><span class="line">   QLabel* phoneLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;电话&quot;</span>,&amp;w);</span><br><span class="line">   QLineEdit* phoneEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;w);</span><br><span class="line">   phoneLabel-&gt;<span class="built_in">setBuddy</span>(phoneEdit);</span><br><span class="line"></span><br><span class="line">   QObject::<span class="built_in">connect</span>(nameEdit,nameEdit-&gt;editingFinished,phoneEdit,[&amp;phoneEdit]()&#123;</span><br><span class="line">       phoneEdit-&gt;<span class="built_in">setFocus</span>();</span><br><span class="line">   &#125;);   <span class="comment">//回车转移焦点</span></span><br><span class="line"></span><br><span class="line">   QGridLayout* layout = <span class="keyword">new</span> QGridLayout; <span class="comment">//设置布局</span></span><br><span class="line">   layout-&gt;<span class="built_in">addWidget</span>(nameLabel,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">   layout-&gt;<span class="built_in">addWidget</span>(nameEdit,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">   layout-&gt;<span class="built_in">addWidget</span>(phoneLabel,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">   layout-&gt;<span class="built_in">addWidget</span>(phoneEdit,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">   w.<span class="built_in">setLayout</span>(layout);                        </span><br></pre></td></tr></table></figure><p><img src="/2022/img/label_1-166151206868525.gif" alt=""></p><ul><li>显示图片</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;://images/label_img.jpg&quot;</span>));</span><br><span class="line"><span class="comment">//如上所示，显示的图片是固定的大小，如何让图片按我们想要的大小显示呢？</span></span><br><span class="line"><span class="comment">//1，设置Label的大小，如果有布局，会随着布局动态变化</span></span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">340</span>,<span class="number">180</span>);</span><br><span class="line"><span class="comment">//2，设置内容缩放</span></span><br><span class="line">label-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li>显示Gif动图</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">QMovie *movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;F:/MyCode/QtCode/QtCourse/DisplayWidgets/images/label_gif.gif&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setMovie</span>(movie);</span><br><span class="line">movie-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure><h2 id="font-color-red-分组框-GroupBox-font"><font color='red'>分组框(GroupBox)</font></h2><h3 id="信号与槽-8">信号与槽</h3><p><strong><mark class="hl-label default">signals</mark> </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toggled</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label default">slots</mark> </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setChecked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br></pre></td></tr></table></figure><h3 id="公有函数-2">公有函数</h3><table><thead><tr><th style="text-align:center">序号</th><th>函数&amp;描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>void setAlignment(<em>Qt::Alignment</em>)设置对齐方式</td></tr><tr><td style="text-align:center">2</td><td>void setCheckAble(bool <em>checkable</em>)该分组框是否可以被选择</td></tr><tr><td style="text-align:center">3</td><td>void setflat(bool <em>flat</em>)分组框通常由顶部有标题的包围框组成。 如果启用此属性，则大多数样式只绘制框架的顶部部分; 否则，将绘制整个框架。</td></tr><tr><td style="text-align:center">4</td><td>void setTitle(const QString&amp; <em>title</em>)设置分组框的标题</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QGroupBox* groupBox = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="keyword">this</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">resize</span>(<span class="number">320</span>,<span class="number">320</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;我是分组框&quot;</span>);</span><br><span class="line"><span class="comment">//groupBox-&gt;setAlignment(Qt::AlignCenter);</span></span><br><span class="line"><span class="comment">//groupBox-&gt;setFlat(true);</span></span><br><span class="line"></span><br><span class="line">groupBox-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(groupBox,&amp;QGroupBox::clicked,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;clicked&quot;</span>;&#125;);</span><br><span class="line"><span class="built_in">connect</span>(groupBox,&amp;QGroupBox::toggled,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;toggled&quot;</span>;&#125;);</span><br><span class="line"></span><br><span class="line">QList&lt;QCheckBox*&gt; checkBoxs;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    checkBoxs.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">QString</span>(<span class="string">&quot;checkBox%1&quot;</span>).<span class="built_in">arg</span>(i),groupBox));</span><br><span class="line">    checkBoxs[i]-&gt;<span class="built_in">move</span>(<span class="number">10</span>,i*<span class="number">40</span>+<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">groupBox-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-Widget控件</title>
      <link href="/2022/08/25/Qt-Widget%E6%8E%A7%E4%BB%B6/"/>
      <url>/2022/08/25/Qt-Widget%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>1. QWidget</h1><blockquote><p>QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject, 也就意味着所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收。这里给大家介绍一下关于这个类常用的一些API函数。</p></blockquote><p><img src="/2022/img/image-20201009170432819.png" alt="image-20201009170432819"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给当前窗口设置父对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent, Qt::WindowFlags f)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的父对象, 没有父对象返回 nullptr</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidget::parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口位置 -------------</span></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内</span></span><br><span class="line"><span class="function">QRect <span class="title">QWidget::frameGeometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">const</span> QRect&amp; <span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">const</span> QRect &amp;)</span></span>;</span><br><span class="line"><span class="comment">//此属性保存小部件的内部几何形状，不包括任何窗口框架,等于QRect(0,0, width()， height()) </span></span><br><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取小控件在父控件中的位置</span></span><br><span class="line"><span class="function">QPoint <span class="title">pos</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 移动窗口, 重新设置窗口的位置</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口尺寸 -------------</span></span><br><span class="line"><span class="comment">// 获取当前窗口的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置窗口的尺寸信息</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">maximumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">minimumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口固定的尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">int</span> maxw, <span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">int</span> minw, <span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的高度    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定的高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedHeight</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumHeight</span><span class="params">(<span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumHeight</span><span class="params">(<span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedWidth</span><span class="params">(<span class="type">int</span> w)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumWidth</span><span class="params">(<span class="type">int</span> maxw)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumWidth</span><span class="params">(<span class="type">int</span> minw)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口图标 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 构造图标对象, 参数为图片的路径</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// 设置当前窗口的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--Slots--*/</span></span><br><span class="line"><span class="comment">//------------- 窗口标题 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的标题</span></span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowModified</span><span class="params">(<span class="type">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断窗口是否可用</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEnabled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEnabled</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口显示 -------------</span></span><br><span class="line"><span class="comment">// 关闭当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 隐藏当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::hide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 显示当前创建以及其子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置窗口是否可见</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 全屏显示当前窗口, 只对windows有效</span></span></span><br><span class="line"><span class="function">[slot] <span class="type">void</span> <span class="title">QWidget::showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最大化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最小化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMinimized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将窗口回复为最大化/最小化之前的状态, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showNormal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 信号 -------------</span></span><br><span class="line"><span class="comment">// QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);</span></span><br><span class="line"><span class="comment">// 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span>;</span><br><span class="line"><span class="comment">// 窗口图标发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowIconChanged</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 窗口标题发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowTitleChanged</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="设置鼠标样式">设置鼠标样式</h2><h3 id="Qcursor">Qcursor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取鼠标的全局坐标</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QPoint <span class="title">pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] QPoint <span class="title">pos</span><span class="params">(<span class="type">const</span> QScreen *screen)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将鼠标移动到全局的指定坐标    </span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] <span class="type">void</span> <span class="title">setPos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] <span class="type">void</span> <span class="title">setPos</span><span class="params">(QScreen *screen, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] <span class="type">void</span> <span class="title">setPos</span><span class="params">(<span class="type">const</span> QPoint &amp;p)</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] <span class="type">void</span> <span class="title">setPos</span><span class="params">(QScreen *screen, <span class="type">const</span> QPoint &amp;p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//QScreen在多屏幕的时候可用    </span></span></span><br></pre></td></tr></table></figure><p><a href="https://www.iconfont.cn/">iconfont图标下载网站</a></p><ul><li>以下代码可以通过点击按钮切换并查看所有鼠标的(内置)形状</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;切换鼠标形状&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCursor</span>(Qt::<span class="built_in">CursorShape</span>(i));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;切换成功&quot;</span>&lt;&lt;Qt::<span class="built_in">CursorShape</span>(i);</span><br><span class="line">    i = (i+<span class="number">1</span>)%<span class="number">25</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>除了内置形状之外，还可以自定义鼠标形状</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPixmap* cursorPixmaps[<span class="number">2</span>]=&#123;<span class="keyword">new</span> <span class="built_in">QPixmap</span>(<span class="string">&quot;://images/cursor_one.png&quot;</span>),</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">QPixmap</span>(<span class="string">&quot;://images/cursor_two.png&quot;</span>)&#125;;</span><br><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;切换鼠标样式&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setCursor</span>(<span class="built_in">QCursor</span>(*cursorPixmaps[i]));</span><br><span class="line">    i = (i+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="setWhatsThis">setWhatsThis</h2><p>setToolTip用来设置提示信息，那么setWhatsThis是用来干嘛的呢？顾名思义就是用来说明这是啥玩意的</p><ul><li><p>先创建三个按钮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPushButton*btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;open&quot;</span>,<span class="keyword">this</span>);  </span><br><span class="line">QPushButton*btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;new&quot;</span>,<span class="keyword">this</span>);   </span><br><span class="line">QPushButton*btn3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;look&quot;</span>,<span class="keyword">this</span>);  </span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);                                </span><br><span class="line">btn3-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">0</span>);                                </span><br><span class="line">                                                  </span><br><span class="line">btn1-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;打开文件&quot;</span>);                         </span><br><span class="line">btn1-&gt;<span class="built_in">setWhatsThis</span>(<span class="string">&quot;open a new file&quot;</span>);            </span><br><span class="line">                                                  </span><br><span class="line">btn2-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;新建文件&quot;</span>);                         </span><br><span class="line">btn2-&gt;<span class="built_in">setWhatsThis</span>(<span class="string">&quot;create a new file&quot;</span>);          </span><br><span class="line">                                                  </span><br><span class="line">btn3-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;查看&quot;</span>);                           </span><br><span class="line">btn3-&gt;<span class="built_in">setWhatsThis</span>(<span class="string">&quot;查看其他按钮的详细信息&quot;</span>);                </span><br><span class="line">                                                  </span><br><span class="line"><span class="built_in">connect</span>(btn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()     </span><br><span class="line">&#123;                                                 </span><br><span class="line">    QWhatsThis::<span class="built_in">enterWhatsThisMode</span>();                </span><br><span class="line">&#125;);                                               </span><br></pre></td></tr></table></figure></li><li><p>运行程序后按Shift + F1会出现当前获得焦点的widget的whatsThis信息</p></li><li><p>调用QWhatsThis的静态函数enterWhatsThisMode进入whatsThis模式，此时当鼠标移动到设置了whatsThis的widget上光标会出现一个问号，再点击则会出现whatsThis的窗口。</p></li></ul><h2 id="设置窗口图标">设置窗口图标</h2><ul><li>修改窗口和任务栏显示的图标</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;://images/snowBall.png&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="设置应用程序图标">设置应用程序图标</h2><p>简单三步，搞定~</p><ul><li><p>1，创建一个图标格式(ico)的文件，<code>可以将一个普通的图片转成.ico格式的图标文件</code></p><p><a href="https://convertio.co/zh/">图片格式在线转换</a></p></li><li><p>2，将转换好的ico文件放到源文件所在目录，即和.pro文件同级目录</p></li><li><p>3，在.pro项目文件中添加如下代码<code>zay.ico 即图标名</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC_ICONS += zay.ico</span><br></pre></td></tr></table></figure><h2 id="QWidget槽函数">QWidget槽函数</h2><p><strong>show,hide,setVisible,setHidden,close 小结</strong></p><ul><li><p>0，在Qt中如果一定要自己释放对象，官方推荐使用<code>[slot] void QObject::deleteLater()</code>来释放对象</p></li><li><p>1，<code>[slot] void setVisible(bool visible)</code> 设置Widget可见或不可见</p></li><li><p>2，<code>slot] void QWidget::setHidden(bool *hidden*)</code> 1号的马甲</p></li><li><p>3，<code>[slot] void QWidget::show()</code> 1号的马甲</p></li><li><p>4，<code>[slot] void QWidget::hide()</code>  1号的马甲</p></li><li><p>5，<code>[slot] bool QWidget::close()</code> <strong>看情况调用4号或者0号(该部件是否有父部件)</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">呵呵，<span class="built_in">show</span>()、<span class="built_in">hide</span>()、<span class="built_in">setVisible</span>()、<span class="built_in">setHidden</span>() 这<span class="number">4</span>个函数让人看得眼花缭乱。怎么办？</span><br><span class="line">看看代码吧：</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setHidden</span><span class="params">(<span class="type">bool</span> hidden)</span> </span>&#123; <span class="built_in">setVisible</span>(!hidden); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">setVisible</span>(<span class="literal">true</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123; <span class="built_in">setVisible</span>(<span class="literal">false</span>); &#125;</span><br></pre></td></tr></table></figure><p>代码很清楚：这四个东西之中，只有 setVisible 是独立的，其他三个都是它的马甲！<br>setVisible 的作用是什么呢？顾名思义，使得一个Widget可见或不可见。<br><strong>要点</strong>：<font color='orange'>不可见，是Widget不在界面上显示，但不代表对象被析构！</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1]创建关闭自己的按钮</span></span><br><span class="line">QPushButton* closeBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;closeSelf&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(closeBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::close);</span><br><span class="line"><span class="comment">//点击右上角关闭按钮会销毁窗口</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QObject::destroyed,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;this destroyed&quot;</span>;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[2]创建子窗口</span></span><br><span class="line">QWidget* subWidget = <span class="keyword">new</span> QWidget;</span><br><span class="line">subWidget-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;subWidget&quot;</span>);</span><br><span class="line">subWidget-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//subWidget-&gt;setAttribute(Qt::WidgetAttribute::WA_DeleteOnClose);   //点击关闭按钮时销毁窗口        </span></span><br><span class="line"><span class="built_in">connect</span>(subWidget,&amp;QWidget::destroyed,<span class="keyword">this</span>,[=]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;subWidget destroyed&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//[3]创建关闭子窗口的按钮</span></span><br><span class="line">QPushButton*closeSubWidgetBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;closeSubWidget&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">closeSubWidgetBtn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(closeSubWidgetBtn,&amp;QPushButton::clicked,subWidget,[=]()&#123;</span><br><span class="line">    subWidget-&gt;<span class="built_in">close</span>();</span><br><span class="line">    subWidget-&gt;<span class="built_in">deleteLater</span>();   <span class="comment">//推荐这样销毁对象</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;subWidget;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//[4]创建显示子窗口的按钮</span></span><br><span class="line">QPushButton*showSubWidgetBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;showSubWidget&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">showSubWidgetBtn-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(showSubWidgetBtn,&amp;QPushButton::clicked,subWidget,&amp;QWidget::show);             </span><br></pre></td></tr></table></figure><h2 id="坐标转换">坐标转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">mapFrom</span><span class="params">(<span class="type">const</span> QWidget *parent, <span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromParent</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapTo</span><span class="params">(<span class="type">const</span> QWidget *parent, <span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapToGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapToParent</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><ul><li><p>这几个函数都是转换相对坐标系用的. <strong>用另一个坐标系统的坐标值, 来表达当前坐标系统中某个坐标所指向的某个点,</strong></p><p>记住: 一定要先确<strong>两个坐标系统</strong>再确定<strong>一个点</strong></p></li><li><p><strong>相对坐标</strong>：获取自己相对于父控件的位置 QWidget::pos()</p></li><li><p><strong>绝对坐标</strong>：将当前控件的相对位置转换为屏幕绝对位置 QWidget::mapToGlobal()</p></li><li><p><strong>绝对坐标转为相对坐标</strong>：将绝对位置对应到控件的相对位置 QWidget::mapFromGlobal()</p></li></ul><h2 id="设置窗口标志">设置窗口标志</h2><ul><li>用Qt写一个窗口，如果继承QDialog，那窗口就只有关闭按钮，如果继承QWidget，那么就有关闭，最大化，最小化三个按钮，怎样才能让关闭按钮可用，而最大化和最小化按钮不可用呢？</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅仅显示关闭按钮，添加一个帮助按钮?</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::WindowType::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint);</span><br><span class="line"><span class="comment">//从窗口标志中移除帮助按钮标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() &amp; ~Qt::WindowContextHelpButtonHint);</span><br><span class="line"><span class="comment">//移除标志或单纯添加一个标志，可以用一下简单的函数true为设置，false为移除</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlag</span>(Qt::WindowContextHelpButtonHint,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>更多标志详见<a href="#%E9%99%84%E5%BD%95%E4%B8%80">附录一 </a></li></ul><h2 id="设置窗口状态">设置窗口状态</h2><ul><li>将窗口状态设置为windowState。 窗口状态是<a href="#%E9%99%84%E5%BD%95%E4%BA%8C">附录二</a>中状态的组合。</li><li>如果窗口不可见(即isVisible()返回false)，窗口状态将在调用show()时生效。 对于可见窗口，更改是立即的。 例如，要在全屏模式和普通模式之间切换，请使用以下代码:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w-&gt;<span class="built_in">setWindowState</span>(w-&gt;<span class="built_in">windowState</span>() ^ Qt::WindowFullScreen);</span><br></pre></td></tr></table></figure><ul><li>为了恢复和激活最小化的窗口(同时保持其最大化和/或全屏状态)，使用以下方法:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w-&gt;<span class="built_in">setWindowState</span>((w-&gt;<span class="built_in">windowState</span>() &amp; ~Qt::WindowMinimized) | Qt::WindowActive);</span><br></pre></td></tr></table></figure><ul><li>调用这个函数将隐藏小部件。 必须调用show()使小部件再次可见，在某些窗口系统中，Qt::WindowActive不是立即的，在某些情况下可能会被忽略。</li></ul><h2 id="设置属性">设置属性</h2><ul><li>setAttribute用来设置小部件的属性，testAttribute查看是否设置了某种属性。</li></ul><p><strong>常用属性</strong></p><table><thead><tr><th>枚举</th><th>值(十进制)</th><th>描述</th></tr></thead><tbody><tr><td>Qt::WA_AcceptDrops</td><td>78</td><td>允许来自拖放操作的数据被拖放到小部件上(参见QWidget::setAcceptDrops())</td></tr><tr><td>Qt::WA_AlwaysShowToolTips</td><td>84</td><td>为非活动窗口启用工具提示</td></tr><tr><td>Qt::WA_CustomWhatsThis</td><td>47</td><td>表示小部件希望在“这是什么?”模式下继续正常运行。 这是由小部件的作者设置的。</td></tr><tr><td>Qt::WA_DeleteOnClose</td><td>55</td><td>使Qt在小部件接受关闭事件时删除该小部件</td></tr><tr><td>Qt::WA_MouseTracking</td><td>2</td><td>指示小部件启用了鼠标跟踪。 参见QWidget:: mouseTracking</td></tr><tr><td>Qt::WA_TranslucentBackground</td><td>120</td><td>指示小部件应该有一个半透明的背景，也就是说，小部件的任何非透明区域都将是半透明的，因为小部件将有一个alpha通道。 设置此标志将导致设置WA_NoSystemBackground。 在Windows上，小部件还需要设置Qt:: framesswindowhint窗口标志。 该标志由小部件的作者设置或清除。</td></tr></tbody></table><h2 id="发布程序">发布程序</h2><p>Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll，如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe(这个文件在Qt安装目录的bin文件下可以找到)</p><p>不同的编译器和版本需要使用不同的windeployqt版本打包</p><p>以官方 Qt 5.14.2+MinGW32 开发环境为例：</p><ul><li>1，通过Qt命令行运行windeployqt工具，开始菜单-&gt;Qt 5.14.2-&gt;5.4-&gt;MinGW 4.9 (32-bit)-&gt;Qt 5.14.2 (MinGW 7.3.0 32-bit)</li><li>把需要打包的Qt可执行程序拷贝到一个单独的文件夹里面，然后再把命令行工作目录切换到该文件夹</li><li>最后执行命令<code>windeployqt maye.exe</code></li></ul><h1>2. 资源文件 .qrc</h1><blockquote><p>需要我们给窗口设置图标</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图标对象</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName)</span><br><span class="line"><span class="comment">// QWidget类的 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 给窗口设置图标</span></span></span><br><span class="line"><span class="function"><span class="comment">// 弊端: 发布的exe 必须要加载 d:\\pic\\1.ico 如果对应的目录中么有图片, 图标就无法被加载</span></span></span><br><span class="line"><span class="function"><span class="comment">//发布exe 需要额外发布图片, 将其部署到某个目录中</span></span></span><br><span class="line"><span class="function"><span class="title">setWindowIcon</span><span class="params">(QIcon(<span class="string">&quot;d:\\pic\\1.ico&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>使用资源文件解决上述的弊端:</p><blockquote><p>优势:</p><ol><li>将图片资源放到资源文件</li><li>当程序编译的时候, 资源文件中的图片会被转换为二进制, 打包到exe中</li><li>直接发布exe就可以, 不需要额外提供图片资源了</li></ol></blockquote><p>资源文件的创建</p><p><img src="/2022/img/image-20200412103034187-1601290192153.png" alt="image-20200412103034187"></p><p><img src="/2022/img/image-20200412103106280-1601290192156.png" alt="image-20200412103106280"></p><p><img src="/2022/img/image-20200412103135989-1601290192157.png" alt="image-20200412103135989"></p><p><img src="/2022/img/image-20200412103213774-1601290192157.png" alt="image-20200412103213774"></p><ul><li><p>资源文件的使用</p><ul><li>打开资源文件</li></ul><p><img src="/2022/img/image-20200412103300715-1601290192157.png" alt="image-20200412103300715"></p><ul><li>添加前缀</li></ul><p><img src="/2022/img/image-20200412103405364-1601290192158.png" alt="image-20200412103405364"></p><ul><li><p>添加文件</p><p><img src="/2022/img/image-20200412103458462-1601290192158.png" alt="image-20200412103458462"></p><ul><li><p>弹出以文件选择对话框, 选择资源文件</p><ul><li>资源文件放到什么地方?<ul><li>放到和 项目文件  .pro 同一级目录或者更深的目录中</li><li><code>错误的做法: 将资源文件放到 .pro文件的上级目录, 这样资源文件无法被加载到</code></li></ul></li></ul></li><li><p>资源文件中添加的图片资源</p><p><img src="/2022/img/image-20200412104000877-1601290192158.png" alt="image-20200412104000877"></p></li></ul></li><li><p>如何在程序中使用资源文件中的图片</p><p><img src="/2022/img/image-20200412104156739-1601290192158.png" alt="image-20200412104156739"></p></li></ul></li></ul><h1>附录一</h1><ul><li>此枚举类型用于为小部件指定各种窗口系统属性。 它们相当不寻常，但在少数情况下是必要的。 其中一些标志取决于底层窗口管理器是否支持它们。</li></ul><table><thead><tr><th>枚举</th><th>值(十六进制)</th><th>描述</th></tr></thead><tbody><tr><td>Qt::Widget</td><td>0x00000000</td><td>这是QWidget的默认类型。 这种类型的小部件如果有父部件，则为子部件，如果没有父部件，则为独立窗口。</td></tr><tr><td>Qt::Window</td><td>0x00000001</td><td>指示小部件是一个窗口，通常带有窗口系统框架和标题栏，而不管小部件是否有父窗口。</td></tr><tr><td>Qt::Dialog</td><td>0x00000002| Window</td><td>指示小部件是一个窗口，应该装饰为一个对话框(即，通常在标题栏中没有最大化或最小化按钮)。</td></tr><tr><td>Qt::Sheet</td><td>0x00000004| Window</td><td>指示窗口是macOS上的工作表。 由于使用工作表意味着窗口模式，推荐的方法是使用QWidget::setWindowModality()，或QDialog::open()</td></tr><tr><td>Qt::Drawer</td><td>Sheet | Dialog</td><td>指示小部件是macOS上的一个抽屉</td></tr><tr><td>Qt::Popup</td><td>0x00000008| Window</td><td>指示小部件是弹出式顶级窗口，即它是模态窗口，但具有适合于弹出式菜单的窗口系统框架。</td></tr><tr><td>Qt::Tool</td><td>Popup | Dialog</td><td>指示小部件是工具窗口。 工具窗口通常是一个小窗口，比通常的标题栏和装饰更小，通常用于工具按钮集合</td></tr><tr><td>Qt::ToolTip</td><td>Popup | Sheet</td><td>指示小部件是一个工具提示。 这在内部用于实现工具提示</td></tr><tr><td>Qt::SplashScreen</td><td>ToolTip | Dialog</td><td>表示该窗口为启动画面。 这是QSplashScreen的默认类型</td></tr><tr><td>Qt::Desktop</td><td>0x00000010| Window</td><td>指示此小部件是桌面。 这是QDesktopWidget(此类已经过时)的类型</td></tr><tr><td>Qt::SubWindow</td><td>0x00000012</td><td>指示此小部件是子窗口，例如QMdiSubWindow小部件</td></tr><tr><td>Qt::ForeignWindow</td><td>0x00000020| Window</td><td>表示此窗口对象是一个句柄，表示由另一个进程或手动使用本机代码创建的本机平台窗口。</td></tr><tr><td>Qt::CoverWindow</td><td>0x00000040| Window</td><td>指示该窗口表示覆盖窗口，该窗口在某些平台上最小化应用程序时显示。</td></tr></tbody></table><ul><li>窗口提示可以有多个(不一定会生效，看平台是否支持)</li></ul><table><thead><tr><th>枚举</th><th>值(十六进制)</th><th>描述</th></tr></thead><tbody><tr><td>Qt::FramelessWindowHint</td><td>0x00000800</td><td>产生一个无边框的窗口。 用户不能通过窗口系统移动或调整无边框窗口的大小</td></tr><tr><td>Qt::NoDropShadowWindowHint</td><td>0x40000000</td><td>去掉窗口阴影</td></tr><tr><td>Qt::CustomizeWindowHint</td><td>0x02000000</td><td>关闭默认的窗口标题提示</td></tr><tr><td>Qt::WindowTitleHint</td><td>0x00001000</td><td>给窗口一个标题栏</td></tr><tr><td>Qt::WindowSystemMenuHint</td><td>0x00002000</td><td>添加一个窗口系统菜单，可能还有一个关闭按钮(例如在Mac上)。 如果你需要隐藏或显示关闭按钮，使用WindowCloseButtonHint更便于移植。</td></tr><tr><td>Qt::WindowMinimizeButtonHint</td><td>0x00004000</td><td>添加一个最小化按钮</td></tr><tr><td>Qt::WindowMaximizeButtonHint</td><td>0x00008000</td><td>添加一个最大化按钮</td></tr><tr><td>Qt::WindowMinMaxButtonsHint</td><td>WindowMinimizeButtonHint |WindowMaximizeButtonHint</td><td>添加最小化和最大化按钮</td></tr><tr><td>Qt::WindowCloseButtonHint</td><td>0x08000000</td><td>添加一个关闭按钮</td></tr><tr><td>Qt::WindowContextHelpButtonHint</td><td>0x00010000</td><td>向对话框添加上下文帮助按钮</td></tr><tr><td>Qt::WindowStaysOnTopHint</td><td>0x00040000</td><td>通知窗口系统该窗口应该位于所有其他窗口的顶部</td></tr><tr><td>Qt::WindowStaysOnBottomHint</td><td>0x04000000</td><td>通知窗口系统该窗口应位于所有其他窗口的底部</td></tr></tbody></table><h1>附录二</h1><ul><li>窗口状态 <code>Qt::WindowState</code></li></ul><table><thead><tr><th>枚举</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Qt::WindowNoState</td><td>0x00000000</td><td>窗口没有状态设置(正常状态)</td></tr><tr><td>Qt::WindowMinimized</td><td>0x00000001</td><td>窗口被最小化(即图标化)</td></tr><tr><td>Qt::WindowMaximized</td><td>0x00000002</td><td>窗户周围有一个框架，使其最大化</td></tr><tr><td>Qt::WindowFullScreen</td><td>0x00000004</td><td>窗口填充了整个屏幕，周围没有任何边框</td></tr><tr><td>Qt::WindowActive</td><td>0x00000008</td><td>该窗口是活动窗口，即它有键盘焦点</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-内存回收</title>
      <link href="/2022/08/23/Qt-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/08/23/Qt-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介">简介</h3><p>Qt内存管理机制：Qt 在内部能够维护对象的层次结构。对于可视元素，这种层次结构就是子组件与父组件的关系；对于非可视元素，则是一个对象与另一个对象的从属关系。在 Qt 中，在 Qt 中，删除父对象会将其子对象一起删除。<br>C++中delete 和 new 必须配对使用(一 一对应)：delete 少了，则内存泄露，多了麻烦更大。Qt中使用了 new 却很少 delete，因为 QObject 的类及其继承的类，设置了 parent（也可在构造时使用 setParent 成员函数或 parent 的 addChild）故 parent 被 delete 时，这个 parent 的相关所有 child 都会自动 delete，不用用户手动处理。但 parent 是不区分它的 child 是 new 出来的还是在栈上分配的。这体现 delete 的强大，可以释放掉任何的对象，而 delete 栈上对象就会导致内存出错，这需要了解 Qt 的半自动的内存管理。另一个问题：child 不知道它自己是否被 delete 掉了，故可能会出现野指针。那就要了解Qt的智能指针 <strong>QPointer</strong> 。</p><h3 id="内存管理">内存管理</h3><ol><li>QObject 及其派生类的对象，如果其 parent 非 nullptr，那么其 parent 析构时也会析构该对象。<strong>这里的 parent 是指父对象</strong> 。</li><li>父子关系：父对象、子对象。<font color='orange'>这是Qt中所特有的，与类的继承关系无关</font> 。</li></ol><ul><li><strong><font color=#3b8dfe>父类和子类：派生关系上</font></strong></li><li><strong><font color=#3b8dfe>父对象与子对象：组件层面上</font></strong></li></ul><p>从源码也可看出这一差别：</p><img src="/2022/img/image-20220823174132743.png?lastModify=1661254809" alt="QPushButton部分源码" style="zoom: 50%;" /><p><code>QPushButton</code> 继承自(派生于) <code>QAbstractButton</code> ，而 <code>QPushButton</code> 的构造函数中参数 parent 的类型却为 <code>QWidget</code> 。同时，也必须用 parent 去初始化父类。</p><img src="/2022/img/image-20220823185936204.png?lastModify=1661254809" alt="代码" style="zoom:67%;" /><h3 id="内存问题例子">内存问题例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent)</span><br><span class="line">&#123;</span><br><span class="line">    QLabel *label = new QLabel(&quot;Hello Qt!&quot;);</span><br><span class="line">    label-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong> label 既没有指定 parent，也没有对其调用 delete，所以会造成内存泄漏。</p><p><strong>改进方式：</strong></p><ul><li>分配对象到栈上而不是堆上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent)</span><br><span class="line">&#123;</span><br><span class="line">    QLabel label(&quot;Hello Qt!&quot;);</span><br><span class="line">    label.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​分析：<strong>构造函数执行完毕，对象生命周期结束会被自动析构，窗口上的控件消失不见，故不可采用此方式</strong></p><ul><li>使用指定父对象的方式自动管理内存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyPushButton:public QPushButton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using QPushButton::QPushButton;</span><br><span class="line"></span><br><span class="line">    ~MyPushButton()</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;MyPushButton 析构~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent)</span><br><span class="line">&#123;</span><br><span class="line">    QPushButton* btn2 = new MyPushButton(&quot;第二个按钮&quot;,this);</span><br><span class="line">    btn2-&gt;move(100,0);</span><br><span class="line">&#125;</span><br><span class="line">//运行之后关掉窗口，应用程序输出显示：MyPushButton 析构~</span><br></pre></td></tr></table></figure><p>​<strong>自动内存管理便是 Qt 实际所采用的方式</strong></p><h3 id="自动内存回收模型">自动内存回收模型</h3><p>在 Qt 中，最基础和核心的类是：QObject，QObject 内部有一个 list，会保存 children，还有一个指针保存 parent，当自己析构时，会自己从 parent 列表中删除并且析构所有的 children。</p><p><img src="/2022/img/image-20220823174533047.png?lastModify=1661254809" alt="示意图"></p><h3 id="deleteLater-与-delete">deleteLater 与 delete</h3><p>deleteLater() 是QT的产物， 而 C++ 标准是没有的；delete 是C++与QT公用的，所以很多人，是不太相信 deleteLater() 的。</p><p>QT源码说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void QObject::deleteLater()</span><br><span class="line">&#123;</span><br><span class="line">    QCoreApplication::postEvent(this, new QDeferredDeleteEvent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool QObject::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    switch (e-&gt;type()) &#123;</span><br><span class="line">    ......</span><br><span class="line">    case QEvent::DeferredDelete:</span><br><span class="line">        qDeleteInEventHandler(this);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qDeleteInEventHandler(QObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    delete o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看到，返回到事件循环后，调用 deleteLater() 的对象才会被销毁，否则不执行。</p><p>如果线程中没有运行着的事件循环，线程中的对象调用了 deleteLater()，当线程结束后对象才被销毁。当第一次 QDeferredDeleteEvent 传递给事件循环后，对象的任何待处理事件 (pending events) 都从事件队列中移除。</p><p>Qt中不建议手动 delete 掉 QObject 对象。<br>原因一：不注意父子关系会导致某个对象析构两次，一次是手动析构，还有一次是 parent 析构，后者可能会出现 delete堆上的对象。<br>原因二：删除一个 pending events 等待传递的 QObject 会导致崩溃，所以不能直接跨线程删除对象，而 QObject 析构函数会断开所有信号和槽，因此<br>deleteLater 代替比较好，它会让所有事件都发送完一切处理好后马上清除这片内存，而且就算调用多次的 deletelater 也是安全的</p><p>很多人应该用过 QPointer.吧， deleteLater() 跟它类似，就是在删除一个对像时，依赖它的子对象，子对象的子对象都会关联地删除。当我们使用父对象来创建一个对象的时候 ，父对象会把这个对象添加到自己的子对象列表中。当这个父对象被删除的时候，它会遍历它的子对象类表并且删除每一个子对象，然后子对象们自己再删除它们自己的子对象，这样递归调用直到所有对象都被删除。 这种父子对象机制会在很大程度上简化我们的内存管理工作，减少内存泄露的风险。 所以，在 Qt 中，你可以大胆地 new 对象，而不去释放(前提是指定了父对象) 。</p><blockquote><p>文章参考：[deleteLater](<a href="https://blog.csdn.net/qq84395064/article/details/120970299">Qt deleteLater()和delete 区别_奶爸程序员的博客-CSDN博客_deletelater和delete</a>)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-信号与槽机制</title>
      <link href="/2022/08/23/Qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/08/23/Qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式(发布-订阅模式)。当某个<code>事件</code>发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p></blockquote><h2 id="1-1-信号的本质">1.1 信号的本质</h2><p>信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。</p><p>因此根据上述的描述我们得到一个结论：信号的本质就是事件，比如：</p><ul><li><p>按钮单击、双击</p></li><li><p>窗口刷新</p></li><li><p>鼠标移动、鼠标按下、鼠标释放</p></li><li><p>键盘输入</p></li></ul><p>那么在Qt中信号是通过什么形式呈现给使用者的呢？</p><ul><li>我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。</li><li>对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号。</li><li>信号的呈现形式就是函数， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。</li></ul><p><code>在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。</code></p><h2 id="1-2-槽的本质">1.2 槽的本质</h2><p>槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private或 protected），可以具有任何参数，可以被重载，也可以被直接调用(但是不能有默认参数)。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><p>举个简单的例子：</p><p>女朋友说：“我肚子饿了！”，于是我带她去吃饭。</p><p>上边例子中相当于女朋友发出了一个信号， 我收到了信号并其将其处理掉了。</p><ul><li>女朋友 -&gt; 发送信号的对象, 信号内容: 我饿了</li><li>我 -&gt; 接收信号的对象并且处理掉了这个信号, 处理动作: 带她去吃饭</li></ul><p><code>在Qt中槽函数的所有者也是某个类的实例对象。</code></p><p>写信：发件人    信的内容      收件人  收到信做事情</p><h2 id="1-3-信号和槽的关系">1.3 信号和槽的关系</h2><p>在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起，好比牛郎和织女想要相会必须要有喜鹊为他们搭桥一样。</p><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection  <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数:</strong><ul><li><strong>sender</strong>: 发出信号的对象</li><li><strong>signal</strong>: sender对象的信号，信号是一个函数</li><li><strong>receiver</strong>: 信号接收者</li><li><strong>method</strong>: receiver对象的槽函数, 当检测到sender发出了signal信号, receiver对象调用method方法</li></ul></li></ul><p><code> connect函数相对于做了信号处理动作的注册,调用conenct连接信号与槽时，sender对象的信号并没有产生, 因此receiver对象的method也不会被调用,method槽函数本质是一个回调函数, 调用的时机是信号产生之后。 调用槽函数是Qt框架来执行的,connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功</code>。</p><h1>2. 标准信号槽使用</h1><h2 id="2-1-标准信号-槽">2.1 标准信号/槽</h2><p>在Qt提供的很多类中都可以对用户触发的某些特定事件进行检测,  当事件被触发后就会产生对应的信号, 这些信号都是Qt类内部自带的, 因此称之为标准信号。</p><p>同样的，在Qt的很多类内部为我了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。</p><p>系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在<code>Contents</code>中寻找关键字 <code>signals</code>，信号的意思，但是我们发现并没有找到，这时候我们应该看当前类从父类继承下来了哪些信号，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个</p><h2 id="2-2-使用">2.2 使用</h2><blockquote><p>功能实现： 点击窗口上的按钮, 关闭窗口</p><ul><li>按钮: 信号发出者 -&gt; <code>QPushButton</code></li><li>窗口: 信号的接收者和处理者 -&gt; <code>QWidget</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单击按钮发出的信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭窗口的槽函数</span></span></span><br><span class="line"><span class="function">[slot] <span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单击按钮关闭窗口</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;closewindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure><h1>3. 自定义信号槽使用</h1><blockquote><p>Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。</p></blockquote><p>如果想要使用自定义的信号和槽, 首先要编写新的类并且让其继承Qt的某些标准类,我们自己编写的类想要在Qt中使用使用信号槽机制, 那么必须要满足的如下条件:</p><ul><li><strong>这个类必须从 <mark class="hl-label default">QObject</mark> 类或者是其子类进行派生</strong></li><li><strong>在定义类的第一行头文件中加入 <code>Q_OBJECT</code> 宏</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-自定义信号">3.1 自定义信号</h2><ul><li><p><strong>信号是类的成员函数</strong></p></li><li><p><strong>返回值必须是 void 类型</strong></p></li><li><p>参数可以随意指定, 信号也支持重载</p></li><li><p>信号需要使用 signals 关键字进行声明, 使用方法类似于 public 等关键字</p></li><li><p><strong>信号函数只需要声明, 无法定义(没有函数体实现)</strong></p></li><li><p>在程序中发送自定义信号: 发送信号的本质就是调用信号函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">emit <span class="title">mysignals</span><span class="params">()</span></span>;<span class="comment">//发送信号</span></span><br></pre></td></tr></table></figure><p><span style="color:red;font-size:13px;">emit是一个空宏，没有特殊含义，仅用来表示这个语句是发射一个信号，不写当然可以，但是不推荐。</span></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例: 信号重载</span></span><br><span class="line"><span class="comment">// Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//qRegisterMetaType</span></span><br></pre></td></tr></table></figure><p>信号参数的作用是数据传递, 谁调用信号函数谁就指定实参，实参最终会被传递给槽函数</p><h2 id="3-2-自定义槽">3.2 自定义槽</h2><blockquote><p>槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的。</p></blockquote><p><strong>特点：</strong></p><ul><li><p><strong><font color='orange'>返回值是 void 类型</font></strong></p></li><li><p><strong><font color='orange'>不能有默认参数</font></strong></p></li><li><p>槽函数也支持重载</p><ul><li>槽函数参数个数, 需要看连接的信号的参数个数</li><li><strong><font color=#3b8dfe>槽函数的参数是用来接收信号发送的数据的, 信号的参数就是需要发送的数据</font></strong></li><li>举例:<ul><li>信号函数:  void testsig(int a, double b);</li><li>槽函数:   void testslot(int a, double b);</li></ul></li><li>总结:<ul><li><strong>槽函数的参数应该和对应的信号的参数个数, 类型一一对应</strong></li><li><strong>信号的参数可以大于等于槽函数的参数个数，未被槽函数接受的数据会被忽略，但信号的参数不可少于槽函数的参数</strong><ul><li>信号函数: void testsig(int a, double b);</li><li>槽函数:   void testslot(int a);</li></ul></li></ul></li></ul></li></ul><p><strong>槽函数的类型:</strong></p><ul><li>成员函数<ul><li>普通成员函数</li><li>静态成员函数</li></ul></li><li>全局函数</li><li><strong>lambda表达式(匿名函数)</strong></li></ul><ol start="4"><li>槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写)<ul><li><strong>public slots:</strong></li><li><strong>private slots:</strong></li><li><strong>protected slots:</strong></li></ul></li></ol><p>场景举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 女朋友饿了, 我请她吃饭</span></span><br><span class="line"><span class="comment">// class GirlFriend</span></span><br><span class="line"><span class="comment">// class OneSelf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GirlFriend</span>(QObject*parent = <span class="literal">nullptr</span>):<span class="built_in">QObject</span>(parent)&#123;&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneSelf</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OneSelf</span>(QObject*parent = <span class="literal">nullptr</span>):<span class="built_in">QObject</span>(parent)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goEat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;goEat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">goEatFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;goEatFood&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onHungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;宝贝饿了呀，多喝热水哟~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onBtnClicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GirlFriend *girl;</span><br><span class="line">    OneSelf* self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>widget.cpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    girl = <span class="keyword">new</span> <span class="built_in">GirlFriend</span>(<span class="keyword">this</span>);</span><br><span class="line">    self = <span class="keyword">new</span> <span class="built_in">OneSelf</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//连接槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::onHungry);</span><br><span class="line"><span class="comment">//连接普通成员函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEat);</span><br><span class="line"><span class="comment">//连接静态成员函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEatFood);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按下就饿了&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//通过widget间接发送girl的hungry信号    </span></span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::onBtnClicked);</span><br><span class="line">     <span class="comment">//连接信号，直接发送girl的hungry信号   </span></span><br><span class="line">    <span class="comment">//connect(btn,&amp;QPushButton::clicked,girl,&amp;GirlFriend::hungry);    </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onBtnClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit girl-&gt;<span class="built_in">hungry</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4. 信号槽拓展</h1><h2 id="4-1-信号槽使用拓展">4.1 信号槽使用拓展</h2><ul><li><p>一个信号可以连接多个槽函数, 发送一个信号有多个处理动作</p><ul><li>需要写多个 <code>connect</code> 连接</li><li>信号的接收者可以是一个对象, 也可以是多个对象</li></ul></li><li><p>一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的</p><ul><li>写多个 <code>connect</code> 就可以</li></ul></li><li><p><strong><font color='orange'>信号可以连接信号</font></strong></p><ul><li><p>信号接收者可以不出来接收的信号, 继续发出新的信号 -&gt; 传递了数据, 并没有进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;one&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton*btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;two&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//点击btn按钮，会让btn2按钮发出clicked信号</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,btn2,&amp;QPushButton::clicked);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(btn2,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::onClicked);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;okok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>信号槽是可以断开的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-信号槽的连接方式">4.2 信号槽的连接方式</h2><ul><li><p>Qt5的连接方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法:</span></span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure></li><li><p>Qt4的连接方式</p><blockquote><p>这种旧的信号槽连接方式在Qt5中是支持的, 但是不推荐使用, 因为这种方式在进行信号槽连接的时候, <strong>信号槽函数通过宏 <code>SIGNAL</code> 和 <code>SLOT</code> 转换为字符串类型。</strong></p><p><font color='red'>因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测， 如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt4的信号槽连接方式</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,<span class="built_in">SIGNAL</span>(信号函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)),</span><br><span class="line">        <span class="type">const</span> QObject *receiver,<span class="built_in">SLOT</span>(槽函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)));</span><br></pre></td></tr></table></figure></li><li><p>应用举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="comment">// Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>基于上面写的信号与槽，我们来处理如下逻辑: 我饿了, 我要吃东西</p><ul><li><p><strong>分析</strong>: 信号的发出者是我自己, 信号的接收者也是我自己</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Me m;</span><br><span class="line"><span class="comment">// Qt4处理方式  注意不要把信号与槽的名字写错了，因为是转为字符串写错了不会报错，但是连接会失败</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>()), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>(QString)), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>(QString)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt5处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);<span class="comment">// error:no matching member function for call to &#x27;connect&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为什么Qt4的方式没有错误，Qt5的方式却有问题了呢？</strong></p><ul><li>Qt4的方式在传信号和槽的时候用了宏进行强转，而且都带了参数，不会有二义性问题产生</li><li><font color='red'>Qt5中，信号和槽都有重载，此事connect函数根本就不知道你要使用的是重载中的哪一个，所以只能报错咯！</font></li></ul></li><li><p><strong>如何解决Qt5中的信号和槽重载中的二义性问题呢？</strong></p><ul><li><p>一，<strong><font color='orange'>通过函数指针解决</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号</span></span><br><span class="line"><span class="built_in">void</span> (Me::*funchungury)() = &amp;Me::hungury;</span><br><span class="line"><span class="built_in">void</span> (Me::*funchungury_QString)(QString) = &amp;Me::hungury;</span><br><span class="line"><span class="comment">//槽</span></span><br><span class="line"><span class="built_in">void</span> (Me::*funceat)() = &amp;Me::eat;</span><br><span class="line"><span class="built_in">void</span> (Me::*funceat_QString)(QString) = &amp;Me::eat;</span><br><span class="line"><span class="comment">//有参连接</span></span><br><span class="line"><span class="built_in">connect</span>(me,funchungury_QString,me,funceat_QString);</span><br><span class="line"><span class="comment">//无参连接</span></span><br><span class="line"><span class="built_in">connect</span>(me,funchungury,me,funceat);</span><br></pre></td></tr></table></figure></li><li><p>二，<strong><font color='orange'>通过Qt提供的重载类(QOverload)解决</font></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参连接</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,QOverload&lt;QString&gt;::<span class="built_in">of</span>(&amp;MyButton::hungury),<span class="keyword">this</span>,QOverload&lt;QString&gt;::<span class="built_in">of</span>(&amp;MyButton::eat));</span><br><span class="line"><span class="comment">//无参连接, 无需在&lt;&gt;中写void</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,QOverload&lt;&gt;::<span class="built_in">of</span>(&amp;MyButton::hungury),<span class="keyword">this</span>,QOverload&lt;&gt;::<span class="built_in">of</span>(&amp;MyButton::eat));</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><strong>总结</strong><ul><li>Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug</li><li>Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生</li><li>当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响</li><li>当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针</li></ul></li></ul><h2 id="4-3-Lambda表达式">4.3 Lambda表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;touch me&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton*btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;天王盖地虎&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span>  <span class="type">int</span> flag = <span class="literal">false</span>;<span class="comment">//可以这样用</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;小鸡顿蘑菇&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;天王盖地虎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag = !flag;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Lambda表达式是C++11最重要也是最常用的特性之一，是现代编程语言的一个特点，简洁，提高了代码的效率并且可以使程序更加灵活，Qt是完全支持c++语法的， 因此在Qt中也可以使用Lambda表达式。</p><p>Lambda表达式就是一个匿名函数， 语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br><span class="line">- capture: 捕获列表</span><br><span class="line">    - params: 参数列表</span><br><span class="line">    - opt: 函数选项</span><br><span class="line">    - ret: 返回值类型</span><br><span class="line">    - body: 函数体</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 示例代码-&gt;匿名函数的调用:</span></span><br><span class="line"><span class="type">int</span> ret = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>关于Lambda表达式的细节介绍:</p><ol><li>捕获列表: 捕获一定范围内的变量<ul><li><code>[] </code>- 不捕捉任何变量</li><li><code>[&amp;] </code>- 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=] </code>-  捕获外部作用域中所有变量, 并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>拷贝的副本在匿名函数体内部是只读的</li></ul></li><li><code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li><li><code>[bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li><li><code>[&amp;bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的this指针<ul><li>让lambda表达式拥有和当前类成员函数同样的访问权限</li><li>如果已经使用了 &amp; 或者 =, 默认添加此选项</li></ul></li></ul></li><li>参数列表: 和普通函数的参数列表一样</li><li>opt 选项 --&gt;  <code>可以省略</code><ul><li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li></ul></li><li>返回值类型:<ul><li>标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略</li></ul></li><li>函数体:<ul><li>函数的实现，这部分不能省略，但函数体可以为空。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器中的排队与调度</title>
      <link href="/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/"/>
      <url>/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>经过上一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/">路由器的工作原理</a>》的学习，我们应该发现当端口的处理速率与交换结构的转发速率不匹配时，就可能发生排队(Queuing)；以何种方式调离队列中的分组，称之为调度(Scheduling)。本文将详细讨论这两个问题。</p></blockquote><h3 id="font-color-red-何处出现排队-font"><font color='red'>何处出现排队</font></h3><p>排队的位置和程度取决于流量负载、端口处理速率以及交换结构的转发速率，当端口处理速率和转发速率不匹配时，就会发生排队。当队列占满整个缓冲区时，路由器将无法接收到新的分组，这时就会产生 <strong>丢包(packet loss)</strong> 。在 TCP 一章的讨论中，我们经常说到的丢包就在这里产生。</p><h4 id="font-color-orange-输入排队-font"><font color='orange'>输入排队</font></h4><p><u>如果交换结构的转发速率慢于输入端口的处理速率，就会在输入端口发生排队</u>，因为到达的分组必须加入输入端口队列中，以等待通过交换结构传输到输出端口。在输入端口的排队大致能分为两种类型：<strong>1.端口竞争；2.队头阻塞(Head-Of-The-Line, HOL)</strong> 。如下图所示：</p><img src="/2022/img/image-20220819103139081.png" alt="排队示意图" style="zoom:67%;" /><p><strong><mark class="hl-label blue">端口竞争</mark> </strong></p><p>如图，当第一排端口的队头分组和第三排的队头分组要发往同一个输出端口时，就会发生排队。即使不发往同一个端口，由于交换结构种类的限制，也可能发生排队，比如经总线交换和经内存交换每次只能交换一个分组，而 crossbar 交换也并非任何时候都能实现并行交换，详见《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/">路由器的工作原理</a>》。</p><p><strong><mark class="hl-label blue">HOL</mark> </strong></p><p>如上图，当发生端口竞争时，第一排队头先交换，第三排队头等待；由于第三排队头的阻塞，即使第三排队尾的分组的目的端口为第二排输出端口(没有端口竞争)，其也无法发送(FIFO策略)，这种阻塞就叫做队头阻塞。有研究表明，由于 HOL 阻塞，只要输入链路上的分组到达速率达到队列容量的 58%，输入队列的长度就将无限增大，导致大量丢包，所以 HOL 是输入队列面临的首要问题之一。解决 HOL 的主流方法是使用 <strong>虚拟输出队列(Virtual Output Queues)</strong> 。虚拟输出队列总体的想法十分朴素：在输入端口<u>将发送到不同端口的数据包虚拟成不同的队列</u>，并且彼此互不影响，这样一来即使队头数据包被阻塞也将不会影响发送到其他端口的数据包的发送。如下图 2 × 4 的输入输出交换结构中，每个输入端口将根据数据包输出端口的不同而加入专属“虚拟队列”（图中以不同的颜色区分），这样一来，在同一输入端口而目的端口不同的数据包的发送将彼此互不影响。除了虚拟输出队列外，还有其他许多解决排头阻塞的算法，如神经网络、<em>i</em>SLIP等等。</p><img src="/2022/img/format,f_auto.png" alt="虚拟输出队列" style="zoom:67%;" /><blockquote><p>只有在缓存式输入的交换机中才会出现队头阻塞的情况，如果交换机内部的带宽足够的话，缓存输入就是没有必要的了——所有的缓存都可以在输出处被处理，从而也避免了队头阻塞。这样的无缓存式输入架构在中小型规模的乙太网交换机中非常常见。</p></blockquote><h4 id="font-color-orange-输出排队-font"><font color='orange'>输出排队</font></h4><p>当交换速度较慢时，可能在输入端口形成排队；那么当交换速度足够快时，就能避免队列的形成吗？答案是否定的。即使 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>N</mi><mo>×</mo><msub><mi>R</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{switch}=N×R_{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，一旦当大量分组需要从不同输入端口传输到同一个输出端口时，队列也会在这个输出端口形成。当没有足够的内存来缓存分组时，要么将其丢弃(drop-tail)，要么删除队列中的某个分组来为新分组腾出空间。有时可能会在队列被填满之前就主动丢弃新分组，以此向发送方提供拥塞信号，这种策略被称为 <strong>主动队列管理(AQM)</strong> 算法。</p><p><strong><mark class="hl-label blue">多少缓存才足够？</mark> </strong></p><p>通过上述的简单讨论，不难发现似乎都是因为队列空间(缓存)不够大才造成的丢包，那么我们直接扩大路由器的缓存不就行了吗？事实上，确定合适的缓冲大小是一个复杂的问题。<strong>缓存设置过小会发生丢包，这不难理解；缓存设置过大，即使不会丢包，但也会引发高延迟并形成恶性循坏，其危害甚至比丢包更为严重</strong> ！这就是臭名昭著的 <strong>缓冲膨胀(buffer bloat)</strong> 。<strong>大多数<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制</a>算法都依靠测量丢包的发生来确定连接两端之间的可用带宽</strong> 。该算法会加快数据传输速度，直到数据包开始丢失，然后降低传输速率。理想情况下，他们会不断调整传输速率，直到达到链路的平衡速度为止。为了使算法能够选择合适的传输速度，必须及时收到有关丢包的反馈。使用大容量缓冲区时，数据包虽然最后会到达目的地，但延迟较高。因为数据包没有丢失，所以即使上行链路饱和，TCP 也不会减慢速度，从而进一步导致缓冲区饱和，从而进一步造成高延迟，这对实时类应用无疑是致命的。</p><p>缓冲膨胀的解决可以从两个角度切入：针对网络的解决方案和针对端点的解决方案。前者通常采用队列管理算法的形式，如 AQM 算法；后者包含 TCP 的 BBR 算法，详见笔者另一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP拥塞控制详解(二)</a>》。关于缓存大小的经验法则是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B=RTT×C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ，其中 C 是链路的容量，RTT 是平均往返时延。</p><h3 id="font-color-red-分组调度-font"><font color='red'>分组调度</font></h3><p>队列形成后，我们自然会考虑如何将分组调离队列并发送。就实际生活而言，一般我们排队会遵循 <strong>先到先服务(FCFS, 也称之为先进先出(FIFO))</strong> 策略；然而我们也经常在车站售票窗口看见“军人优先服务”。类似地，路由器中的队列也有不同的排队策略，这些方式叫做 <strong>分组调度(Packets Scheduling)</strong> 。</p><h4 id="font-color-orange-先进先出-FIFO-font"><font color='orange'>先进先出(FIFO)</font></h4><p>先进先出属于典型的被动队列管理的方法，它调度包的方法是：先到达路由器的分组先被传输，其它分组采用默认的排队方式。然而，路由器的缓存总是有限的，如果分组到达时缓存已满，那么路由器就不得不丢弃该分组。由于 FIFO 总是丢弃队尾的分组，所以又称它为“去尾”（drop-tail）算法。FIFO和“去尾”是最简单的分组调度和丢弃策略，两者有时可被视为一体，简单称为 FIFO 排队。<br>FIFO排队的算法简单，实施容易，是目前Internet使用最为广泛的一种方式。然而 FIFO 无法“识别”面向连接的连续 TCP 数据流，当存在占用大量带宽的对 TCP 不友好的流时，网络可能会持续拥塞，TCP 流分享不到应有的带宽。</p><h4 id="font-color-orange-优先权排队-priority-queuing-font"><font color='orange'>优先权排队(priority queuing)</font></h4><p>在此规则下，<strong>到达的分组根据既定规则被划入一个优先权类，每一个优先权类都有自己的队列，同一个队列中的分组采用 FIFO 策略</strong> 。如下图，分组 1、3、4 属于高优先权类，分组 2、5 属于低优先权类。分组 1 达到后即开始传输，在这期间分组 2、3 相继到达；分组 3 的优先权高于分组 2，所以分组 1 传输完成后轮到 3 传输；分组 4 在分组 2 传输时到达，在 <strong>非抢占式优先权排队</strong> 规则下，一旦分组开始传输，就不能被打断，所以即使分组 4 的优先权高于分组 2，也需要等到分组 2 传输完毕后才能传输分组 4 。</p><img src="/2022/img/image-20220819170315190.png" alt="image-20220819170315190" style="zoom:67%;" /><p>然而，虽然高优先级业务的带宽和时延得到了最大限度的保证，但若高优先级业务持续占据带宽，会导致低优先级业务一直得不到调度，这显然是不公平的，所以有了下面的 <strong>轮循和加权公平排队</strong> 策略。</p><h4 id="font-color-orange-轮循和加权公平排队-WFQ-font"><font color='orange'>轮循和加权公平排队(WFQ)</font></h4><p>WFQ是在发生拥塞时稳定网络运行的一种自动的方法，它能提高处理性能并减少分组的重发。WFQ主要有三个目的：</p><ol><li><p>为每个活动流提供公平的带宽分配机制，即WFQ名字中的F（fairness）的含义</p></li><li><p>为少量交互流提供更快的调度机制</p></li><li><p>为高优先级的流提供更多的带宽</p></li></ol><p>WFQ 根据流对报文进行动态分类，分类判据可为五元组和 IP 服务类型(TOS字段)，然后使用 Hash 算法映射到不同的队列中。另外，如果使用WFQ，那么 low-volume（字节数小的报文）、higher-precedence（优先级高的报文）的流会比 large-volume、lower-precedence 的流更先处理(目的二)。在出队的时候，WFQ 按流的优先级来分配每个流应占有出口的带宽。优先级的数值越小，所得的带宽越少。优先级的数值越大，所得的带宽越多。这样就保证了相同优先级业务之间的公平，体现了不同优先级业务之间的权值。详细内容参考[WFQ](<a href="https://baike.baidu.com/item/WFQ/10000942">WFQ_百度百科 (baidu.com)</a>) 。</p><blockquote><p>参考文章：《计算机网络自顶向下》，<a href="%5B%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83_%E7%9F%A5%E8%A1%8C%E6%B5%81%E6%B5%AA%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E7%BD%91%E7%BB%9C%E9%98%9F%E5%88%97%5D(https://blog.csdn.net/zengxiantao1994/article/details/53080941#:~:text=%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E5%B1%9E%E4%BA%8E%E5%85%B8%E5%9E%8B,%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8E%92%E9%98%9F%E6%96%B9%E5%BC%8F%E3%80%82)">FIFO</a>，<a href="http://lihaizhou.top/2020/08/27/%E8%87%AD%E5%90%8D%E6%98%AD%E8%91%97%E7%9A%84bufferbloat/">缓冲膨胀</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器的工作原理</title>
      <link href="/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文主要讨论网络层数据平面中的转发功能的硬件实现，即如何将分组从路由器的输入链路传输到合适的输出链路。</p></blockquote><p>下图展示了通用路由器的一般结构：</p><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3qV3nJvjh-GRCnpGI%2Fimage.png" alt="通用路由器的1一般结构" style="zoom:67%;" /><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3qgLtqu7FWWNziVrZ%2Fimage.png" alt="输入端口" style="zoom:67%;" /><img src="/2022/img/assets%2F-M8zvqNNVZctOHx6v8No%2F-ME3magMx6taYZhZPGd3%2F-ME3r8ffUymOfqAgojKQ%2Fimage.png" alt="输出端口" style="zoom:67%;" /><p>我们可以从图中看到，路由器大致有 <strong>输入端口、输出端口、交换结构、路由处理器</strong> 四个主要组件，下面我们简单分析各个组件的功能：</p><h3 id="font-color-red-输入端口-font"><font color='red'>输入端口</font></h3><p>1 号部分负责物理层功能：PHY(Physical Layer Device)模块或者 MAU(Medium Attachment Unit)模块将信号转换成通用格式，并将信号发送给 MAC 模块；<br>2 号部分负责链路层功能：MAC 模块收到 PHY 模块发来的信号后，将信号转换为数字信息，到达信号末尾时检查 FCS，<strong>如果 FCS 出错则直接丢弃此分组</strong> ，若无错则 <strong>再检查分组 MAC 头部中的接收方 MAC 地址是否与自己一致</strong> ，若不一致则直接丢弃，若一致则去掉 MAC 报头并将数据部分移交给网络层；<br>3 号部分负责网络层功能：<strong>查询转发表</strong> ，决定此分组的输出端口；</p><blockquote><p>为了更清楚地了解 PHY 和 MAC 模块在输入与输出端口中的作用，我们来看看电脑的网卡是如何将信息发送到网络中的：</p><p>首先，MAC 模块从报头开始将数字信息按每个比特转换为电信号(通用信号)，这里注意，<strong><font color='orange'>将数字信号转换为电信号的时间就是我们所说的传输时延</font></strong> ；然后 PHY(MAU) 模块将电信号转为转换为可在网线上传输的格式，并通过网线发送出去。不同链路有着不同的信号格式，<strong><font color='red'>但 MAC 模块不关心这些区别，它只负责将数字信号转换为通用信号并转发给 PHY 模块，然后 PHY(MAU) 再将其转换为可在网线上传输的格式</font></strong> 。接收网络中的信号是上述过程的逆过程，不再过多阐述。</p></blockquote><p>下面我们详细了解路由表的查询：</p><img src="/2022/img/417F6E2A7DA886977A88FF9C0AE6F9AC.png" alt="转发表示例" style="zoom:50%;" /><p><u>转发表由路由处理器计算生成和更新</u>。<strong>转发表从路由处理器经过独立的总线复制到<u>线路卡</u>(Line Card)，通过使用在每个输入端口的副本，转发决策就能在每个输入端口本地做出，无须每个分组都调用路由处理器来进行决策，从而避免了集中式处理的瓶颈</strong> 。<strong><font color='red'>查询转发表时，会忽略主机号，只根据子网掩码匹配 IP 地址的网络号</font></strong> ，且采用 <strong><font color=#3b8dfe>最长前缀匹配规则</font> (longest prefix matching rule)</strong> 。拿上图来说，目标地址为 <code>192.168.1.10</code> 的分组到达了路由器，然后将 <code>192.168.1.10</code> 和表中各 IP 地址分别与相应子网掩码进行与运算，若所得结果相同，则匹配。而计算后发现，图中 3、4、5 排记录都能匹配，<strong>根据最长前缀匹配规则，路由器最终匹配到网络号比特数最长的一条记录</strong> (图中第4条)。<u>网络号比特越长，说明子网中主机越少，从而减小了后续的寻找范围</u>。需要注意的是，即使根据最长前缀匹配规则，我们仍然可能匹配到多条候选记录(例如考虑到路由器或网线故障而设置的备用路由)，<strong>这时需要根据跃点数进行判断，跃点数越小则表明该路由越近。因此应该选择跃点数较小的记录</strong> 。<font color='orange'>若找不到匹配记录且不存在默认路由，路由器就会丢弃此分组，并通过 ICMP 消息告知发送方；若存在默认路由，则不匹配项都会被发送的默认路由</font> ；<code>0.0.0.0</code> 即为默认路由。</p><p>提高转发表查找速率是路由的核心问题之一。考虑具有 10 Gbps带宽的输入链路和 64 字节的 IP 数据报，其输入端口在另一个 IP 数据报到达之前仅有 51.2 纳秒的时间来处理数据报！所以实际网络对输入端口处理数据的速度要求极高，可以通过以下几个方面来提高速度：</p><ol><li>采用硬件执行查找。硬件执行速率往往比软件执行速率高几个数量级。</li><li>提高查找算法的效率。</li><li>缩小转发表的规模。路由器会使用 CIDR 来减小转发表的条目数量，从而提高查询效率，详见笔者另一篇文章 [<a href="https://jyxcpp.netlify.app/2022/08/16/ip%E7%BC%96%E5%9D%80/">IP编址</a>]。</li><li>提高内存访问速度。</li></ol><p>除了上述的处理，输入端口还需要进行其他操作，比如检查 IP 首部的版本号、CheckSum 和 TTL ，<u>并重写后两个字段</u>：每经过一个路由，TTL 就需要自减一次，这是为了防止发生路由循环，TTL 初始值通常设为 64 或 128 ；<strong><font color='orange'>由于 CheckSum 作用域包含了 TTL ，所以随着 TTL 的更新，CheckSum 也需要重新计算</font></strong> 。</p><h3 id="font-color-red-交换结构-Switching-Fbric-font"><font color='red'>交换结构(Switching Fbric)</font></h3><p>确定好分组的输出端口后，就可以进入到路由器的交换结构。通过交换结构，分组才能由输入端口被转发到正确的输出端口。交换结构有如下三种方式：</p><img src="/2022/img/IMG_0447(20220818-180045).PNG" alt="三种交换技术" style="zoom: 50%;" /><ol><li><strong>内存交换：</strong> 最早的的路由器就是传统的计算机，交换直接由 CPU 控制。分组从输入端口被复制到内存中，然后 CPU 提取出目的 IP 地址并在表中进行查找合适的输出端口，然后再将该分组复制到相应的输出端口缓存中。这种方式效率较低，原因在于：（1）查找表都由 CPU 进行；（2）由于总线一次只能进行内存读/写操作，所以不能同时进行多个分组交换。许多现代路由器也采用经内存交换，但与早期路由器的一个主要差别是：转发表查找和将分组写入相应端口的内存是由线路卡来处理的。</li><li><strong>总线交换：</strong> 输入端口经一根共享总线将分组直接传送到输出端口，其工作方式为：在输入端口为每个分组加上标签，然后经交换结构发送该分组至所有输出端口，但只有与该标签匹配的输出端口才会接收该分组；然后分组在输出端口去除标签并发送。相比于经内存交换，经总线交换无需路由处理器的干预，效率上有所提升；但由于每次只有一个分组能够跨越总线，所以交换带宽受总线速率限制，但对于网络边缘的路由器，总线速率通常够用。</li><li><strong>crossbar交换：</strong> 纵横式交换结构由 2N 条总线构成，它连接 N 个输入端口和 N 个输出端口。交叉点通过交换结构控制器(交换结构的一部分)进行开闭操作，当分组从 A 交换到 Y 时(A×Y交换)，只需要开启总线 A 和 Y 之间的交叉点即可。通过这样的设计，<strong>crossbar 交换结构就能并行地转发多个分组</strong> ，但并非任何时候都能执行并行转发，如下情况除外：（1）来自不同端口的多个分组有相同的目的端口。（2）(N×N)交换严格无阻塞，(M×N)交换可能发生阻塞；比如(A×X)与(B×Y)同时进行就会发生阻塞(交换路线交叉)。</li></ol><blockquote><p>设计交换网的时候一般要大于 1.2 倍的端口速率，这样才能保证在路由器内部交换网无阻塞的传输数据，这个 1.2 叫做加速比（speed up ratio）,比如华为的NE5000E路由器的加速比是 2，所以可以实现交换网无阻塞的传输数据。</p></blockquote><h3 id="font-color-red-输出端口-font"><font color='red'>输出端口</font></h3><p>输出端口取出其内存中的分组并将其发送到输出链路上。输出分组前可能面临排队和调度，相关内容见笔者另一篇文章《<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/">路由器中的排队与调度</a>》。另外，在全双工模式下每个端口既是入端口也是出端口。其他操作相当于输入端口的逆操作，不再赘述。</p><h3 id="font-color-red-路由处理器-font"><font color='red'>路由处理器</font></h3><img src="/2022/img/IMG_0445(20220818-115058)-166082484083011.PNG" alt="路由选择处理器" style="zoom:50%;" /><p>路由处理器执行控制平面的功能，包括：执行路由选择协议、计算并下发路由表、网络管理等。路由处理器可以集成在路由器中，每个路由器独立地执行各自的路由算法和其他操作；也可以只负责与远程控制器进行通信，远程控制器收集整个网络的信息，并通过一根总线(上图虚线)下发转发表至各个路由器。这种集中式管理，控制平面与数据平面分开的方式称为 <strong>SDN(Software Defined Network)</strong> ，详细内容参见《<a href="https://jyxcpp.netlify.app/2022/08/17/%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E4%B8%8Esdn/">通用转发与SDN</a>》。</p><blockquote><p>限笔者水平，文章难免有错误之处，如读者发现错误，敬请指出。<br>文章参考：《计算机网络自顶向下》，《网络是如何连接的》，<a href="https://www.zhihu.com/question/48343492">CLOS架构</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用转发与SDN</title>
      <link href="/2022/08/17/%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E4%B8%8ESDN/"/>
      <url>/2022/08/17/%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E4%B8%8ESDN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于IP地址的转发</title>
      <link href="/2022/08/17/%E5%9F%BA%E4%BA%8EIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8F%91/"/>
      <url>/2022/08/17/%E5%9F%BA%E4%BA%8EIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>路径MTU发现</title>
      <link href="/2022/08/16/%E8%B7%AF%E5%BE%84MTU%E5%8F%91%E7%8E%B0/"/>
      <url>/2022/08/16/%E8%B7%AF%E5%BE%84MTU%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IP分片与重组</title>
      <link href="/2022/08/16/IP%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/"/>
      <url>/2022/08/16/IP%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>广播,多播,任播</title>
      <link href="/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/"/>
      <url>/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IPv4与IPv6报头格式</title>
      <link href="/2022/08/16/IPv4%E4%B8%8EIPv6%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/08/16/IPv4%E4%B8%8EIPv6%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NAT技术</title>
      <link href="/2022/08/16/NAT%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/08/16/NAT%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IP编址</title>
      <link href="/2022/08/16/IP%E7%BC%96%E5%9D%80/"/>
      <url>/2022/08/16/IP%E7%BC%96%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-IP地址的定义-font"><font color='red'>IP地址的定义</font></h3><p>IP 地址(IPv4)由 32 位 bit 储存，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，即允许最多 43 亿台设备连入网络。为方便人为识别 IP 地址，我们采用 <strong>点分十进制</strong> 来表示 IP 地址，如下：<br><img src="/2022/img/IMG_0441(20220817-104106).PNG" alt="点分十进制" style="zoom:50%;" /></p><p>需要注意的是，<strong>IP 地址并非根据主机台数来配置，而是根据主机的网卡(NIC)来配置</strong> 。由于每一台主机一般都有多张网卡，而每张网卡又必须分配一个 IP 地址，所以 IPv4 的 IP 地址数目(约43亿)根本不够用，为了在 IPv4 的基础上容纳更多的主机， <a href="">NAT技术</a>应运而生。IPv6 也能很好的解决此问题，但由于网络规模巨大，全面替代 IPv4 还需要假以时日。</p><p>同时，为了方便网络管理和路由控制，<strong>IP 地址分为网络号和主机号</strong> 。网络号(网段)用来表示相邻的一片主机(如公司内的主机采用一个网络号)，主机号则表示网络段中的某一台主机。IP 地址的主机标识不能在同一网段中重复出现。网络号和主机号如何方便网络管理和路由控制呢？举例来说，对于网络管理，广播利用网络号直接将数据报发送到具有同一网络号的所有主机中，而无需一台主机一台主机地发送；对于路由控制，<strong>进行路由时，路由器只看网络号而忽视主机号</strong> 。那么，究竟从第几位开始是网络号，第几位开始又是主机号呢？最初二者使用 IP 地址的分类进行区分，而现在基本使用 <strong>子网掩码(subnet mask)</strong> 区分。<u>需要注意，在有些情况下依据部分功能、系统和协议的需求，前一种方法依然存在。</u></p><h3 id="font-color-red-IP-地址的分类-font"><font color='red'>IP 地址的分类</font></h3><p>IP 地址被分为 A，B，C，D，E五类。它根据 IP 地址中从第 1 位到第 4 位的比特序对网络号和主机号进行区分，如下图：</p><img src="/2022/img/IMG_0442(20220817-112008).PNG" alt="IP分类" style="zoom:50%;" /><p><strong>A类地址</strong> ：首位以 <code>0</code> 开头，第 2 位到第 8 位是其网络标识，即 0.0.0.0 ~ 127.0.0.0 是 A 类的网络号，后面的 24 位为主机地址。因此 A 类地址的一个网段可容纳最多 16,777,214 个主机。<br><strong>B类地址</strong> ：首位以 <code>10</code> 开头，第 2 位到第 16 位是其网络标识，即 128.0.0.1 ~ 191.255.0.0 是 B 类的网络号，后面的 16 位为主机地址。因此 A 类地址的一个网段可容纳最多 65,534 个主机。<br><strong>C类地址</strong> ：首位以 <code>110</code> 开头，第 2 位到第 24 位是其网络标识，即 192.168.0.0 ~ 239.255.255.0 是 C 类的网络号，后面的 8 位为主机地址。因此 A 类地址的一个网段可容纳最多 254 个主机。<br><strong>D类地址</strong> ：首位以 <code>1110</code> 开头，第 2 位到第 32 位是其网络标识，即 224.0.0.0 ~ 239.255.255.255 是 D 类的网络号。D 类地址没有主机号，常被用于多播。关于多播，参考<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/">此处</a> 。</p><p>另外，A 类地址保留给政府，B 类给中等以上的公司，C 类分配给个人，D 类用于多播，E 类尚未使用。</p><blockquote><p>注意，观察到主机数目都减去了 2，这是因为主机号全为 0 时表示整个子网，全为 1 时表示向子网所有设备发送报文，即广播；关于广播，参见<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD-%E4%BB%BB%E6%92%AD/">此处</a>；<code>0.0.0.0</code> 地址对应于未知地址，指在本机的路由表里没有特定条目指明如何到达；一般用户主机为了获得一个可用的 IP 地址，就给 DHCP 服务器发送 IP 分组，并用这样的地址作为源地址。</p></blockquote><p>我们发现，架构 A、B 类网络时，一个网段中将存在数万乃至数十万的主机，这类情况在实际架构时通常是不存在的。因此，IP 地址的分类显得浪费资源，我们需要一种更好的划分方式。</p><h3 id="font-color-red-CIDR与VLSM-font"><font color='red'>CIDR与VLSM</font></h3><p>由于 IP 地址的分类造成的严重浪费，人们放弃了这种 IP 分配策略，开始采用任意长度分割 IP 的网络号和主机号。这种方式叫做 <strong>CIDR(无类型域间路由)</strong> 。通过使用 CIDR ，我们就可以将多个 C 类地址合并为一个网络地址范围，如下：</p><img src="/2022/img/IMG_0444(20220818-102905).PNG" alt="CIDR" style="zoom:50%;" /><p>在 CIDR 之前，如果很多个 C 类网络在一起，经过路由器的时候就被宣告成很多条子网掩码为 <code>255.255.255.0</code> 的路由条目(一个C类地址是 24 位网络号)，其数目是巨大的，非常消耗路由器的资源。CIDR 的基本思想是取消 IP 地址的分类结构，将多个地址块聚合在一起生成一个更大的网络( <strong>路由聚合</strong> )，<strong>以减少路由表中的路由条目，从而降低路由的性能损耗</strong> 。而在 CIDR 之前，多个 C 类网络是无法被聚合在一起的。</p><p>在 CIDR 应用初期，<u>网络内部</u>(一段连续分配的IP地址,比如公司内部) 采用固定长度的子网掩码机制，也就是说，当子网掩码的长度被设置为 /24 以后，域内所有的子网掩码都必须使用同样的长度。然而，一个公司内有些部门可能有 100 台主机，另一些部门可能只有 25 台，两个部门的子网掩码却都相同(即分配的主机IP数目也相同)，这就导致了 IP 地址的浪费。如果采用统一的标准，就难以架构一个高效的网络。为此人们提出了组织内部(即子网)要使用可变长度的、高效的 IP 地址分配方式。</p><p>于是，<strong>VLSM(Variable Length Subnet Mask)</strong> 应运而生。<strong>VLSM 通过对 IP 地址的主机号进行再划分，把其一部分划入网络号，就能划分各种类型大小的子网了</strong> 。 比如一个公司内部的子网掩码被设为 /24 (可容纳254个主机)，那么对于只有 100 台主机的部门，我们可以把部分主机号归入网络号，将此部门的子网掩码设置为 /25 (可容纳127个主机)，这样就有效提高了 IP 地址的利用率。</p><p>通过以上描述，我们可以发现，<strong>CIDR 更多是一个 ISP/Provider 级别的概念，常用于网络核心；而 VLSM 是地址块的接收者用来更有效地使用分配的地址块的一种机制，多用于网络边缘</strong> 。</p><p>CIDR 与 VLSM 的关系简单总结为：<strong><font color='orange'>CIDR 和 VLSM 在某程度上可以看做是逆过程，CIDR 是把几个小网络汇聚成一个大网络来做表示，而 VLSM 则是把一个大网络继续细分为几个小网络进行 IP 地址分配。前者能让路由器的路由条目得到有效的减少，而后者可以充分利用 IP 进行地址分配而解决 IP 地址不被浪费的问题。</font></strong></p><blockquote><p>文章参考：<a href="https://community.cisco.com/t5/switching/what-is-the-difference-between-cidr-and-vlsm/td-p/1172242">思科</a>，<a href="https://blog.csdn.net/qq_43207781/article/details/105059613">CIDR与VSLM的区别</a>，《计算机网络自顶向下》，《图解TCP/IP》，《网络是如何连接的》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
          <category> IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层概述</title>
      <link href="/2022/08/16/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/16/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>传输层依赖网络层提供进程到进程的通信，而网络层提供主机到主机的通信。网络层在协议栈中属于最复杂的层次，它可以分为大概两个层次：<strong>数据平面</strong> 与 <strong>控制平面</strong> 。数据平面管理的是数据包在路由器中的<u>转发</u>(Forwarding)，其讨论的是数据包应该从输入端口被转发到哪一个输出端口以及如何转发的问题，前一个问题我们将在<a href="https://jyxcpp.netlify.app/2022/08/17/%E5%9F%BA%E4%BA%8EIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8F%91/">基于IP地址的转发</a>和<a href="https://jyxcpp.netlify.app/2022/08/17/%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E4%B8%8ESDN/">通用转发与SDN</a>中详细讨论，后一个问题将在<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84/">路由器交换结构(Switching Fabric)</a>中解答。当数据报到达路由器时，如果转发速度慢于数据报到达速度，则可能出现排队，若队列已满，则可能出现更严重的情况——丢包，我们会在<a href="https://jyxcpp.netlify.app/2022/08/17/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%8E%92%E9%98%9F%E4%B8%8E%E8%B0%83%E5%BA%A61/">排队与调度</a>中了解此问题的解决方案。同时，网络层的任何操作都离不开 IP 地址，我们会在<a href="https://jyxcpp.netlify.app/2022/08/16/IP%E7%BC%96%E5%9D%80/">IP编址</a>中学习 IP 地址的构成与分类。网络层将传输层的段(Segment)封装成数据报(Datagram)进行传输，其中将涉及到<a href="https://jyxcpp.netlify.app/2022/08/16/IPv4%E4%B8%8EIPv6%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F/">IP数据报格式</a>，<a href="https://jyxcpp.netlify.app/2022/08/16/IP%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/">IP分片与重组</a>。</p><p>。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差错检测和纠正技术</title>
      <link href="/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>虽然将本节放入链路层专栏，但需要知道，差错检测和纠正技术不单单出现在链路层，传输层也有此技术的应用，比如 TCP/UDP 中的校验和。校验和主要用于传输层，奇偶校验和循环冗余检测(CRC)则主要用于链路层。</p></blockquote><h3 id="font-color-red-校验和-font"><font color='red'>校验和</font></h3><p><strong>校验和(Checksum)</strong> 是一个端到端的校验方式，<u>由发送端计算，然后由接收端验证，如果接收方检测到校验和有差错，则报文会被直接丢弃</u> 。其目的是为了发现首部和数据在发送端到接收端之间发生的任何改动。<strong>UDP 可选择使用校验和，而 TCP 则强制使用校验和</strong> 。CheckSum 不同领域可能采用不同算法，算法存在细微差别，且覆盖区域也不同：</p><ul><li><p>IP校验和：IP 首部</p></li><li><p>ICMP校验和：ICMP 首部 + ICMP 数据</p></li><li><p>UDP、TCP校验和：首部 + 数据 + 伪首部</p></li></ul><blockquote><p><u>伪首部并非 TCP&amp;UDP 数据报中实际的有效成分，它是一个虚拟的数据结构，其中的信息是从数据报所在 IP 分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和</u> 。伪头部 = 源 IP 地址 + 目的 IP 地址 + 8 位协议 + 16 位 UDP 长度，通过 伪头部+UDP头部+应用层数据，就可以检测出网络层(被递交到错误主机)，传输层(被递交到错误进程)，应用层(应用数据错误)的比特错误。</p></blockquote><p>下面以 UDP 校验和举例(TCP类似)。</p><p><strong><mark class="hl-label blue">一.计算校验和：</mark> </strong></p><ol><li><p>把校验和字段设置为 0 (下一步计算时，会包含此部分，所以必须设置为零)</p></li><li><p>把需要校验的数据看成以 16 位为单位的数字组成，依次进行 <strong><font color='orange'>二进制反码求和</font></strong></p></li><li><p>把得到的结果存入校验和字段中</p></li></ol><p>另外注意：</p><ul><li>UDP、TCP 数据报的长度可以为奇数字节，因为计算时是 16 位为单位，所以此时计算校验和时需要在最后增加一个填充字节 0 (<u>只是计算校验和用，不发送出去</u>)。</li><li><strong>二进制反码求和，就是先把这两个数取反，然后求和，如果最高位有进位，则向低位进 1</strong> 。<strong>先取反后相加与先相加后取反，得到的结果是一样的，因此实现代码都是先相加，最后再取反。</strong></li></ul><p><img src="/2022/img/image-20220816104346070.png" alt="示意图"></p><p><strong><mark class="hl-label blue">二.检验校验和：</mark> </strong></p><p>把需要校验的内容(包括校验和字段)看成以 16 位为单位的数字，依次进行二进制反码求和，<strong>如果结果是0表示正确，否则表示错误</strong> 。</p><p><strong><mark class="hl-label blue">三.实现代码：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title">check_sum</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *buffer, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cksum = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//16位为单位数字相加</span></span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cksum += *buffer++;</span><br><span class="line">        size -= <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//长度奇数情况</span></span><br><span class="line">    <span class="keyword">if</span>(size)</span><br><span class="line">        cksum += *((<span class="type">unsigned</span> <span class="type">char</span> *)buffer);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//高位有进位，进位到低位，下面两行代码保证了高16位为0。</span></span><br><span class="line">    cksum = (cksum&gt;&gt;<span class="number">16</span>) + (cksum&amp;<span class="number">0xffff</span>);</span><br><span class="line">    cksum += (cksum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//最后取反</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(~cksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><mark class="hl-label blue">为什么要用反码计算校验和？</mark> </strong></p><p><strong>因为使用反码计算就可以避免依赖系统的字节序(大小端)</strong> 。即无论你是发送方计算机或者接收方检查校验和时，都不要调用htons或者ntohs，直接通过上面的算法就可以得到正确的结果。用反码求和时，交换16位数的字节顺序，得到的结果相同，只是字节顺序相应地也交换了；而如果使用原码或者补码求和，得到的结果可能就不同。举例如下：</p><p><img src="/2022/img/20160929173826754.png" alt="反码计算校验和"></p><p>可见，使用反码进行校验和计算，不同字节序所得结果相同。</p><p><strong><mark class="hl-label blue">UDP可选校验和：</mark> </strong></p><p>UDP 协议可以不选择使用校验和。在这种情况下，发送前 CheckSum 字段全部填充 0 ；如果在 UDP 发送方决定使用 CheckSum 的情况下计算出其值全为0，则在发送前将其全改为 1；注意，这这并不会产生混淆，因为 CheckSum 有可能被计算为全 0 ，但不可能被计算为全 1 (这意味着 CheckSum 覆盖的数据全为 0 ，这是不可能的)。</p></blockquote><h3 id="font-color-red-奇偶校验-font"><font color='red'>奇偶校验</font></h3><p>奇偶校验用来检测数据传输过程中是否发生比特错误，是众多校验码中最为简单的一种。<strong>采用何种校验是事先规定好的</strong> 。<u>通常专门设置一个奇偶校验位</u> ，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性，偶校验同理。</p><img src="/2022/img/v2-ed494a01b2527927febaac2845b51d9c_1440w.jpg" alt="奇偶校验" style="zoom:67%;" /><blockquote><p>上图中直接将校验位放在了原始字节流的末尾，但实际上通常专门设置一个奇偶校验位。</p></blockquote><p><strong><mark class="hl-label blue">计算原理：</mark> </strong></p><p>如果事先规定了采用奇校验，则发送方利用校验位将 <u>数据+校验位</u>  中的 1 的个数调整为奇数个（如上图），接收方收到分组后检验 <u>数据+校验位</u> 的 1 的个数，如果为奇数个，则 <strong>基本</strong> 能够说明数据没有发生错误，反之 <strong>一定</strong> 出错。偶校验同理。</p><p><strong><mark class="hl-label blue">万一校验位本身出错呢？</mark> </strong></p><p>目前笔者没有了解到此问题的解决方案，但需要知道的是，相对于数据而言校验位本身占的位数极少，本来一个分组发生比特错误的概率就极少，而错误发生在校验位而非数据位的概率就更加少了，所以并不用很担心此问题。即使发生错误，链路层和传输层也提供 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">ARQ 协议</a>来保障数据的正确性。</p><p><strong><mark class="hl-label blue">当出错比特数为偶数，此方法不就失效了吗？</mark> </strong></p><p>是的，奇偶校验只能检测到出错比特数为奇数的情况，一旦为偶数，就无法检测出错误。但需要知道的是，在某些可靠性较高的链路上(如,以太网)发生比特错误的概率是很小的，而同一个分组中发生多个比特错误的概率则是极小的，在这种情况下，单个奇偶校验位应该是足够的。然而即使如此，测量已经表明差错经常以“突发”的方式聚集在一起，而不是独立的发生，使用单比特奇偶校验保护的一帧中，未检测差错的概率达到了 50%，所以显然我们需要更健壮的差错保护方式。下面我们提供三种方式来提高其健壮性：</p><ol><li><p>为每 N 个字节设置一个校验位。比如有 1000 字节的数据，每 100 字节设置一个校验位，则需要总共 10 个校验位。只有在连续的 100 个字节中同时出现多个比特错误才可能导致校验失败，这再次大大减少了失误发生的概率。（此方法为笔者推测，仅供参考）</p></li><li><p><strong><font color='orange'>二维奇偶校验：</font></strong> 将数据的 N 个比特划分为 D 行 D 列，对每行和每列都计算校验位。一旦某处发生错误，那么其行/列校验位都会发生变动，<strong>因此接收方不仅可以检测的错误的发生，还能定位错误并将其纠正！</strong></p><img src="/2022/img/IMG_0440(20220816-154217).PNG" alt="IMG_0440(20220816-154217)" style="zoom: 50%;" /><p>需要注意的是，并非任何差错情况都能够纠正(但都可检测到)，只要一个分组中出现多个比特差错，就无法纠正。原因是，假设发生两个比特错误，则再上图中就会有三条或四条线，对应三个或四个交点，而只发生了两处错误，所以无法准确定位。</p></li><li><p><strong><font color='orange'>汉明码：</font></strong> 汉明码(海明码)在上世纪 40 年代早早地就诞生了，不过直到今天的 ECC 内存里面，我们还在使用这个技术方案，而海明也因为海明码获得了图灵奖。汉明码与二维奇偶校验类似，也属于多重奇偶校验。汉明码不仅可以验证数据是否有效，还能在数据出错的情况下指明错误位置(仅发生一处错误时)。下面我们详细了解其计算方法。</p></li></ol><p><strong><mark class="hl-label blue">汉明码计算方法</mark> </strong></p><p><strong>冗余位：</strong> “冗余位”是一种二进制位，它被用来添加到需要传输的数据信息中，以侦测数据在传输过程中发生的丢失或者改变。汉明码需要多少个冗余位？答案如图：</p><img src="/2022/img/image-20220816170748013.png" alt="image-20220816170748013" style="zoom:50%;" /><p>对于 7 位有效数据，汉明码需要 4 位冗余码进行纠错，所以最早的汉明码又叫 <u>7-4 汉明码</u> 。<u>下面的讨论采用 7-4 方式且使用 <strong>奇校验</strong> 进行举例说明</u> 。</p><p><strong>编码方式：</strong></p><ol><li><p>为方便讨论，对比特位进行编号。7个有效位，4个冗余位，一共11位。<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom: 33%;" /></p></li><li><p><u>汉明码对于奇偶校验位的位置有特殊要求</u> ：<strong>所有2的幂次位（2^0=1,2^1=2,2^2=4,2^3=8……）作为“奇偶校验位”</strong> ，因此，第1位，第2位，第4位，第8位为奇偶校验位，其他的7位为数据位。<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064187407110.png" alt="示意图" style="zoom:33%;" /></p></li><li><p>表示出索引的二进制：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064194823213.png" alt="示意图" style="zoom: 50%;" /><br>并对索引进行分类：<u>从右往左（低位往高位）数</u> ，第一位是“1”的索引有：1011, 1001, 0111, 0101, 0011, 0001；于是这些位置由第一个校验码管理：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064212510716.png" alt="示意图" style="zoom: 50%;" /><br>第二位是“1”的索引有：1011, 1010, 0111, 0110, 0011, 0010；于是这些位置由第二个校验码管理：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064216439519.png" alt="示意图" style="zoom: 50%;" /><br>其他两组同理。</p></li><li><p>填充数据位：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064231040322.png" alt="示意图" style="zoom: 50%;" /><br>填充冗余位：第一组(1,3,5,7,9,11位)：1 的个数为 4 个，偶数个，因此①号应该为 1(采用的是奇校验)；类似的，得出其他冗余位：<br><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064258132625.png" alt="示意图" style="zoom:50%;" /></p><p>构造完毕。</p></li></ol><p><strong>汉明码的纠错机制：</strong><br>汉明码通过检查每一小组的“奇校验”，来确定是否发生了错误。<br>首先第一组（1,3,5,7,9,11位）：1 的个数为 6 位，不再是奇数个了，因此，我们可以断定，这一组中肯定有某个数据发生了错误，但不能确定是哪一位上发生了错误。为了达到“奇校验”，我们必须补 1 个 1 来达到奇数个 1。<br>接下来，我们检查第二组（2,3,6,7,10,11） ，1的个数为3位，仍然满足“奇校验”，因此我们也可以断定这一组中没有任何一位数据发生了改变。所以，我们只需要补 0。<br>我们继续检查第三组（4,5,6,7），1 的个数为 2，不在满足“奇校验”，因此，我们可以断定，这一组中也有数据发生改变。为了达到“奇校验”，我们必须补 1 个 1 来达到奇数个1。<br>我们检查第四组（8,9,10,11位），1 的个数为 3 位，满足“奇校验”，因此没有发生改变。所以我们只需要补0。<br>如下图所示：</p><p><img src="/2022/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70-166064303859628.png" alt="示意图"></p><p>我们发现，最后得出来的二进制数是：<code>0101</code> ，我们会神奇地发现，<code>0101</code> 就是十进制 5 的二进制表现，因此，我们可以准确的知道，5号位上发生了数据的改变，我们只要对 5 号位进行置反操作即可。最后，接收方就可以修改成为正确的数据。</p><blockquote><p>二维奇偶校验与汉明码谁略胜一筹？<br>笔者提供一个思路(仅供参考)：对于 10000 字节的数据而言，二维奇偶校验需要 200 个冗余字节(行100，列100)；而汉明码则最少只需要约 14 个字节(通过上面的公式计算得出)，所以在有效利用率上，汉明码更胜一筹。但显然二维奇偶校验的思路更加简单。</p></blockquote><h3 id="font-color-red-循环冗余校验-CRC-font"><font color='red'>循环冗余校验(CRC)</font></h3><p>CRC 循环冗余校验属于检错码，只能检测出现了错误，但<u>无法纠正错误</u> 。与 CRC 循环冗余校验类似的，还有奇偶校验，<u>但是 CRC 漏检率更低</u> ，因此在实际应用中更为重要。CRC 常用于数据链路层的错误检测，通常在帧尾添加 CRC 校验码。<br><strong>CRC 校验流程概述</strong> ：发送方在原始数据的基础上，加上 CRC 校验码，组成新的发送数据；然后接收方对收到的 <code>原始数据 + 校验码</code> 进行校验，判断数据在传输过程中是否出现错误，若出错则丢弃，并反馈相应信息。</p><p><strong><mark class="hl-label blue">CRC校验步骤：</mark> </strong></p><p><strong><font color=#3b8dfe>发送方追加校验码：</font></strong></p><ol><li>假设原始数据是：<code>101001</code></li><li><strong>生成待追加的校验码，需要使用一个生成多项式G(x)(收发双方事先约定)</strong> ，例如 G(x) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3 + x^2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>构造被除数：原始数据 + 生成多项式最高次项个0，即：<code>101001000</code></li><li>除数：除数实际上就是生成多项式的系数，G(x) <strong>展开得到</strong> : G(x) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mi>x</mi><mn>0</mn></msup><mtext>，</mtext></mrow><annotation encoding="application/x-tex">1 × x^3 + 1 × x^2 + 0 × x^1 + 1 × x^0，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span></span></span></span>即 <code>1101</code></li><li>两数相除得余数，<u>并进行补位(补到与生成多项式最高次项一致)</u> ，即得到校验码。但是，这里的除法跟常规除法并不相同，本处使用的是<strong>模2除法</strong> ；常规除法在上下两行数进行运算时，使用的是减法运算，而这里使用的是异或运算。通过上述运算，得到校验码 <code>001</code>，添加到原始数据之后，得到最终发送数据为   <code>101001001</code></li></ol><p><img src="/2022/img/2021021213262352.png" alt="示意图"></p><p><strong><font color=#3b8dfe>接收方进行校验：</font></strong></p><ol><li>继续接前文，假设收到的数据为 <code>101001001</code></li><li>接收方对该数据做除法，除数仍然是之前使用的多项式的系数 <code>1101</code> ，过程如下：</li></ol><p><img src="/2022/img/20210212134841902.png" alt="示意图"></p><p><strong>若余数不为0，则表明发生比特错误</strong> 。</p><blockquote><p>另外，在实际使用 CRC 时，采用的生成多项式更为复杂，从而确保较低的漏检率：<br><img src="/2022/img/20210212140304184.png" alt="常见多项式"></p></blockquote><h3 id="font-color-red-总结-font"><font color='red'>总结</font></h3><p>接收方检测和纠正差错的能力被称为 <strong>前向纠错(Forward Error Correction, FEC)</strong> 。在网络环境中，FEC 可以单独应用，也可以与链路层的 ARQ 技术一起应用。FEC 技术具有很高应用价值，因为它们可以减少重发次数，避免了潜在的往返时延，这对于实时网络应用尤其重要。</p><blockquote><p>参考资料：<a href="https://blog.csdn.net/jiangqin115/article/details/39315085">伪首部</a>，<a href="http://www.metools.info/code/c128.html">校验和计算器</a>，<a href="https://www.cnblogs.com/iamwho/p/11510160.html">校验和计算方法</a>，<a href="https://blog.csdn.net/axiqia/article/details/52704061?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-52704061-blog-103358272.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-52704061-blog-103358272.pc_relevant_vip_default&amp;utm_relevant_index=1">校验和计算原理</a>，<a href="https://blog.csdn.net/qq_19782019/article/details/87452394">汉明码通俗讲解</a>，<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E7%A0%81/3226749">汉明码-百度</a>，<a href="https://blog.csdn.net/TL18382950497/article/details/113794438">CRC计算流程详解</a>，<a href="https://zhuanlan.zhihu.com/p/61636624">CRC代码实现</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 链路层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP存活检测机制</title>
      <link href="/2022/08/08/TCP%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/"/>
      <url>/2022/08/08/TCP%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">TCP存活检测的背景</mark> </strong></p><p>由于 TCP 位于传输层，两端的连接为逻辑信道(由五元组控制)而非物理连接，所以当两端处于连接状态但未发送数据时，理论上即使中间的路由器崩溃重启、或者中间的网络线路拔掉在插上等等，只要客户端和服务器端的主机没有发生异常，这个TCP连接仍然是处于连接状态的。这会引发以下问题：</p><ol><li>服务器资源被持续占用（需要保存连接的状态信息）</li><li>防火墙和NAT设备可能会保存一个连接超时的定时器，如果这个 TCP 连接长时间没有数据传输，定时器超时后，服务器端和客户端实际上已经不能在进行通信。</li></ol><p>为了解决上面的两个问题，TCP连接需要一个存活检测机制，定时检测当前的 TCP 连接是否可用，以刷新防火墙和 NAT 信息，或者当检测到连接失败的时候释放相关资源。TCP 存活检测机制主要为 <strong>长连接</strong> 服务。</p><p><strong><mark class="hl-label blue">存活检测实现方式</mark> </strong></p><ol><li><strong>应用层心跳机制</strong></li><li><strong>TCP保活机制</strong></li></ol><p>相比传输层的存活检测，应用层的检测更灵活且不依赖传输层的协议，但需要应用自定义心跳消息头。心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉对方自己还活着。事实上这是为了保持<a href="https://baike.baidu.com/item/%E9%95%BF%E8%BF%9E%E6%8E%A5">长连接</a>，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。</p><p><strong><mark class="hl-label default">应用层心跳机制</mark> </strong></p><p>应用层的心跳包其实就是一个预先规定好格式的数据包，在程序中启动一个定时器，定时发送即可，这是最简单的实现思路。通常，当双端正常通信时，各端接收到数据包本身也能说明连接是“有心跳的”，故此时无需心跳包。所以，对于用于保活的心跳包，我们仅在没有数据来往达到一定时间间隔时才发送一次心跳包。一般是客户端主动给服务器端发送心跳包，服务器端做心跳检测决定是否断开连接。</p><p><strong><mark class="hl-label default">TCP保活机制</mark> </strong></p><p>在TCP存活检测中有一个 <strong>存活定时器</strong> ，当 TCP 连接的任何一个方向有业务数据传输时，就会把这个存活定时器重置为 <code>keepalive time</code> ，当固定时间内没有数据传输导致本端这个定时器超时的时候，TCP就会发送一个探测包(keepalive probe )，若对端接收到这个探测包后响应一个 ACK，本端接收到这个 ACK 时就会重置这个存活定时器为 <code>keepalive time</code> 。如果本端没有收到这个 ACK 响应，会以 <code>keepalive interval</code> 为间隔时间重复发送探测包，如果一直发送了<code>keepalive probes</code> 次都没有收到 ACK 响应，则认为这个连接已经失活。如果中间的某次收到 ACK 响应则会重置存活定时器为 <code>keepalive time</code> ，并且停止 <code>keepalive interval</code> 为间隔的探测包重复发送。</p><p><code>keepalive time</code> 一般为 7200 ms，即两个小时(时间太长，没有实际意义)；<code>keepalive interval</code> 一般为 75 ms；<code>keepalive probs</code> 一般为 9 次。所以如果连接一直未响应，最晚两个小时十多分钟就会自动断开连接。<u>keepalive功能必须默认关闭</u> 。</p><p><strong><mark class="hl-label blue">为什么有了TCP保活机制，还需要应用层心跳检测？</mark> </strong></p><p>因为 TCP 的保活机制并不能准确体现应用层的可用性。应用层心跳除了说明进程还活着，更重要的是说明进程还能正常工作。一旦客户端发生死锁， 其心跳机制也会锁住，这样服务端就能感知到不正常，从而及时断开连接。而 TCP 的保活机制依然正常，所以无法向外界反馈正确信息。</p><blockquote><p>文章参考：<a href="https://www.zhihu.com/question/40602902">TCP37</a>，<a href="https://www.zhihu.com/question/40602902">知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP计时器详解</title>
      <link href="/2022/08/08/TCP%E4%B8%83%E7%A7%8D%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/08/TCP%E4%B8%83%E7%A7%8D%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>建立连接定时器 (connection-establishment timer)<br>重传定时器 (retransmission timer)<br>延迟应答定时器 (delayed ACK timer)<br>坚持定时器 (persist timer)<br>保活定时器 (keepalive timer)<br>FIN_WAIT_2 定时器 (FIN_WAIT_2 timer)<br>TIME_WAIT 定时器 (TIME_WAIT timer, 也叫2MSL timer)</p></blockquote><p><strong><mark class="hl-label blue">建立连接定时器</mark> </strong></p><p>建立连接的过程中，在发送 SYN 时， 会启动一个定时器(1秒或3秒，取决于实现)，如果 SYN 包丢失了， 那么 1 秒以后会重新发送 SYN 包，若再次超时，则会将 RTO 设为 2，再超时则设为 4，每次翻倍（指数回退）。在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5，所以一般等待 60 秒后再无回应就会关闭连接。</p><p><strong><mark class="hl-label blue">重传定时器</mark> </strong></p><p>重传定时器在 TCP 发送<u>普通报文</u>时设定，具体大小(一般为1秒)参见<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">RTT的测量</a>，在计时器超时后没有收到返回的确认 ACK，发送端就会重新发送队列中需要重传的报文段。使用 RTO 重传计时器一般有如下规则：</p><ol><li>当TCP发送了位于发送队列最前端的报文段后就启动这个RTO计时器；</li><li>收到 ACK 报文后，若所有已发送分组都被确认，则停止计时，若只是部分确认，则重开计时器。</li><li>若超时，则重传所有未完成报文（有待考证）。</li></ol><p>对于普通报文的重传定时器，最大重传次数由 <code>tcp_retries2</code> 决定，详细参考<a href="https://www.cnblogs.com/lshs/p/6038527.html">此处</a> 。</p><p><strong><mark class="hl-label blue">延迟应答定时器</mark> </strong></p><p>延迟确认也被称为捎带ACK， 这个定时器在延迟应答的时候使用（最大时间为 0.5 秒）。收到第一个 ACK 报文后，等待一段时间，若最长 0.5 秒内未收到第二个报文，则直接发送 ACK。TCP 最多只能延迟确认一次，即 ACK 报文最多只能累积确认两个报文。</p><p><strong><mark class="hl-label blue">坚持定时器</mark> </strong></p><p>当 TCP 的一端一直接收数据，但是应用层没有及时读取的话，会导致缓存区不断减小，<code>window size</code> 会变为 0，此时我们称呼这个接收窗口为零窗(zero window)，对端也不能在发送更多的数据。如果随后本端应用层从 TCP 接收缓存中读取了足够数据，TCP 模块有了足够的新的接收缓存的时候，就会发送一个TCP报文，并带有一个有效非零的 <code>Window size</code> 来指示对端自己已经可以接收新数据了。这个带有有效<code> Window size</code> 的报文我们称为窗口更新(window update)报文。<strong>窗口更新报文一般为 pure ACK 报文，不消耗系列号，所以发生丢失并不会进行重传</strong> 。如果窗口更新报文发生丢失，那么接收端会等待发送端发送新的数据，而发送端会等待窗口更新报文，这种场景下，两端互相等待对方，就会产生 <strong>死锁</strong> （Nagle算法和延迟ACK同时生效的时候也会产生类似的死锁）。为了避免死锁，发送方会设置一个 <strong>坚持计时器</strong> ，每当这个定时器超时的时候，发送端就会发送 <strong>零窗口探测报文</strong> 。RFC1122 建议初始坚持定时器时间为RTO，随后每次超时重传进行指数回退，最大指数回退次数为 <code>tcp_retries2</code> 。达到 <code>tcp_retries2</code> 后不再进行指数回退，且继续以当前 RTO 进行重传。<strong>可以看到这里没有释放 TCP 连接，而在 RTO 重传指数回退过程中，当超过根据 <code>tcp_retries2</code> 计算的最大重传时间的时候就会释放TCP连接。</strong></p><p><strong><mark class="hl-label blue">保活计时器</mark> </strong></p><p><strong>在 TCP 连接建立的时候指定了 <code>SO_KEEPALIVE</code> ，保活定时器才会生效</strong> 。如果客户端和服务端长时间没有数据交互，那么需要保活定时器来判断是否对端还活着，但是这个其实很不实用，因为默认是 2 小时没有数据交互才探测，时间实在是太长了。如果你真的要确认对端是否活着， 那么应该自己实现心跳包，而不是依赖于这个保活定时器。详细参见<a href="https://jyxcpp.netlify.app/2022/08/08/tcp%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/">此处</a> 。</p><p><strong><mark class="hl-label blue">FIN_WAIT_2定时器</mark> </strong></p><p>主动关闭方收到第二次挥手的 FIN 报文后进入 <code>FIN_WAIT_2</code> 状态。由于可能因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的 FIN，所以需要 <code>FIN_WAIT_2</code> 定时器进行计时， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的 FIN 那么直接释放这个连接。对于 close() 函数关闭的连接，由于无法再发送和接收数据，所以 <code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒；对于 shutdown() 函数，主动关闭方无法再发送数据，但还可以接收数据，所以可能不会计时，待讨论。</p><p><strong><mark class="hl-label blue">TIME_WAIT定时器</mark> </strong></p><p>第四次握手后，主动关闭方进入 <code>TIME_WAIT</code> 状态，并等待 <code>2MSL</code> 后关闭。关于为什么需要等待 <code>2MSL</code> ，参见<a href="https://jyxcpp.netlify.app/2022/08/03/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/">此处</a> 。<code>MSL</code> 是数据包在网络中的最大生存时间，其值应大于 ip 协议中 <code>TTL</code> 换算的时间，rfc793 建议 <code>MSL</code> 设置为 2 分钟，linux 遵循伯克利习惯设置为 30 s。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP“粘包”</title>
      <link href="/2022/08/08/TCP%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D/"/>
      <url>/2022/08/08/TCP%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>首先需要明白，“TCP 粘包”这个称呼本身是有问题的，因为 <strong>TCP 是面向字节流的协议</strong> ，不存在数据边界，所以 TCP 本身就不会有什么“粘包”的问题。要说“粘包”，这个词更适合形容 UDP 这类 <strong>面向数据报</strong> 的协议。所以说，“粘包”并不是 TCP 的范畴，而是程序员基于错误的理解来实现上层逻辑，从而导致的问题，和 TCP 本身无关。再具体而言，“TCP粘包问题”应该阐述为——<u>在TCP传输协议下，应用层数据拼装发送和接收解析的问题</u> 。不过为了方便描述，下文就采用“TCP粘包”一词。</p></blockquote><p><strong><mark class="hl-label blue">粘包如何产生？</mark> </strong></p><p>“粘包”的首要原因就是 <strong>基于字节流</strong> 这个特点。字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串，而这些 01 串之间 <strong>没有任何边界</strong> 。应用层传到 TCP 协议的数据以字节流的方式发送到下游，这些数据可能被切割（过大）和组装（过小）成段，接收端收到这些段后没有正确还原原来的消息，因此出现粘包现象。粘包可以发生在发送端和接收端。</p><p><strong>发送端：</strong></p><p>在 Nagle 算法（参考<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">此处</a>）开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到 <code>MSS</code> （或含有 <code>Fin</code> 包），立刻发送，否则等待下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为200ms），第一个包没到 <code>MSS</code> 长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><img src="/2022/img/1460000039691668.png" alt="negle引起发送端粘包" style="zoom: 80%;" /><p>如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就像是两个包粘在一起，就会导致粘包问题。</p><p><strong>接收端：</strong></p><p>如果接收端一直较忙，没来得及取出缓冲区的数据，导致缓冲区挤压，最后一次性取出大量数据，也可能产生粘包。</p><img src="/2022/img/1460000039691676.png" alt="关闭Negle也可能粘包" style="zoom:67%;" /><p><strong><mark class="hl-label blue">如何解决粘包？</mark> </strong></p><p>粘包出现的根本原因是不确定 <strong><u>消息</u>的边界</strong> 。接收端在面对&quot;无边无际&quot;的二进制流的时候，根本不知道收了多少 01 才算一个<u>消息</u> 。一不小心拿多了就说是粘包。所以说粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><blockquote><p>应用层的数据包称为“消息”，TCP 的数据包称为“段”，UDP 的数据包称为“数据报”，链路层则称为“帧”。所以，“粘包”也许应该叫“粘消息”，哈哈哈。</p></blockquote><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong> ，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。一般有两种分包方法：</p><ol><li><p><strong>以指定字符（串）为包的结束标志</strong> ：这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如， FTP协议， SMTP 协议，一个命令或者一段数据后面加上&quot;\r\n&quot;（即所谓的 <strong>CRLF</strong> ）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。这种协议一般用于一些包含各种命令控制的应用中。如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。</p><img src="/2022/img/1460000039691673.png" alt="消息边界头尾标志" style="zoom: 50%;" /></li><li><p><strong>包头 + 包体格式</strong> ：这种格式的包一般分为两部分，即包头和包体，<strong>包头是固定大小的</strong> ，且包头中必须含有一个字段来说明接下来的包体有多大。当收到数据时，首先提取包头大小的数据量，解析包头得到包体长度，根据此长度继续提取后面的包体即可。可见，此方法要求接收方从一开始就必须采用约定方式提取数据，而不能中途使用。</p></li></ol><p>下面给出 <mark class="hl-label default">包体+包头</mark>  方式的代码示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制1字节对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">//协议头</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg_header</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int32_t</span>  bodysize;         <span class="comment">//包体大小  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包最大字节数限制为10M</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PACKAGE_SIZE    10 * 1024 * 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatSession::OnRead</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receivTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//while连续读取数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不够一个包头大小</span></span><br><span class="line">        <span class="keyword">if</span> (pBuffer-&gt;<span class="built_in">readableBytes</span>() &lt; (<span class="type">size_t</span>)<span class="built_in">sizeof</span>(msg_header))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LOGI &lt;&lt; &quot;buffer is not enough for a package header, pBuffer-&gt;readableBytes()=&quot; &lt;&lt; pBuffer-&gt;readableBytes() &lt;&lt; &quot;, sizeof(msg_header)=&quot; &lt;&lt; sizeof(msg_header);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取包头信息</span></span><br><span class="line">        msg_header header;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;header, pBuffer-&gt;<span class="built_in">peek</span>(), <span class="built_in">sizeof</span>(msg_header));<span class="comment">//注意只能peek，不能提取，因为倘若接下来根据包头中的字段得到包体大小时，如果剩余数据不够一个包体大小，你又得把这个包头数据放回缓冲区。</span></span><br><span class="line">        <span class="comment">//包头有错误，立即关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> (header.bodysize &lt;= <span class="number">0</span> || header.bodysize &gt; MAX_PACKAGE_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//务必判断bodysize的合法性，有可能是非法客户端发来攻击，也可能数据错误。</span></span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;Illegal package, bodysize: %lld, close TcpConnection, client: %s&quot;</span>, header.bodysize, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            conn-&gt;forceClose();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收到的数据不够一个完整的包</span></span><br><span class="line">        <span class="keyword">if</span> (pBuffer-&gt;<span class="built_in">readableBytes</span>() &lt; (<span class="type">size_t</span>)header.bodysize + <span class="built_in">sizeof</span>(msg_header))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        pBuffer-&gt;<span class="built_in">retrieve</span>(<span class="built_in">sizeof</span>(msg_header));</span><br><span class="line">        <span class="comment">//inbuf用来存放当前要处理的包</span></span><br><span class="line">        std::string inbuf;</span><br><span class="line">        inbuf.<span class="built_in">append</span>(pBuffer-&gt;<span class="built_in">peek</span>(), header.bodysize);</span><br><span class="line">        pBuffer-&gt;<span class="built_in">retrieve</span>(header.bodysize);</span><br><span class="line">        <span class="comment">//解包和业务处理</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Process</span>(conn, inbuf.<span class="built_in">c_str</span>(), inbuf.<span class="built_in">length</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//客户端发非法数据包，服务器主动关闭之</span></span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;Process package error, close TcpConnection, client: %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            conn-&gt;forceClose();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// end while-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">UDP会粘包吗？</mark> </strong></p><p>不会，UDP 面向报文，其报头中有本报文的长度信息，可以区分数据包，所以不会粘包。</p><blockquote><p>参考文章：<a href="https://segmentfault.com/a/1190000039691657">详解粘包</a>，<a href="https://www.zhihu.com/question/20210025">知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拥塞控制详解(一)</title>
      <link href="/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">什么是网络拥塞？</mark> </strong></p><p>当 TCP 数据包经由网络中的路由器传输的时候，如果路由器的收包速度大于处理速度，路由器一般会先把收到的数据包缓存起来等待后续处理。但是当网络传输速度过大时，则会导致路由器的缓存空间全部被占用从而只能丢弃一部分数据包，如果一个路由器或者交换机等网络节点由于性能或者带宽等因素的限制而不能及时处理这些业务数据的时候，就会强制丢包，这种场景就叫做 <strong>拥塞(congestion)</strong> 。</p><p><img src="/2022/img/282120371196460.png" alt="当负载超过Cliff之后，吞吐量就急剧下降，延迟相应急剧上升。Cliff点也就是网络的最大负载，一旦超过网络的整体性能就大打折扣"></p><p><strong><mark class="hl-label blue">拥塞控制和流量控制的关系？</mark> </strong></p><ol><li>流量控制是点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收；拥塞控制是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，关注到传输链路上所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制是以显式的方式在TCP头中通过 Window size 字段通告发送方，流量控制关注的是接收端和发送端；<u>拥塞控制大多是通过隐式的方式控制发送端速率，接收端依据特定的收发包情况来推测网络拥塞状况</u> 。</li></ol><p>简单而言，<strong>流量控制考虑的是接收方的接收能力，拥塞控制考虑的是网络的传输能力</strong> 。网络拥塞本来应该由 IP 协议负责，但因为 IP 是一个不可靠且简单的协议，所以此责任不得不落于 TCP 身上。</p><blockquote><p>具体而言，如果网络上的延时突然增加，那么，TCP 流量控制只重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大，最终导致整个网络的崩溃。</p></blockquote><p>对应流量控制中的 <code>rwnd</code> ，TCP 会维护一个 <code>cwnd</code> 变量来控制拥塞窗口的大小。<strong><font color='orange'>发送端实际可用的窗口大小 <code>W = min(rwnd, cwnd)</code></font></strong> （不过为了方便描述，cwnd 通常指 MMS 大小的包的个数）</p><p>。已经发送但还没有被 ACK 确认的数据量叫做 <strong>flight size</strong> ，<strong>拥塞控制限制发送速率的方式就是让 <code>flight size&lt;=W</code></strong> ，另外有两点需要注意：</p><ol><li><p>在没有使用 SACK 时，flight size 就是当前已经发送数据包的最大 seq 减去当前接收到的最大 ACK Number。</p></li><li><p>在使用 SACK 时，flight size 还需要扣除被 SACK 反馈的数据包。</p></li></ol><blockquote><p>W 的合理值应该接近网络的 <strong>带宽延迟积</strong> 。</p><p><strong>数据包守恒原则：</strong> 在一个运行平稳的 TCP 连接中流动的数据包应该是守恒的，意思是当只有旧的数据包被成功传输到对端后，新的数据包才能加入到连接中。传输中的包称为 in_flight ，进行拥塞控制的时候，如果 <code>in_flight&gt;=cwnd</code> 的，就表示拥塞窗口不允许在额外发送数据包了。</p></blockquote><p>TCP 拥塞控制主要包含下面四个算法：<strong>慢启动，拥塞避免，快速恢复，快速重传</strong> 。</p><h3 id="font-color-red-慢启动-font"><font color='red'>慢启动</font></h3><p>一个 TCP 连接启动的时候并不知道 cwnd 应该取多大的值适合当前的网络状况，因此 TCP 发送方会从一个较小的初始值指数抬升 cwnd 到某一个值，这个 cwnd抬升的过程就叫做慢启动。慢启动算法如下：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><img src="/2022/img/271.jpg" alt="慢启动算法" style="zoom:50%;" /><blockquote><ul><li>注意，是 <strong>每个 ACK</strong> 都会使 <code>cwnd</code> 翻倍，而不是每一批 ACK（拥塞避免采用）。可见，慢启动会进行指数增长，<code>cwnd</code> 短时间内迅速增大，为防止其过大，还需要引入 <strong>慢启动阈值(ssthresh)</strong> ，一旦达到阈值，便进入 <strong>拥塞避免</strong> 。</li><li>如果延迟确认，则也会进行指数增长，不过是 1.5 的幂。</li><li>Linux 3.0后把 <code>cwnd</code> 初始化成了 10个 MSS。</li></ul></blockquote><h3 id="font-color-red-拥塞避免-font"><font color='red'>拥塞避免</font></h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd，即每收完同一批数据包的ACK，cwnd++</strong> 。</p><img src="/2022/img/281.jpg" alt="拥塞避免" style="zoom:67%;" /> <p>显然，慢启动是指数增加算法，而拥塞避免是线性增加算法，两种方法合起来常称为 <strong>AIMD算法</strong>（加法增大乘法减少）。这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><h3 id="font-color-red-拥塞处理-font"><font color='red'>拥塞处理</font></h3><p>拥塞窗口增大的过程中，也随时有可能发生拥塞。TCP 中，一般使用两种事件作为拥塞发生的标志：1）<strong>超时重传</strong> ；2）<strong>收到三次重复 ACK</strong> ；收到三次重复 ACK 情况下的拥塞程度低于超时重传，因为当发送方收到三次重复 ACK 时，说明一个段发生了丢失或延迟，但三个段已经被接收，说明网络拥堵有所恢复。</p><p>TCP 如下处理这两种拥塞情况：</p><ol><li><strong>RTO超时：</strong><ul><li>sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ul></li><li><strong>收到三次重复 ACK（TCP Reno）：</strong><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li><li>进入快速恢复算法</li></ul></li></ol><h3 id="font-color-red-快速恢复-font"><font color='red'>快速恢复</font></h3><p>快速恢复和快速重传一般同时使用。快速恢复算法如下：</p><ul><li>cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）</li><li>重传 Duplicated ACK 指定的数据包</li><li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li><li>如果收到了新的 ACK，那么，cwnd = sshthresh ，然后就进入拥塞避免的算法。</li></ul><img src="/2022/img/拥塞发生-快速重传.drawio.png" alt="Reno 快速恢复" style="zoom:67%;" /><p><strong><mark class="hl-label blue">cwnd=ssthresh+3，为什么加3？</mark> </strong></p><p>因为既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大些。后续收到冗余 ACK 仍增加的原因同理。</p><blockquote><p>然而上面这个算法也存在问题，那就是——它依赖于 3 个重复的 ACK 。注意，3 个重复的 ACK 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。SACK 或 D-SACK 的方法虽然可以让 Fast Recovery 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。New Reno 对此做出了改进。</p></blockquote><p><strong>New Reno下的快速恢复：</strong></p><ul><li>当发送方这边收到了3个 Duplicated ACK，进入快速重传模式，重传冗余 ACK 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 ACK 可以确认所有已经被发送方传输出去的数据。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li><li>一旦发送方这边发现了 Partial ACK 出现，那么，发送方就可以推理出来有多个包被丢了，于是乎继续重传窗口内未被确认的第一个包。直到再也收不到 Partial Ack，才真正结束快速恢复这个过程。</li></ul><p>另一种带有 SACK 的快速恢复是 <strong>FACK</strong> 算法，自行了解，我也不懂。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/lshs/p/6038757.html">拥塞算法</a>，<a href="http://www.52im.net/thread-515-1-1.html">TCP概述</a>，<a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D">小林coding</a>，<a href="https://blog.csdn.net/dl962454/article/details/115796513">拥塞简介</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP流量控制详解</title>
      <link href="/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-滑动窗口-font"><font color='red'>滑动窗口</font></h3><p>TCP 流量控制基于 <strong>滑动窗口</strong> (连续 ARQ 协议) 实现。滑动窗口既保证了分组无差错、有序接收，也实现了流量控制。</p><p><img src="/2022/img/101120ihanzfsth0hhcllk.png" alt="发送方滑动窗口示意图"></p><p>发送方的滑动窗口由接收方控制，实现方法为：在接收方传递给发送方的报文中加入 Window Size 信息，从而告知发送方自己的窗口大小，<strong>且发送方必须服从接收方的管理</strong> 。在 TCP 实现中，<strong>两端的窗口大小相同</strong> 。另外需要注意的是，发送方不一定会一次性发送整个窗口的数据，这根据网络情况而定。</p><blockquote><p><strong><font color='orange'>窗口本身是一种抽象</font></strong> ，发送窗口有三个变量实现，分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> （第一个未完成分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Sn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span></span></span></span> （下一个待发送分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mrow><annotation encoding="application/x-tex">S{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span> （窗口大小）。</p><img src="/2022/img/IMG_0427(20220802-163852).PNG" alt="窗口的抽象" style="zoom:50%;" /></blockquote><p><img src="/2022/img/104946z1skgjjxx8g0txbx.png" alt="滑动窗口示意图"></p><p>一般而言，流量控制分为两种：1）发送方输出的流量过多，接收方来不及接收。2）发送方发得太少，导致浪费带宽（数据只有一两个字节，而报头就占了几十个字节）。对于第一种则很好控制，只要发送方将每次输出的流量控制在接收方告知的窗口大小内即可；对于第二种情况(被称之为 <strong>糊涂窗口综合征</strong> )，则相对复杂。</p><blockquote><p><strong>糊涂窗口综合征</strong> ：当发送端进程产生数据缓慢或接收端进程数据拉取缓慢时，会导致发送方以很小的段发送，这会降低信道的利用率。这个问题称之为糊涂窗口综合征。此问题可以从发送方和接收方解决：</p><ul><li><strong><font color='orange'>发送方： Nagle 算法，Cork 算法</font></strong></li><li><strong><font color='orange'>接收方：Clark Solution，延迟确认</font></strong></li></ul></blockquote><h3 id="font-color-red-延迟确认-font"><font color='red'>延迟确认</font></h3><p><strong>延迟确认（Delayed Acknowledgements）用于接收方</strong> ，其工作原理：当包到达接收方时，不立即确认，而是等待一定时间再发送确认。等待一段时间有两个好处：</p><ol><li>此时间内接收方进程可以拉取数据，清空部分缓冲区以提供更大窗口（这样就可以使发送方一次发送更多的字节）。</li><li>接收方不必确认每一个段，减少了 pure ACK ，提高了通信效率。这基于发送方的 <strong>累积确认</strong> 。</li></ol><p>需要注意，<strong><font color='orange'>延迟确认最多延迟一次，即每两个报文就必须发送 ACK 报文；最多延迟 0.5 秒，若未等到下一个包，则直接发送 ACK</font></strong> 。同时，<u>延迟确认必须同时满足以下几点才可使用</u> ：</p><ol><li><p><strong>当前已经收到的但是还没有回复 ACK 的报文长度小于接收 MSS。</strong></p><blockquote><p>这很好理解，<u>TCP 是基于字节流的协议</u> ，数据没有边界，所以发送方填充数据时应该会将每个段填充到最大长度（ MMS ）时才会继续填充下一个。若数据长度未达 MMS，我们就可以合理猜测对方数据已经发送完（也可能是因为对方进程产生数据太慢）。</p></blockquote></li><li><p><strong>当前没有处于 quick ACK模式</strong></p></li><li><p><strong>当前接收窗口中没有先前接收的乱序报文</strong></p></li></ol><p>仅有延迟确认机制，不会导致请求延迟(初以为是必须等到 ACK 包发出去，recv系统调用才会返回)。一般来说，只有当该机制与Nagle算法或拥塞控制(慢启动或拥塞避免)混合作用时，才可能会导致时耗增长。</p><blockquote><p><strong>quick ACK：</strong></p><p>与延迟 ACK 对应，Linux 还有一个 quick ACK 模式，这种 quick ack 模式下就会对每个数据包都回复一个 ACK。在<u>连接初始建立时候</u> 、<u>收包间隔大于 RTO 时</u> 、<u>收到不在接收窗内的报文的时候</u>  等场景下就会进入 quck ack 模式，进入 quick ac k模式的时候，会把 quick ack 计数器初始化为 16 (也有可能是小于16的某个值)，这就是说随后的 16 个数据包都不采用延迟 ACK。</p></blockquote><h3 id="font-color-red-Nagle-算法-font"><font color='red'>Nagle 算法</font></h3><blockquote><p>如果发送方 TCP 正在为一个创建数据很缓慢的进程服务，则可能引起糊涂窗口综合征。解决方法是防止发送方一个一个字节地发送数据。发送方被迫等待到将数据集成较大的数据块时再发送。那么需要等待多久？太长，延误进程；太短，数据不够长，效率低。Nagle 提供了一个简单的方法解决此问题。</p></blockquote><p><strong>Nagle 算法用于发送方</strong> ，其方法非常简单：</p><ol><li>即使从发送方进程接收来的数据只有 1 字节，也直接将其封装并发送。</li><li>发送第一个段后，发送方在缓冲区积累数据并等待，<strong><font color='orange'>直到发送方接收到 ACK 或数据积累到 MMS 或包中有 FIN 再发送。</font></strong></li></ol><p><strong><mark class="hl-label blue">Nagle与延迟ACK引发死锁</mark> </strong></p><p>当 Nagle 算法和延迟 ACK 同时使能的时候，可能会造成如下情况：</p><ol><li>客户端发送第一个小包，并被服务端接收。</li><li>客户端等待 ACK 或数据长度达到 MMS。</li><li>服务端延迟确认等待下一个包直到超时（0.5s）。</li></ol><p>这使得两端相互等待，引发 <strong>死锁(deadlock)</strong> 。这种情况下就会提升平均时延，降低网络性能，因此可能需要禁用Nagle算法或者延迟ACK算法。另外，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序</strong> ，你需要关闭这个算法。在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法</p><h3 id="font-color-red-Cork-算法-font"><font color='red'>Cork 算法</font></h3><p><strong>Nagle 算法用于发送方</strong> 。Cork 算法与 Nagle 算法类似，但 Cork 算法则更为激进，一旦打开 Cork 算法，TCP 不关注是否有收到 ACK 报文，只要当前缓存中累积的数据量不满 MMS 时，就不会将数据包发出，直到一个 RTO 超时后才会把不满 MMS 的数据包发出去。</p><p>linux 中可以通过 <code>TCP_CORK</code> 选项来设置 Socket 打开 Cork 算法。<code>TCP_NODELAY</code> 选项和 <code>TCP_CORK</code> 选项在 Linux 早期版本是互斥的，但目前最新的 linux版本已经可以同时打开这两个选项了，但是 <code>TCP_CORK</code> 选项的优先级要比 <code>TCP_NODELAY</code> 选项的优先级要高。</p><blockquote><p>CORK 与 Nagle 的区别是，Nagle 算法是尽量避免大量的小包发送，而 CORK 算法是期望完全避免发送小包（无论是大量还是少量的小包）。</p></blockquote><h3 id="font-color-red-Clark-Solution-font"><font color='red'>Clark Solution</font></h3><p><strong>Clark Solution 用于接收方</strong> 。要避免接收方的糊涂窗口综合征，简单的办法就是不让接收方窗口每次只更新少量可用缓冲区，直到有较大空间时，才通知发送方窗口大小。Clark 解决方法是 <strong><font color='orange'>只要有数据到达就发送确认，但宣布的窗口大小为零，直到窗口足够放入具有最大长度的报文段，或者至少半个缓存空间是空的</font></strong> 。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/lshs/p/6038647.html">Cork</a>，<a href="https://www.cnblogs.com/lshs/p/6038641.html">Nagle</a>，<a href="https://www.cnblogs.com/lshs/p/6038635.html">延迟ACK</a>，<a href="http://www.52im.net/thread-515-1-1.html">TCP简介</a>，《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP重传机制详解</title>
      <link href="/2022/08/07/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/07/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-超时重传-font"><font color='red'>超时重传</font></h3><p><strong><font color='orange'>超时重传基于定时器，以时间驱动重传</font></strong> 。当发送端发送数据包后会启动相应计时器，如果在一定时间内未收到接收端发来的 ACK 报文导致计时器超时，则会重传相应报文。</p><blockquote><p>需要注意的是，是仅重发相应超时报文还是重发所有未完成（已发出但未收到 ACK）的报文，在各个机制中有所不同（这取决于定时器的数量）。比如在【停等协议】中， 仅有一个定时器，一旦超时，重发所有未完成包；而在【选择重传协议】中，每个报文都有一个定时器，超时后仅重传对应报文。详细内容见：<a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">详解ARQ协议</a></p></blockquote><p>超时重传面临三个主要问题：</p><ol><li><p><strong>RTO(重传时间) 如何确定？</strong></p></li><li><p><strong>超时才发生重传，延迟较高。</strong></p></li><li><p><strong>发生超时后，重传哪些包？</strong></p><blockquote><p>比如，发送端按序发送 1，2，3，4，5 个包，发送端只接收到第 1，2，4，5个包，那么接收端只能发送 ACK = 3 的 ACK 报文（表明 3 之前的都已收到），发送端收到 ACK 报文后，定时器超时， 由于此时第 3，4，5 的 ACK 报文都没有收到，那么发送端该重发哪些报文呢？只发 3 的报文还是发送 3，4，5 的报文？前者会节省带宽，但是若 4，5 真的也丢失了，又会等待重传；后者会快一点，但是会浪费带宽，也可能会有无用功。</p></blockquote></li></ol><p>对于第一个问题，笔者写了另一篇文章详尽阐述，参见<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">此处</a> ；对于第二个问题，<strong>快速重传</strong> 机制会很好地解决；对于第三个问题，<strong>SACK</strong> 机制派上用场。另外需要知道的是，若连续超时重传，则会进行 <a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">指数回退</a> ，超过一定次数则会终止连接，务必参见<a href="https://www.cnblogs.com/lshs/p/6038527.html">重传示例</a> 。</p><h3 id="font-color-red-快速重传-font"><font color='red'>快速重传</font></h3><p><strong><font color='orange'>快速重传不以时间为驱动，而以数据驱动重传。</font></strong> 【快速重传】机制如下图：</p><p><img src="/2022/img/140607dww7fwawwfft7a1j.png" alt="快速重传示意图"></p><p>如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ACK 回2，结果 2 因为某些原因没收到，3 到达了，于是还是 ACK 回2；后面的 4 和 5 都到了，但是还是 ACK 回 2，因为 2 还是没有收到，于是发送端收到了四个 <code>ACK = 2</code> 的确认，知道了 2还 没有到，于是就马上重传 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是回复 <code>ACK = 6</code> 。</p><blockquote><p><strong>注意！大多数书上和博客对【重复】描述并不清晰，个人认为应该如此描述：1. 收到三个 <u>冗余</u> 的ACK，重传；2. 收到四个 <u>重复</u> 的ACK，重传；</strong></p></blockquote><p>**<mark class="hl-label blue">为什么要重复三次才发送？</mark>  **<br>那是因为 dup ACK 即可能是丢包造成的，也可能是网络乱序造成的。基于实验，定值为 3 。</p><p>然而，【快速重传】机制只解决了【超时重传】的时间延迟较长的问题，但还是没有解决第三个问题。对于上面的示例来说，是重传 2 呢还是重传 2，3，4，5呢？因为发送端并不清楚这连续的 3 个 <code>ACK = 2</code> 是谁传回来的。也许发送端发了 20 份数据，是 6，10，20 传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些 TCP 的实际的实现）。为此，引入【SACK方法】。</p><h3 id="font-color-red-SACK-font"><font color='red'>SACK</font></h3><p>【SACK】即 Selective Acknowledgment ，这种方式需要在 TCP 头部里加一个 SACK 选项，选项格式如下：</p><img src="/2022/img/image-20220807120644997.png" alt="image-20220807120644997" style="zoom:67%;" /><img src="/2022/img/140643mooa22groefuggoh.jpg" alt="SACK示意图" style="zoom: 67%;" /><p><code>SACK</code> 汇报的是接收方当前 ACK 号之后的已经收到的字节数。通过 <code>SACK</code> ，发送方就可以判断接收方还有哪些包没有收到，进而就可以只重传特定的分组，大大提高了效率。同时注意：</p><ol><li>如果要支持 <code>SACK</code>，必须双方都要支持，在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）；</li><li><strong>TCP的选项不能超过40个字节，所以 SACK 段不能超过4组</strong>。</li><li>接收方可能 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，<strong>发送方也不能完全依赖 SACK</strong> ，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传。</li><li>SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</li></ol><blockquote><p>需要注意，【SACK】是【选择性确认】，不同于 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">ARQ</a> 协议中的【选择重传】，二者有相似之处，但前者并不代替 ACK，只是在 ACK 报文中添加额外的信息来帮助发送方进行确认。</p></blockquote><h3 id="font-color-red-DSACK-font"><font color='red'>DSACK</font></h3><p>Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。采用如下方法判断是 SACK 还是 DSACK：</p><ul><li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 DSACK</li><li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 DSACK</li></ul><p>DSACK 用法举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一.ACK丢包</span><br><span class="line"></span><br><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line">  </span><br><span class="line">3000-3499    3000-3499   3500 (ACK dropped)</span><br><span class="line">3500-3999    3500-3999   4000 (ACK dropped)</span><br><span class="line">3000-3499    3000-3499   4000, SACK=3000-3500</span><br><span class="line">----------------------------------------------</span><br><span class="line">二.网络延迟</span><br><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line">  </span><br><span class="line">500-999        500-999     1000</span><br><span class="line">1000-1499      (delayed)                         -&gt;| SACK</span><br><span class="line">1500-1999      1500-1999   1000, SACK=1500-2000    | SACK</span><br><span class="line">2000-2499      2000-2499   1000, SACK=1500-2500    | SACK</span><br><span class="line">2500-2999      2500-2999   1000, SACK=1500-3000    | SACK</span><br><span class="line">1000-1499      1000-1499   3000                    |</span><br><span class="line">               1000-1499   3000, SACK=1000-1500  &lt;-| DSACK</span><br></pre></td></tr></table></figure><p><strong>可见，引入了D-SACK，有这么几个好处：</strong></p><ul><li>可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</li><li>是不是自己的 timeout 太小了，导致重传。</li><li>网络上出现了先发的包后到的情况</li><li>网络上是不是把我的数据包给复制了。</li></ul><p>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控。Linux下的 <code>tcp_dsack</code> 参数用于开启这个功能（Linux 2.4后默认打开）。</p><blockquote><p>从纠错层面上而言，DSACK 和 SACK 完全相同，只是 DSACK 在收到包且重复的情况下也会反馈信息给发送方，使发送方更全面地了解网络情况。</p></blockquote><h3 id="font-color-red-早期重传（ER）-font"><font color='red'>早期重传（ER）</font></h3><blockquote><p>学习【快速重传】时，你可能会想到，万一经常出现发送方只收到两次或者一次冗余的 ACK 报文而无法快速重传报文时，咋办？只有等定时器超时吗？那这样效率是不是又会降下来？是对，为了解决此类情况，谷歌提出了【早期重传】。</p></blockquote><p>按照 RFC5827，ER 有两种形式一种是基于字节的，一种是基于包的，基于包的ER精度要高于基于字节的ER，linux 实现的是基于 TCP 包的 ER，因此我们这里只介绍基于包的ER。</p><p><strong>ER 是在没有新数据可以发送的场景下降低快速重传 dup ACK的门限</strong> ，dup ACK 是由乱序 TCP 报文触发的，但是发出的总数据包的个数少于 4 个的时候，就会因为没有足够的 dup ACK 而不能触发快速重传(假设默认 dup ACK 门限是 3)。<strong>当同时出现下面两个条件时，启用ER：</strong></p><ol><li>发出去的但是还没有收到ACK确认的TCP报文个数 (oseg) 小于 4。</li><li><u>缓存中没有未发送数据或者发送窗口受限不能发送新数据</u> （如果允许发送新数据的话就可以进一步触发 dup ACK 来达到门限了。）</li></ol><p>当满足上面两个条件时候，如果这个 TCP 未使能 SACK 的时候，用来触发 ER 的 dup ACK 门限必须降低为 <code>ER_thresh = oseg - 1</code> ；当这个 TCP 连接 SACK 的时候，触发 ER 的条件则变为，<code>(oseg-1) 个TCP包已经被 SACK 确认</code> 。</p><blockquote><p><strong>最好启用 SACK ，原因如下：</strong></p><p>假设发送 1，2，3 个包，第 1，3 个包顺利到达，第 2 个包丢失，此时可能有以下两种情况：</p><ol><li>第 1 个包被接收到时延迟确认，当收到第 3 个包时，必须发送 ACK=2  包（延迟确认机制最多只能延迟一个包）。那么此时如果未开启 SACK ，发送发就会收到一个正常的 ACK，而不是 dup ACK 。这样一个 dup ACK 都没有收到过，所以也就不会触发ER机制，而只能靠RTO超时来进行重传(而且S2和S3都要重传)；如果开启了 SACK，则发送方知道第 1，3 个包已经被收到，于是确认（SACKED）这两个包，并启用 ER 发送第 2 个包。</li><li>第 1 个包被收到时直接返回确认，则都会开启 ER 。</li></ol></blockquote><blockquote><p>参考文章：<a href="https://www.cnblogs.com/lshs/p/6038527.html">重传次数到底怎么定？</a> ，<a href="https://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/">早期重传</a> ，<a href="http://www.52im.net/thread-513-1-1.html">TCP详解</a> ，<a href="https://www.cnblogs.com/lshs/p/6038575.html">TCP 20</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP Fast Open(TFO)</title>
      <link href="/2022/08/05/TCP-Fast-Open-TFO/"/>
      <url>/2022/08/05/TCP-Fast-Open-TFO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>当前 web 和 web-like 应用中一般都是在三次握手后开始数据传输，相比于 UDP，多了一个 RTT 的时延，即使当前很多应用使用 <strong>长连接</strong> 来处理这种情况，但是仍然由一定比例的短连接，这额外多出的一个 RTT 仍然对应用的时延有非常大的影响。TFO就是在这种背景下面提出来的。</p></blockquote><h3 id="font-color-red-什么是-TFO？-font"><font color='red'>什么是 TFO？</font></h3><img src="/2022/img/e8b8def71ea7471dac12535fe1068790tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="对比图" style="zoom:67%;" /><p>说明：TCP 第三次握手发送的 ACK 报文可以携带数据，所以当客户端收到 HTTP Response 前需要两个来回（RTT），而在 TFP 第二次及以后的请求中，只需要一个来回（RTT）就可收到数据。</p><p>我们知道当前网络上的 TCP 流量大部分是 <strong>短连接</strong> (short TCP conversation)，比如浏览 http 网页。这种连接的特点是：连接持续时间不长，除去三次握手和四次挥手的控制报文交互，它们之间的数据报文并不多。三次握手和四次挥手占据通信较大比例，这就使得通信效率降低。</p><blockquote><p>点击此处：<a href="https://cloud.tencent.com/developer/article/1640430">什么是短链接与长连接？</a></p></blockquote><p>尽管 <a href="https://switch-router.gitee.io/blog/tcp-fastopen/(https://tools.ietf.org/html/rfc793)">RFC793</a> 并没有禁止 SYN 报文携带数据，<u>但所有的 TCP 实现默认都不会使用</u> 。原因是这不太安全，站在 Server 的角度，收到这样一个 SYN 报文，但这个时候 TCP 握手还没完成呢，对端真的可信吗？说不定是一个伪造源端的 TCP 报文，稳妥起见，这个数据报文还是等握手完成之后再上送给应用吧。<u><strong>这就是 TCP Fast Open 的来源，它允许在第一个握手的 SYN 报文中携带数据，如此以来，短连接便可以节省一次来回的 RTT。</strong></u> 即使 Web 浏览器之类的应用程序尝试使用HTTP 长连接来缓解此问题，即浏览器保持与 Web 服务器的连接，并将该连接重用于以后的 HTTP 请求。但是，这种技术的有效性会降低，因为空闲连接可能会在它们被重用之前关闭。<u>例如，为了限制资源使用，繁忙的 Web 服务器通常会主动关闭空闲的 HTTP 连接。</u></p><h3 id="font-color-red-TFO过程-font"><font color='red'>TFO过程</font></h3><ol><li>在使用 TFO 之前，client 首先需要通过一个普通的三次握手连接获取 <strong>FOC</strong> (Fast Open Cookie)<ul><li>1.client 发送一个带有 Fast Open 选项的SYN包，同时携带一个空的 cookie 域来请求一个 cookie</li><li>2.server 产生一个 cookie，然后通过 SYN-ACK 包的 Fast Open 选项来返回给 client</li><li>3.client 缓存这个 cookie 以备将来使用 TFO 连接的时候使用</li></ul></li><li>执行 TFO<ul><li>1.client 发送一个带有数据的 SYN 包，同时在 Fast Open 选项中携带之前通过正常连接获取的 cookie</li><li>2.server 验证这个 cookie。如果这个 cookie 是有效的，server 会返回 SYN-ACK 报文，然后这个 server 把接收到的数据传递给应用层。如果这个 cookie是无效的，server 会丢掉 SYN 包中的数据，同时返回一个 SYN-ACK 包来确认 SYN 包中的系列号。</li><li>4.client 发送ACK包来确认 server 的 SYN 和数据，如果 client 端 SYN 包中的数据没有被服务器确认，client 会在这个 ACK 包中重传对应的数据。</li><li>4.剩下的连接处理就类似正常的 TCP 连接了，client 一旦获取到 FOC，可以重复 Fast Open 直到 cookie 过期。</li></ul></li></ol><h3 id="font-color-red-注意事项：-font"><font color='red'>注意事项：</font></h3><p><strong><mark class="hl-label blue">Cookie 的格式：</mark> </strong></p><p>Cookie 通过 TCP 的选项(Kind = 34)在 TCP 双方之间交互，其格式如下。它的值由 Server 根据 &lt;ClinetIP、ServerIP&gt; 生成。注意，<strong>Cookie 与 TCP 端口号无关</strong> ，即使应用程序不同，<strong>只要 Client 和 Server 使用的 IP 不变，两台主机上的 TCP 程序就可以复用一个 Cookie</strong> ，换句话说，这个 Cookie 是主机粒度的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">                                |      Kind     |    Length     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">~                            Cookie                             ~</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">Kind            1 byte: value = 34</span><br><span class="line">Length          1 byte: range 6 to 18 (bytes); limited by</span><br><span class="line">                        remaining space in the options field.</span><br><span class="line">                        The number MUST be even.</span><br><span class="line">Cookie          0, or 4 to 16 bytes (Length - 2)</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">TFO 重连：</mark> </strong></p><p>TFO 场景下，client 在超时重传 SYN 包以及 server 超时重传 SYN-ACK 报文的时候应该去掉 Fast Open 选项和对应的数据，以免因为<strong>不兼容 TFO</strong> 而导致连接建立失败。<u>TFO 功能需要在 TCP 通信的双方都启用时才会生效</u> 。</p><p><strong><mark class="hl-label default">TFO 不保证幂等性</mark> </strong></p><blockquote><p><strong>什么是幂等性？</strong></p><p><strong>幂等</strong> 是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。在 TCP 中，幂等性可以指对重复包的丢弃。</p></blockquote><p>虽然 TCP 保证重复数据包(重复经常发生)会被接受者忽略，但是<strong>这个保证并不适用于连接的握手过程</strong> 。在 TFO 下随着 SYN 发送的数据有可能重复递交到应用层。例如在 IP 层不可靠传输的情况下，发送端的一个 SYN 包被传输成了两个 SYN 包，而在接收端，接收到第一个SYN包后，接收端把随SYN的数据传递到应用层，然后继续收到第二个重复包则可能再次将随 SYN 传输的数据再次传向应用层。<u>因此如果应用层不能忍受这种包重复，则不能开启TFO特性。</u></p><blockquote><p>参考文章：<a href="https://www.cnblogs.com/lshs/p/6038488.html">TCP Fast Open</a> ，<a href="https://toutiao.io/posts/1580/app_preview">移动网络性能解密</a> ，<a href="https://lwn.net/Articles/508865/">TFO详解</a> ，<a href="">TFO</a><a href="https://switch-router.gitee.io/blog/tcp-fastopen/">https://switch-router.gitee.io/blog/tcp-fastopen/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTT的测量（RTTM）</title>
      <link href="/2022/08/05/RTT%E7%9A%84%E6%B5%8B%E9%87%8F/"/>
      <url>/2022/08/05/RTT%E7%9A%84%E6%B5%8B%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>我们直到，重传机制是 TCP 协议中一种重要的通信保障手段。在超时重传下，当重传计时器超过 RTO (Retransmission Time Out) 时就会终止计时器并重发。而其中 RTO 是基于 RTT （Round-Trip Time）得到的，那么 RTT 又是如何得到的呢？似乎看起来很简单，好像就是在发送端发包时记下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，接收到 ACK 报时再记一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，于是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mtext>–</mtext><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">RTT = T_1 – T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  。没那么简单，这只是一个采样，不能代表普遍情况。</p></blockquote><h4 id="font-color-red-Jacobson-Karels-算法-font"><font color='red'>Jacobson / Karels 算法</font></h4><ol><li><p>我们需要采样一些 RTT，称为 <strong>SampleRTT</strong> 。需要注意， SampleRTT 与单个分组没有一一对应的关系，由于 <strong>延迟确认</strong> 的存在，两个确认可能合并为一个 ACK 包。SampleRTT 可能随网络情况而波动，任何值都可能是不典型的，所以直接使用 SampleRTT 是不可靠的。</p></li><li><p>为了估计一个典型的 RTT，自然想到对 SampleRTT 求平均（加权平均），得到<strong>平滑RTT（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">RTT_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</strong> ，计算方法如下：<br><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mi>α</mi><mo>×</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RTT_S = (1 - α)RTT_S+α×SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span></span></span></span></strong></p><p>其中 α 取决于实现，一般为 0.125</p></li><li><p>另外，还需要引入 RTT偏差（DeviationRTT），即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTT_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，其计算依赖于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">RTT_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 SampleRTT：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>β</mi><mo>×</mo><mi mathvariant="normal">∣</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>−</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">RTT_D=(1-β)×RTT_D+β×|RTT_S-SampleRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mord">∣</span></span></span></span></p><p>其中 β 取决于实现，一般为 0.25</p></li><li><p>最后根据 RTT 计算 RTO：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mn>4</mn><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTO=RTT_S+4×RTT_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RTO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li></ol><p>上面的叙述为了流畅性省略了一些内容，下面是全过程：</p><img src="/2022/img/IMG_0439(20220805-181810).PNG" alt="RTO计算过程" style="zoom: 50%;" /><p>下面给出一个例子：当 <code>SNY+ACK</code> 段传来时，SampleRTT 被测量为 1.5 秒，计算 RTO：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">SampleRTT=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.13889em;">RTT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">RTT_S=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.5</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mn>1.5</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>0.75</mn></mrow><annotation encoding="application/x-tex">RTT_D=1.5/2=0.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1.5/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mn>1.5</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>0.75</mn></mrow><annotation encoding="application/x-tex">RTO=1.5+4×0.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RTO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span></span></span></span></li></ol><blockquote><p>平均 RTT 一般定为 0.25 秒；同时需要注意，<strong>RTT 指的是传播时延而非传输时延</strong> ；<code>RFC 6298</code> 推荐的初始 RTO 为 1 秒。</p></blockquote><h4 id="font-color-red-Karn算法-font"><font color='red'>Karn算法</font></h4><p>重传计时器超时会重发报文。而上面的这个算法对于重传会遇到这样一个问题：当发送方收到来自接收方的 ACK 段时，如何判别这个段是第一次发的还是重传的？即使知道，也会面临如下问题：你是用第一次发数据的时间和 ACK 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？</p><img src="/2022/img/101017ipbtj3eijbtmj2j2.jpg" alt="示意图" style="zoom:67%;" /><ul><li>情况（a）是 ACK 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li><li>情况（b）是 ACK 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li></ul><p>而 <strong>Karn</strong> 算法简单粗暴地解决了此问题——<u>当需要重传时，则不采用此报文来测量 RTT，等到发送方不需要重发某个段时，再进行采样</u> 。但是，这样一来，又会引发一个新问题——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重传所有的包。由于重转的不采样，RTO 就不会被更新，这导致网络实时状况被发送端忽略（发送方就无法合理调整后续发送行为），可能加重网络拥塞。<strong>Karn</strong> 算法据此提出 <strong><font color='orange'>指数回退</font></strong> ，当发生重传时，则 RTO 翻倍。例如重传一次后 RTO = 2 s，还未收到，再重传一次，RTO = 4 s …<br><strong>即，Karn 算法规定两点：1）碰上重传则不采样；2）碰上重传则 RTO 翻倍。</strong></p><h4 id="font-color-red-时间戳测量RTT-font"><font color='red'>时间戳测量RTT</font></h4><p>详解笔者的另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/04/tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">时间戳RTTM</a></p><blockquote><p>文章参考：《计算机网络自顶向下第六版》 ，《计算机自顶向下第七版》 ，<a href="https://www.cnblogs.com/lshs/p/6038536.html">TCP 14</a> ，<a href="http://www.52im.net/thread-515-1-1.html">即时通讯网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间戳——RTTM与序列号回绕</title>
      <link href="/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/04/TCP-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="font-color-red-时间戳格式-font"><font color='red'>时间戳格式</font></h4><p>时间戳（TimeStamp—TSOPT）选项格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           Kind: 8</span></span><br><span class="line"><span class="comment">//         Length: 10 bytes</span></span><br><span class="line"><span class="comment">//          +-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="comment">//          |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|</span></span><br><span class="line"><span class="comment">//          +-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="comment">//              1       1              4                     4</span></span><br></pre></td></tr></table></figure><p><code>TSval</code> 表示发送端发出该报文时的本地时间戳， 而 <code>TSecr</code> 则负责回放 (Echo) 最近一次收到的对端报文中的 <code>TSval</code> 的值。下面是一组典型的时间戳交互过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                   TCP  A                               TCP B</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;A,TSval=1,TSecr=120&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(A),TSval=127,TSecr=1&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;B,TSval=5,TSecr=127&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(B),TSval=131,TSecr=5&gt;</span></span><br></pre></td></tr></table></figure><p>启用 Timestamp 选项需要经过双方的协商，<u>协商在三次握手时完成</u> ，<font color='orange'>如果协商成功,则在后续的报文中， 除了 RST 之外的所有报文均必须包含 Timestamp 选项，若未协商成功，即使后续报文有 Timestamp 选项也一并忽略。</font></p><h4 id="font-color-red-时间戳作用-font"><font color='red'>时间戳作用</font></h4><p>在RFC1323中，TSOPT主要有两个用途一个是 <strong>RTTM</strong>  (round-trip time measurement)即根据 ACK 报文中的这个选项测量往返时延，另外一个用途是 <strong>PAWS</strong>  (protect against wrapped sequence numbers)，即防止同一个连接的系列号重叠。另外还有一些其他的用途，如 SYN-cookie、 Eifel Detection Algorithm 等等。下面详述前两个用途。</p><h5 id="font-color-orange-RTTM-font"><font color='orange'>RTTM</font></h5><blockquote><p>对此，时间戳不能走得太慢，这是为了能更准确地测量报文的 RTT。假设这个时钟 10s 才 tick 一下，那么对于 往返时间为 1s 的 TCP 连接，一端发送报文之后，很有可能会发现收到对端的 ACK 报文中的 TSecr 和当前时钟 的值是一样的，这说明 RTT 为 0 ! 显然，这是十分荒谬的。需要说明的是，RTT 的测量不需要时间戳也能进行，只是使用时间戳可以解决 RTTM 中某些棘手的问题（区分重传报），参见另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/05/rtt%E7%9A%84%E6%B5%8B%E9%87%8F/">RTT的测量</a></p></blockquote><p><strong><mark class="hl-label blue">TSOPT如何测量RTT？</mark> </strong></p><p>一般而言，客户端和服务端会互发数据和确认，但此处为了更清楚地说明问题，我们只考虑客户端发送数据，服务端回应 ACK 报文。于是有以下过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           客户端 A                               服务端 B</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;A,TSval=1&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(A),TSecr=1&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                             &lt;B,TSval=5&gt; -----&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  &lt;---- &lt;ACK(B),TSecr=5&gt;</span></span><br></pre></td></tr></table></figure><p><strong>客户端如此测量 RTT</strong> ：将本端此刻时间戳填入 TSOPT 选项中的 TSval 部分，并发送报文 A ；服务端接收到报文 A 后，将 TSval 部分的值放入 ACK 报中的 TSecr 部分并发送；客户端接收到 ACK 报文后取出 TSecr ，并将此刻时间戳减去 TSecr ，即得到 RTT 。通常情况下，发送 ACK 报文时只需要无脑填入对端上一个报文的 TSval 就行了，但有几种特殊场景需要注意：</p><ol><li><p><strong>Delay ACK（延迟确认）：</strong></p><blockquote><p>延迟确认有两大好处：1.减少网络中 ACK 包的数量（<u>最多延迟一个包</u> ），以减小网络拥塞；2.如果接收端刚好也有数据发送，则可以将数据和 ACK一起发送（数据捎带确认），减少了 pure ACK 的数量。</p></blockquote><p>如果启用了 Delay ACK, 并且接收端收到了多个报文，这些报文的 TSval 不同，那么应该 Echo 哪一个报文的 TSval 呢?答案是：<strong>需要 Echo 最早收到的那个报文的 TSval</strong>  , 因为只有这样，发送端测量的 RTT 才更加准确（更保守）。<u>本地会维护一个 TS.recent 变量，其用来保存下一个填入 TSecr 的时间戳,当需要发送报文时，报文的 TSecr 始终从当前 TS.Recent 获得。</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟确认下：                                       TS.Recent   </span></span><br><span class="line"><span class="comment">//              &lt;A, TSval=1&gt; -------------------&gt;     1      </span></span><br><span class="line"><span class="comment">//                                                    </span></span><br><span class="line"><span class="comment">//              &lt;B, TSval=2&gt; -------------------&gt;     1      </span></span><br><span class="line"><span class="comment">//                                                     </span></span><br><span class="line"><span class="comment">//                       &lt;---- &lt;ACK(B), TSecr=1&gt;      1      </span></span><br><span class="line"><span class="comment">//可见，echo的是最早发送的报文</span></span><br></pre></td></tr></table></figure></li><li><p><strong>乱序或丢失：</strong></p><p>发送端发送了多个报文，但中间有报文出现了丢失或者乱序，这会使得接收端的窗口产生<strong>空洞</strong> (即在未收到序号较小的报文时，先收到序号较大的报文)。这种情况可能预示着链路发生了拥塞，因此，此时也会让接收方 Echo 稍早时候的 TSval ，而不是序号最大报文的 TSval , 这样使得发送端估算的 RTT 能偏大，也就是发送报文更保守，有利于减小拥塞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送顺序：A-&gt;B-&gt;C-&gt;D-&gt;E</span></span><br><span class="line"><span class="comment">接受顺序：</span></span><br><span class="line"><span class="comment">                                         TS.Recent   </span></span><br><span class="line"><span class="comment">       &lt;A, TSval=1&gt; -------------------&gt;    1       </span></span><br><span class="line"><span class="comment">                                                     </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(A), TSecr=1&gt;1       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;C, TSval=3&gt; -------------------&gt;1       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(A), TSecr=1&gt;1    </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;B, TSval=2&gt; -------------------&gt;1-&gt;2    </span></span><br><span class="line"><span class="comment">                                                   </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(C), TSecr=2&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;E, TSval=5&gt; -------------------&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(C), TSecr=2&gt;2       </span></span><br><span class="line"><span class="comment">                                                    </span></span><br><span class="line"><span class="comment">       &lt;D, TSval=4&gt; -------------------&gt;2-&gt;4    </span></span><br><span class="line"><span class="comment">                                                   </span></span><br><span class="line"><span class="comment">                &lt;---- &lt;ACK(E), TSecr=4&gt;4                                                       </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意第 11 行，ACK 报文中的 TSecr = 1 而不是 3 ，原因是：1.使 RTT 偏大，保守计算；2.如果发送 3 ，则 TS.Recent 改为 3 ，那么接收到 B 包时，会计算<code>TSecr = 2 &lt; TS.Recent = 3</code> ，从而判断 B 是历史报文而导致错误丢弃。</p></li></ol><h5 id="font-color-orange-PAWS-font"><font color='orange'>PAWS</font></h5><blockquote><p>由于序号占 32 位，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，即最大 4 个 GB 。在一般网络下（假定 1 MB /S），那么循环一圈序列号所花费的时间约为 1.19 小时，而 <code>MSL</code> （报文最大生存时间）为 30 秒（Linux），所以一般情况下即使是发生序列号回绕也不会接收到历史报文。但在高速网络（千兆网）下，可能循环一圈只需要十几秒甚至几秒，此时网络中的历史报文就有较大概率落入新连接的窗口（窗口最大 1 GB），从而造成数据错乱。由此，还需要引入 <strong>时间戳</strong> 来解决此问题。</p></blockquote><p>举个例子，假设发送端的序号从 1 开始计数，此时已经发送了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>+</mo><mn>4999</mn></mrow><annotation encoding="application/x-tex">2^{32}+4999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4999</span></span></span></span> 字节的数据，当前接收端的 <code>RCV.NXT = 5000</code>, <code>TS.Recent = 100</code> , 如果收到一个报文 <code>Seq = 5000</code> , <code>LEN = 1000</code> , <code>TSval=70</code>  如果不看时间戳，那么接收端会认为这个报文正好是预期的报文，但是这个报文实际上却是第 5000 ~ 5999 字节的报文；而有了时间戳，之间根据 <code>TSval &lt; TS.Resent</code> 就可判断此报文已过期。</p><p><strong><mark class="hl-label blue">时间戳的时间部分占32位，不也会用完并回绕吗？</mark> </strong></p><p>是的，时间戳也会回绕，不过需要时间戳是以时间为驱动进行增长（1ms，实现不同），而序列号是以字节为驱动进行增长。按照 1ms 的时间戳时钟计算，32-bit 的时间戳回绕一次的周期是 24.8 天， 而实际上连接实际不会这么长，所以远不用担心时间戳回绕。</p><p><strong><mark class="hl-label blue">时间戳还有什么作用？</mark> </strong></p><ol><li>当开启时间戳后，即使在 <code>TIME-WAIT</code> 状态下也允许建立连接。参考 <a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html">此处</a></li><li>时间戳可以用于 SYN Cookie 中。参考 <a href="https://jyxcpp.netlify.app/2022/08/04/syn%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/">此处</a></li><li>RACK 重传</li><li>Eifel 探测算法</li></ol><blockquote><p>文章参考：<a href="https://www.cnblogs.com/lshs/p/6038494.html">TCP 08</a> ，<a href="https://switch-router.gitee.io/blog/tcp-timestamp/">时间戳那点事</a> ，<a href="https://switch-router.gitee.io/blog/TCP-SYN-Cookies/">SYN Cookie</a> ，<a href="https://blog.51cto.com/u_9164120/3289669">RTT</a>  ，<a href="https://www.gingerdoc.com/tcp-seq-and-loop">序列号回环</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYN泛洪攻击</title>
      <link href="/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/08/04/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><mark class="hl-label blue">什么是 SYN 泛洪攻击？</mark> </strong></p><p>SYN 洪水（半开连接攻击）是一种<u>拒绝服务 (DDoS) 攻击</u> ，旨在耗尽可用服务器资源，致使服务器无法传输合法流量。通过 TCP 三次握手时，重复发送初始连接请求 (SYN) 数据包，攻击者将占满目标服务器上的所有 <strong>半连接队列</strong> ，导致服务器在响应合法流量时表现迟钝乃至全无响应。</p><p><strong><mark class="hl-label blue">SYN 泛洪攻击原理？</mark> </strong></p><ol><li>攻击者通常使用伪造的不同的 IP 地址向目标服务器发送大量 <code>SYN</code> 数据包。</li><li>然后，服务器分别对每一项连接请求做出响应（发送 <code>ACK+SYN</code> 包），并确保打开的端口做好接收响应的准备。</li><li>在服务器等待最后一个 <code>ACK</code> 数据包（永远不会到达）的过程中，攻击者将继续发送更多 <code>SYN</code> 数据包。每当有新的 <code>SYN</code> 数据包到达，服务器都会临时打开一个新的端口并在一段特定时间内保持连接，久而久之就会占满服务端的 <strong>半连接队列</strong> ，使得服务器不能为正常用户服务。</li></ol><p><strong><mark class="hl-label blue">半连接队列与全连接队列</mark> </strong></p><p>正常流程：</p><ul><li>当服务端接收到客户端的 <code>SYN</code> 报文时，会将其加入到内核的 <strong>SYN 队列（半连接队列）</strong> ；</li><li>接着发送 <code>SYN + ACK</code> 给客户端，等待客户端回应 <code>ACK</code> 报文；</li><li>服务端接收到 <code>ACK</code> 报文后，从 SYN 队列移除放入到 <strong>Accept 队列（全连接队列）</strong> ；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从 Accept 队列取出连接。</li></ul><img src="/2022/img/3d05f574867b70d1134e685e5f5ac137.jpg" alt="示意图" style="zoom:50%;" /><p>而在 SYN 泛洪攻击下，SYN 队列将不断接收攻击者发送的 SYN 包直到队列溢出，这种情况下，正常用户发送的连接请求也会被延迟或者拒绝。</p><p><strong><mark class="hl-label blue">如何预防SYN泛洪？</mark> </strong></p><ol><li><p><strong><font color='orange'>SYN Cookie</font></strong></p><p><code>Syn-Flood</code> 攻击成立的关键在于服务器资源是有限的，而服务器收到请求会分配资源。通常来说，服务器用这些资源保存此次请求的关键信息，包括请求五元组，以及 TCP 选项，如 <code>MSS</code> 、<code>timestamp</code> 、<code>Sack</code>、<code>Wscale</code> 等等。当后续的 <code>ACK</code> 报文到达，三次握手完成，新的连接创建，这些信息才会被复制到连接结构中，用来指导后续的报文收发。</p><p>那么现在的问题就是服务器 <strong>如何在不分配资源的情况下</strong></p><ul><li><p>验证之后可能到达的 <code>ACK</code> 的有效性，保证这是一次完整的握手</p></li><li><p><strong>保存 <code>SYN</code> 报文中携带的 TCP 选项信息</strong></p></li></ul><blockquote><mark class="hl-label blue">SYN Cookie 原理</mark>  ：<p>TCP 连接建立时，双方的起始报文序号是可以任意的。<code>SYN cookies</code> 利用这一点，按照以下规则构造初始序列号：</p><ul><li>设 <code>t</code> 为一个缓慢增长的时间戳(典型实现是每64s递增一次)</li><li>设 <code>m</code> 为客户端发送的 <code>SYN</code> 报文中的 <code>MSS</code> 选项值</li><li>设 <code>s</code> 是连接的四元组信息和 <code>t</code> 经过密码学运算后的 <code>Hash</code> 值，即 <code>s = hash(sip,dip,sport,dport,t)</code> ，<code>s</code> 的结果取低 <strong>24</strong> 位。</li></ul><p>则初始序列号 <code>n</code> 为：</p><ul><li>高 <strong>5</strong> 位为 <code>t mod 32</code></li><li>接下来<strong>3</strong>位为 <code>m</code> 的编码值</li><li>低 <strong>24</strong> 位为 <code>s</code></li></ul><p>当客户端收到此 <code>SYN+ACK</code> 报文后，它会回复 <code>ACK</code> 报文，且报文中 <code>ack = n + 1</code> ，那么在服务器收到它时，将<code>ack - 1</code> 就可以拿回当初发送的 <code>SYN+ACK</code> 报文中的序号了！服务器巧妙地通过这种方式间接保存了一部分 <code>SYN</code> 报文的信息。接下来，服务器需要对 <code>ack - 1</code> 这个序号进行检查：</p><ul><li>将高 <strong>5</strong> 位表示的 <code>t</code> 与当前之间比较，看其到达的时间是否能接受。</li><li>根据 <code>t</code> 和连接元组重新计算 <code>s</code> ，看是否和低 <strong>24</strong> 一致，若不一致，说明这个报文是被伪造的。</li><li>解码序号中隐藏的 <code>mss</code> 信息</li></ul><p>到此，连接就可以顺利建立了。</p><mark class="hl-label blue">SYN Cookie 缺点</mark>  ：<ol><li><code>MSS</code> 的编码只有<strong>3</strong>位，因此最多只能使用 <strong>8</strong> 种 <code>MSS</code> 值</li><li>服务器必须拒绝客户端 <code>SYN</code> 报文中的其他只在 <code>SYN</code> 和 <code>SYN+ACK</code> 中协商的选项，原因是服务器没有地方可以保存这些选项，比如<code>Wscale</code>和 <code>SACK</code></li></ol><mark class="hl-label blue">SYN Cookie 与时间戳</mark>  ：<p>如果服务器和客户端<strong>都</strong>打开了时间戳选项，那么服务器可以将客户端在 <code>SYN</code> 报文中携带的 TCP 选项的信息暂时保存在时间戳中。<br><img src="/2022/img/" alt="img"></p></blockquote></li><li><p><strong><font color='orange'>修改 Linux 内核参数</font></strong></p><ul><li><p>控制半队列的最大值如下参数：<mark class="hl-label default">net.core.netdev_max_backlog</mark> </p></li><li><p>SYN_RCVD 状态连接的最大个数：<mark class="hl-label default">net.ipv4.tcp_max_syn_backlog</mark> </p></li><li><p>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：<mark class="hl-label default">net.ipv4.tcp_abort_on_overflow</mark> </p><blockquote><p>半/全连接队列的相关参数和源码分析请参见笔者其他文章。</p></blockquote></li></ul></li></ol><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000019292140">深入浅出TCP中的SYN-Cookies</a> ，<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">小林coding</a> ，<a href="https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/">cloudflare</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手与四次挥手</title>
      <link href="/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/08/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>TCP 协议是 <strong>面向连接</strong> 的协议，通信前需要先在双端建立 <strong>逻辑信道</strong> ，即使是断开连接也不能说断就断，还需双方同意。所以下面我们详细说明 TCP 的连接管理。</p></blockquote><p>在TCP的连接建立过程中一般需要处理下面三个问题</p><ol><li>要使每一方能够确知对方的存在。</li><li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</li><li>能够对传输实体资源（如缓存大小等）进行分配</li></ol><p>TCP建立连接最常见的方式就是通过<strong>三次握手(three-way handshake)</strong> ，连接释放最常见的方式则是 <strong>四次挥手(four-way handshake)</strong> ，下面我们先介绍这两种最常见的连接管理机制。</p><h3 id="font-color-red-三次握手-font"><font color='red'>三次握手</font></h3><img src="/2022/img/IMG_0435(20220803-151548).PNG" alt="TCP三次握手" style="zoom: 50%;" /><ol><li>客户端会随机初始化序号（client_ISN），将此序号置于 TCP 首部的 <code>序号</code> 字段中，同时把 <code>SYN</code> 标志位置为 1 ，表示 <code>SYN</code> 报文。接着把第一个 <code>SYN</code> 报文发送给服务端，表示向服务端发起连接，<strong><u><font color='orange'>该报文不包含应用层数据</font></u></strong> ，之后客户端处于 <mark class="hl-label default">SYN-SENT</mark>  状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的 <code>序号</code> 字段中，其次把 TCP 首部的 <code>确认应答号</code> 字段填入 client_isn + 1 , 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为  1 ，同时写入 <code>rwnd</code> ，以告知对方自己的窗口大小。最后把该报文发给客户端，<strong><u><font color='orange'>该报文也不包含应用层数据</font></u></strong> ，之后服务端处于 <mark class="hl-label default">SYN-RCVD</mark>  状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 1 ，其次 <code>确认应答号</code> 字段填入 server_isn + 1 ，最后把报文发送给服务端。<strong><u><font color='orange'>这次报文可以携带客户到服务器的数据</font></u></strong> ，之后客户端处于 <mark class="hl-label default">ESTABLISHED</mark>  状态。</li><li>服务器收到客户端的应答报文后，也进入 <mark class="hl-label default">ESTABLISHED</mark>  状态。之后双方便可进行通信。</li></ol><blockquote><p><strong><font color=#FF00FF> <code>SYN</code> 和 <code>SYN+ACK</code> 段不携带数据，所以不消耗序列，<code>ACK</code> 段可携带数据，若携带数据，则消耗序列</font></strong> ，而 <strong>TFO</strong> 可以在前两次交换数据，参考<a href="">此处</a></p><p>三次握手之前的连接都称之为 <strong>半连接</strong> 。</p></blockquote><blockquote><p><strong><font color=#3b8dfe>ISN 为什么要随机？</font></strong></p><ol><li><p><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong></p><p>四元组唯一标识一个 TCP 连接，当一个 TCP 连接在经历四次挥手关闭时，假如有一个数据包延迟特别大，而这个连接在关闭后又马上以相同的四元组建立起来，那么先前这个连接的 TCP 数据包到达的时候，大概率系列号还落在接收窗内，那么这个数据包就可能会被错误接收。因此 RFC0793 指出 ISN 应该每 4μs 自增 1，从而防止同一个连接的不同实例的数据包混淆。<br><code>ISN = M + F(localhost, localport, remotehost, remoteport)</code></p><ul><li><p><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</p></li><li><p><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。若四元组相同，则随机数相同。<a href="!%5Bimg%5D(https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png)">示意图点这里</a></p></li></ul></li><li><p><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong></p><p>TCP 系列号欺骗如下图所示：</p><p><img src="/2022/img/image-20220803170133160.png" alt="示意图"></p><p>假设 A 是服务器，B 是拥有特殊权限的客户端，C 是攻击者。</p><ol><li>第一条消息 C 冒充 B 来向服务器 A 请求建立连接，此时 C 发出的数据包的 IP 地址会填写成 B 的；</li></ol></li><li><p>第二条消息假设 A 没有其他手段来验证 B，而仅仅根据 IP 地址判断 C 发过来的建立连接的请求是 B 发过来的，因此向 B 发送 <code>SYN+ACK</code> ，此时假设 B 被 C 进行了 DOS 攻击或者处于其他异常状态而不能响应第二条消息(如果 B 处于正常状态会响应一个 <code>RST</code> 包来重启 TCP 连接)；</p></li><li><p>第三条消息假如 C 能正确的猜测出 A 在第二条消息中的 ISN，就可以冒充 B 和 A 完成三次握手的过程，让 A 误以为和 B 建立了连接。接下来 C 就可以冒充 B 给 A 发送一些危险数据或者指令而实现攻击。</p></li></ol></blockquote><p><strong><mark class="hl-label blue">为什么是三次握手？不是两次、四次？</mark> </strong></p><ol><li><p><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></p><p>我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文。</p><img src="/2022/img/image-20220803170152579.png" alt="示意图" style="zoom:67%;" /><p>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接，那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li><li>收到新 SYN 报文后，才重新建立起新连接。</li></ul><p>而两次握手则会直接建立历史连接，服务器可能直接发送数据，造成资源的浪费：</p><img src="/2022/img/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接" style="zoom: 67%;" /></li><li><p><strong>三次握手才可以同步双方的初始序列号</strong></p><p><u>本质而言，TCP 握手握的是通信双方数据原点的序列号</u> ，通过同步双方初始序列号来实现 <strong>双向可靠传输</strong> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  A  --SYN=9        --&gt;  B</span></span><br><span class="line"><span class="comment">//  A  &lt;-SYN=4 ACK=10 --   B</span></span><br><span class="line"><span class="comment">//  A  --      ACK=5  --&gt;  B</span></span><br></pre></td></tr></table></figure><p>两次握手只能实现 A 方和 B 方就 A 方的同步，也就是说，两次握手只能保证 A 到 B 的数据传输是可靠的，反向则无法保证。这就相当于，A -&gt; B是 TCP，而B -&gt; A是 UDP（类比不是很准确）。如果要保证 B 到 A 的数据传输也可靠，则还需要第三次握手。</p></li><li><p><strong>防止资源浪费</strong></p><p>在 SYN 泛洪攻击下，两次握手就建立了连接，而后服务器便向对端发送数据，然而对方压根不会回应，白白造成资源的浪费。</p></li></ol><blockquote><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul></blockquote><h3 id="font-color-red-四次挥手-font"><font color='red'>四次挥手</font></h3><blockquote><p>四次握手是在半关闭场景下进行的断连接操作，还有另一种断开操作只需要三次挥手。</p></blockquote><p><img src="/2022/img/740952-20161107133341092-1088495812.png" alt="半关连接-四次挥手"></p><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong> <u>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</u></li></ol><blockquote><p><strong>半关连接</strong> ：TCP 的半关连接是指 TCP 连接只有一方发送了 <code>FIN</code> ，另一方没有发出 <code>FIN</code> 包，<u><font color='orange'>仍然可以在一个方向上正常发送数据</font></u> 。这种场景并不常见，一般来说调用 shutdown() 接口时候就会进入半关闭状态，调用常规的 close() 一般是期待完整的双向关闭这个 TCP 连接。shutdown() 接口相当指示程序，本端已经没有数据待发送，所以发送一个 <code>FIN</code> 到对端，但是仍然可以从对端接收数据，直到对端发送一个 <code>FIN</code> 指示关闭连接为止，详见后文。<a href="https://www.cnblogs.com/lshs/p/6038468.html">同时关闭参考此处</a></p></blockquote><p><strong><mark class="hl-label blue">断开连接为什么需要四次挥手？</mark> </strong></p><p><u>因为 TCP 是 <strong>全双工协议</strong> ，双方都可以接收和发送数据，所以断开连接时，也需要服务端和客服端都确定对方将不再发送数据。</u></p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，<u>而服务端可能还有数据需要处理和发送</u> ，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p><strong><mark class="hl-label blue">四次挥手可以变成三次吗？</mark> </strong></p><p><font color='pink'>可以。实际上，三次挥手比四次挥手更为常见</font>。 以下情形会转为三次挥手：</p><ul><li><p><font color=#3b8dfe>当接收端收到 <code>FIN</code> 报文时没有需要发送的数据，且开启了延迟确认</font>，则会将 <code>ACK</code> （第二次）和 <code>FIN</code> （第三次）合并发送。</p></li><li><p><font color=#3b8dfe>当接收端收到 <code>FIN</code> 报文时只有少于 MMS 的少量数据，且开启了延迟确认</font>，则会将 <code>ACK</code> 、<code>FIN</code> 报文和数据合并发送。</p></li><li><p>当发送方调用 close() 时，表明自己不再接收和发送数据，之后接收方如果还发送数据，发送方内核会发送 RST 报文强制释放连接，所以此方式比较粗暴，勉强算得上三次挥手。</p><img src="/2022/img/640-16615889860813.png" alt="图片" style="zoom:67%;" /></li></ul><p><strong><mark class="hl-label blue">FIN 报文一定得调用关闭连接的函数，才会发送吗？</mark> </strong></p><p>不一定。如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p><p><strong><mark class="hl-label blue">为什么需要设置 TIME_WAIT ？</mark> </strong></p><ol><li><p><strong><font color='orange'>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</font></strong></p><p>当序列号发生回绕时，就没法直接通过序列号来判断新老报文了。这时，一个历史报文可能刚好落在在同一四元组的新连接下的窗口中，此时窗口就会接收历史报文，从而引起数据错乱。于是，最直接的办法就是 <strong><u>等待网络中的所有包消失</u></strong> ，所以需要设置 <code>TIME_WAIT</code> 。</p><blockquote><p>可以通过 <strong>时间戳</strong> 的方式判断新老报文。详细内容会在其他文章中讲解。</p></blockquote></li><li><p><strong><font color='orange'>保证被动关闭连接的一方，能被正确的关闭；</font></strong></p><p>假设客户端收到服务器的 FIN 后不等待 TIME_WAIT 而直接关闭连接，那么如果最后客户回复的 ACK 丢失，则服务器会超时重发 FIN，此时由于客户端的客户状态已经丢失（因为连接已关闭），所以它将直接回复 RST，从而被服务器解释为异常终止。</p></li></ol><p><strong><mark class="hl-label blue">为什么 TIME_WAIT 等待的时间是 2MSL？</mark> </strong></p><p><strong><u><font color=#FF00FF>因为 2MSL 可以保证网络上所有的历史报文全部消失</font></u></strong> ，参见下图：</p><img src="/2022/img/14f8dc84f7d660ffa06e18a4877707ae.png" alt="示意图" style="zoom: 67%;" /><p>假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失。附带也能够保证上条问题第二点。详细参见：<a href="https://www.zhihu.com/people/noo-40/answers">知乎文章</a> 。</p><blockquote><p><code>MSL</code> 应大于 IP 协议 <code>TTL</code> 换算的时间，RFC793 建议 <code>MSL</code> 设置为 2 分钟，Linux 遵循伯克利习惯设置为 30 s。</p></blockquote><h3 id="font-color-red-握手和挥手的异常处理-font"><font color='red'>握手和挥手的异常处理</font></h3><p>参考：<a href="https://bbs.huaweicloud.com/blogs/293731">握手和挥手的异常处理</a></p><blockquote><p>文章参考：<br>《计算机网络自顶向下》，《UNP》，<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">小林coding</a> ，<a href="https://www.cnblogs.com/lshs/p/6038477.html">TCP系列五</a> ，<a href="https://www.zhihu.com/people/noo-40/answers">知乎文章</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP概述及报头解析</title>
      <link href="/2022/08/02/TCP%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%8A%A5%E5%A4%B4%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/08/02/TCP%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%8A%A5%E5%A4%B4%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-TCP-特征概述-font"><font color='red'>TCP 特征概述</font></h3><p>TCP 协议在网络 OSI 参考模型中的第四层——传输层，是一个 <strong><font color='red'>面向连接的（connection-oriented）、可靠的（reliable）、字节流式的（byte stream）</font></strong> 传输协议。</p><blockquote><ul><li><strong>面向连接</strong> ：在应用 TCP 协议进行通信之前，双方通常需要通过三次握手来建立 TCP 连接，连接建立后才能进行正常的数据传输。但是同时面向连接的特性给 TCP 带来了复杂的 <strong>连接管理</strong> 以及用于检测连接状态的 <strong>存活检测机制</strong> 。同时，TCP 提供全双工通信。</li><li><strong>可靠性</strong> ：TCP 层需要解决来自 IP 层的四种常见传输错误问题，分别是 <strong>比特错误</strong> (packet bit errors)、<strong>包乱序</strong> (packet reordering)、<strong>包重复</strong> (packet duplication)、<strong>丢包</strong> (packet drops)，TCP要提供可靠的传输，就需要有额外的机制处理这几种错误。TCP 通过使用 <strong>确认</strong> ，<strong>重传</strong> ，<strong>校验和</strong> 这三种基本机制来实现可靠传输。因此TCP协议具有<u>超时与重传管理、窗口管理、流量控制、拥塞控制</u>等功能。</li><li><strong>字节流式</strong> ：应用层发送的数据会在 TCP 的发送端缓存起来，统一分段(例如一个应用层的数据包分成两个TCP包)或者打包(例如多个应用层的数据包打包成一个TCP数据包)发送，到接收端的时候接收端也是直接按照字节流将数据传递给应用层。也就是说，<strong>TCP 的数据流是没有边界的</strong> ，这可能导致粘包。作为对比，同样是传输层的协议，UDP 并不会对应用层的数据包进行打包和分片的操作，一般一个应用层的数据包就对应一个 UDP 包。</li></ul></blockquote><h3 id="font-color-red-报头解析-font"><font color='red'>报头解析</font></h3><img src="/2022/img/IMG_0433(20220803-094417).PNG" alt="报头格式" style="zoom:67%;" /><p>报头大小为 <strong>20 ~ 60 字节</strong> ，若没有 option ，则为 20 字节。下面对图中各部分进行解析。</p><ul><li><p><strong>源端口和目的端口：</strong> 分别用来唯一标识主机和服务器的进程。</p><blockquote><p>源端口、目的端口、以及源 IP 地址、目的 IP 地址统称为 <strong>四元组</strong> ，它唯一的标识了一个 TCP 连接。一个 IP 地址和一个端口号组成 <strong>套接字地址</strong> 。接收端的 TCP 层根据不同的端口号来将数据包传送给应用层的不同程序，这个过程叫做 <strong>解复用</strong> (demultiplex)。相应的发送端会把应用层不同程序的数据映射到不同的端口号，这个过程叫做 <strong>复用</strong> (multiplex)。</p></blockquote></li><li><p><strong>序列号(SN)：</strong>  TCP 为待发送缓冲区中的数据编号，与 ARQ 协议不同，此处<u>是为每个字节进行编号，而不是为段进行编号</u> 。序列号范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</p><blockquote><p>连接时，TCP 在范围内生成一个 <u>随机数</u> 作为 <strong>初始序号（ISN）</strong> ，那么第一个字节的序号应为 ISN + 1 。例如，ISN = 23 ，第一个分组大小为 500，则其序号为 24 ~ 500 ，那么下一个分组就需要从 501 开始编号。当 SYN =1 时，该序列号有效。TCP 通过序列号来判断丢包，重复和失序。</p></blockquote></li><li><p><strong>确认号(ACK)：</strong> 当 ACK 位为 1 时，该确认号有效。接收方通过使用确认号来告知发送方已收到的字节数（或下一次想收到的字节），比如，接收方收到 <code>SN = 54</code> 的分组，然后回复 <code>ACK = 55</code> 的分组来告知发送方我已收到 55 之前的字节（或下一次我想收到 55 开头的字节流）。与 <a href="https://jyxcpp.netlify.app/2022/07/31/%E8%AF%A6%E8%A7%A3arq%E5%8D%8F%E8%AE%AE/">GBN</a> 相同，<u>确认号时累积的。</u></p></li><li><p><strong>头部长度：</strong> 表示报头总大小。注意，头部长度仅占 4 bit ，范围为 0 ~ 15 ，而报头大小为 20 ~ 60 bytes，所以头部长度的单位是 4 bytes，也就是说，若头部长度为 11，则报头总大小为 <code>11 × 4 = 44</code> bytes 。</p></li><li><p><strong>保留：</strong> 占 6 位，这些位必须是0。为了将来定义新的用途所保留，其中 RFC3540 将保留字段中的最后一位定义为 Nonce 标志，用于处理拥塞。</p></li><li><p><strong>窗口大小：</strong> 16 位，表明接收端窗口的空闲空间大小，<u>最大的窗口大小为64Kb</u> 。这个值通常被称为 <strong>rwnd</strong> 。注意，它也可以表示为<u>对方必须维持的窗口大小</u> ，因为发送方必须服从接收方的支配。用于流量控制。</p></li><li><p><strong>校验和：</strong> 发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端 checksum 校验失败的时候会直接丢掉这个数据包。CheckSum 是根据 <u>伪头部+TCP头+TCP数据</u> 三部分进行计算的。</p><blockquote><p><u>伪首部只参与校验，不占空间，不参与传输</u> 。UDP 伪头部 = 源 IP 地址 + 目的 IP 地址 + 8位协议 + 16位UDP长度 。<br><strong>UDP 发送方可以选择不计算校验和，而 TCP 必须计算校验和</strong> 。UDP 伪首部目的是让UDP两次检查数据是否已经正确到达目的地：第一次，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的；第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP。相较于链路层的 CRC 校验，TCP/UDP 校验和提供相对较弱的差错保护。</p></blockquote></li><li><p><strong>紧急指针：</strong> 16位，指向优先数据的字节，在URG标志设置了时才有效。<u>如果URG标志没有被设置，紧急域作为填充</u> 。</p></li><li><p><strong>标志位：</strong></p><ul><li><strong>CWR(Congestion Window Reduce)</strong> ：拥塞窗口减少标志被发送主机设置，用来表明它接收到了设置ECE标志的TCP包，发送端通过降低发送窗口的大小来降低发送速率</li><li><strong>ECE(ECN Echo)</strong> ：ECN 响应标志被用来在 TCP 3次握手时表明一个 TCP 端是具备 ECN 功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11。ECN(Explicit Congestion Notification)是一种由网络层辅助的拥塞控制方法，用于显式通知终端拥塞的发生。参考<a href="https://jyxcpp.netlify.app/2022/08/07/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">此处</a></li><li><strong>URG(Urgent)</strong> ：该标志位置位表示紧急(The urgent pointer) 标志有效。该标志位目前已经很少使用。</li><li><strong>ACK(Acknowledgment)</strong>：取值 1 代表 ACK 字段有效，这是一个确认包，取值0则不是确认包。</li><li><strong>PSH(Push)</strong> ：该标志置位时，一般是表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。<u>在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。</u></li><li><strong>RST(Reset)</strong> ：用于复位相应的TCP连接。通常在发生异常或者错误的时候会触发复位 TCP 连接，这可能导致数据丢失。作用如下：<ol><li>向一个未打开的端口发送连接请求</li><li>应用程序主动终止一个连接</li><li>应用程序还没有接收缓存中的数据，连接被提前关闭</li><li>TWA(TIME-WAIT Assassination)</li><li>半开连接的情况下发送数据。参考 <a href="https://www.cnblogs.com/lshs/p/6038500.html">此处</a></li></ol></li><li><strong>SYN(Synchronize</strong>) ：该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号.</li><li><strong>FIN(Finish)</strong> ：带有该标志置位的数据包用来结束一个TCP会话，<u>但对应端口仍处于开放状态</u> ，准备接收后续数据。</li></ul></li><li><p><strong>选项(Option)</strong> ：长度不定，但长度必须以是32bits的整数倍。常见的选项包括 MSS、SACK、Timestamp 等。<u>可用于填充</u> 。</p><blockquote><img src="/2022/img/20191026141216154.png" alt="可选字段的格式" style="zoom:67%;" /><p><img src="/2022/img/740952-20161107134032077-307444296.png" alt="选项含义"></p><p>常用选项为：</p><ul><li><p><strong>最大报文传输段(Maximum Segment Size — MSS )</strong> ：<strong><font color='red'>MSS只出现在前两次握手中</font></strong> ，默认值为 536 。</p></li><li><p><strong>窗口扩大选项(window scaling – WSOPT  )</strong> ：<strong><font color='red'>该选项只出现在前两次握手中</font></strong> ，因此当TCP连接建立起来后，window scale就固定了。</p><blockquote><p><code>window size</code> 占 16 位，最大 64 kb，在网络情况很好的状态下，这么小的窗口无法满足较高的网络性能，所以需要用 WSOPT 选项扩大窗口。该选项格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//         +---------+---------+---------+</span></span><br><span class="line"><span class="comment">//         | Kind=3  |Length=3 |shift.cnt|</span></span><br><span class="line"><span class="comment">//         +---------+---------+---------+</span></span><br></pre></td></tr></table></figure><p>当使用 WSOPT 选项的时候，接收窗口的实际大小则为 <code>Window Size &lt;&lt; shift.cnt</code>，其中 <u><strong>shift.cnt 按照协议最大只能为14</strong></u> ，当接收端接收到的 shift.cnt 大于 14 的时候，则按照 14 来处理 <strong>Window Size</strong> 。WSOPT 选项最大可将原有的 16 位 <strong>Window Size</strong> 扩展到近 30 位大小(大约1GB)，可以有效提升TCP允许使用的接收缓存。</p></blockquote></li><li><p><strong>选择确认选项(Selective Acknowledgements —SACK )</strong> ：用于重传和拥塞控制，笔者其他文章会详述。</p></li><li><p><strong>时间戳选项(timestamps )</strong> ：用于 <u>测量往返时延</u> （RTTM，利于掌握网络拥塞信息），<u>防止序列号回绕</u> （PAWS）（参见：<a href="https://jyxcpp.netlify.app/2022/08/04/tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98/">序列号回绕</a> ）</p></li><li><p><strong>NOP</strong> ：<u>选项部分的每种选项长度必须是4字节的倍数，不足时用NOP补充</u> 。注意，是用来填充选项之间的空隙。</p></li><li><p><strong>EOL</strong> ：用来填充整个选项部分的末尾。</p><blockquote><p>举例：假如 <strong>Header Length</strong> 指定的 TCP 头长为 40 bytes，其中第 29-38 bytes 为 TSOPT 选项，则可以在第 39 byte 处添加一个 EOL 选项指示选项列表结束，可以看到 EOL 并没有位于 TCP 头的结束位置的第 40 byte。对于最后一个 byte RFC793 协议规定需要以 0 来填充。这个EOL后面填充的 0 已经不属于 TCP 选项的一部分了。然而，linux 本身发送 TCP 数据包的时候并不会添加 EOL 选项，而是通过添加一个或者多个 NOP 选项来实现整个 TCP 头长的四字节对齐。</p></blockquote></li><li><p><strong>FOC</strong> ：用于 <strong>TFO</strong> 的 Cookie 选项，参见<a href="https://jyxcpp.netlify.app/2022/08/05/tcp-fast-open-tfo/">此处</a></p></li></ul></blockquote></li></ul><blockquote><p>文章参考：</p><p><a href="https://www.cnblogs.com/lshs/p/6038458.html">TCP协议01</a> ,<a href="https://www.gingerdoc.com/tcp-intro">姜知笔记</a> ,<a href="https://coolshell.cn/articles/11564.html">TCP那些事</a> , <a href="https://www.cnblogs.com/lshs/p/6038494.html">TCP 8</a> , 《计算机网络自顶向下》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识端口</title>
      <link href="/2022/08/02/%E5%88%9D%E8%AF%86%E7%AB%AF%E5%8F%A3/"/>
      <url>/2022/08/02/%E5%88%9D%E8%AF%86%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-什么是端口？-font"><font color='red'>什么是端口？</font></h3><p>我们知道，<strong>网络层提供主机到主机的通信，而传输层提供进程到进程的通信</strong> 。在网络层中，IP 地址是识别主机的标识符，网络包通过 IP 地址来寻找主机；相对地，在传输层中，端口是主机上进程的标识符，网络包通过 IP 地址到达主机后，又通过端口号来寻找对应进程。即，<strong><font color=#3b8dfe>端口号用来唯一标识主机进程</font></strong> 。</p><blockquote><p>一个 IP 地址和一个端口号组成了 <strong>套接字地址</strong> ，套接字地址唯一标识了网络中的进程。而客户端和服务器端的 IP 地址与端口，以及传输层协议，共同组成了 <strong>五元组</strong> ，用来标识唯一通信。</p></blockquote><p>客户端程序使用 <strong>临时端口号</strong> 定义自己，之所以叫“临时端口号”，是因为其生命周期较短，本次使用完该端口，下一次就不一定再使用。临时端口号通常选择 49152 ~ 65535之间的数。</p><p>服务器端也需要使用端口号定义自身，但此端口号不能随机选择，否则客户端访问服务器端时，将不知道其端口号。所以服务器必须使用 <strong>公用端口号（well-know port）</strong></p><div class="note info flat"><p><strong><font color='gree'>ICANN范围</font></strong></p><p><strong>公用端口：</strong> <strong>0 ~ 1023</strong></p><p><strong>注册端口：</strong> <strong>1024 ~ 49151</strong></p><p><strong>动态端口：</strong> <strong>49152 ~ 65535</strong></p><p><strong><font color=#3b8dfe>端口号在计算机中占 16 位 bit ，故总范围是 0 ~ 65535</font>。</strong>  公用端口号由 ICANN 预留给 TCP 和 UDP 协议使用的端口号（如 http - 80，DNS - 53）；注册端口号由公司和其他用户向 ICANN 登记注册；动态端口号供进程任意挑选。</p></div><div class="note warning flat"><p>需要注意的是，在网络术语中，端口有两种含义，一种是物理上的端口，如路由器，交换机和集线器上的端口，此端口用于连接其他网络设备；一种是逻辑上的端口，一般是指 TCP/IP 协议中的端口 ，即我们上面所述的端口。</p></div><blockquote><p><strong>一个端口号是否可以被多个进程绑定？</strong></p><ul><li><strong>同种协议通常不可以</strong> ，但有一种情况可以：如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的。</li><li><strong><font color='red'>UDP 和 TCP 可以绑定同一个端口</font></strong> 。TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个255号端口，UDP 也可以有一个255号端口，二者并不冲突。</li><li><strong>注意：一个端口号只能同时被一个进程绑定，但一个端口号可以同时建立多个 Socket 连接，不要混淆两者！</strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解ARQ协议</title>
      <link href="/2022/07/31/%E8%AF%A6%E8%A7%A3ARQ%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/31/%E8%AF%A6%E8%A7%A3ARQ%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><font color='gree'>自动重传请求</font></strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中 <u>数据链路层</u> 和 <u>传输层</u> 的错误纠正协议之一。它通过使用 <strong>确认</strong> ， <strong>超时</strong> ，<strong>校验和</strong> 这三个机制，<strong>在不可靠服务的基础上实现可靠的信息传输，且是一种面向连接的协议。</strong></p><blockquote><p><font color='orange'>ARQ 协议到底属于数据链路层的协议还是传输层的协议?</font></p><p>ARQ 是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了 ARQ ，并不专属某一层。例如，数据包到达数据链路层的网卡和交换机后会进行 FCS 校验，如果错误则直接丢弃；又如在 TCP（传输层）中，数据包的 TCP 报头有 seq 序列号，用于检测失序和丢失。</p></blockquote><p><strong><font color=#FF00FF>ARQ 包含三个协议：停止 - 等待协议（SW），回退N帧协议（GBN），选择重传协议（SR）</font></strong> 。下面对各个协议进行详细分析。</p><h3 id="font-color-red-停止-等待协议（SW）-font"><font color='red'>停止 - 等待协议（SW）</font></h3><ul><li><p><strong>发送方和接收方都只有大小为 1 的滑动窗口</strong> 。每当发送方发送一个分组时，就会开启一个计时器，一旦超时，就重发分组，这意味着，<strong>当收到接收方发来的 ACK 前，发送方都必须将已发送的分组留在窗口中而不可删除。</strong></p></li><li><p>ARQ 协议通过 <strong>序号（seq）</strong> 和 <strong>确认号（ACK）</strong> 来判断失序和重复分组。由于信道中只可能同时存在一个分组或 ACK ，<strong>所以 seq 只需要 1 位，即 0 和 1</strong>  。ACK 号表明的是自己 <strong>预期收到的序号</strong> （比如发送方发送了 seq = 1 的分组，接收方收到后，应发送 ACK = 0 的报文，表明自己下一次想要收到 seq = 0 的报文。</p><blockquote><p>在<mark class="hl-label default">停止 - 等待协议</mark>  中，确认号总是以模 2 运算的方式声明预期收到的下一个分组。</p></blockquote></li><li><p>为了发现破坏分组，我们需要在分组中加入一种被称之为 <strong>校验和</strong> 的检测数据，当发送方收到分组后，会利用校验和进行检测，如果校验和不正确，则说明包发生错误，将其丢弃。</p><blockquote><p>关于校验和，请移步博主另一篇文章：<a href="https://jyxcpp.netlify.app/2022/08/16/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF/">差错检测与纠正技术</a></p></blockquote></li><li><p><strong>对于发送方</strong> ：</p><ul><li>若收到进程传来的数据，发送方创建分组 ，保留分组的副本，并将其发送，同时开启计时器。</li><li>若收到无错（校验和正确）ACK 且与其值等于待发送分组序号，则进入第一步。</li><li>若收到被破坏的 ACK 或 无关 ACK ，则直接丢弃。</li><li>若发生超时，则重发分组，并重开计时。</li></ul><p><strong>对于接收方</strong> ：</p><ul><li><p>若预期无错分组 Seq  = R 到达，则分组被传递到进程，然后窗口滑动，ACK = （R + 1）% 2 被发送。</p></li><li><p>若失序无错分组 Seq != R到达，则分组被丢弃，且发送 ACK = R 。</p></li><li><p>若有错分组到达，直接将其丢弃。注意，不发送 ACK！</p><img src="/2022/img/IMG_0426(20220802-152553).PNG" alt="停止等待协议" style="zoom: 50%;" /></li></ul></li><li><p><strong>效率分析：</strong> 如果我们的信道带宽较大，那么此方式将非常低效，信道中永远只有一个分组，利用率极低。</p><blockquote><p><strong><font color=#3b8dfe>带宽时延积</font>：</strong> 传播时延 × 带宽<br>注意，<strong>传播时延 ≠ 传输时延</strong></p><p>假设在 停止 - 等待 系统中，线路带宽为 1Mbps，1 bit 发送需要 20 毫秒完成往返。求其带宽时延积和信道利用率。</p><p>带宽时延积 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>20</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mn>20000</mn></mrow><annotation encoding="application/x-tex">(1 × 10^6) × (20 × 10^{-3}) = 20000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20000</span></span></span></span> ，即信道容量可达 20000 位，而系统只发送了 1000 位，所以信道利用率为 5%。</p><p>如果系统在往返时间内发送 15 个分组（15000位），则信道利用率达 75%（信道利用率不是越高越好），由此我们引出 <strong>回退N帧协议</strong> 。</p></blockquote></li></ul><h3 id="font-color-red-回退N帧协议（GBN）-font"><font color='red'>回退N帧协议（GBN）</font></h3><blockquote><p>在网络或其他领域中，在之前的任务结束前，经常会开始另外一个新任务。这称之为 <strong>流水线（pipeline）</strong> 。流水线往往可以提高传输效率。</p></blockquote><ul><li><p>发送方收到 ACK 前可以同时连续发送多个分组且<strong>窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{m}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong> （原因见下文），<strong>但接收方只能缓冲一个分组（窗口大小为 1）</strong> 。</p><blockquote><p><strong><font color='orange'>窗口本身是一种抽象</font></strong> ，发送窗口有三个变量，分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> （第一个未完成分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Sn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span></span></span></span> （下一个待发送分组）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mrow><annotation encoding="application/x-tex">S{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></span> （窗口大小），接收窗口仅<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><img src="/2022/img/IMG_0427(20220802-163852).PNG" alt="窗口的抽象" style="zoom:50%;" /></blockquote></li><li><p><strong>序号是模 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 的</strong> ，其中 m 为序号字段的位大小，如 TCP 的 Seq 段为 16 ，范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>    。</p></li><li><p>在本协议中，<strong>确认号 ACK 是累积的</strong> 。例如，接收方发送 ACK = 4 ，则说明 <strong>Seq = 4 之前的分组</strong> 都已收到，这对于 ACK 报文的丢失尤其有用（见后文图示）。</p></li><li><p><strong>仅有一个计时器</strong> 。因为第一个未完成分组的计时器总是最先停止，且计时器超时直接重发所有分组，所以只需要一个。</p></li><li><p><strong>对于发送方</strong> ：</p><ul><li><p>当发送窗口内第一个分组时开始计时，<strong>一旦超时，全发所有未完成（已发送但未收到 ACK）分组</strong> 。</p><blockquote><p>如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">S_f = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">S_n = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> ，且计时器（发送分组 4 时开始计时）超时，则重发分组 4，5，6。</p></blockquote></li><li><p>如果无错且相关 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi><mo>=</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ACK = S_f+m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> （显然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>&lt;</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_f&lt;S_f+m&lt;=S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ）到达，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub><mo>=</mo><msub><mi>S</mi><mi>f</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">S_f=S_f+m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 。并且，<strong>若所有未完成分组都被确认，则计时器停止并进行下一轮发送；若不是所有未完成分组都被确认（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mi>K</mi><mo mathvariant="normal">≠</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">ACK ≠ S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ），则计时器重新开始</strong> 。</p></li><li><p>若被破坏或无关的 ACK 报文到达，直接丢弃。注意，不会重发。</p></li><li><p>若发生超时，直接重发所有未完成分组，并重新计时。</p></li></ul><p><strong>对于接收方</strong> ：</p><ul><li>若对应无错分组到达，报文被解开并传入进程，随后窗口滑动，接着发送 ACK。</li><li>若无错但无关分组到达，将其丢弃，<strong>且发送 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的 ACK 报文</strong> （表明自己需要的是 Seq = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的分组）。</li><li>若被破坏分组到达，则直接丢弃。注意，不发送 ACK 。</li></ul></li></ul><div class="note info flat"><p><strong><font color=#3b8dfe>为什么发送窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{m}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ？</font></strong></p><p><strong>新接收窗口可能将历史延迟报文当作新报文接收，如下：</strong></p><img src="/2022/img/IMG_0428(20220802-173239).PNG" alt="示意图" style="zoom:50%;" /></div><blockquote><p><strong>累积确认如何起作用</strong> ：</p><img src="/2022/img/IMG_0429(20220802-173821).PNG" alt="示意图" style="zoom:50%;" /><p>可见，ACK = 3 到达后，同时完成了对 Seq = 1，2 的确认。</p></blockquote><p>总览图：</p><img src="/2022/img/IMG_0430(20220802-174823).PNG" alt="总览图" style="zoom: 67%;" /><h3 id="font-color-red-选择重传（SR）协议-font"><font color='red'>选择重传（SR）协议</font></h3><blockquote><p>显然，GBN 协议在网络拥塞时，效率会很低，因为只要一个包丢失或错误或乱序，都会导致重发所有未完成分组，从而进一步加剧网络拥塞，形成恶循环。为了解决此问题，选择性重传协议应运而生。</p></blockquote><ul><li><p><strong>发送窗口相对于 GBN 更小，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></strong> ， 且发送窗口和接收窗口大小一致。</p></li><li><p><strong>接收窗口允许储存失序分组</strong> ，直到成为连续分组。</p></li><li><p>与 GBN 不同，<strong>SR 的确认号不是累积的</strong> ，仅定义为本次收到的报文，对其他分组没有反馈。</p></li><li><p>理论上需要需要为每一个未完成分组分配单独计时器，但这样会给系统造成很大开销，所以只使用一个计时器。原因同 GBN 。</p><blockquote><p>《计算机网络第七版》中表示 SR 协议中，每个分组都会分配单独计时器，这样可以做到超时只重发指定的未完成报文。可以用单个硬件定时器来模拟多个逻辑定时器的操作。GBN 仍只使用一个计时器。</p></blockquote></li><li><p><strong>对发送方：</strong></p><ul><li>若收到进程数据，则创建分组，然后发送分组并保留副本，同时开启计时器（如果未开启）。</li><li>若无错且相关 ACK 到达，则将对应分组标记为已确认；若 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ，那么窗口向右滑动，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 指向第一个未完成分组；此时若还存在未完成分组，则重启计时器，否则停止计时。</li><li>若出错或无关 ACK 到达，则丢弃。</li><li>若超时，则发送所有未完成分组。</li></ul><p><strong>对接收方：</strong></p><ul><li>若 Seq 在接收方窗口内的无错分组到达，则储存分组，且发送 ACK = Seq ；此外，若 Seq = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则分组以及之前连续到达的分组被传递到应用层，并滑动窗口。</li><li>若 Seq 不在接收窗口内的无错分组到达，则丢弃，且发送 ACK = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li><li>若出错分组到达，直接丢弃。</li></ul></li></ul><div class="note info flat"><p><strong><font color=#3b8dfe>为什么窗口最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>？</font></strong></p><img src="/2022/img/IMG_0431(20220802-201744).PNG" alt="示意图" style="zoom: 50%;" /></div><p>总览图：</p><img src="/2022/img/IMG_0432(20220802-202103).PNG" alt="总览图" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络是如何链接的</title>
      <link href="/2022/07/20/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E9%93%BE%E6%8E%A5%E7%9A%84/"/>
      <url>/2022/07/20/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E9%93%BE%E6%8E%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-浏览器生成消息-font"><font color='red'>浏览器生成消息</font></h2><h3 id="font-color-orange-生成HTTP消息-font"><font color='orange'>生成HTTP消息</font></h3><h4 id="font-color-FF00FF-了解-URL-font"><font color=#FF00FF>了解 URL</font></h4><p>网址，即 <strong><font color=#3b8dfe>URL</font></strong> （Uniform Resource Locator，统一资源定位符），根据访问目标的不同，有如下几种 URL ：</p><img src="/2022/img/20220720083407.PNG" alt="IMG_0407(20220720-083348)" style="zoom:67%;" /><p>URL 开头的文字如：“http”，“ftp”，“mailto”，表示浏览器访问 URL 时应该使用的 <strong>协议类型</strong> 。</p><div class="note info no-icon disabled"><p><strong><font color=#3b8dfe>http：Hypertext Transfer Protocol，超文本传送协议</font></strong></p><p><strong><font color=#3b8dfe>ftp：File Transfer Protocol，文件传送协议</font></strong> ，是一种上传和下载文件时使用的协议。</p><p>像 “file” 这样的 URL 访问的是本地文件，无需使用网络，所以准确来说 “file” 不是协议，而是“访问方法”</p></div><div class="note info no-icon disabled"><p><strong>URI , URL , URN 的区别：</strong></p><ul><li>URI （Uniform Resource Identifier ）：统一资源标识符。</li><li>URL（Uniform Resource Locator）：统一资源定位符。</li><li>URN（Uniform Resource Name）：统一资源名称。</li></ul><p><strong><font color=#3b8dfe>URI 唯一标识资源，有 URL 和 URN 两种形式。URL通过描述资源的位置来标识资源，而URN是通过名字来标识资源的，与位置无关。</font></strong></p><p>拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是 URI 的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是 URI ，通过身份证号能让我们能且仅能确定一个人。那统一资源定位符 URL 是什么呢?也拿人做例子然后跟 HTTP 的 URL 做类比，就可以有：<br><code>动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/[张三.人]</code><br>可以看到，这个字符串同样标识出了唯一的一个人，起到了 URI 的作用，所以 URL 是 URI 的子集。URL 是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是 URl 的一种实现，而   <strong>URL 就是用定位的方式实现的 URI 。</strong></p><p><strong>URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。</strong></p></div><h4 id="font-color-FF00FF-解析-URL-font"><font color=#FF00FF>解析 URL</font></h4><p>输入网址并按下回车后，<strong>浏览器做的第一件事便是解析 URL</strong> 。<strong>浏览器通过解析URL 来确定访问目标的位置</strong> 。下面以 HTTP 为例。</p><img src="/2022/img/20220720084845.PNG" alt="IMG_0408(20220720-084833)" style="zoom:67%;" /><div class="note info no-icon disabled"><p>有时可能遇见省略文件名的情况：</p><ol><li><p><code>http://www.lab.glasscom.com/dir/</code></p><p>此时，服务器一般已经设置好忽略文件名时要访问的默认文件名，大多数情况为 index.html 或者 default.html 。</p></li><li><p><code>http://www.lab.glasscom.com/</code></p><p>同上，不过此时访问的是根目录下的默认文件。</p></li><li><p><code>http://www.lab.glasscom.com</code></p><p>同上，不过此时省略了根目录，但仍表示访问根目录下的默认文件。</p></li><li><p><code>http://www.lab.glasscom.com/book</code></p><p>此例中的 book 本应该理解为文件，因为其后没有 <code>/</code> 。但因为许多人没有正确理解省略文件名的规则，经常把目录末尾的 <code>/</code> 省去，所以我们采用如下惯例进行处理：</p><p><strong><font color=#3b8dfe>如果该 web 服务器根目录下存在 book 目录，则将 book 当目录处理；如果存在 book 文件，则当文件处理。 </font></strong> <strong>注意，不会两者同时存在</strong> 。</p></li></ol></div><div class="note info no-icon disabled"><p><strong>WWW代表什么意思？</strong></p><p>WWW只是一个命名习惯，通常将用作网站服务器的计算机起名 www，<code>www.qq.com</code>，将邮件服务器的计算机取名为 mail，<code>mail.qq.com</code>。</p><p><strong>万维网（World Wide Web） 亦作WWW、Web，是一个透过互联网访问的，由许多互相链接的超文本组成的系统</strong> 。万维网是信息时代发展的核心，也是数十亿人在互联网上进行交互的主要工具。网页主要是文本文件格式化和超文本置标语言（HTML）。除了格式化文字之外，网页还可能包含图片、视频、声音和软件组件，这些组件会在用户的网页浏览器中呈现为多媒体内容的连贯页面。<strong>万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</strong></p></div><h4 id="font-color-FF00FF-生成HTTP请求消息-font"><font color=#FF00FF>生成HTTP请求消息</font></h4><blockquote><p>对 URL 解析之后，浏览器确定了 web 服务器和文件名，接下来便生成 HTTP 请求消息。</p></blockquote><p>请求消息格式如下：</p><img src="/2022/img/20220720095418.png" alt="image-20220720095418886" style="zoom:67%;" /><p>这里重要的是浏览器如何确定方法。一般而言，在地址框输入 URL 并按下回车，或者点击某个链接，都会使用 GET 方法，而在网页中填写表单，则使用 POST 方法。实际上，我们所在网页的 html 文件中已经指定了浏览器该确认何种方法：</p><img src="/2022/img/20220720100008.PNG" alt="IMG_0412(20220720-095940)" style="zoom:67%;" /><h4 id="font-color-FF00FF-服务器返回响应消息-font"><font color=#FF00FF>服务器返回响应消息</font></h4><p>响应消息格式如下：</p><img src="/2022/img/20220720100606.png" alt="image-20220720100606475" style="zoom:67%;" /><p>状态码和响应短语用来表示请求的执行结果是成功还是出错。</p><p>当网页只有文字时，当这里就处理完毕了（消息体中有网页的文字信息），若还有图片，则还需要进一步操作。</p><p>当网页包含图片时，会在网页中相应位置嵌入表示图片文件的 <strong>标签的控制信息</strong> 。遇到相关标签时，浏览器会再次访问 web 服务器，按照标签中指定的文件名向服务器请求相应图片，并显示在预留空间中，如下：</p><img src="/2022/img/20220720101737.PNG" alt="请求消息示例" style="zoom:67%;" /><img src="/2022/img/20220720101826.PNG" alt="响应消息示例" style="zoom: 67%;" /><img src="/2022/img/20220720101944.PNG" alt="图片文件的请求和响应" style="zoom:67%;" /><h3 id="font-color-orange-DNS-解析-font"><font color='orange'>DNS 解析</font></h3><h4 id="font-color-FF00FF-了解-IP-地址-font"><font color=#FF00FF>了解 IP 地址</font></h4><blockquote><p>生成 HTTP 消息后，需要 <strong>委托操作系统</strong> 将消息发送给 Web 服务器（<strong><font color=#3b8dfe>浏览器只能够解析 URL 并生成 HTTP 消息，但不具备将消息发送到网络中的功能</font></strong> ）。委托给操作系统前，我们还需要向 DNS ( Domain Name System) 服务器查询该服务器域名对应的 IP 地址。在这之前，先了解什么是 IP 地址。</p></blockquote><p><strong><font color=#3b8dfe> IP 地址是由一串 32 bit 的数字，按照 8 bit 为一组分为 4 组，分别用十进制表示然后再用原点隔开。</font></strong> IP 地址由 <strong>网络号</strong> 和 <strong>主机号</strong> 构成，但这两者的具体结构不固定（组建网络时用户可以自定义它们的分配关系），所以还需要 <strong>子网掩码</strong> 来辅助判断 IP 的内部结构。</p><img src="/2022/img/20220720104812.PNG" alt="IP地址的结构" style="zoom:50%;" /><p>那么，什么是子网？这需要从 TCP/IP 的基本思路说起，下面这张图可以较好地概括：</p><img src="/2022/img/20220720105312.PNG" alt="示意图" style="zoom: 67%;" /><h4 id="font-color-FF00FF-调用-DNS-解析器-font"><font color=#FF00FF>调用 DNS 解析器</font></h4><blockquote><p>我们向 DNS 服务器发送域名，DNS 返回域名对应的 IP。对于 DNS 服务器，我们电脑上就应该有 DNS 客户端，而这个客户端就称为 <strong>DNS 解析器</strong> 。DNS 解析器实际上就是一个函数（gethostbyname( )），包含在操作系统的 Socket 库中。</p></blockquote><div class="note info flat"><p>Socket 库是在加州伯克利分校开发的 UNIX 系操作系统 BSD 中开发的 C 语言库。互联网中的大多数功能都是基于 Socket 库开发的，可以说，Socket 库是网络开发中的标准库。</p></div><p>Socket 库中的程序都是标准组件，只需要在应用程序中调用即可：</p><img src="/2022/img/20220720110740.PNG" alt="IMG_0419(20220720-110730)" style="zoom:50%;" /><p>调用解析器后，DNS 服务器返回 IP 到浏览器指定的内存地址中。接下来，浏览器向 Web 服务器发送消息时，<strong>只需要从该地址中取出 IP 地址并将它和 HTTP 消息一起交给操作系统即可</strong> 。</p><p>来自 DNS 解析器的查询消息包含以下 3 种信息：</p><ul><li><p><strong>域名</strong></p><p>服务器（Web，邮件，数据库等类的服务器）的名称</p></li><li><p><strong>Class</strong></p><p>最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而 Class 就是识别网络的信息。而现在除了互联网已经没有其他类型的网络了，所以 Class 的值永远为 IN</p></li><li><p><strong>记录类型</strong></p><p>当类型为 A (Address) 时，表示域名对应的是 IP 地址；当类型为 MX (mail exchange) ，表示域名对应的是邮件服务器。类型不同，返回的消息也会不同。</p></li></ul><img src="/2022/img/20220720115913.PNG" alt="示意图" style="zoom: 50%;" /><p><strong><font color=#3b8dfe>DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址</font></strong></p><div class="note info no-icon disabled"><ul><li><p>DNS 请求消息采用 UDP 协议发送！</p></li><li><p>Web 服务器需要先在 DNS 服务器上注册才可以被找到。</p></li><li><p>向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址，不过此地址作为 TCP/IP 的一个设置项目已经事先设置好了，无需再次查询。</p></li></ul></div><h4 id="font-color-FF00FF-域名的层次结构-font"><font color=#FF00FF>域名的层次结构</font></h4><blockquote><p>互联网中有无数的服务器，将所有服务器的信息全部保存在一台 DNS 服务器中是不可能的，理由如下：</p><ul><li><strong>单点故障</strong>：嗝屁一个，全球着急</li><li><strong>通信容量</strong>：上亿台主机发送的查询DNS报文请求，包括但不限于所有的HTTP请求，电子邮件报文服务器，TCP长连接服务</li><li><strong>远距离的时间延迟</strong></li><li><strong>维护开销大</strong>：因为所有的主机名-ip映射都要在一个服务站点更新</li></ul><p>所以需要将信息分布在多台 DNS 服务器中，为了提高效率，还需要分层次保存。</p></blockquote><p>域名如何分层次？</p><mark class="hl-label default">www.lab.glasscom.com</mark> <p>在域名中，越靠右的级别越高，就相当于 “com公司中glasscom部门下lab科的www”</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP</title>
      <link href="/2022/07/08/CSAPP/"/>
      <url>/2022/07/08/CSAPP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-计算机系统漫游-font"><font color='red'>计算机系统漫游</font></h2><h3 id="font-color-orange-生成可执行文件的过程-font"><font color='orange'>生成可执行文件的过程</font></h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRhello.c--&gt; B{预处理器}--&gt;hello.i--&gt;L{编译器}--&gt;hello.s--&gt;G{汇编器}--&gt;K(&quot;hello.o&quot;)--&gt;A{链接器}--&gt;可执行目标文件Z(&quot;printf.o&quot;)--&gt;A  </pre></div><blockquote><ul><li><code>hello.i</code> 文件是在 <code>hello.c</code> 的基础上进行了宏替换，头文件展开等操作。</li><li>编译器将C代码转变为汇编语言程序，而汇编器将汇编语言程序转变为机器语言，而不是汇编器将C代码转变为汇编语言。</li><li><strong>汇编语言为不同的高级语言提供了相同的输出语言。任何高级语言都需要先转为汇编语言，因为汇编语言才是和机器语言一一对应的。</strong> 汇编语言的种类取决于电脑使用的 CPU 指令架构。所以机器代码和汇编代码的移植性比高级语言差许多。</li><li><code>printf</code> 函数在单独预编译好的 <code>printf.o</code> 的文件中，这个文件需要以某种方式合并到 <code>hello.c</code> 文件中，链接器就负责此过程。</li></ul></blockquote><h3 id="font-color-orange-系统的硬件组成-font"><font color='orange'>系统的硬件组成</font></h3><ol><li><p><strong>总线</strong></p><blockquote><p>总线在各个部件中传输信息字节。总线被设计成传送定长的字节块，即 <strong>字（word）</strong> ，目前大多数计算机要么是4个字节（32位），要么8字节（63位）。<font color='gree'>由于每次只能传送定长的字节块，所以C语言中的整型提升意义就在于此。</font></p></blockquote></li><li><p>I/O设备</p><blockquote><p>最基本的I/O设备：键盘，鼠标，显示器，磁盘。</p></blockquote></li><li><p>主存</p><blockquote><p>主存又一组 <strong>动态随机存取储存（DRAM）</strong> 芯片组成。</p></blockquote></li><li><p>处理器</p><blockquote><p>处理器看上去是指令集架构的简单实现，大多数离不开下面几个操作：</p><ul><li>加载：从主存复制数据到寄存器。</li><li>存储：从寄存器复制数据到主存。</li><li>操作：把两个寄存器的内容复制到ALU（算术/逻辑单元），ALU对其进行算术运算，并将结果放在一个寄存器中保存结果。</li><li>跳转：指向下一条指令。</li></ul></blockquote></li></ol><h3 id="font-color-orange-高速缓存-font"><font color='orange'>高速缓存</font></h3><p>运行程序时，需要先将磁盘中的代码复制到主存中，再由主存复制到 CPU 并运行程序，这些复制便是额外开销，减慢了程序真正工作的效率。</p><blockquote><p>所以目前已经有了 CPU 和内存结合的技术，以解决数据运输的巨大开销。</p><p>当下，存取速度远慢于 CPU 计算速度，未来想要进一步提高计算机运行速度，存取技术才是突破口。</p></blockquote><p>为了缓解这样巨大的复制和运输开销，<strong>高速缓存储存器</strong> 应运而生。</p><img src="/2022/img/20220709092100.png" alt="缓存分级" style="zoom:50%;" /><div class="note info flat"><p>L1，L2，L3高速缓存由 <strong>静态随机访问储存器（SRAM）</strong> 实现。</p></div><p><strong><font color='greew'>储存器的层次结构的主要思想：上一级储存器作为低一层存储器的高速缓存。</font></strong></p><h3 id="font-color-orange-操作系统管理硬件-font"><font color='orange'>操作系统管理硬件</font></h3><p><strong>操作系统是应用程序和硬件直接的一层软件，所有应用对硬件的操作都必须通过操作系统来进行，即 系统调用 。</strong></p><p>操作系统的两大功能：</p><ol><li>防止硬件被失控的应用滥用。</li><li>向应用程序提供简单一致的机制来控制复杂而大不相同的低级硬件设备。</li></ol><p><strong><font color=#00FFFF>简单而言，操作系统给应用提供硬件的一种抽象。</font></strong></p><p>操作系统通过几个基本的抽象概念（<u>进程</u>，<u>虚拟内存</u>，<u>文件</u>）来实现这两个功能：</p><ul><li>文件是对 I/O 设备的抽象。</li><li>虚拟内存是对主存和磁盘 I/O 设备的抽象。</li><li>进程是对处理器，主存和 I/O 设备的抽象。</li></ul><h3 id="font-color-orange-进程-font"><font color='orange'>进程</font></h3><p><strong><font color=#00FFFF>进程是操作系统对一个正在运行的程序的一种抽象。</font></strong> 一个 CPU 看上去像是在并发地执行多个进程，这是通过处理器在进程间来回切换实现的。操作系统实现这种交错执行的机制称作 <strong>上下文切换</strong> 。操作系统保持跟踪进程运行所需的所有状态信息，这种状态也就是上下文，包含许多信息，如：PC和寄存器的值，主存的内容等。<strong>任何时刻，单处理器只能执行一个进程的代码。</strong> 操作系统从当前进程转到其他进程时，就会保存当前的上下文，并恢复新进程的上下文，新进程就会从之前停止的地方开始。</p><p><strong>进程间的切换由操作系统内核（kernel）管理。内核不是单独的进程，而是系统管理全部进程所用代码和数据结构的集合。</strong></p><h3 id="font-color-orange-文件-font"><font color='orange'>文件</font></h3><blockquote><p>Linux哲学：<strong>一切皆文件</strong></p></blockquote><p><strong>文件就是字节序列，仅此而已。</strong> 在 Linux/Unix 中，每个 I/O 设备，包括磁盘，键盘，显示器甚至网络，都可以看作为文件。所有输入输出操作都是由 Unix I/O 的系统函数调用读写文件来实现的。文件向应用程序提供了统一的视角来看待各种 I/O 设备，大大简化了程序员的工作量。</p><h3 id="font-color-orange-Amdahl定律-font"><font color='orange'>Amdahl定律</font></h3><p><strong><font color='pink'>想要显著加速整个系统，必须要提升全系统中相当大部分的速度</font></strong> 。</p><blockquote><p>如果系统中 60% 的部分加速到无需时间，那么整个系统最终的加速比也只有 2.5X</p></blockquote><hr><h2 id="font-color-red-信息的处理和表示-font"><font color='red'>信息的处理和表示</font></h2><p><strong><font color='greew'>信息 = 位 + 解释</font></strong></p><blockquote><p>由于不同数据类型有不同的底层实现原理，导致它们的行为也大不相同，比如整形能够进行结合律和交换律，而浮点数却不行。整形是精确的，而浮点是近似的。对相同的位进行不同的解释，得到的结果也大不相同。</p></blockquote><h3 id="font-color-orange-信息存储-font"><font color='orange'>信息存储</font></h3><p><strong>字节（byte）是最小的可寻址单位（操作单位），而不是内存中单独的位。</strong> 每个字节由唯一的数字表示，表示其地址，所有字节的地址集合构成了 <strong>虚拟地址空间</strong> 。程序数据，指令和控制信息完全在虚拟内存空间中管理。</p><blockquote><p>C编译器将指针和类型信息联系起来，如此便可以根据指针值的类型来生成不同的机器级代码。</p><p><strong><font color='gree'>实际上，机器代码中并不包含关于数据类型的信息</font></strong> 。问题：那么运行时，CPU 怎么知道用什么方式来解释位？</p></blockquote><h4 id="font-color-00FFFF-十六进制-font"><font color=#00FFFF>十六进制</font></h4><p><strong>一个十六进制数 = 4个位</strong> ，<strong>两个十六进制数 = 2个位 = 1个字节</strong></p><blockquote><p>比如：0x173A4</p><img src="/2022/img/20220709110111.png" alt="image-20220709110110979" style="zoom:67%;" /></blockquote><h4 id="font-color-00FFFF-字数据大小-font"><font color=#00FFFF>字数据大小</font></h4><p><strong>字长（word size）指明了指针的大小，决定了虚拟地址空间的最大大小</strong> 。</p><p>64 位机器大多可以运行 32 位程序，而 32 位机器无法运行 64 位程序。”32位程序“ 或 “64位程序” 区别在于该程序是如何编译的，而不是其运行的机器类型。</p><p>同时，C数据类型的大小也受字数据大小的影响。</p><blockquote><p>char 常用于储存单个字符，但它也可以用来储存整数值，因为其本质仍是整数。然而并不值得这样做，编译器有可能生成额外代码将 char 变为 int，造成不必要的开销。</p></blockquote><p>为了数据类型大小对机器的依赖，ISO C99 引入了大小固定的数据类型，如：int32_t，int64_t 。</p><p><strong>C标准仅规定 char 的大小必须为 1 字节，其他类型仅规定了下限，而没有规定上限。</strong></p><blockquote><p>大部分数据类型都默认编码为有符号类型，但 char 是个例外，C标准不保证这一点，尽管大多编译器视其为有符号数。</p></blockquote><h4 id="font-color-00FFFF-寻址和字节顺序-font"><font color=#00FFFF>寻址和字节顺序</font></h4><p><strong>小端（little endian）：</strong> 高位在高地址（违背直觉）</p><p><strong>大端（big   endian）：</strong> 高位在低地址（符合直觉）</p><p>如表示：0x01234567</p><img src="https://jyxcpp.netlify.app/img/20220709113101.PNG" alt="IMG_0381(20220709-113043)" style="zoom:67%;" /><p><strong>一旦选定了特定操作系统，字节顺序也就确定了。</strong></p><blockquote><p>如何确定大小端？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">char</span> *b = (<span class="type">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*b == <span class="number">0x78</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line">&#125;demo;</span><br><span class="line"> </span><br><span class="line">demo.sh = <span class="number">0x0001</span>;<span class="comment">//小端：0x0100    大端:0x0001</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(demo.ch == <span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-00FFFF-移位运算-font"><font color=#00FFFF>移位运算</font></h4><p><strong>左移 k 位时，丢弃最高的 k 位，并在右边补上 k 个 0 。</strong> 右移时，分为 <strong>算术右移</strong> 和 <strong>逻辑右移</strong> ：</p><p>算术右移：左端补上 k 个 <strong>有效位</strong> 的值。</p><p>逻辑右移：左端补上 k 个 0</p><blockquote><ul><li><p>C语言标准没有明确定义有符号数的右移采用哪种方式，但几乎所有编译器和机器都对有符号数采用算术右移。无符号数只能采用逻辑右移。</p></li><li><p>在许多机器上， <strong><font color=#FF00FF>实际的位移量 = k % w</font></strong> （w是数据类型所占位数），比如 <code>int a = 0x12345678 &lt;&lt; 36</code> ，实际上的的位移量应该是 <code>36%32=4</code> 。不过此行为对于C程序而言是未定义的（java特别要求采用上述方式），应保证位移量小于数据所占位数。</p></li></ul></blockquote><h4 id="font-color-00FFFF-补码编码-font"><font color=#00FFFF>补码编码</font></h4><blockquote><p>C/C++ 支持有符号数（默认）和无符号数，java 只支持有符号数。</p><p><strong>C语言标准并没有要求有符号数的表示需用补码，但基本上所有实现都采用的补码。相反，Java标准要求必须用补码。</strong></p></blockquote><p>补码编码用于有符号整数，不同于无符号数编码，补码编码将最高有效位解释为负权，如下：</p><img src="https://jyxcpp.netlify.app/img/20220710093132.png" alt="image-20220710093132790" style="zoom:67%;" /><p><strong><font color='greew'>即：当符号位为1时，为负数；符号位为0时，为负数。</font></strong></p><div class="note info flat"><p>补码如此设计是为了让计算机用加法来实现减法，因为计算机只有加法器。而减法的实现正是通过最高位截断来实现的，如下图：</p><img src="https://jyxcpp.netlify.app/img/20220710103319.png" alt="减法实现" style="zoom:50%;" /></div><blockquote><p>至于原码和反码，只是为了帮助我们快速地计算相反数而引入的概念，个人认为学习时最好不要自动引入这两者，否则很容易混乱。</p><p>A - B = A + (-B)，<strong>减一个正数B，等于加上B的相反数，即B的补码</strong> 。对计算机而言，A 和 B 本来就是采用的补码，所以 B 本来就是负数，不存在 -B 这一说。只是对人而言，当补码为负数时不太好计算，所以引入原码和反码来辅助计算(具体见后文) ，就可以很方便的把减 B 变为加上 B 的相反数。</p><p><strong>浮点数中会使用的原码的概念。</strong></p></blockquote><p><strong>补码的属性：</strong></p><ul><li><p>|MIN| = |MAX| + 1</p><blockquote><p>这会造成细微的计算错误： <strong>-MIN = MIN</strong></p><p>所以：<font color='red'>X &gt; Y != (-X) &lt; (-Y)</font></p></blockquote></li><li><p>最大的无符号数比最大的有符号数的两倍还大1。</p></li></ul><div class="note info flat"><p>简单了解一下原码，反码和补码的关系，以应对计算：</p><p>真值：带符号位的机器数对应的真正数值称为机器数的真值。</p><ul><li><p>原码：符号位加上真值的 <strong>绝对值</strong> , 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 = 0000 0001</p><p>[- 1]原 = 1000 0001</p></li><li><p>反码：正数的反码是其本身，负数的反码是在其原码的基础上, <strong><font color='greew'>符号位不变</font></strong> ，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[- 1] = [10000001]原 = [11111110]反</p></li><li><p>补码：正数的补码就是其本身，负数的补码是在其原码的基础上, <strong><font color='greew'>符号位不变</font></strong> ， 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1 ] = [10000001]原 = [11111110]反  = [11111111]补</p></li></ul><p><strong>一般情况下不要引入这几个概念，极易混。对于整形的储存方式，就只分为无符号编码和补码。</strong></p><p><strong><font color='red'>将二进制数（无论补码还是无符号编码）取反加1（补码）的结果和原二进制数相加，其和为0</font></strong> 。</p><p>对补码而言：<strong>-X = ~X + 1</strong></p><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解</a></p></div><h4 id="font-color-00FFFF-有符号数和无符号数的转换-font"><font color=#00FFFF>有符号数和无符号数的转换</font></h4><ul><li><p><strong>当强制地转换在有符号类型和无符号类型间转换时，结果的位值不变，只改变解释这些位的方式</strong></p></li><li><p><strong>当隐式地发生转换时，有如下几个规则：</strong></p><blockquote><ul><li><p><strong><font color='red'>整形提升：</font></strong> signed 符号扩展，unsigned 零扩展。</p><blockquote><p>符号扩展：高位补充符号位的值</p><p>零扩展：高位补零</p><p>这样做可以在保持值不变的情况下将位数少的二进制数（如8位）转为位数多的二进制数（如32位）。</p><p>从直观上理解为什么高位补符号位其值不变：</p><p>a = 1110           -&gt; 取反加一 -&gt; 0010</p><p>b = 11111110    -&gt; 取反加一 -&gt; 00000010</p><p>a和b的相反数相同，故 a = b</p></blockquote></li><li><p><strong><font color='red'>值保护规则：</font></strong> <font color='red'>仅针对无符号数！ </font> <strong>如果 signed int 可以装下扩展前 unsigned 类型的所有值</strong> ，则提升（零扩展）后将其视为 signed int，反之视作 unsigned int 。</p></li><li><p><strong><font color='red'>无符号数和有符号数混合运算时，有符号数会默认转变为无符号数。</font></strong> <font color='red'>此规则发生在前两个规则之后，具体看后文</font></p><div class="note danger flat"><blockquote><p><strong><font color='red'>应极力避免有符号数和无符号数的混合运算，其差错难以发现！</font></strong></p></blockquote></div></li></ul></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aha&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dada&quot;</span>;   <span class="comment">//结果输出dada</span></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aha&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dada&quot;</span>;  <span class="comment">//结果输出aha</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>第一种情况：<ol><li><code>unsigned char</code> 和 <code>signed int</code> 比较，首先 <code>unsigned char</code> 采用值保护规则，进行提升，由于 <code>signed int</code> 可以装下 <code>unsigned char</code> 的所有值，所以提升后，a 的类型为 <code>signed int</code></li><li>a 和 b 都为 <code>signed int</code> ，直接进行比较，a &gt; b，输出 dada</li></ol></li><li>第二种情况：<ol><li><code>unsigned int</code> 和 <code>signed int</code> 混合运算，后者变为无符号数，-1 变为 INT_MAX</li><li>进行比较，b &gt; a ，输出aha</li></ol></li></ul><p><strong><font color=#FF00FF>补码转为无符号数：</font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220710160958.png" alt="关系式"></p><p><strong><font color=#FF00FF>无符号数转换为补码：</font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220710161025.png" alt="关系式"></p><hr><h4 id="font-color-00FFFF-截断-font"><font color=#00FFFF>截断</font></h4><p><strong>截断无符号数为k位：X’ = X % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span></strong></p><p><strong>截断有符号数为k位：X’ = X % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> ，且最高位作符号位</strong></p><blockquote><p><strong><font color='orange'>取模是丢高位，除法是丢低位：</font></strong></p><p>10101 ➗2   = 1110</p><p>10101 %  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> = 1110</p></blockquote><p>不论大端还是小段，截断丢弃的都是高位数据！所以下面方法来判断大端还是小端是无效的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">char</span> c = a;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0x78</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong><font color='red'>整数运算实际上就是一种模运算形式！</font></strong></p><hr><h4 id="font-color-00FFFF-无符号加法-font"><font color=#00FFFF>无符号加法</font></h4><p><strong><font color=#FF00FF>X + Y = ( X + Y ) % <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></font></strong></p><p><img src="https://jyxcpp.netlify.app/img/20220713083030.png" alt="image-20220713083023388"></p><p>模数加法形成了一种数学结构，即 <strong>阿贝尔群</strong> 。也就是说，模数加法是 <strong>可交换</strong> 和 <strong>可结合的</strong> 。</p><blockquote><p>这说明对于 ( X + Y ) - Y ，无论 ( X + Y ) 是否溢出，始终有 ( X + Y ) - Y = X</p><p><strong><font color=#FF00FF>这也是整形运算可使用交换律和结合律的原因，而浮点数运算则不可。</font></strong></p></blockquote><hr><h4 id="font-color-00FFFF-补码加法-font"><font color=#00FFFF>补码加法</font></h4><img src="https://jyxcpp.netlify.app/img/20220713083826.PNG" alt="公式" style="zoom:67%;" /><img src="https://jyxcpp.netlify.app/img/20220713083902.PNG" alt="示意图" style="zoom:67%;" /><p><strong>加正数则顺时针，减正数则逆时针</strong>。</p><div class="note danger flat"><p><strong><font color='red'>所以 X&lt;1 不等价于 X-1&lt;0</font></strong> ，当 X = INT_MIN 时，X - 1 = INT_MAX</p><p>此类细节错误经常出现，需要注意！</p></div><hr><h4 id="font-color-00FFFF-乘以常数-font"><font color=#00FFFF>乘以常数</font></h4><blockquote><p>在大多数机器上，整数乘法往往需要较多的时钟周期，而其他整数运算（加减，位级运算，移位）只需要 1 个时钟周期。因此编译器会试着用移位和加法的组合运算来代替常数的乘法</p></blockquote><p><strong><font color=#FF00FF>对无符号和补码值都有： X&lt;&lt; K = X * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span></font></strong></p><p>技巧：考虑一组从位位置 n 到位位置 m （n&gt;m）的连续的 1 ，如对于 14 而言有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0000 0000 0000 1110</span></span><br><span class="line"><span class="comment">//                ⬆⬆⬆⬆</span></span><br><span class="line"><span class="comment">//                3210</span></span><br></pre></td></tr></table></figure><p><strong>则可以有下面两种形式表示此计算：</strong></p><ol><li>x &lt;&lt; n + x&lt;&lt;(n-1) + … + x&lt;&lt;m</li><li>x&lt;&lt;(n + 1) - (x &lt;&lt; m)</li></ol><p>显然，第二种方法更好。</p><blockquote><p>例如：</p><ul><li>X * 14 = X * ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> +<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> ) = (X&lt;&lt;3) + (X&lt;&lt;2)+ (X&lt;&lt;1) = (X&lt;&lt;4) - (X&lt;&lt;1)</li><li>3*A = A&lt;&lt;1 + A</li></ul></blockquote><hr><h4 id="font-color-00FFFF-除以常数-font"><font color=#00FFFF>除以常数</font></h4><blockquote><p>整数除法比整数乘法需要更多的时钟周期（30乃至更多），所以编译器也会 <strong>尝试</strong> 用左移来代替除法。</p></blockquote><p><strong>无符号数和补码数分别使用逻辑右移和算术右移来实现除法。</strong></p><p>对于无符号数和补码数，<strong><font color='greew'>除以 2 的幂的除法</font></strong> ，都有：<strong><font color='greew'>X &gt;&gt;k = [X / <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>]</font></strong></p><blockquote><p>[ a ] 代表不超过 a 的最大整数，如 [14.5] = 14 ，[-3.5] = -4，即向下舍入。</p></blockquote><div class="note info flat"><p>如果想要变为向上舍入，即令 [ a ] = 超过 a 的最小整数，则需要使用以下 “偏置技术”：</p><p><strong>(x+(1&lt;&lt;k)-1)&gt;&gt;1 = [x/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>]</strong></p><p><strong><font color='greew'>而对于大多数补码机器而言，一般策略是：对正数向下舍入，对负数向上舍入（以0为参考点）。所以一般使用如下方法：</font></strong></p><p><mark class="hl-label default">(x &lt; 0?x+(1 &lt;&lt; k ) - 1 : x) &gt;&gt; k</mark></p></div><div class="note danger flat"><p><strong><font color='red'>这种方法不能推广到任意常数的除法！因为除法没有分配律。</font></strong></p></div><hr><h4 id="font-color-00FFFF-浮点数-font"><font color=#00FFFF>浮点数</font></h4><blockquote><p>在六七十年代，计算机界对浮点数的处理比较混乱，各家厂商都有自己的一套规则，缺少统一的业界标准，这给数据交换、计算机协同工作带来了很大不便。Intel 在研发 8087 浮点数协处理器时，聘请到加州大学伯克利分校的 William Kahan 教授以及他的两个伙伴，来为 8087 协处理器设计浮点数格式，他们的工作完成地如此出色，设计的浮点数格式具有足够的合理性和先进性，被 IEEE 组织采用为浮点数的业界标准，并于 1985 年正式发布，这就是 IEEE 754 标准。IEEE 754完成了对浮点数的统一，所有计算机都支持此标准。</p></blockquote><p>了解浮点数之前，我们先来认识一下 <strong>定点数</strong> ：</p><img src="https://jyxcpp.netlify.app/img/20220713113938.png" alt="定点数" style="zoom:50%;" /><p><img src="https://jyxcpp.netlify.app/img/20220713114053.png" alt="定点数"></p><p><strong>特点</strong></p><p>如此一来，小数点就永远在第16位之后，整数部分和小数部分一目了然，不管什么时候，整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。</p><p><strong>精度</strong></p><p>小数部分的 <strong>最后一位可能是精确数字，也可能是近似数字</strong>（由四舍五入、向零舍入等不同方式得到）；除此以外，<strong>剩余的31位都是精确数字</strong> 。从二进制的角度看，这种定点格式的小数，<strong>最多有 32 位有效数字，但是能保证的是 31 位；也就是说，整体的精度为 31~32 位</strong> 。</p><p><strong>范围</strong></p><p>将内存中的所有位（Bit）都置为 1，小数的值最大，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>，极其接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>，换算成十进制为 65536。将内存中最后一位（第32位）置 1，其它位都置0，小数的值最小，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p><strong>综述</strong></p><p>用定点格式来存储小数，优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。</p><p><strong><font color=#FF00FF>浮点数</font></strong></p><blockquote><p>浮点数使用指数的形式来存储小数，当指数变化时，其小数点的位置也发生变化，故而称之为浮点数。</p></blockquote><p><strong>C语言标准规定</strong> ，小数在内存中以科学计数法的形式来存储，具体形式为：</p><mark class="hl-label default">flt = sign × mantissa × base^exponent</mark> <p>说明：</p><ul><li><mark class="hl-label default">flt</mark>  是要表示的小数。</li><li><mark class="hl-label default">sign</mark>  用来表示 flt 的正负号，它的取值只能是 0 或 1：取值为 0 表示 flt 是正数，取值为 1 表示 flt 是负数。</li><li><mark class="hl-label default">base</mark>  是基数（进制），它的取值大于等于 2。</li><li><mark class="hl-label default">mantissa</mark>  为尾数，或者说精度，是 base 进制的小数，并且 1 ≤ mantissa ＜ base，这意味着，**小数点前面只能有一位数字**  <div class="note danger flat"><p>注意，10.101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，10.101 不是尾数，尾数必须要满足 1 ≤ mantissa ＜ base 。</p></div></li><li><mark class="hl-label default">exponent</mark>  为指数，是一个整数，可正可负，并且为了直观一般采用十进制表示。</li></ul><p>例如：1.0101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> ，其中 1.0101 是尾数，10 是基数，3 是指数。</p><p><strong><font color=#FF00FF>将小数转换为浮点格式</font></strong></p><p>当 base 取值为 10 时，19.625 的浮点形式为：</p><p>19.625 = 1.9625 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">10^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></p><p>当 base 取值为 2 时，将 19.625 转换成二进制为 10011.101，用浮点形式来表示为：</p><p>19.625 = 10011.101 = 1.0011101 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>19.625 整数部分的二进制形式为：<br>19 = 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span> = 10011<br>小数部分的二进制形式为：<br>0.625 = 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> + 0 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> + 1 × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> = 101<br>将整数部分和小数部分合并在一起：<br>19.625 = 10011.101</p></blockquote><p>可以看出，当基数（进制）base 确定以后，<strong><font color=#00FFFF>指数 exponent 实际上就成了小数点的移动位数</font></strong> ：</p><ul><li>exponent 大于零，mantissa 中的小数点右移 exponent 位即可还原小数的值；</li><li>exponent 小于零，mantissa 中的小数点左移 exponent 位即可还原小数的值。</li></ul><p><strong><font color=#FF00FF>储存</font></strong></p><p><strong>32 位整形（float）：</strong> <mark class="hl-label default">符号位 1 bit</mark>  + <mark class="hl-label default">指数位 8 bit</mark>  + <mark class="hl-label default">尾数位 23 bit</mark> </p><p><strong>64 位整形（double）：</strong> <mark class="hl-label default">符号位 1 bit</mark>  + <mark class="hl-label default">指数位 11 bit</mark>  + <mark class="hl-label default">尾数位 52 bit</mark> </p><ul><li><p><strong>符号位：</strong> 用 0 表示正数，用 1 表示负数。</p></li><li><p><strong>尾数位：</strong> 当采用二进制形式后，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：<strong><font color='red'>尾数的整数部分一定为 1（规格化）</font></strong> ，是一个恒定的值，<strong>这样就无需在内存中提现出来，可以将其直接截掉，只要把小数点后面的二进制数字放入内存中即可</strong> 。对于 1.0011101，就是把 0011101 放入内存。</p></li><li><p><strong>指数位：</strong> 指数必须要有正负，但指数的存储并没有像整形那样采用补码编码的形式，而是采用的是 <strong>取中间值</strong> 的方式：</p><blockquote><p><strong><font color=#00FFFF>在规格化的情况下，</font></strong> float 的指数部分占用 8 Bits，能表示从 0-255 的值，取其中间值 127 （偏置值，bias），指数在写入内存前 <strong>先加</strong> 上127，读取时 <strong>再减</strong> 去 127 ，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。</p><p>对于 double ，bias = 1023 ，</p><p>其中，<strong>bias = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong></p></blockquote></li></ul><p><strong>根据 <mark class="hl-label default">exponent</mark>  的不同，编码的值可以分为三种情况：</strong></p><ul><li><p>规格化的</p><p><img src="https://jyxcpp.netlify.app/img/20220713160938.png" alt="规格化"></p></li><li><p>非规格化值</p><p><img src="https://jyxcpp.netlify.app/img/20220713183224.png" alt="非规格化"></p><p><strong><font color=#00FFFF>非规格化值的尾数不包含隐含的开头的 1，而是 0</font></strong></p></li><li><p>无穷大</p><p><img src="https://jyxcpp.netlify.app/img/20220713161208.png" alt="无穷大"></p></li><li><p>NaN（Not a Number）</p><p><img src="https://jyxcpp.netlify.app/img/20220713161445.png" alt="NaN"></p></li></ul><div class="note info flat"><p><strong>了解规范化数</strong></p><p><strong><font color=#00FFFF>规格化数的 E = e - bias ，非规格化数的 E = 1 - bias</font></strong> ，其中 <strong>E 为实际值，e 为内存值</strong> 。非规格化数采用此方式，可以极其巧妙使非规格化值平滑过度到规格化值，如下：</p><p><img src="https://jyxcpp.netlify.app/img/20220713173041.png" alt="假定的8位浮点格式"></p><p>可以看见，最大非规格化数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>7</mn><mn>512</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {7} {512}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">512</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 到最小规格化数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>8</mn><mn>512</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {8} {512}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">512</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的平滑转换。这种转换归功于对非规格化数的 E 的定义，其可以弥补非规格化数的尾数没有隐含的开头的 1 。</p><p><strong>同时还可以发现，当把上图中的位表达式解释为无符号数时，其就是升序排列的！</strong> 这并非偶然，IEEE 格式如此设计就是为了使浮点数能够使用整数排序函数来进行排序。</p><p><strong>规格化数的用途：</strong></p><ul><li><font color=#00FFFF>提供了表示浮点 0 的方法。因为使用规格化数，mantissa 必须的整数部分一定为 1，所以无法表示 0 </font>。当所有域都为 0 时，表示 +0.0 ；当符号位为 1 ，其他域为 0 时，表示 -0.0 。</li><li><font color=#00FFFF>表示那些很接近 0 的数</font></li></ul></div><div class="note info flat"><p>一些运算的结果不能是实数或无穷，就会返回 NaN，比如计算 根号下-1 或 ∞ - ∞ ，有时也可以用来表示某些未初始化的数据。</p></div><p><strong><font color='red'>精度</font></strong></p><p>计算机浮点误差主要来源于：一个有限位数的小数并不一定能转换成有限位数的二进制，只有末位是 5 的小数才 <strong>有可能</strong> 转换成有限位数的二进制，其它的小数都不行。 float 和 double 的尾数部分是有限的，固然不能容纳无限的二进制；即使小数能够转换成有限的二进制，也有可能会超出尾数部分的长度，此时也不能容纳。这样就必须“四舍五入”，将多余的二进制“处理掉”，只保留有效长度的二进制，这就涉及到了精度的问题。<strong>也就是说，浮点数不一定能保存真实的小数，很有可能保存的是一个近似值。</strong><br>对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24 位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的 23 位都是精确数字。也就是说，整体的精度为 23~24 位。如果转换成十进制，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16777216</mn></mrow><annotation encoding="application/x-tex">2^{24}= 16 777 216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16777216</span></span></span></span> ，一共8位；也就是说，<strong>最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。</strong></p><blockquote><p>比如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.5=1×2^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.75</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.75 = 1×2^{-1}+1×2^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ；而 0.55 与 0.755 就无法用有限的二进制位表示。</p></blockquote><p><strong><font color='red'>过程示范：</font></strong></p><p>将 12345 转为浮点格式：</p><ol><li><p>12345 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.100000011100</mn><msub><mn>1</mn><mn>2</mn></msub><mo>×</mo><mn>1</mn><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">1.1000000111001_2 × 12^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">1.100000011100</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>丢弃尾数开头的 1 ，并在 <strong>末尾</strong> 增加 10 个 0 ，来构造尾数字段，得到 <code>10000001110010000000000</code></p><blockquote><p><font color='red'>注意，小数是在末尾添 0 ，整数是在 开头添 0</font></p></blockquote></li><li><p>13 + 127 = 140 ，其二进制为：<code>10001100</code></p></li><li><p>符号位为 0</p></li><li><p>得到 <code>01000110010000001110010000000000</code></p></li></ol><p>同时可以发现，整形 12345 和 浮点 12345 有如下对应关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形 00000000000000000011000000111001</span></span><br><span class="line"><span class="comment">// 箭头                    ⬇···········⬇</span></span><br><span class="line"><span class="comment">// 浮点           01000110010000001110010000000000</span></span><br></pre></td></tr></table></figure><p>浮点的尾数部分与整形第一位后的所有位相对应。</p>]]></content>
      
      
      <categories>
          
          <category> 技术书籍笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/2022/06/28/git%E5%85%A5%E9%97%A8/"/>
      <url>/2022/06/28/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-本地操作-font"><font color='red'>本地操作</font></h2><h3 id="font-color-orange-安装Git-font"><font color='orange'>安装Git</font></h3><p>在Windows上使用Git，需从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按 <strong>默认选项</strong> 安装即可。</p><p>安装完成后，在 <code>git bash</code> 中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--global</code> 表示全局，你这台机器上所有的Git仓库都会使用这个配置。</p></blockquote><h3 id="font-color-orange-创建版本库-font"><font color='orange'>创建版本库</font></h3><blockquote><p>版本库（repository），简单来说就是一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。</p></blockquote><ol><li><p><strong>首先创建一个空目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> learnGit</span><br><span class="line">$ <span class="built_in">cd</span> learnGit</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 <mark class="hl-label default">git init</mark>  命令把这个目录变成Git可以管理的仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><blockquote><mark class="hl-label default">init</mark> 后，目录下会多一个隐藏目录 <mark class="hl-label default">.git</mark>  ，此目录用于管理仓库，不可随意更改。<p>通过 <mark class="hl-label default">ls -a</mark>  即可查看。</p></blockquote></li><li><p><strong>将文件添加到版本库</strong></p><div class="note info flat"><p>所有的版本控制系统，其实只能跟踪 <strong>文本文件</strong> 的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化。</p></div><p>首先在 <mark class="hl-label default">learnGit</mark>  目录中创建一个 <mark class="hl-label default">demo.text</mark>  文件。</p><p><strong>把文件添加到仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure><p><strong>把文件提交到仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;wrote a readme file&quot;</span> readme.text</span><br></pre></td></tr></table></figure><p><font color=#FF00FF>提交说明很重要！不可图省事就将其忽略</font></p><div class="note info flat"><p>如果命令后不添加文件名，则提交所有文件。</p></div></li></ol><h3 id="font-color-orange-查看版本信息-font"><font color='orange'>查看版本信息</font></h3><ul><li><mark class="hl-label default">git status</mark>  命令可以让我们时刻掌握仓库当前的状态，让我们知道那些文件修改了但还未添加，或添加了还未提交。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   readme.txt</span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><mark class="hl-label default">git diff 文件名</mark>  可以对比多个版本间的修改。<p><strong><font color=#00FFFF>显示暂存区和工作区的差异:</font></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git diff [file]</span><br><span class="line">若不加[file]，则比较所有文件</span><br></pre></td></tr></table></figure><p><strong><font color=#00FFFF>显示暂存区和上一次提交的差异:</font></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached [fileName]</span><br><span class="line">或</span><br><span class="line">$ git diff --staged [fileName]</span><br></pre></td></tr></table></figure><p><strong><font color=#00FFFF>显示两次提交之间的差异:</font></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;              </span><br><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt; --name-only  </span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff 3c6b 8037</span><br><span class="line">diff --git a/aha.docx b/aha.docx</span><br><span class="line">index 2c0f5a0..27f23f0 100644</span><br><span class="line">--- a/aha.docx</span><br><span class="line">+++ b/aha.docx</span><br><span class="line">@@ -1,2 +1,5 @@</span><br><span class="line"> 发生的洛克菲勒手动阀</span><br><span class="line"> 哈哈哈哈</span><br><span class="line">+发射点发生</span><br><span class="line">+发生发生</span><br><span class="line">+发士大夫撒</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>8037</code> 和 <code>3c6b</code> 是简写后的 <code>commit id</code> ， <code>commit id</code> 可以通过 <mark class="hl-label default">git log</mark>  命令查看</p></li><li><p><code>8037</code> 和 <code>3c6b</code> 的位置不同，则输出的内加减号会相反。<strong>最好将最新的 <code>commit id</code> 放在后面</strong></p></li><li><p>第 6 行 <code>@@ -1,2 +1,5 @@</code> 含义：</p></li></ul><p><code>-1,2</code> ：-1 代表修改前的文件，2 代表从第一行开始的前两行内容</p><p><code>+1,5</code> :  +1 代表修改后的文件，4 代表从第一行开始的前五行内容</p></blockquote></li></ul><h3 id="font-color-orange-版本回退-font"><font color='orange'>版本回退</font></h3><ul><li><mark class="hl-label default">git log</mark> 查看提交日志<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure><mark class="hl-label default">git log --pretty=oneline</mark> 可以简化输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br></pre></td></tr></table></figure><div class="note info flat"><p>Git 的 <code>commit id</code> （版本号）和SVN不一样，Git 的 <code>commit id</code> 不是1，2，3……递增的数字，而是一个 <code>SHA1</code> 计算出来的一个非常大的数字，用十六进制表示。因为Git是分布式的版本控制系统，多人可在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p></div></li><li><mark class="hl-label default">git reset</mark> 进行回退<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><blockquote><p><code>HEAD</code> 表示当前版本，也就是最新的提交 <code>1094adb...</code> ,上一个版本就是<code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成 <code>HEAD~100</code> 。</p><p><code>--hard</code> 后续进行剖析。</p></blockquote><p>回退之后，使用 <mark class="hl-label default">git log</mark>  发现之前最新的版本已经不在了，那么如何再返回到之前最新的版本？</p><p>使用 <mark class="hl-label default">git reflog</mark> 来查看之前的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>即可得到原先的版本号，再进行 <mark class="hl-label default">git reset--hard [commitID]</mark> 。</p></li></ul><h3 id="font-color-orange-暂存区和工作区-font"><font color='orange'>暂存区和工作区</font></h3><p><strong><font color=#00FFFF>工作区</font></strong> （Working Directory）进行工作时所在的文件夹（上文的 gitLearn目录），工作区下有一个隐藏的目录 <code>.git</code> ，这个不算工作区，而是Git的<strong>版本库</strong> 。</p><p>版本库中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="/2022/img/20220628212438.jpeg" alt="示意图"></p><p>第一步是用 <mark class="hl-label default">git add</mark>  把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用 <mark class="hl-label default">git commit</mark>  提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><blockquote><p>提交之后若没有做任何更改，那么工作区便是”干净的“：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></blockquote><h3 id="font-color-orange-跟踪修改-font"><font color='orange'>跟踪修改</font></h3><div class="note primary flat"><p><strong><font color='red'>Git跟踪并管理的是修改，而非文件。</font></strong></p><p><code>git</code> 的 <strong>快照</strong> 是对该版本所有文件状态的一种&quot;描述&quot;，每次提交 <code>commit</code> 时 <code>git</code> 会生成 <strong>快照</strong> 来记录这次 <code>commit</code> 时整个项目所有文件的信息。</p><p>这个快照并不是这次 <code>commit</code> 时项目中所有文件的拷贝，而是一种索引</p></div><p>每次修改，必须先 <mark class="hl-label default">git add</mark> 到暂存区，才能 <mark class="hl-label default">commit -m</mark> 到分支中。</p><h3 id="font-color-orange-撤销修改-font"><font color='orange'>撤销修改</font></h3><ul><li><p><strong>丢弃工作区的修改（还未 <mark class="hl-label default">git add</mark>  ）：</strong> <mark class="hl-label default">git restore file</mark> </p><blockquote><p>此时有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></blockquote></li><li><p><strong>将暂存区撤回到工作区（工作区可能改变）：</strong> <mark class="hl-label default">git reset HEAD file</mark> 或 <mark class="hl-label default">git restore --staged file</mark> </p></li><li><p><strong>仅消除暂存区的文件记录，工作区不会变 ：</strong> <mark class="hl-label default">git rm —cached</mark> </p></li><li><p><strong>从master同时恢复工作区和暂存区：</strong> <mark class="hl-label default">git restore --source=HEAD --staged --worktree [file]</mark> </p></li><li><p><strong>撤销 <mark class="hl-label default">git commit</mark> ：</strong> 版本回退，使用 <mark class="hl-label default">git reset --hard</mark> </p></li></ul><h3 id="font-color-orange-删除文件-font"><font color='orange'>删除文件</font></h3><p>在工作区中删除文件时，如果确实是进行删除，使用 <mark class="hl-label default">git rm</mark>  命令，将文件从工作区中删除，并 <mark class="hl-label default">git add</mark> 到暂存区，而后<mark class="hl-label default">git commit</mark> 到版本库。</p><div class="note info flat"><p>先手动删除文件并 <mark class="hl-label default">git add</mark> 和 <mark class="hl-label default">git rm</mark>  效果是一样的。</p></div><p>如果是误删除，则直接版本回退，使用 <mark class="hl-label default">git reset --hard HEAD^</mark> 。</p><h2 id="font-color-red-远程仓库-font"><font color='red'>远程仓库</font></h2><h3 id="font-color-orange-SSH-注册-font"><font color='orange'>SSH 注册</font></h3><blockquote><p>Git 的本地仓库管理并不能保障数据的安全（硬盘损坏了只能GG），也不利于团队协作。</p><p><strong>远程仓库</strong> 应运而生。</p></blockquote><p><code>github</code> 是全球最大的提供Git仓库托管服务的网站。本地仓库可以很方便地推送到 <code>github</code> 上进行托管，无需担心本地数据丢失。</p><p>由于 <strong>本地Git仓库和GitHub仓库之间的传输是通过 SSH 加密的</strong> ，所以，需要一点设置：</p><ol><li><p>创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code> 和<code>id_rsa.pub</code> 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><p>Keygen 为 Key Generator 的简写形式，就是一般所说的注册机，是为软件注册生成所需的注册码的一种程序。</p></li><li><p>为什么 <code>GitHub</code> 需要 SSH Key 呢？因为 <code>GitHub</code> 需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p><a href="https://www.cnblogs.com/xiongzaiqiren/p/13917949.html">Linux密钥rsa加密原理和ssh使用密钥实现免密码登录</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH原理与运用:远程登入</a></p></li></ul></div><p>而后可以在用户主目录里找到<code>.ssh</code> 目录，里面有<code>id_rsa</code> 和<code>id_rsa.pub</code> 两个文件，这两个就是 SSH Key 的秘钥对，<code>id_rsa</code> 是私钥，不能泄露出去，<code>id_rsa.pub</code> 是公钥，可以放心地告诉任何人。</p><div class="note info flat"><p><a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a></p></div></li><li><p>登陆 <code>GitHub</code>，打开 Account settings，SSH Keys 页面，填入 <code>id_rsa.pub</code> 即可。</p></li></ol><h3 id="font-color-orange-远程仓库管理-font"><font color='orange'>远程仓库管理</font></h3><h4 id="font-color-FF00FF-添加远程库-font"><strong><font color=#FF00FF>添加远程库</font></strong></h4><p>首先在 <code>Github</code> 上新建一个 public 仓库（repository）<code>myRepo</code> 。可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>然后在本地的 <code>learnGit</code> 仓库下运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yourName/learngit.git</span><br><span class="line">或</span><br><span class="line">$ git remote add origin https://github.com/yourName/learngit.git</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>origin</code> ：远程仓库的默认名字。</li><li><code>yourName</code> ：你的 <code>Github</code> 用户名。填他人的用户名虽然可以关联，但是仍无法推送，因为你的 SSH Key 公钥不在他人的账户列表中。</li></ul></blockquote><p><strong>推送命令</strong> ：<mark class="hl-label default">git push</mark> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>master</code> ：把当前分支<code>master</code>推送到远程仓库。</li><li><code>-u</code>参数 ：第一次推送 <code>master</code> 分支时，加上<code>-u</code>参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的<code>master</code> 分支和远程的<code>master</code> 分支 <strong>关联</strong> 起来，在以后的推送或者拉取时就可以简化命令。</li></ul><p>之后推送，只需：<mark class="hl-label default">git push</mark> </p></blockquote><h4 id="font-color-FF00FF-删除远程库-font"><strong><font color=#FF00FF>删除远程库</font></strong></h4><ol><li><p>查看远程仓库信息，获取名称：<mark class="hl-label default">git remote -v</mark> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><blockquote><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p></blockquote></li><li><p>解除绑定：<mark class="hl-label default">git remote rm origin</mark> </p><blockquote><p><code>origin</code> 是远程仓库名，也可能是其他名称。</p><p><strong><font color='yellow'>注意，这只是解除本地仓库和远程仓库的绑定，并没有在物理上删除远程仓库。</font></strong> 要真正删除远程库，需要登录到 GitHub，在后台页面找到删除按钮再删除。</p></blockquote></li></ol><h4 id="font-color-FF00FF-克隆远程仓库-font"><strong><font color=#FF00FF>克隆远程仓库</font></strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:yourName/demo.git</span><br><span class="line">或</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/yourName/demo.git</span><br></pre></td></tr></table></figure><div class="note info flat"><p>前者采用 SSH 协议，后者采用 https 协议。</p><p>Git支持多种协议，包括 https ，但 SSH 协议速度最快。</p></div><p>克隆指定分支（master）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b master git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><h2 id="font-color-red-分支管理-font"><font color='red'>分支管理</font></h2><h3 id="font-color-orange-了解分支-font"><font color='orange'>了解分支</font></h3><blockquote><p>在平常开发中，一般都会对应三种环境，本地环境、测试环境、线上环境。开发的基本流程都是先在本地环境开发好,再把代码发布到测试环境测试，最后再发布到线上环境。</p><p>对于代码，我们使用 Git 分支进行管理，一般而言会对应两个分支, master 和 dev 。</p><p>master 分支主要用于线上发布使用，dev 分支用于平常的开发和测试。除此之外，我们也可以创建多个分支，比如给某次的迭代开发创建一个分支、针对一次代码优化创建一个分支，或者针对一次 Bug 修复，我们可以新建个分支。</p></blockquote><h3 id="font-color-orange-创建与合并分支-font"><font color='orange'>创建与合并分支</font></h3><ol><li><strong>此时只有一条 <code>master</code> 主线。</strong></li></ol><p><img src="/2022/img/20220629234302.png" alt="分支状态"></p><blockquote><p><strong><font color=#00FFFF><code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code> ，<code>master</code> 才是指向（最新）提交的，所以，<code>HEAD</code>指向的就是当前分支。</font></strong></p><p><strong><font color=#FF00FF><code>HEAD</code> 主要是用来管理分支的，而不是处理版本。</font></strong></p></blockquote><ol start="2"><li><p><strong>新建 <code>dev</code> 分支。</strong></p><p><img src="/2022/img/20220629234952.png" alt="分支状态"></p></li></ol><blockquote><p>Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改变<code>HEAD</code> 的指向，工作区的文件都没有任何变化！</p><p><code>HEAD</code> 指向 <code>dev</code> 表妹当前分支为 <code>dev</code> 。</p></blockquote><div class="note danger flat"><p><strong><font color='red'>分支的创建位置不能乱选！在master或dev上创建分支是有区别的！</font></strong></p></div><ol start="3"><li><p><strong>提交 <code>dev</code> 分支上的修改。</strong></p><p><img src="/2022/img/20220629235213.png" alt="分支状态"></p></li><li><p>切换到 <code>master</code> 主分支，并合并 <code>dev</code> 。</p><p><img src="/2022/img/20220629235430.png" alt="分支状态"></p></li></ol><hr><ul><li><p><strong>创建：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br></pre></td></tr></table></figure></li><li><p><strong>切换：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">或</span><br><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure></li><li><p><strong>创建并切换：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">或</span><br><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>此命令相当于连续使用前两个命令。</p><div class="note danger flat"><p><strong><font color='red'>注意，切换分支前必须先 commit，否则当前工作区的更改可能提交到切换后的分支，导致混乱。</font></strong></p></div></li><li><p><strong>查看当前分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><blockquote><p><code>git branch </code>命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p></blockquote></li><li><p><strong>合并分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><blockquote><p>注意是在 <code>master</code> 分支上合并 <code>dev</code> 分支。</p><p><code>Fast-forward</code> 表面本次合并是 “快进模式” ，也就是直接把 <code>master</code> 指向 <code>dev</code> 的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能 <code>Fast-forward</code> ，还有其他方式的合并。</p></blockquote></li><li><p><strong>查看合并情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -graph</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br></pre></td></tr></table></figure></li><li><p><strong>删除分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure></li></ul><h3 id="font-color-orange-解决冲突-font"><font color='orange'>解决冲突</font></h3><p>情形：</p><ol><li>在 <code>dev</code> 分支上修改了 <code>demo.text</code> ，并提交了修改。</li><li>切换到 <code>master</code> 分支。</li><li>在 <code>master</code> 分支上再次修改 <code>demo.text</code> ，并提交修改。</li><li>在 <code>master</code> 分支上合并 <code>dev</code> 分支。</li></ol><p>此时报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Auto-merging demo.text</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> demo.text</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>也可使用 <mark class="hl-label default">git status</mark> 查看冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>冲突原因在于：同时在两个分支上更改同一文件，Git 不知道采用谁的修改</strong></p><p><img src="/2022/img/20220629232128.png" alt="分支状态"></p><blockquote><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来。<strong>若修改的不是同一文件，则可以直接合并</strong> ，而若修改的是同一文件，就可能发生如上的冲突。</p></blockquote><p>解决办法： <strong><font color=#00FFFF>直接在当前分支（master）上决定最终的修改，提交后进行合并即可。</font></strong></p><p><img src="/2022/img/20220629232821.png" alt="成功合并后的分支状态"></p><p>如上所示，<strong>Git 就会在 merge 时生成一个新的 commit</strong></p><div class="note danger flat"><p><strong>注意，修改并合并后，仅仅是把 <code>master</code>  的修改提交了，<code>dev</code> 分支上的东西仍然未变。</strong></p></div><p>合并分支时，如果可能，Git 会优先使用 <code>Fast-forward</code> 模式来进行合并。如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit 。</p><p>禁用 <code>Fast-forward</code> ：<mark class="hl-label default">--no-ff</mark> </p><p><img src="/2022/img/20220630094332.png" alt=""></p><h3 id="font-color-orange-分支管理策略-font"><font color='orange'>分支管理策略</font></h3><div class="note info flat"><p>Git的特色之一就是可以灵活的建立分支，因为有分支的存在，才构成了多工作流的特色。事实的确如此，因为项目开发中，多人协作，分支很多，虽然各自在分支上互不干扰，但是我们总归需要把分支合并到一起，而且真实项目中涉及到很多问题，例如版本迭代，版本发布，Bug 修复等，为了更好的管理代码，需要制定一个工作流程，这就是通常意义上的 Workflow ，也就是我们常说的分支管理策略。</p></div><p>目前使用度最高的工作流前三名分别是以下三种（排名不分先后）：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//nvie.com/posts/a-successful-git-branching-model/">Git Flow</a></li><li><a href="https://link.zhihu.com/?target=http%3A//scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a></li><li><a href="https://link.zhihu.com/?target=https%3A//docs.gitlab.com/ee/workflow/gitlab_flow.html">GitLab Flow</a></li></ul><p>其中 Git Flow 出现的最早，GitHub Flow 在 Git Flow 的基础上，做了一些优化，适用于持续版本的发布，而 GitLab Flow 出现的时间比较晚，所以综合前面两种工作流的优点，制定而成的一个工作流。</p><p>在采用 <code>Git Flow</code> 工作流的项目中，代码的中央仓库会一直存在以下两个长期分支：</p><ul><li><strong>Master</strong></li><li><strong>Develop</strong>（dev）</li></ul><p>其中 origin／master 分支上的最新代码永远是版本发布状态。origin／develop 分支则是最新的开发进度。</p><p>当 develop 上的代码达到一个稳定的状态，可以发布版本的时候，develop 上这些修改会以某种特别方式被合并到 master 分支上，然后标记上对应的版本标签。</p><p>团队的每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了，测试完成后再将 <code>dev</code> 合并到 <code>master</code> 上即可。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="/2022/img/20220630094724.png" alt="teamwork"></p><h3 id="font-color-orange-Bug-分支-font"><font color='orange'>Bug 分支</font></h3><p>情形：</p><p>你的名字叫 bob ，你在 <code>bob</code> 分支上工作时，接到一个修复代号为101的bug的任务时，很自然地，你想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 <code>bob</code> 上进行的工作还没做完，不能提交，怎么办？</p><blockquote><p>为什么要提交后才能创建其他分支？</p><p><strong><font color=#FF00FF>因为如果不提交就切换到新分支，那么你在本分支上修改的 <code>test</code> 文件就会同时存在于新分支的工作区上，而这个文件是本分支的，如此就导致冲突和覆盖</font></strong></p></blockquote><p>使用 <mark class="hl-label default">git stash</mark>  命令来储存工作区现场，处理完 Bug 后再恢复现场即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>此时查看工作区状态，就是 “干净” 的。<strong>然后就可以放心地创建分支来修复bug。</strong></p><p><strong><font color=#00FFFF>首先确定要在哪个分支上修复bug</font>，假定需要在 <code>dev</code> 分支上修复，就从 <code>dev</code> 创建临时分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">&#x27;issue-101&#x27;</span></span><br></pre></td></tr></table></figure><p>修复完成后，切换到 <code>dev</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>Bug 修复完成，继续回到 <code>bob</code> 分支上继续你的任务。那么如何恢复之前的工作区？</p><p>先使用 <mark class="hl-label default">git stash list</mark>  命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>然后恢复 <code>stash</code> ：</p><ol><li><p>使用 <mark class="hl-label default">git stash apply</mark>  ，但是恢复后，stash内容并不删除，你需要用 <mark class="hl-label default">git stash drop</mark> 来删除。</p><p>此命令也可以恢复指定的 <code>stash</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <mark class="hl-label default">git stash pop</mark> ，恢复的同时把stash内容也删了。</p></li></ol><p><strong><font color=#FF00FF> 修复了 <code>dev</code> 分支的bug后，你有理由怀疑，由于你所在的 <code>bob</code> 分支是从 <code>dev</code> 分支分出来的（或合并了 <code>dev</code> ），所以，这个bug其实在当前 <code>bob</code> 分支上也存在。</font></strong></p><p>那么如何解决 <code>bob</code> 分支上同样的 Bug？重新修改一遍？麻烦，且若之前修改的地方太多，你重新修改也不一定能和之前完全一样，风险很大！</p><p><strong>使用 <mark class="hl-label default">cherry-pick</mark>  命令，仅将某次的提交复制到本分支上来：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>同样的bug，要在 <code>bob</code> 上修复，我们只需要把 <code>4c805e2</code> 这个提交所做的修改“复制”到 <code>bob</code>分支。注意：我们只想复制 <code>4c805e2</code> 这个提交所做的 <strong><font color='red'>修改</font></strong> ，并不是把整个 <code>dev</code> 分支 merge 过来。</p><p>为什么不能直接 merge ？</p><p>一般而言，个人分支 <code>bob</code> 会比 <code>dev</code> 分支新很多，比如 <code>bob</code> 分支修改了 a，b，c 三个文件。而 <code>dev</code> 之前已经修复了 Bug（可能修改了文件d），那么 <code>bob</code> 和 <code>dev</code> 分支都有修改，就无法直接合并，还要进行其他操作，很麻烦。</p></div><div class="note danger flat"><p><strong><font color='red'>注意，<code>cherry-pick</code> 也可能引起冲突！</font></strong></p><p>情形：若你在 <code>dev</code> 改 Bug 时，先后提交了两次： <code>4ed34</code> 和 <code>233af</code> ，那么你就无法直接 <code>cherry-pick</code> <code>233af</code> ，因为这两次提交的代码很可能是连续的，你只 <code>cherry-pick</code> 后一次修改的代码，大概率会跑不起来。所以需要依次 <code>cherry-pick</code> 。</p></div><h3 id="font-color-orange-删除分支-font"><font color='orange'>删除分支</font></h3><mark class="hl-label default">git branch -d</mark> <p>如果 <code>feature</code> 分支还没有合并时，要删除此分支，会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-</span><br><span class="line">error: The branch <span class="string">&#x27;feature&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D feature-vulcan&#x27;</span>.</span><br></pre></td></tr></table></figure><p>所以需要使用 <mark class="hl-label default">git branch -D</mark>  强制删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature</span><br><span class="line">Deleted branch feature (was 287773e).</span><br></pre></td></tr></table></figure><h3 id="font-color-orange-多人协作-font"><font color='orange'>多人协作</font></h3><ul><li><p><strong>推送分支：</strong></p><mark class="hl-label default">git push</mark> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><blockquote><p>如果只写 <mark class="hl-label default">git push</mark>  ，则默认推送本分支到之前绑定的远程仓库的对应分支上去。</p><p>如果没有绑定，则：</p><ol><li><mark class="hl-label default">git push origin dev</mark>  ，即为本次推送指定远程仓库为 origin ，分支为 dev ，但没有持续绑定。</li><li><mark class="hl-label default">git push --set-upstream origin dev</mark>  ，指定远程仓库为 origin ，分支为 dev ，且持续绑定（前提是远程仓库和分支存在）。</li><li><mark class="hl-label default">git push -u origin dev</mark>  ，指定远程仓库为 origin ，分支为 dev ，且持续绑定，若远程分支不存在，则创建并推送。</li></ol></blockquote></li><li><p><strong>抓取分支：</strong></p><ul><li><mark class="hl-label default">git pull</mark>  ，抓取远程分支，并与本地分支合并。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin dev:temp //抓取origin远程仓库下的dev分支，并和本地temp分支合并</span><br><span class="line">$ git pull origin dev //抓取远程的dev分支，并与本分支合并。</span><br></pre></td></tr></table></figure></li><li><mark class="hl-label default">git fetch</mark>  ，此命令会抓取远程分支，但不会与本地分支合并！<blockquote><p>抓取后不合并，哪抓取的远程分支放在哪里了？答案是在 <strong><font color=#00FFFF>远程仓库副本</font></strong> 下。</p><p><img src="/2022/img/20220630201728.jpeg" alt="原理图"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin dev</span><br><span class="line">From github.com:jyxcpp/test</span><br><span class="line"> * branch            dev        -&gt; FETCH_HEAD</span><br></pre></td></tr></table></figure><p>上面的 <code>FETCH_HEAD</code> 是一个版本链接，记录在本地的一个文件中， <strong><font color='red'>指向着目前已经从远程仓库取下来的分支的末端版本</font></strong> 。</p><p>可以使用 <mark class="hl-label default">git log FETCH_HEAD</mark>  查看 fetch 日志。</p><p>也可以使用 <mark class="hl-label default">git diff FETCH_HEAD</mark>  或 <mark class="hl-label default">git diff HEAD FETCH_HEAD</mark>  来比较抓取的分支和本地对应的分支的区别，<strong>前者是当前分支相对于 <code>FETCH_HEAD</code> 的区别，后者相反。</strong> （个人感觉后者更直观）</p><p><img src="/2022/img/20220630203520.webp" alt="img"></p></blockquote></li></ul><div class="note danger flat"><p>有时 push 代码到 git 时，出现提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To ../remote/</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;../remote/&#x27;</span></span><br></pre></td></tr></table></figure><p>问题分析：别人上传到远程仓库后，你没有及时的同步（拉取）到本地，但是你同时又添加了一些内容（提交），以致于你在提交时，它会检测到你之前从远程仓库拉取的时候的仓库状态和现在的不一样。于是，它为了安全起见拒绝了你的提交。</p><p>问题解决：<br>（1）先把git的东西fetch到你本地然后merge后再push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git merge origin FETCH_HEAD  ////将拉取下来的最新内容合并到当前所在的分支</span><br></pre></td></tr></table></figure><p>先抓取远程仓库的更新到本地，然后与你的本地仓库合并（可能有冲突，需要先解决冲突才能合并），这样就可以使远程仓库和你本地仓库一致了，然后就可以提交修改了。</p><p>（2）这2句命令等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p><strong>但是使用git fetch + git merge 更加安全。</strong></p></div><div class="note info flat"><p><mark class="hl-label default">git pull</mark>  = <mark class="hl-label default">git fetch</mark>  + <mark class="hl-label default">git merge</mark></p><p>首先，基于本地的 <code>FETCH_HEAD</code> 记录，比对本地的 <code>FETCH_HEAD</code> 记录与远程仓库的版本号，然后 <mark class="hl-label default">git fetch</mark>  获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。</p></div></li></ul><h2 id="font-color-red-标签管理-font"><font color='red'>标签管理</font></h2><h3 id="font-color-orange-创建标签-font"><font color='orange'>创建标签</font></h3><ol><li><p>首先切换到需要打标签的分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jiangyuxuan@LAPTOP-OFA3GEIB MINGW64 /d/gitlearn (dev)</span><br><span class="line">$ git switch <span class="built_in">test</span></span><br><span class="line">Switched to branch <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <mark class="hl-label default">git tag</mark>  打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><blockquote><p><strong>默认标签是打在最新提交的commit上的</strong> 。如果要给历史提交版本打标签，可先使用 <mark class="hl-label default">git log</mark>  查看 <code>commit id</code> ，再打标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line"></span><br><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>即可对 <code>f52c633</code> 的提交打上标签。</p><p>还可以在打标签的同时附加说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 1094adb</span><br></pre></td></tr></table></figure><p>用 <code>-a</code> 指定标签名， <code>-m</code> 指定说明文字</p></blockquote></li><li><mark class="hl-label default">git tag</mark>  查看所有标签。</li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br></pre></td></tr></table></figure><ol start="4"><li><mark class="hl-label default">git show</mark>  查看标签信息。</li></ol>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.0</span><br><span class="line">commit 47e4fbc87af536ddd3e442c8fc6e549b4864f5a3 (HEAD -&gt; <span class="built_in">test</span>, tag: v2, tag: v1.1, tag: v1.0, dev)</span><br><span class="line">Author: jyxcpp &lt;1572676601@qq.com&gt;</span><br><span class="line">Date:   Wed Jul 6 15:13:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    aha</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong><font color='red'> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</font></strong></p></div><h3 id="font-color-orange-操作标签-font"><font color='orange'>操作标签</font></h3><ul><li><mark class="hl-label default">git push origin</mark>  推送标签到远程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v2 //推送某一个标签到远程仓库</span><br><span class="line">$ git push origin --tags //一次性推送所有标签</span><br></pre></td></tr></table></figure></li><li><mark class="hl-label default">git tag -d</mark>  删除标签：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v0.1&#x27;</span> (was f15b0dd)</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong><font color=#00FFFF>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</font></strong></p></div><p>如果要删除远程标签：</p><ol><li><p>本地删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br></pre></td></tr></table></figure></li><li><p>push 到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure><p><strong>注意格式！</strong></p></li></ol></li></ul><h2 id="font-color-red-参与开源项目-font"><font color='red'>参与开源项目</font></h2><p>现在有这样一种情形：</p><p>有一个叫做Joe的程序猿写了一个游戏程序，而你可能要去改进它。并且Joe将他的代码放在了GitHub仓库上。</p><p>下面是你要做的事情：</p><p><img src="/2022/img/20220707094528.png" alt="示意图"></p><p><strong>fork 并且更新GitHub仓库的图表演示</strong></p><ol><li>**Fork 他的仓库 ** ：这是GitHub操作，这个操作会复制Joe的仓库（包括文件，提交历史，issues，和其余一些东西）。复制后的仓库在你自己的GitHub帐号下。目前，你本地计算机对这个仓库没有任何操作。</li><li>**Clone 你的仓库 ** ：这是Git操作。使用该操作让你发送&quot;请给我发一份我仓库的复制文件&quot;的命令给GitHub。现在这个仓库就会存储在你本地计算机上。</li><li>**更新某些文件 ** ：现在，你可以在任何程序或者环境下更新仓库里的文件。</li><li>**提交你的更改 ** ：这是Git操作。使用该操作让你发送&quot;记录我的更改&quot;的命令至GitHub。此操作只在你的本地计算机上完成。</li><li><strong>将你的更改push到你的GitHub仓库</strong> ：这是Git操作。使用该操作让你发送&quot;这是我的修改&quot;的信息给GitHub。Push操作不会自动完成，所以直到你做了push操作，GitHub才知道你的提交。</li><li><strong>给 Joe 发送一个 pull request</strong> ：如果你认为Joe会接受你的修改，你就可以给他发送一个pull request。这是GitHub操作，使用此操作可以帮助你和Joe交流你的修改，并且询问Joe是否愿意接受你的&quot;pull request&quot;，当然，接不接受完全取决于他自己。</li><li>如果 Joe 接受了你的 pull request，他将把那些修改拉到自己的仓库！</li></ol><div class="note danger flat"><p><strong>一定要从自己的账号下 clone 仓库，这样你才能推送修改。如果直接从项目作者的仓库地址克隆，因为没有权限，你将不能推送修改。</strong></p></div><h2 id="font-color-red-自定义Git-font"><font color='red'>自定义Git</font></h2><h3 id="font-color-orange-忽略特殊文件-font"><font color='orange'>忽略特殊文件</font></h3><blockquote><p>在实际的项目开发中，我们可能不想将一些文件添加到 Git 仓库中。比如，一些敏感文件、临时文件、自动生成文件、日志文件等。而你必须把某些文件放到Git工作目录中，但又不想提交它们，此时就需要让 Git 忽略对这些文件的跟踪。</p></blockquote><p>如果我们想某个文件保留在项目中，又不想它受到 Git 的跟踪管理，那我们可以使用文件 <code>.gitignore</code> 文件，我们只需要创建该文件，然后并添加到我们项目的 <strong>根目录</strong> 中，最后把你想要忽略（让 Git 不进行跟踪）的文件名称填写到该文件中就可以了。如果我们要忽略 <code>C.md</code> 我们可以将这行添加到 <code>.gitignore</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch <span class="built_in">test</span></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        A.md</span><br><span class="line">        B.md</span><br><span class="line">        C.md            //有三个文件，想要Git忽略对 C.md 的跟踪</span><br><span class="line">                          </span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"><span class="comment">#----------------------------------------------------</span></span><br><span class="line">$ <span class="built_in">touch</span> .gitignore      //创建 .gitignore 文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------</span></span><br><span class="line">$ vim .gitignore        //往 .gitignore 文件中写入 C.md </span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------</span></span><br><span class="line">$ git status      </span><br><span class="line">On branch <span class="built_in">test</span></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        .gitignore</span><br><span class="line">        A.md</span><br><span class="line">        B.md           //C.md 消失，未被跟踪。</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure><div class="note info flat"><p>虽然我们可以直接在 <code>.gitignore</code> 文件中直接书写我们要忽略的文件名称，但是我们也可以使用 <code>通配符</code> 来忽略一系列满足条件的文件或文件夹。</p><p>通配符允许你使用特殊的字符来表示某些格式/字符。在 <code>.gitignore</code> 文件中，我们可以使用：</p><ul><li>空白行作为空格</li><li><code>#</code> ： 将行标记为注释</li><li><code>*</code> ： 与 0 个或多个字符匹配</li><li><code>?</code> ：与 1 个字符匹配</li><li><code>[abc]</code> ： 与 a、b 或 c 匹配</li><li><code>**</code> ： 与嵌套目录匹配，比如 a/**/z 与以下项匹配<ul><li>a/z</li><li>a/b/z</li><li>a/b/c/z</li></ul></li></ul><p>下面我们来看一些简单的例子来学习一下通配符的使用，比如我们需要忽略当前项目根目下的 <code>A</code> 文件夹中的所有的 80 张 <code>PNG</code> 格式的图片，我们可以在 <code>.gitignore</code> 文件中书写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/A/*.png</span><br></pre></td></tr></table></figure></div><p><strong><font color=#00FFFF>其他问题：</font></strong></p><ul><li><p><strong>不能将文件添加到仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add C.md</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">C.md</span><br><span class="line">hint: Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>可以使用 <mark class="hl-label default">git add -f</mark>  强制添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -f C.md</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>-f</code> 选项强制添加的文件，在后续的使用中与其他正常被 Git 跟踪的文件使用效果一样。也就是说 <code>C.md</code> 文件将会受到 Git 的跟踪管理。</p></blockquote></li><li><p><strong>已经添加到暂存区中的文件如何忽略：</strong></p><p>我们忘记了在 <code>.gitignore</code> 文件中添加忽略文件 <code>C.md</code>，直接使用了 <code>gid add .</code> 命令，将所有的文件都添加到了<code>暂存区</code> 中，然后想要将其从暂存区中移除：使用 <mark class="hl-label default">git rm -- cached</mark> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> --cached B.md</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;B.md&#x27;</span></span><br><span class="line"></span><br><span class="line">jiangyuxuan@LAPTOP-OFA3GEIB MINGW64 /d/gitlearn (<span class="built_in">test</span>)</span><br><span class="line">$ git status</span><br><span class="line">On branch <span class="built_in">test</span></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   .gitignore</span><br><span class="line">        new file:   A.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        B.md</span><br></pre></td></tr></table></figure></li></ul><div class="note danger flat"><p><font color='red'>在创建仓库时，一定要先处理忽略文件，也就是你的 .gitignore 文件一定要在项目初始化完成后提交！因为后期再来处理忽略文件，就非常的麻烦与复杂。</font></p></div><h3 id="font-color-orange-配置别名-font"><font color='orange'>配置别名</font></h3><ul><li><p><strong>添加别名：</strong></p><p>比如将 <code>commit -m</code> 简写为 <code>com</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.com <span class="string">&quot;commit -m&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除别名：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --<span class="built_in">unset</span> alias.l</span><br></pre></td></tr></table></figure><p><strong><font color='red'>由于使用 git config 设置命令别名时指定了 <code>--global</code> 选项，在删除别名时也要加上 <code>--global</code> 选项。</font></strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转专业失败总结</title>
      <link href="/2022/06/24/%E8%BD%AC%E4%B8%93%E4%B8%9A%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/24/%E8%BD%AC%E4%B8%93%E4%B8%9A%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>失败不是结果，它发生在每一个瞬间。</p></blockquote><p>​由于笔试失误，我转计算机专业失败了，一年的期待落空，一年的努力化为泡影。迷茫和矛盾充斥内心，一方面，我难以接受这样的结果，计算机是我的兴趣，其他学科的学习可以说是煎熬，我难以想象未来的学习该怎么继续；另一方面，我接受这次失败，因为它是必然的，过去一年的许多瞬间都加固了它的必然性。痛定思痛，与其虚假的彷徨，不如反思自己的失败。</p><blockquote><p>​为什么说失败发生在每一个瞬间？</p><ol><li>明知转专业看重绩点，却依然忽视本专业课程的学习，过度看重转专业面试和所谓的计算机“项目”经验，耗费了许多经历在小项目的制作上。</li><li>笔试考的是基础的算法题，为什么依然“失误”——无他，手不熟尔。编程学而不精，没有注重编程基础能力，总是以自己的“项目”为傲，不愿走出舒适区。</li><li>浪费了大量时间和精力在无关的事情上。我总是以自己不打游戏为傲，以为自己因此赢得了不少宝贵的时间。去他妈的，都是自我安慰。。。即使没打游戏，我还是浪费了一大把时间，关键是我还说不出来这些时间浪费在哪了。</li><li>不专注，没有沉下心来做事。总认为本土木专业的课程耗费我的“宝贵时间”，但却没见自己把这些“宝贵时间”用在计算机上，一年下来，计算机学习的进度也就如此。最后导致土木绩点不高，计算机专业也没能转成。</li><li>找借口，拖延。总想着等我转成了（哪来的信心？），我就全身心投入计算机的学习。实际上，如果我从一开始就投入（哪怕算上土木的学习），现在都能去实习了，结果呢？</li></ol></blockquote><p>​</p><p>​要善于总结教训，更要善于吸收教训！过去的一年中，我很多次想过要改变自己，想过晨跑，想过学精英语，想过学好计算机… 最后都不了了之。而这次失败对我而言是深刻的，所以它也许是一次契机，能让我真正地改变自己。坦然地面对失败吧，它对整个人生而言，不值一提（就像小学的一次数学不及格让我当时感觉天都塌了）。如果我还不知悔改，还旧错重犯，这篇文章，就是用来打我自己的脸！</p><p>​重新规划好未来一年，改正错误，调整心态，继续前进！</p>]]></content>
      
      
      <categories>
          
          <category> 成长记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shared_ptr与虚析构</title>
      <link href="/2022/06/20/shared-ptr%E4%B8%8E%E8%99%9A%E6%9E%90%E6%9E%84/"/>
      <url>/2022/06/20/shared-ptr%E4%B8%8E%E8%99%9A%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  ~<span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Data* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AX</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">AX</span>();</span><br><span class="line">  ~<span class="built_in">AX</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AXData* ax_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下不会存在内存泄漏的写法是？</p><p>A. <code>AX* p = new AX(); delete p;</code></p><p>B. <code>A* p = new AX(); delete p;</code></p><p>C. <code>shared_ptr&lt;A&gt; p = shared_ptr&lt;A&gt;(make_shared&lt;AX&gt;()); delete p; </code></p><p>D. <code>shared_ptr&lt;A&gt; p = shared_ptr&lt;A&gt;(make_shared&lt;A&gt;());  delete p; </code></p><blockquote><p>正确答案： <font color='gree'>A,C,D</font></p><p>解析：</p><p>B：基类析构函数没有声明为 <code>virtual</code> ，所以 p 所指的对象析构时，不会调用基类的析构函数。</p><p>D：正常情况，显然不会内存泄漏。</p><p>C：<strong><font color=#00FFFF>shared_ptr创建时会记住原来的类型的析构函数，基类指针析构时仍会调用派生类的析构函数。</font></strong></p><hr><p><strong><font color='orange'>shared_ptr 创建时即捕获析构动作，何解？</font></strong></p><p>本人也不懂。。。待笔者读完《STL源码剖析》后再回来解释。</p><p><a href="https://zhuanlan.zhihu.com/p/56865771">你不一定知道的智能指针细节 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载，覆盖与隐藏</title>
      <link href="/2022/06/20/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/"/>
      <url>/2022/06/20/%E9%87%8D%E8%BD%BD%E8%A6%86%E7%9B%96%E9%9A%90%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/img/20220620174905.png" alt="image-20220620174904944"></p><blockquote><p>此三者的区别是针对继承关系下的成员函数而言。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解assert与if</title>
      <link href="/2022/06/20/assert-%E4%B8%8Eif/"/>
      <url>/2022/06/20/assert-%E4%B8%8Eif/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="font-color-red-一-assert的作用-font"><font color='red'>一. assert的作用</font></h2><p>和 <code>if</code> 的作用基本无异，都用来检测一些边界条件和进行安全性检查，如：</p><ol><li>指针是否为空？</li><li>被除数是否为 0？</li><li>函数调用的返回结果是否有效？</li><li>打开一个文件是否成功？</li></ol><p>使用格式：<code>assert(exp);</code></p><p><code>assert</code>  会计算表达式 <code>expression</code>  ，如果其值为假（即为0），那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 <code>abort</code> 来<strong>终止程序运行</strong> 。</p><p>从功能上而言，下面的两种写法等效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="number">0</span> != b);</span><br><span class="line"><span class="comment">//上下两者在功能上等价</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b is zero...&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='orange'>同时需要注意，<code>assert</code> 是宏，而非函数：</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(condition) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(condition) <span class="comment">/*implementation defined*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>从上面assert的宏可看出：</p><ol><li>如果定义了宏 <code>NDEBUG</code>，那么 <code>assert()</code> 宏将不做什么动作，也就是相当于一条空语句： <code>(void)0;</code>，<strong>当在 release 阶段编译代码的时候，都会在编译选项中(Makefile)定义这个宏</strong> 。</li><li>如果没有定义宏 <code>NDEBUG</code>，那么 <code>assert()</code> 宏将会把一些检查代码进行替换，我们在<strong>开发阶段执行 debug 模式编译时，一般都会屏蔽掉这 <code>NDEBUG</code> 这个宏</strong> 。一般来说断言 assert() 是仅在 Debug 版本起作用的宏。在发布版本时，我们不应该再依赖 assert() 宏，因为程序一旦出错，assert() 会抛出一段用户看不懂的提示信息，并毫无预警地终止程序执行，这样会严重影响软件的用户体验，所以在发布模式下应该让assert()失效。另外在程序中频繁的调用 assert() 会影响程序的性能，增加额外的开销。</li></ol></blockquote><h2 id="font-color-red-二-assert与if的区别-font"><font color='red'>二. assert与if的区别</font></h2><p><strong><font color=#FF00FF>在功能上没有明显区别。</font></strong> 二者在工程代码中都很常见，没有对错之分，更多只是编程风格和习惯上的差异。</p><blockquote><p><font color='orange'>（1） assert 支持者</font></p><p>我作为 <code>my_concat()</code> 函数的实现者，目的是拼接字符串，那么传入的参数必须是合法有效的，<strong>调用者需要负责这件事</strong> 。如果传入的参数无效，我会表示十分的惊讶！怎么办：崩溃给你看！</p><p><font color='orange'>（2）if 支持者</font></p><p>我写的 <code>my_concat()</code> 函数十分的健壮，我就预料到调用者会乱搞，故意的传入一些无效参数，来测试我的编码水平。没事，来吧，我可以处理任何情况！</p></blockquote><p>从上文我们得知，<code>assert</code> 仅在 debug 模式下有效， release 模式下不会作用。而 debug 模式是用来排除 bug 的，即排除 <strong><font color=#FF00FF>非法情况</font></strong> ，将 <strong>所有可能存在</strong> 的非法情况全部排除后，才能发行（release）。而如果试图用 <code>if</code> 来判断非法情况并处理错误（以此提高所谓的程序 “健壮性” ），则很可能会隐藏本来就需要排查的非法情况。而这样的程序发行之后，随时会因为某些极端情况而崩溃。</p><blockquote><p><strong><font color=#00FFFF>非法情况：</font></strong> 即逻辑层面的 bug 。非法情况是完全不应该出现的情况，逻辑上不允许它的存在。如传入的参数为空指针（<strong>在不同的场景下有不同的要求</strong>）。</p><p><strong><font color=#00FFFF>错误情况：</font></strong> 是可以存在，且无法完全避免的情况，在逻辑允许之内。如 <code>malloc()</code> 未申请到内存，返回 <code>NULL</code> 。</p><p><code>assert</code> 便是用来处理非法情况（验证有效性）它最大作用就是：<strong>在开发阶段，让我们的程序尽可能地 crash。每一次的 crash，都意味着代码中存在着 bug，需要去修正。当我们写下一个 assert 断言的时候，就说明：断言失败的这种情况是是不被允许存在的。必须保证断言成功，程序才能继续往下执行。</strong></p><p><code>if</code> 则是用来处理逻辑上各种可能出现的情况，包括错误情况。每一个分支都是合理的，是允许出现的，我们都要对这些分支进行处理。</p></blockquote><h2 id="font-color-red-三-使用注意事项-font"><font color='red'>三. 使用注意事项</font></h2><ol><li><p><strong>在函数开始处检验传入参数的合法性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">resetBufferSize</span><span class="params">(<span class="type">int</span> nNewSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">assert</span>(nNewSize &gt;= <span class="number">0</span>);     <span class="comment">//nNewSize&lt;0是非法情况</span></span><br><span class="line"><span class="built_in">assert</span>(nNewSize &lt;= MAX_BUFFER_SIZE); </span><br><span class="line"><span class="keyword">if</span>(nNewSize == <span class="number">0</span>)&#123;...&#125;     <span class="comment">//nNewSize=0是可能的情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(nOffset&gt;=<span class="number">0</span> &amp;&amp; nOffset+nSize&lt;=m_nInfomationSize);  <span class="comment">//不好</span></span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line"><span class="built_in">assert</span>(nOffset &gt;= <span class="number">0</span>); </span><br><span class="line"><span class="built_in">assert</span>(nOffset+nSize &lt;= m_nInfomationSize);  <span class="comment">//好</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在发行后遇到问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(i++ &lt; <span class="number">100</span>); <span class="comment">//错误</span></span><br><span class="line"><span class="comment">//========================</span></span><br><span class="line"><span class="built_in">assert</span>(i &lt; <span class="number">100</span>)</span><br><span class="line">i++;               <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p><strong>assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</strong></p></li><li><p><strong>有的地方,assert不能代替条件过滤</strong></p><p>这需要分清 <strong><font color=#00FFFF>非法情况</font></strong> 与 <strong><font color=#00FFFF>错误情况</font></strong> 。</p></li></ol><hr><p>如有错误，烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高质量编写strcpy()</title>
      <link href="/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E5%86%99strcpy/"/>
      <url>/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E5%86%99strcpy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>《高质量C++编程指南》的作者林锐博士，曾去微软中国研究院面试，而面试官让他写一个简单的strcpy()函数。林博士很惊讶，心想这有什么难的。而半小时后，林博士大汗淋漓地走出了”考场“。</p><p>这样一个小不点函数，面试官从三个方面考察：</p><ul><li>代码风格</li><li>出错处理</li><li>算法复杂度分析</li></ul><p>由此可见，编写出合格的strcpy()是不容易的，它尤其考验程序员的基本功和思维的严密性。</p></blockquote><p>下面直接给出最终代码，再逐步剖析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(des == src)</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    <span class="built_in">assert</span>(des != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* temp = des;</span><br><span class="line">    <span class="keyword">while</span>((*des++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><font color='orange'>参数类型：</font></strong> 将<code>src</code>的内容拷贝到<code>des</code>中，并不会修改<code>src</code>。所以为了防止误操作改变<code>src</code> ，需要声明为<code>const char*</code>。</li><li><strong><font color='orange'>自赋值：</font></strong> 当<code>des</code>与<code>src</code>相同时，直接返回任意一者。此处的自赋值并不是像实现<code>string</code>类的赋值函数中的那样必要，但无疑，当两者相同时这样处理更高效。</li><li><strong><font color='orange'>检查空指针：</font></strong> 这是绝对必要的一步，不检查会引起崩溃。为什么使用 <code>assert</code> 而不是 <code>if</code>  ，可见<a href="https://jyxcpp.github.io/2022/06/20/assert-yu-if/">详解if与assert</a>。那么为什么要用两行<code>assert</code> 而不直接 <code>assert((dest!=NULL) &amp;&amp; (src !=NULL))</code>?因为前者能定位出错的位置，而后者并不能定位到两个指针中哪个为NULL。</li><li><strong><font color='orange'>保存原始des值：</font></strong> des的指向已经更改，不能直接返回。</li><li><strong><font color='orange'>返回值为什么是<code>char*</code> ：</font></strong> 为了支持链式赋值：<code>int len = strlen(strcpy(des,src))；</code></li></ul></blockquote><p>很多人疑惑为什么不考虑内存重叠（src低于des）的情况，下面是我的猜测：</p><blockquote><ol><li>strcpy()不同于memcpy()，后者能应对内存重叠是因为它有第三个参数n（开辟的字节数），如果发生内存重叠，则可以从高位往低位拷贝，这个过程必须要用n来计数。而前者没有参数n，只能依靠字符串结束符<code>'\n'</code> 来判别终点，所以无法从高位往低位拷贝。</li><li>也许某些时候不要考虑太高的容错性，这样会隐藏人为过失，导致最后bug难以溯源。灵活性 != 容错性。</li></ol></blockquote><hr><p>有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高质量C++编程指南</title>
      <link href="/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8FCpp%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/06/19/%E9%AB%98%E8%B4%A8%E9%87%8FCpp%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/img/20220619190951.png" alt="高质量C编程指南"></p><blockquote><p>图片不是很清楚，附上导图pdf和本书pdf：<a href="https://pan.baidu.com/s/1VPet6-2dVqXjLW2gN2fXMQ?pwd=gzwb">高质量C++编程pdf</a>，提取码：gzwb</p></blockquote><p>本书由林锐博士撰写，他的个人经历便可以映射出本书的价值：</p><blockquote><p>我从读大学到博士毕业十年来一直勤奋好学，累计编写了数十万行 C++/C 代码。有 这样的苦劳和疲劳，我应该称得上是编程老手了吧?<br>我开发的软件都与科研相关(集成电路 CAD 和 3D 图形学领域)，动辄数万行程序， 技术复杂，难度颇高。这些软件频频获奖，有一个软件获得首届中国大学生电脑大赛软件展示一等奖。在 1995 年开发的一套图形软件库到 2000 年还有人买。罗列出这些“业绩”，可以说明我算得上是编程高手了吧?<br>可惜这种个人感觉不等于事实。<br>读博期间我曾用一年时间开发了一个近 10 万行 C++代码的 3D 图形软件产品，我内心得意表面谦虚地向一位真正的软件高手请教。他虽然从未涉足过 3D 图形领域，却在 几十分钟内指出该软件多处重大设计错误。让人感觉那套软件是用纸糊的华丽衣服，扯 一下掉一块，戳一下破个洞。我目瞪口呆地意识到这套软件毫无实用价值，一年的心血白化了，并且害死了自己的软件公司。<br>人的顿悟通常发生在最心痛的时刻，在沮丧和心痛之后，我作了深刻反省，“面壁” 半年，重新温习软件设计的基础知识。补修“内功”之后，又觉得腰板硬了起来。博士毕业前半年，我曾到微软中国研究院找工作，接受微软公司一位资深软件工程师的面试。 他让我写函数 strcpy 的代码。<br>太容易了吧?<br>错! 这么一个小不点的函数，他从三个方面考查:<br>(1)编程风格;<br>(2)出错处理;</p><p>(3)算法复杂度分析(用于提高性能)。<br>在大学里从来没有人如此严格地考查过我的程序。我花了半个小时，修改了数次， 他还不尽满意，让我回家好好琢磨。我精神抖擞地进“考场”，大汗淋漓地出“考场”。 这“高手”当得也太窝囊了。我又好好地反省了一次。<br>我把反省后的心得体会写成文章放在网上传阅，引起了不少软件开发人员的共鸣。 我因此有幸和国产大型 IT 企业如华为、上海贝尔、中兴等公司的同志们广泛交流。大 家认为提高质量与生产率是软件工程要解决的核心问题。高质量程序设计是非常重要的环节，毕竟软件是靠编程来实现的。<br>我们心目中的老手们和高手们能否编写出高质量的程序来? 不见得都能!<br>就我的经历与阅历来看，国内大学的计算机教育压根就没有灌输高质量程序设计的观念，教师们和学生们也很少自觉关心软件的质量。勤奋好学的程序员长期在低质量的程序堆中滚爬，吃尽苦头之后才有一些心得体会，长进极慢，我就是一例。<br>现在国内 IT 企业拥有学士、硕士、博士文凭的软件开发人员比比皆是，但他们 接受大学教育时就“先天不足”，岂能一到企业就突然实现质的飞跃。试问有多少软件开发人员对正确性、健壮性、可靠性、效率、易用性、可读性(可理解性)、可扩展性、 可复用性、兼容性、可移植性等质量属性了如指掌?并且能在实践中运用自如?。“高质量”可不是干活小心点就能实现的!</p></blockquote><p>而本书重在给我们灌输高质量编程的观念，弥补大学教育的不足。同时作者给出了许多实用的建议，值得好好阅读。</p><p>本书最后给出了一套C++题目，作者表示如果你能在没有任何提示的情况下，第一次就全对，请你收他为徒。哈哈，试一试吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术书籍笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="/2022/06/19/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/06/19/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-explicit关键字-font"><strong><font color='red'>explicit关键字</font></strong></h3><p>C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, <strong>它的作用是表明该构造函数只能显式调用, 而不能充当转换构造函数</strong>（当构造函数只有一个参数或其他参数都有缺省值时）。 跟它相对应的另一个关键字是implicit,。类构造函数默认情况下即声明为implicit。</p><blockquote><p><strong><font color=#FF00FF>为何尽量对单参数构造函数使用explicit？</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;我被用了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);<span class="comment">// 被隐式转换为func(A(1)) ，本来是1却被自动调用了A(1)这就是拷贝初始化</span></span><br><span class="line">        <span class="comment">//输出：&quot;我被调用了&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上，func(1)可能只是操作失误。</p><p><strong><font color=#FF00FF>什么时候下，构造函数可以充当转换构造函数？</font></strong></p><ul><li>当构造函数只有一个参数且没有<code>explict</code>关键字修饰时。</li><li>当构造函数有多个参数且除第一个参数外其他参数都有默认值（第一个参数也可以有）时。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类内存布局与虚函数表</title>
      <link href="/2022/06/19/%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
      <url>/2022/06/19/%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-类内存布局-虚函数表-font"><strong><font color='red'>类内存布局 + 虚函数表</font></strong></h3><p>sizeof（C）的数值是（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> b;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> *c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color=#FF00FF>类的内存布局：</font></strong></p><ul><li><p><strong><font color='orange'>类中static修饰的变量不占用类大小,因为修饰后存储在静态区域。</font></strong></p></li><li><p><strong><font color='orange'>sizeof是用来计算栈大小，不涉及全局区，故类的静态成员大小sizeof不涉及。</font></strong></p><blockquote><p>对于new或malloc开辟的区域，sizeof计算的也只能是其指针的大小，无法得到开辟的内存大小！</p></blockquote></li><li><p><strong><font color='orange'>类与结构一样,都有字节对齐的问题。</font></strong></p></li><li><p><strong><font color='orange'>含有虚函数的类中，类起始地址会放置一个指向<font color='red'>虚函数表的指针</font>，也占类的内存。</font></strong></p></li><li><p><strong><font color='orange'>类中的枚举也不会占用内存。</font></strong></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体对齐</title>
      <link href="/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/06/19/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-结构体对齐-font"><strong><font color='red'>结构体对齐</font></strong></h3><p>在上下文及头文件均正常的情况下，以下代码打印的结果是（假设运行在 64 位计算机上）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">short</span> *pdata;</span><br><span class="line">    <span class="type">char</span> errstr[<span class="number">32</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">st_t</span> st[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)(st[<span class="number">2</span>].errstr + <span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (p - (<span class="type">char</span> *)(st)));</span><br></pre></td></tr></table></figure><p>A.  32B. 120 C. 114<font color='gree'>D. 144 </font></p><blockquote><p><strong><font color=#FF00FF>结构体对齐：</font></strong></p><ul><li>内部对齐：结构体成员之间会留有空隙。</li><li>外部对齐：在结构体数组中，结构体之间也可能留有空隙。</li></ul><p><strong><font color=#FF00FF>对齐规则：</font></strong></p><p><strong>1.第一个成员在与结构体变量偏移量为0的地址</strong></p><p><strong>2.其他成员变量要对齐到对齐数的整数倍的地址处</strong>(<font color='orange'>对齐数 = 编译器默认的对齐数（VS中为8） 与 成员变量大小的较小值</font>)，即 <strong><font color='gree'>内部对齐</font></strong> 。</p><p><strong>3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数，取所以成员变量中对齐数最大的)的整数倍</strong>，<strong>即<font color='gree'>外部对齐</font></strong></p><p><strong>4. 如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍，如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S3</span> &#123;</span><br><span class="line"><span class="type">double</span> d;  <span class="comment">//▣</span></span><br><span class="line"><span class="type">char</span> c;    <span class="comment">//▤</span></span><br><span class="line"><span class="type">int</span> i;     <span class="comment">//▦</span></span><br><span class="line">&#125;;</span><br><span class="line">               <span class="comment">//s3内存布局：▣▣▣▣▣▣▣▣▤▢▢▢▦▦▦▦  最大对齐数为8</span></span><br><span class="line">                            ↑          ↑     ↑</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S4</span> &#123;                 <span class="number">0</span>          <span class="number">8</span>     <span class="number">12</span></span><br><span class="line"><span class="type">int</span> f;     <span class="comment">//▦</span></span><br><span class="line"><span class="type">char</span> c;    <span class="comment">//▤</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S3</span> s3;  </span><br><span class="line">&#125;;             <span class="comment">//s4内存布局：▦▦▦▦▤▢▢▢▣▣▣▣▣▣▣▣▤▢▢▢▦▦▦▦</span></span><br><span class="line">                            ↑     ↑    ↑    </span><br><span class="line">                            <span class="number">0</span>     <span class="number">4</span>    <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong><font color=#FF00FF>为什么要结构体对齐？</font></strong></p><ul><li><strong>平台原因(移植原因)</strong>： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li><li><strong>性能原因</strong>： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</li></ul><p><strong><font color=#FF00FF>如何使结构体内存尽可能小？</font></strong></p><p>​    <strong>根据成员的大小按从大到小的顺序依次声明即可，如double声明在int前，而int声明在char前</strong> 。</p><p><strong><font color=#FF00FF>修改默认对齐数：</font></strong></p><p>​    <code>#pragma pack(x)//设置默认对齐数为x</code><br>如果不想对齐，直接声明 <code>#pragma pack(1)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板的继承</title>
      <link href="/2022/06/19/%E6%A8%A1%E6%9D%BF-%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/06/19/%E6%A8%A1%E6%9D%BF-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-模板的继承-font"><strong><font color='red'>模板的继承</font></strong></h3><p>下面有关函数模板和类模板的说法正确的有？</p><p><font color='gree'>A. 函数模板的实例化是由编译程序在处理函数调用时自动完成的</font></p><p><font color='gree'>B. 类模板的实例化必须由程序员在程序中显式地指定</font></p><p>C. 函数模板的模板参数仅针对参数类型</p><p>D. 类模板的模板参数仅针对数据成员和成员函数类型</p><blockquote><p>C: 函数模版还可以将 <code>函数返回值类型</code> 作为模版参数。</p><p>D: 类模板还可以针对 <code>继承的基类类型</code> 作为模板参数</p><hr><p><strong><font color=#FF00FF>类模板和类模板之间、类模板和类之间可以互相继承</font></strong>。它们之间的派生关系有以下四种情况：</p><ul><li>类模板继承类模板</li><li>类模板继承模板类</li><li>类模板继承普通类</li><li>普通类继承模板类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==============================================1、类模板继承类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T1 x;</span><br><span class="line">    T2 y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&lt;T2, T1&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T1 x1;</span><br><span class="line">    T2 y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1，T2, T3&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B&lt;T1, T3&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T2 x3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================2、类模板继承模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> A&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="comment">//具体化的模板类</span></span><br><span class="line">&#123;</span><br><span class="line">    T x4;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================3、类模板继承普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x4;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line">    T X5;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================================4、普通类继承模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> : <span class="keyword">public</span> F&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数+内联</title>
      <link href="/2022/06/19/%E8%99%9A%E5%87%BD%E6%95%B0-inline/"/>
      <url>/2022/06/19/%E8%99%9A%E5%87%BD%E6%95%B0-inline/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-虚函数-inline-font"><font color='red'>虚函数 inline</font></h3><p>关于虚函数的说法,哪些是正确的( )</p><p>A. 构造函数中调用该类的虚函数，动态绑定机制会生效</p><p><font color='gree'>B. 静态函数不可以是虚函数</font></p><p><font color='gree'>C. 虚函数可以声明为inline</font></p><p>D. 构造函数和析构函数都可以声明为虚函数</p><blockquote><p><strong><font color='orange'>函数绑定：</font></strong> 找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。</p><ul><li><strong><font color='orange'>静态绑定：</font></strong> 在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。</li><li><strong><font color='orange'>动态绑定：</font></strong> 编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。</li></ul><hr><p><strong><font color='orange'>构造函数中调用虚函数问题：</font></strong></p><p><strong><font color=#00FFFF>在构造或析构函数中调用虚函数会执行与之所属类型相对应的虚函数版本。</font></strong></p><p>所以当构造函数中有虚函数时，编译期间就可以确定此虚函数为本类中的函数，不需要再动态绑定。</p><hr><p><strong><font color='orange'>虚函数内联问题：</font></strong></p><p><strong><font color=#00FFFF>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联</font></strong><br>理由如下：内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 <code>inline virtual</code>唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在<strong>编译器具有实际对象而不是对象的指针或引用</strong>时才会发生，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  </span>&#123;  <span class="comment">// 不写inline时隐式内联</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，</span></span><br><span class="line">   <span class="comment">// 编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">   Base b;</span><br><span class="line">   b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，</span></span><br><span class="line">   <span class="comment">// 所以不能为内联。  </span></span><br><span class="line">   Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p><strong><font color=#00FFFF>静态函数不能是虚函数！</font></strong></p><p><em><strong>虚函数是与类对象捆绑的</strong></em>。而类的普通成员函数（包括虚函数）在编译时加入this指针，通过这种方式可以与对象捆绑，而<em><strong>静态函数编译时不加this</strong></em>，因为静态函数是给所有类对象公用的，所以没有在编译时加this，所以无法与对象捆绑，<font color=#FF00FF>而虚函数就是靠着与对象捆绑加上虚函数列表才实现了动态绑定</font>。所以没有this指针虚函数无从谈起。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转型+继承链</title>
      <link href="/2022/06/19/%E8%BD%AC%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E9%93%BE/"/>
      <url>/2022/06/19/%E8%BD%AC%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-2-转型-继承链-font"><em><strong><font color='red'>2. 转型 + 继承链</font></strong></em></h3><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> A* p1 = <span class="keyword">new</span> C;</span><br><span class="line"> B* p2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(p1);  <span class="comment">//L1</span></span><br><span class="line"> A* p3 = <span class="keyword">new</span> A;</span><br><span class="line"> B* p2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(p3);  <span class="comment">//L2</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. L 1语句编译失败，L 2语句编译通过   <font color='gree'> B. L1语句编译通过，L2语句编译失败 </font>    C. L 1，L 2都编译失败       D. L 1，L 2都编译通过</p><blockquote><p><strong><font color='orange'>四种类型转换符：</font></strong></p><ol><li><strong><font color='cornflowerblue'>static_cast</font></strong>：用于良性转换，一般不会导致意外发生，风险很低。</li><li><strong><font color='cornflowerblue'>const_cast</font></strong>：用于 const 与非 const、volatile 与非 volatile 之间的转换。</li><li><strong><font color='cornflowerblue'>reinterpret_cast</font></strong>：高度危险的转换，仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但可实现最灵活的 C++ 类型转换。</li><li><strong><font color='cornflowerblue'>dynamic_cast</font></strong>：<em><strong>借助 RTTI，用于类型安全的向下转型（Downcasting）。</strong></em></li></ol><hr><p><strong><font color='orange'>向下转型</font>：</strong></p><p>当使用 <code>dynamic_cast</code> 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到<em><strong>当前类</strong></em><font color='red'>（指针指向的对象所属的类）</font>的类型信息(type_info)，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p><img src="/2022/img/20220619132309.png" alt="image-20220619132309381" style="zoom:50%;" /><p>故而L1编译能够通过，而L2无法通过编译。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数&amp;虚函数</title>
      <link href="/2022/06/19/%E7%BB%A7%E6%89%BF%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2022/06/19/%E7%BB%A7%E6%89%BF%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下程序输出结果是____</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span> ():<span class="built_in">m_iVal</span>(<span class="number">0</span>)&#123;<span class="built_in">test</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout&lt;&lt;m_iVal&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="built_in">func</span>();&#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">int</span> m_iVal;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;<span class="built_in">test</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ++m_iVal;</span><br><span class="line">      std::cout &lt;&lt; m_iVal &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  A*p = <span class="keyword">new</span> B;</span><br><span class="line">  p-&gt;<span class="built_in">test</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 1 0   <font color='red'> B. 0 1 </font> <font color='gree'>   C. 0 1 2  </font>  D. 不可预期</p><blockquote><p>本问题涉及到两个方面：</p><ol><li><p><font color='red'>C++继承体系中构造函数的调用顺序：</font></p><p><strong>(1)任何虚拟基类的构造函数按照他们被继承的顺序构造</strong></p><p><strong>(2)任何非虚拟基类的构造函数按照他们被继承的顺序构造</strong></p><p><strong>(3)任何成员对象的函数按照他们声明的顺序构造</strong></p><p><strong>(4)类自己的构造函数</strong></p><blockquote><p>需要注意，<strong><font color=#FF00FF>成员对象在进入类构造函数的函数体前就已经完成了初始化</font></strong> （初始化列表中），函数体内的所有参数都只算赋值。</p></blockquote></li><li><p><font color='red'>构造函数中调用虚函数问题：</font></p><p><strong>在构造或析构函数中调用虚函数会执行与之所属类型相对应的虚函数版本。</strong></p><blockquote><p>原因如下：</p><p>假设构造函数中调用虚函数，其会表现为相应的子类函数行为，并且假设子类存在一个成员变量int a；子类定义的虚函数的新的行为会操作a变量，在子类初始化时根据构造函数调用顺序会首先调用父类构造函数，那么虚函数回去操作a，而因为a是子类成员变量，这时a尚未初始化，这是一种危险的行为，作为一种明智的选择应该禁止这种行为。</p></blockquote></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变长参数列表</title>
      <link href="/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
      <url>/2022/06/19/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-可变长参数列表-font"><font color='red'> 可变长参数列表</font></h3><p>该段代码输出（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='gree'>A. 3,3</font>B. 2,2C. 2,3D. 3,2</p><blockquote><p><strong><font color=#FF00FF>参数入栈顺序：</font></strong></p><p>通常情况下c/c++默认入栈方式为<code>__cdecl</code>。</p><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">堆栈清理</th><th style="text-align:left">参数传递</th></tr></thead><tbody><tr><td style="text-align:left">__cdecl</td><td style="text-align:left">Caller</td><td style="text-align:left">以相反的顺序（从右到左）将参数压入堆栈</td></tr><tr><td style="text-align:left">__clrcall</td><td style="text-align:left">n/a</td><td style="text-align:left">按顺序（从左到右）将参数加载到 CLR 表达式堆栈</td></tr><tr><td style="text-align:left">__stdcall</td><td style="text-align:left">Callee</td><td style="text-align:left">以相反的顺序（从右到左）将参数压入堆栈</td></tr><tr><td style="text-align:left">__fastcall</td><td style="text-align:left">Callee</td><td style="text-align:left">存储在寄存器中，然后压入堆栈</td></tr><tr><td style="text-align:left">__thiscall</td><td style="text-align:left">Callee</td><td style="text-align:left">压入堆栈；此指针存储在 ECX 中</td></tr><tr><td style="text-align:left">__vectorcall</td><td style="text-align:left">Callee</td><td style="text-align:left">存储在寄存器中，然后以相反的顺序（从右到左）压入堆栈</td></tr></tbody></table><p>为什么要从右往左入栈？ <strong><font color='gree'>因为要支持可变长参数，如果从左向右，编译器就不知道用户传入了多少实参。 </font></strong> 参数的信息是由第一个参数<code>fmt...</code>确定的（如printf(“%s %s”,str1 ,str2)的参数信息是通过检测两个<code>%s</code>来获取的）。若从左向右压栈，<code>fmt...</code>就被放入了栈底，而栈顶指针由于不清楚各个参数信息，就无法确定偏移量来指向<code>fmt...</code>，所以也无法指向各个参数。相反，若从右向左压栈，<code>fmt...</code>就存放在栈顶，可以直接通过它读取各参数的信息从而确定偏移量。</p><p>所以上题，是先处理<code>*(++p)</code>，再处理<code>*p</code>，故而选A。</p><p><strong><font color=#FF00FF>类型检查与默认参数提升：</font></strong></p><ul><li><p><strong>可变参数部分不会执行类型检查</strong>，因为其原型不能提供可变参数的数目和类型。同时，调用可变参数函数之前必须有其函数原型（这像废话，但在C语言中，函数声明不是必须的，引入头文件(其中的原型)主要作用是用于参数提示和类型检查，而C++中，调用之前必须有原型，否则会报错。</p></li><li><p><strong>可变参数会进行默认参数提升：</strong> <code>char</code>与<code>short</code>总是被提升为<code>int</code>，<code>float</code>总是被提升为<code>double</code>，所以<code>%f</code>可以同时表示<code>float</code>和<code>double</code>。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy与memmove的区别</title>
      <link href="/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/19/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-memcpy与memmove的区别-font"><font color='red'> memcpy与memmove的区别</font></h3><p>这两个函数都是将s2指向位置的n字节数据拷贝到s1指向的位置。<font color=#FF00FF>memcpy 假定两块内存区域没有数据重叠，而 memmove 没有这个前提条件</font>。如果复制的两个区域存在重叠时使用memcpy，其结果是不可预知的（ <strong>未定义的</strong> ），有可能成功也有可能失败。原因如下：</p><ul><li><p>当src地址大于dest地址时，即使有重叠，也可以正常复制。<br><img src="/2022/img/20220619095616.webp" alt=""></p></li><li><p>当src地址小于dest地址时，若重叠，则复制发生异常。</p><img src="/2022/img/20220619095613.webp" alt="" style="zoom:80%;" /><blockquote><p>这种情况下，src的地址小于dest的地址，拷贝前3个字节没问题，但是拷贝第4，5个字节时，原有的内容已经被src拷贝过来的字符覆盖了，所以已经丢失原来src的内容。</p><p>然而，vs2019下进行试验，发现即使是在第二种情况下，memcpy与memmove的结果相同，都正确，原因可能是 memcpy 目前也采用了 memmove 的方式。</p></blockquote></li></ul><p><strong>memmove的实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pd = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ps = src;</span><br><span class="line">    <span class="keyword">if</span>((ps + n &gt; pd)&amp;&amp; ps &lt; pd)</span><br><span class="line">        <span class="keyword">for</span> (pd += n, ps += n; n--;)</span><br><span class="line">            *--pd = *--ps;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">            *pd++ = *ps++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>memmove会对拷贝的数据作检查，确保内存没有覆盖，<strong><font color=#FF00FF>如果发现会覆盖数据，简单的实现是调转开始拷贝的位置，从尾部开始拷贝</font></strong> 。<strong><font color='pink'>但是实际在 C99 实现中，是将内容拷贝到临时空间，再拷贝到目标地址中</font></strong> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> tmp[n];</span><br><span class="line"> <span class="built_in">memcpy</span>(tmp,src,n);</span><br><span class="line"> <span class="built_in">memcpy</span>(dest,tmp,n);</span><br><span class="line"> <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>memcpy的实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *dp = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *sp = src;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *dp++ = *sp++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前memcpy已做改进，以下为源码：</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dst &lt;= src || (<span class="type">char</span> *)dst &gt;= (<span class="type">char</span> *)src + len)&#123;</span><br><span class="line"><span class="comment">//没有内存重叠，从低地址开始复制</span></span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//有内存重叠，从高地址开始复制</span></span><br><span class="line">src = (<span class="type">char</span> *)src + len - <span class="number">1</span>;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树的操作</title>
      <link href="/2022/06/19/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/19/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最详细的二叉排序树讲解视频，没有之一：<a href="https://www.bilibili.com/video/BV1EK4y1e7UY/?spm_id_from=333.788">懒猫老师二叉排序树</a></p><p>直接上代码，有简单注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DataType int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BST_node</span></span><br><span class="line">&#123;</span><br><span class="line">DataType data;</span><br><span class="line">BST_node *left;</span><br><span class="line">BST_node *right;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BST_node* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BST</span>(DataType arr[], <span class="type">size_t</span> arr_size);</span><br><span class="line">~<span class="built_in">BST</span>() &#123; <span class="built_in">release</span>(root); &#125;;   <span class="comment">//可以琢磨一下为何要把release放入析构，而不直接用析构来释放内存。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_traverse</span><span class="params">()</span> </span>&#123; <span class="built_in">traverse</span>(root); &#125;<span class="comment">//中序遍历（即按从小到大遍历），同上，思考一下（提示：递归与root）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(DataType key)</span> </span>&#123; <span class="built_in">bi_insert</span>(root, key); &#125;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(DataType key)</span> </span>&#123; root = <span class="built_in">bi_delete</span>(root, key); &#125;<span class="comment">//删除</span></span><br><span class="line"><span class="function">BST_node* <span class="title">search</span><span class="params">(DataType key)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">bi_search</span>(root, key); &#125;<span class="comment">//寻找某个指定节点，并返回其地址</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(BST_node*)</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(BST_node* node)</span></span>;<span class="comment">//用于析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bi_insert</span><span class="params">(BST_node*&amp; nood, DataType key)</span></span>;<span class="comment">//注意引用</span></span><br><span class="line"><span class="function">BST_node* <span class="title">bi_delete</span><span class="params">(BST_node* node, DataType key)</span></span>;</span><br><span class="line"><span class="function">BST_node* <span class="title">bi_search</span><span class="params">(BST_node* node, DataType key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::bi_insert</span><span class="params">(BST_node* &amp;Root, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">BST_node* new_node = <span class="keyword">new</span> BST_node;</span><br><span class="line">new_node-&gt;data = data;</span><br><span class="line">new_node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">new_node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">Root = new_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Root-&gt;data &gt; data)</span><br><span class="line"><span class="built_in">bi_insert</span>(Root-&gt;left, data);</span><br><span class="line"><span class="keyword">if</span>(Root-&gt;data&lt;data)</span><br><span class="line"><span class="built_in">bi_insert</span>(Root-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::release</span><span class="params">(BST_node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">release</span>(node-&gt;left);</span><br><span class="line"><span class="built_in">release</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> node;       <span class="comment">//注意！后序遍历删除！！</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">BST::<span class="built_in">BST</span>(DataType arr[], <span class="type">size_t</span> arr_size)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">bi_insert</span>(root, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::traverse</span><span class="params">(BST_node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">traverse</span>(node-&gt;left);</span><br><span class="line">cout &lt;&lt; node-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//只有中序遍历，才能从小到大打印</span></span><br><span class="line"><span class="built_in">traverse</span>(node-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BST_node* <span class="title">BST::bi_search</span><span class="params">(BST_node* node, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;data &gt; key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bi_search</span>(node-&gt;left, key);<span class="comment">//return函数返回值</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;data &lt; key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bi_search</span>(node-&gt;right, key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BST_node* <span class="title">BST::bi_delete</span><span class="params">(BST_node* root, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BST_node* target = <span class="built_in">bi_search</span>(root, key);</span><br><span class="line">BST_node* copy_root = root;</span><br><span class="line">BST_node* temp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (root-&gt;data == key)<span class="comment">//情况一：根节点即为被删除的节点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = root-&gt;left;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">root-&gt;left = temp;</span><br><span class="line"><span class="keyword">return</span> copy_root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                </span><br><span class="line">&#123;</span><br><span class="line">BST_node* temp1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> ((root-&gt;left==<span class="literal">NULL</span> || root-&gt;left-&gt;data != key) &amp;&amp;(root-&gt;right==<span class="literal">NULL</span> || root-&gt;right-&gt;data != key)) <span class="comment">//4种可能的情况，最里面的括号中的顺序不可反！！！</span></span><br><span class="line">key &lt; root-&gt;data ? root = root-&gt;left : root = root-&gt;right;</span><br><span class="line">key &lt; root-&gt;data ? temp = root-&gt;left : temp = root-&gt;right;</span><br><span class="line">temp1 = temp-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (temp1 == <span class="literal">NULL</span>)  <span class="comment">//情况二：被删节点没有右子树，则直接将被删节点的左子树连到被删节点的父节点（作为父节点的右子树还是左子树需要判断，见下if-else）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data &gt; root-&gt;data)</span><br><span class="line">root-&gt;right = temp-&gt;left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">root-&gt;left = temp-&gt;left;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                <span class="comment">//被删节点有右子树，则将被删节点的左子树连到右子树的最左叶子节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp1-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">temp1 = temp1-&gt;left;</span><br><span class="line">temp1-&gt;left = temp-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data &lt; root-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">root-&gt;left = temp-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">root-&gt;right = temp-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> copy_root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;arr&#123; <span class="number">12</span>,<span class="number">32</span>,<span class="number">43</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">15</span>,<span class="number">76</span>,<span class="number">48</span>,<span class="number">98</span>,<span class="number">56</span> &#125;;<span class="comment">//刚学习STL，所以采用STL的数组，也可用普通数组</span></span><br><span class="line"><span class="function">BST <span class="title">bi_ser_tre</span><span class="params">(arr.data(), arr.size())</span></span>;</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入9:&quot;</span> &lt;&lt; endl;</span><br><span class="line">bi_ser_tre.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除76:&quot;</span> &lt;&lt; endl;</span><br><span class="line">bi_ser_tre.<span class="built_in">del</span>(<span class="number">76</span>);</span><br><span class="line">bi_ser_tre.<span class="built_in">in_traverse</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyx坦克大战</title>
      <link href="/2022/06/19/easyx%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
      <url>/2022/06/19/easyx%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>效果图如下：</p><img src="/2022/img/image-20220731195930223.png" alt="image-20220731195930223" style="zoom:50%;" /><p>特色：</p><ul><li>基于像素移动，自由度更高。对地图的破坏基于单元格进行。</li><li>地图编辑器：使玩家能够进行再创作，游戏更加灵活。</li><li>酷酷的音效。实话，这游戏很无聊，最吸引我的是它的bgm。</li></ul><blockquote><p>这个项目是本人在 <strong>01星球</strong> 与小伙伴们合作写的小游戏，也是我的第一个有图形界面的程序（之前都是黑压压的控制台小游戏）。可玩性不高，没有参考意义，仅留做纪念。有兴趣的读者可下载源码：</p><p>链接：<a href="https://pan.baidu.com/s/17PI4mMjW-RfygXp1yS5IjQ?pwd=gzwb">https://pan.baidu.com/s/17PI4mMjW-RfygXp1yS5IjQ?pwd=gzwb</a><br>提取码：gzwb</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树与哈夫曼编码</title>
      <link href="/2022/06/19/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2022/06/19/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈夫曼树的作用：<a href="https://zhidao.baidu.com/question/747308677055660332.html">哈夫曼树是为解决哪种问题发明的</a></p><p>哈夫曼树的构建原理：<a href="http://c.biancheng.net/view/3398.html">哈夫曼树详解</a></p><p>下面浅谈我个人对哈夫曼树的理解及其实现：</p><blockquote><p>阅读网上的哈夫曼树构造方法后，可以发现这是一个重复的过程：提取森林中权值最小的两棵树，并将它们组成新树，再将这个新树再次放入森林，然后重复以上步骤。既然是重复步骤，那么就可以递归实现（实际上，递归也是最易懂，最优雅的方法）。图解如下：</p></blockquote><img src="/2022/img/20220619003149.png" alt="img" style="zoom:67%;" /><ol start="3"><li>把链表第一个（b）和第二个节点©分别作为新根节点new_root的左右孩子，new_root的权值等于左右孩子权值之和，然后将new_root的权值和第三个(d)及其后面的节点权值依次比较，直到找到一个比new_root权值大的节点（找不到则放最后），并把new_root节点插入到此节点之前；重复上述步骤，图解如下：</li></ol><img src="/2022/img/20220619003141.png" alt="img" style="zoom:67%;" /><ol start="4"><li>最后把左孩子的权值改为0，右孩子权值改为1，然后遍历树，对各个字母进行编码代码实现如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">huf_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> data;<span class="comment">//字母或数字</span></span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//权重</span></span><br><span class="line">huf_tree* left;<span class="comment">//左孩子</span></span><br><span class="line">huf_tree* right;<span class="comment">//右孩子</span></span><br><span class="line">huf_tree* rlink;<span class="comment">//右节点</span></span><br><span class="line">string code;<span class="comment">//哈夫曼编码，注意用string更方便！易于递归直接string相加</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">words</span><span class="comment">//临时的结构体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> letters;</span><br><span class="line"><span class="type">int</span> counts;<span class="comment">//字母or数字的出现次数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_huf_tree</span><span class="params">(huf_tree*, <span class="type">int</span>)</span></span>;<span class="comment">//建立哈夫曼树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_lett_arr</span><span class="params">(words**)</span></span>;<span class="comment">//初始化字符的结构体指针数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">essay_data</span><span class="params">(words**)</span></span>;<span class="comment">//提取文章中的字母出现次数,并存入各个字母对应的结构体</span></span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_link_list</span><span class="params">(words**)</span></span>;<span class="comment">//创建哈夫曼树（递归创建）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huf_coding</span><span class="params">(huf_tree* root,string)</span></span>;<span class="comment">//编码（递归）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_code</span><span class="params">(huf_tree* root)</span></span>;<span class="comment">//展示各个字母的码值（递归遍历）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">36</span>;<span class="comment">//26个字母+10个数字</span></span><br><span class="line">words* letter_arr[<span class="number">36</span>]; <span class="comment">//开一个指针数组</span></span><br><span class="line"><span class="built_in">ini_lett_arr</span>(letter_arr);<span class="comment">//初始化字母数组（临时，用以排序）</span></span><br><span class="line"><span class="built_in">essay_data</span>(letter_arr);</span><br><span class="line">huf_tree* head = <span class="built_in">cre_link_list</span>(letter_arr);</span><br><span class="line">huf_tree* root = <span class="built_in">cre_huf_tree</span>(head, n);</span><br><span class="line">root-&gt;code = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">dis_code</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_lett_arr</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">97</span>; i &lt;=<span class="number">122</span>; i++)<span class="comment">//将arr数组0-25设置为存放a-z的小写字母的words结构体</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i<span class="number">-97</span>] = <span class="keyword">new</span> words;<span class="comment">//分配实体空间</span></span><br><span class="line">arr[i - <span class="number">97</span>]-&gt;letters = i;</span><br><span class="line">arr[i - <span class="number">97</span>]-&gt;counts = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">48</span>; i &lt;=<span class="number">57</span> ; i++)<span class="comment">//ASCII码48-57对应字符0-9,分别存入arr[26]-arr[35]</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i - <span class="number">22</span>] = <span class="keyword">new</span> words;</span><br><span class="line">arr[i - <span class="number">22</span>]-&gt;letters = i;</span><br><span class="line">arr[i - <span class="number">22</span>]-&gt;counts = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_huf_tree</span><span class="params">(huf_tree* head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">huf_tree* new_root = <span class="keyword">new</span> huf_tree; <span class="comment">//开辟实体空间</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)<span class="comment">//递归结束的条件：当link_list中只有两个节点，则进行以下操作后返回</span></span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;right = head-&gt;rlink;</span><br><span class="line">new_root-&gt;left = head;</span><br><span class="line">new_root-&gt;data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">new_root-&gt;weight = new_root-&gt;right-&gt;weight + new_root-&gt;left-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br><span class="line">huf_tree* new_head = head-&gt;rlink-&gt;rlink;</span><br><span class="line">huf_tree* temp = new_head;</span><br><span class="line">new_root-&gt;right = head-&gt;rlink;</span><br><span class="line">new_root-&gt;left = head;</span><br><span class="line">new_root-&gt;data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">new_root-&gt;weight = new_root-&gt;right-&gt;weight + new_root-&gt;left-&gt;weight;</span><br><span class="line">head-&gt;rlink-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> step = <span class="number">-1</span>;<span class="comment">//注意，step设置为-1而不是0！由于没有前驱指针（只有后驱指针rlink）,故把A插入BCD中C和D之间，需要把temp停在B而不可停在D！</span></span><br><span class="line"><span class="keyword">if</span> (new_root-&gt;weight &lt; new_head-&gt;weight)</span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;rlink = new_head;</span><br><span class="line">new_head = new_root;   <span class="comment">//如果新产生的根节点权重小于新的头节点，那么此根节点仍然作为链表的头节点；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_root-&gt;weight == new_head-&gt;weight)</span><br><span class="line">&#123;</span><br><span class="line">new_root-&gt;rlink = new_head-&gt;rlink;</span><br><span class="line">new_head-&gt;rlink = new_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//否则将产生的根节点插入到链表合适的位置（权值仍从小到达排列）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (new_root-&gt;weight &gt; temp-&gt;weight))<span class="comment">//第一个条件temp!=NULL很重要</span></span><br><span class="line">&#123;</span><br><span class="line">step++;</span><br><span class="line">temp = temp-&gt;rlink;</span><br><span class="line">&#125;</span><br><span class="line">temp = new_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;rlink;      <span class="comment">//将temp移动到要插入位置的前一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">new_root-&gt;rlink = temp-&gt;rlink;</span><br><span class="line">temp-&gt;rlink = new_root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cre_huf_tree</span>(new_head, n - <span class="number">1</span>);<span class="comment">//此处是最关键也是最难想到的：将最终生成的根节点一路向上传回给主函数！这招很帅</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">essay_data</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入文段(以&#x27;#&#x27;结尾):&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> letter = <span class="built_in">getchar</span>();                      <span class="comment">//这里将所有的字符存入缓冲区，下面的while依次读取</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( letter &gt;= <span class="number">97</span> &amp;&amp; letter &lt;= <span class="number">122</span>)<span class="comment">//小写字母</span></span><br><span class="line">&#123;</span><br><span class="line">arr[letter - <span class="number">97</span>]-&gt;counts++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (letter &gt;= <span class="number">48</span> &amp;&amp; letter &lt;= <span class="number">57</span>)<span class="comment">//数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[letter - <span class="number">22</span>]-&gt;counts++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (letter &gt;= <span class="number">65</span> &amp;&amp; letter &lt;= <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[letter + <span class="number">32</span> - <span class="number">97</span>]-&gt;counts++;<span class="comment">//把大写字母转为小写并存入</span></span><br><span class="line">&#125;</span><br><span class="line">letter = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">if</span> (letter == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">huf_tree* <span class="title">cre_link_list</span><span class="params">(words** arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)          <span class="comment">//冒泡排序，从小到大；36个字母，排35次即可</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">35</span> - i; k++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[k]-&gt;counts &gt; arr[k + <span class="number">1</span>]-&gt;counts)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[k], arr[k + <span class="number">1</span>]);<span class="comment">//用库中的swap()交换指针的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">huf_tree* head = <span class="keyword">new</span> huf_tree;<span class="comment">//为树节点开辟实体空间</span></span><br><span class="line">head-&gt;weight = arr[<span class="number">0</span>]-&gt;counts;</span><br><span class="line">head-&gt;data = arr[<span class="number">0</span>]-&gt;letters;</span><br><span class="line">head-&gt;right = head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">huf_tree* temp_head = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">36</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">huf_tree* huf_node = <span class="keyword">new</span> huf_tree;</span><br><span class="line">huf_node-&gt;weight = arr[i]-&gt;counts;</span><br><span class="line">huf_node-&gt;data = arr[i]-&gt;letters;</span><br><span class="line">huf_node-&gt;left = huf_node-&gt;right = huf_node-&gt;rlink = <span class="literal">NULL</span>;</span><br><span class="line">temp_head-&gt;rlink = huf_node;</span><br><span class="line">temp_head = temp_head-&gt;rlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huf_coding</span><span class="params">(huf_tree* root,string code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span> || root-&gt;left==<span class="literal">NULL</span>)<span class="comment">//实际上，如果right=NULL，则left必定也为NULL</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;left-&gt;code = code + <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root-&gt;left,root-&gt;left-&gt;code);      <span class="comment">//递归需要注意顺序</span></span><br><span class="line"> </span><br><span class="line">root-&gt;right-&gt;code = code + <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">huf_coding</span>(root-&gt;right,root-&gt;right-&gt;code);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_code</span><span class="params">(huf_tree* root)</span><span class="comment">//递归遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;data &gt;= <span class="number">97</span> &amp;&amp; root-&gt;data &lt;= <span class="number">122</span>&amp;&amp;root-&gt;weight!=<span class="number">0</span>)<span class="comment">//数字出现很少，所以这里没有加数字，可以自己加上去</span></span><br><span class="line">&#123;                                                         <span class="comment">//只显示有权重的字符，没出现过的不显示</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;%c&#x27; 出现次数：%-4d   哈夫曼码：&quot;</span>, root-&gt;data, root-&gt;weight);</span><br><span class="line">cout &lt;&lt; root-&gt;code &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dis_code</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">dis_code</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/img/20220619003137.png" alt="img" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法一:八皇后回溯</title>
      <link href="/2022/06/19/%E5%85%AB%E7%9A%87%E5%90%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/19/%E5%85%AB%E7%9A%87%E5%90%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>思路来源：<a href="https://www.bilibili.com/video/BV1ZK411K7A8?spm_id_from=333.999.0.0">动画演示八皇后回溯算法</a></p><p>视频演示的非常清楚，也有详细代码，所以此处不再过多剖析，仅展示代码。</p><p>视频中使用vector来储存每次尝试的结果；需要注意的是，vector本质是new开辟的，而下面代码的实现并未使用new开辟空间，而是采用的栈数组，所以撤销操作时，需要<code>深度拷贝</code>，否则函数返回后，数组将失效！</p></blockquote><p><strong><mark class="hl-label blue">方案一：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir_x[<span class="number">8</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;<span class="comment">//创建两个方向数组</span></span><br><span class="line"><span class="type">int</span> dir_y[<span class="number">8</span>] = &#123;  <span class="number">0</span> , <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">              <span class="comment">//  L  LU  LD  R RU RD  U  D      L左，R右，D下,U上 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">int</span>(*temp)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">int</span> i, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_att_que</span><span class="params">(<span class="type">int</span> (*attack)[<span class="number">8</span>], <span class="type">char</span> (*queen)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">char</span>(*queen)[<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="type">int</span> counts;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> attack[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">char</span> queen[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="built_in">ini_att_que</span>(attack, queen);</span><br><span class="line"><span class="built_in">backtrack</span>(<span class="number">0</span>, attack, queen);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;八皇后问题一共有&quot;</span> &lt;&lt; counts &lt;&lt; <span class="string">&quot;种解法。&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_att_que</span><span class="params">(<span class="type">int</span> (*attack)[<span class="number">8</span>], <span class="type">char</span> (*queen)[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">*(*attack + i) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">*(*queen + i) = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>(*attack)[<span class="number">8</span>], <span class="type">char</span>(*queen)[<span class="number">8</span>])</span><span class="comment">//n为行数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%  c  &quot;</span>, queen[i][k]);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=====================================\n&quot;</span>);</span><br><span class="line">counts++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">8</span>; col++)<span class="comment">//col即column，列数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (attack[n][col] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="built_in">copy_attack</span>(attack,temp);<span class="comment">//备份attack数组</span></span><br><span class="line">queen[n][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//放置皇后；</span></span><br><span class="line"><span class="built_in">update_attack</span>(attack, n, col);</span><br><span class="line"><span class="built_in">backtrack</span>(n + <span class="number">1</span>, attack, queen);<span class="comment">//检测下一行</span></span><br><span class="line"><span class="built_in">copy_attack</span>(temp, attack);<span class="comment">//这里不是备份了！而是撤销之前的update_attack！此处不能直接attack=temp！因为temp是局部变量！函数结束后会被销毁(即需要深拷贝而不是浅拷贝)</span></span><br><span class="line">queen[n][col] = <span class="string">&#x27;#&#x27;</span>;     <span class="comment">//撤销之前放置的皇后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>],<span class="type">int</span>(*temp)[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">temp[i][k] = attack[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_attack</span><span class="params">(<span class="type">int</span>(*attack)[<span class="number">8</span>],<span class="type">int</span> i,<span class="type">int</span> k)</span><span class="comment">//i为行，k为列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt; <span class="number">8</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; <span class="number">8</span>; g++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nx = i + m * dir_x[g];<span class="comment">//nx和ny是被攻击的地方，利用方向数组直接向八个方向辐射！</span></span><br><span class="line"><span class="type">int</span> ny = k + m * dir_y[g];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; <span class="number">8</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">attack[nx][ny] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><mark class="hl-label blue">方案二：</mark> </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,  x[N], ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPut</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++) <span class="comment">//这里的j是指m层的上方所有层</span></span><br><span class="line"><span class="keyword">if</span>(x[m]==x[j]  <span class="comment">//检测[m][i]正上方的[m][j]有没有棋子</span></span><br><span class="line">|| <span class="built_in">abs</span>(j-m)==<span class="built_in">abs</span>(x[j]-x[m]))<span class="comment">//检测[m][i]的左右斜上方有没有棋子：j-m=行距; x[j]-x[m]=列距</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n<span class="number">-1</span>)&#123; <span class="comment">//n-1：我们定义的是8皇后，但数组下标从0开始，也就是说m&gt;7时，就已经满足了条件</span></span><br><span class="line">ret++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;    &quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//横向扫描</span></span><br><span class="line"></span><br><span class="line">x[m]=i;      <span class="comment">//此步非常抽象！八皇后棋盘本应是二维，x数组却是一维，这一步便是用一维数组实现二维效果的关键所在！</span></span><br><span class="line"> <span class="comment">//m是指层数，而x[m]，即x[m]中的数，是指所在列数！即x[m]=i表示棋盘位置[m][i]；且一旦对x[m]赋值，就代表在[m][i]处放棋</span></span><br><span class="line"> <span class="comment">//当x[m]重新被赋值为f，则表示在第m行f列重新放棋，之前的x[m]=i所放的棋自然而然的被移到了[m][f]处，所以就避免了上一种方法的撤销操作！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">canPut</span>(m))<span class="comment">//剪枝</span></span><br><span class="line"><span class="built_in">go</span>(m+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">n=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">go</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ret;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案一和方案二的差别在于：方案一利用二维数组，具象地模拟了放棋和撤棋的过程（比如使用*号代表棋子）；而方案而则使用一维数组，利用下标+下标中的数据来模拟放棋。第二种更加巧妙，没有额外空间复杂度，但相比方案一更抽象。</strong></p><hr><p>若有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const与constexpr的区别</title>
      <link href="/2022/06/18/const%E4%B8%8Econstexpr/"/>
      <url>/2022/06/18/const%E4%B8%8Econstexpr/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>constexpr是C++11的内容，其功能是 ==使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段== 。</p><p>提出它的目的主要是为了解决const双重语义的问题。</p><p><strong><font color=#FF00FF> &quot;双重语义&quot;是指”常量“与”只读“。</font></strong></p><p>要搞清楚const与constexpr的关系，首先应该从”常量“与”只读“的区别入手。</p></blockquote><p><strong>只读</strong> ：侧重对变量或对象本身的属性或者权力。即某个变量没有权利(通过自身)更改其内存。如下：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = b;</span><br></pre></td></tr></table></figure><p>不可通过a变量来修改a内存中的内容。</p><p>值得一提的是，这只是强调不可通过a来修改其内存，即不能继续以下操作:</p><p><code>a = 20;//a为只读，不可修改</code></p><p>但是却可以通过其他办法来改变其内存，很简单，使用指针修改即可：</p><p><code>int* pa = (int*)&amp;a;</code></p><p><code>*pa = 30;//a的值就被修改成了30.</code></p><p>需要强调的是，C++中通过引用或指针修改const的值，只适用于赋的值为左值(变量)的情况！(即const int a = b;) 当被赋的值为右值(即字面量)时（const int a = 10;）便不可被修改。至于为什么，请看下文。</p></blockquote><p><strong>常量</strong> ：侧重内存本身是常量，任何方式都无法修改此部分内存，如下：</p><blockquote><p><code>constexpr int a = 10;</code></p><p><strong><font color=#FF00FF>a此时就与一个常量绑定了，在编译期间，a就会被10替换(类似于宏替换)，以达到优化</font></strong></p><p>注意：使用constexpr时，= 右边必须是右值(即字面常量)，而不可为变量！</p></blockquote><p><strong><font color=#00FFFF>为了区分这两者，C++将“常量”交给了constexpr，将“只读”交给了const</font></strong>。</p><p>还需要注意的是，C++与C不同，后者访问const 变量的值是通过其内存获取的，而前者是通过 <strong><font color='orange'>常量折叠</font></strong> （指const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化）来获取其值的。所以当如下定义时，const与constexpr效果完全相同：</p><blockquote><p>const int a = 10;//与下等价：</p><p>constexpr int a = 10;//这两种情况,a的值无论如何也无法改变</p><p>值得一提的是，下面两种情况是不等价的：</p><p>int b = 10;</p><p>const int a = b;//第一种</p><p>const int a = 10//第二种</p><p>第一种情况虽然在语义上和第二种相同，但编译器对二者的处理是不一样的。前者是 <strong><font color='gree'>运行期常量</font></strong> ，后者是 <strong><font color='gree'>编译期常量</font></strong> 。可参考<a href="http://www.bubuko.com/infodetail-3446312.html">此链接</a></p><p>运行期常量不会进行常量折叠，编译器常量才会进行。为什么？因为运行期常量需要等到代码运行时才能确定，我们完全可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="built_in">max</span>(k,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>很显然，a的值需要等到我们输入k后才能确定。</p><p>此时，a就不可进行常量折叠了(因为常量折叠是在编译期进行的，而这时我们还没输入k)，而是通过C语言的方式，在内存的常量区域开辟空间存放常量a的值，且此后获取a的值都需要访问其内存，而不是直接从符号表中获取。下面用一个最简单的例子进行对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[size] = &#123;<span class="number">0</span>&#125;; <span class="comment">//没有问题</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = a;</span><br><span class="line"><span class="type">int</span> arr[size] = &#123;<span class="number">0</span>&#125;; <span class="comment">//报错，因为完全可用在第一行与第二行直接再对a进行运行时修改。</span></span><br></pre></td></tr></table></figure></blockquote><p>最后再简单总结<code>const</code>，<code>constexpr</code>与<code>#define</code>的区别：</p><ul><li><p>const：</p><p>1.const强调为&quot;只读&quot;，本质仍是变量，可以被间接修改(通过引用方式)。</p><p>2.const有可能为编译期常量，也可能为运行期常量。</p><p>3.定义时会在内存中分配，后面调用只是给出对应的内存地址，不再分配，节省内存空间。</p></li><li><p>constexpr：</p><ol><li><p>constexpr强调&quot;不可修改&quot;，是真正的常量。</p></li><li><p><strong>constexpr限定在了编译期常量 。</strong></p></li></ol></li><li><p>宏定义：</p><p>1.在预处理阶段展开；</p><p>2.没有类型，不做类型检查，仅仅是展开；</p><p>3.define宏定义时不分配内存，但是每次调用均会分配一次内存，会造成内存浪费；</p></li></ul><hr><p>有错误烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kruskal算法剖析</title>
      <link href="/2022/06/18/kruskal%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90/"/>
      <url>/2022/06/18/kruskal%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="font-color-red-一-问题引入-font"><font color='red'>一.问题引入</font></h3><img src="/2022/img/20220618230130.png" alt="img" style="zoom: 33%;" /><p>图中的6个顶点分别代表6个村庄，线段的权值代表村庄之间的距离。请问如何找到最短的路径来访问每一个村庄，且每个村庄只访问一次。</p><h3 id="font-color-red-二-解决-font"><font color='red'>二.解决</font></h3><ol><li>提取图的边，并将边按权值大小从小到大排列，并放入edge数组。如下：</li></ol><p><img src="/2022/img/20220618230116.png" alt="img" style="zoom:33%;" /> <img src="/2022/img/20220618230124.png" alt="img" style="zoom:33%;" /></p><ol start="2"><li><p>创建根数组（辅助数组），数组下标代表顶点节点本身，其元素代表顶点的根节点，如下：</p><blockquote><p>提示：这里的“根”并不是树结构中真正的根，一棵树中只有一个根，而这里的“根”泛指长辈，可能是父节点，也可能是“爷”节点。<font color=#FF00FF>初始化根数组为-1，代表初始状态下每个顶点都各自代表一个集合。</font></p></blockquote></li><li><p>将edge数组中的边从小到大依次放回图中，如果后续加入的边与图中已放入的边形成了环，那么将此边丢弃，继续将下一条边放入，规则同前。</p><blockquote><p><font color=#00FFFF>形成环，即说明加入的这条边的起点和终点已经属于一个集合，有共同的根。加入边的过程就是多个子集不断合并的过程，同一集合中的顶点不可相连。前面的辅助数组就是用来判断起点与终点是否属于一个集合</font>。具体实现看代码注释。</p></blockquote></li><li><p>放入（顶点数-1）条边后，最小生成树（Minimum Spanning Tree）构建完成，即可结束循环。</p><blockquote><p>一棵树有n个节点，则有n-1条边</p></blockquote></li></ol><h3 id="font-color-red-三-细节-font"><font color='red'>三.细节 </font></h3><p>上述算法主要有两点需要考虑：</p><ul><li>树的储存</li><li>集合的表示</li></ul><blockquote><p>树的储存：常见的图储存结构有：邻接矩阵,邻接边表,十字链表,邻接多重表,边集数组。显然，上述算法中频繁涉及到对边的操作，所以边集数组是最佳选择。</p><p>集合的表示：使用辅助数组，存放各顶点的根顶点，如果两个顶点的根相同，则属于同一集合，另则相反。初始化辅助数组元素为-1，代表每个顶点本身就是根节点。</p></blockquote><h3 id="font-color-red-四-实现-font"><font color='red'>四.实现 </font></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VEX  10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EDGE 100  <span class="comment">//10个顶点组成的无向图最多有100条边</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>  <span class="comment">//边的属性结构体</span></span><br><span class="line">&#123;</span><br><span class="line">TYPE start;</span><br><span class="line">TYPE end;</span><br><span class="line">TYPE weight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_gragh</span><span class="params">(<span class="type">int</span>&amp; vex, <span class="type">int</span>&amp; edge, Edge* gragh)</span></span>;<span class="comment">//采用边集数组储存图</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_edge</span><span class="params">(Edge* edges,<span class="type">int</span> edge)</span></span>;<span class="comment">//使用冒泡排序，根据权值大小将边从小到大排序</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> n)</span></span>;<span class="comment">//寻找根节点以判断是否在一个集合中</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> vex; <span class="comment">//顶点个数</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> edge; <span class="comment">//边个数</span></span><br><span class="line"> </span><br><span class="line">Edge gragh[MAX_EDGE];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ini_gragh</span>(vex, edge, gragh);<span class="comment">//边集数组初始化图</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">sort_edge</span>(gragh, edge);<span class="comment">//依据权值大小给边从小到大排序</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> roots[MAX_VEX];  <span class="comment">//根数组，存放各顶点的根节点，以区别是否属于同一个集合</span></span><br><span class="line"> </span><br><span class="line">Edge MST[MAX_EDGE];   <span class="comment">//存放最小生成树（minimum spanning tree）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vex; i++)</span><br><span class="line">roots[i] = <span class="number">-1</span>;  <span class="comment">//初始化root数组，-1代表自己就是根节点；初始状态下每个顶点都是独立的根</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_EDGE; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> vex_m = <span class="built_in">find_root</span>(roots, gragh[i].start);<span class="comment">//寻找起点的根节点</span></span><br><span class="line"><span class="type">int</span> vex_n = <span class="built_in">find_root</span>(roots, gragh[i].end);<span class="comment">//寻找终点的根节点</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (vex_m != vex_n)<span class="comment">//如果两者的根节点不同，说明他们属于不同的集合，可以相连</span></span><br><span class="line">&#123;</span><br><span class="line">MST[count] = gragh[i];<span class="comment">//将此边放入MST数组</span></span><br><span class="line">count++;</span><br><span class="line">roots[vex_m] = vex_n;<span class="comment">//将两个树合并，即将顶点vex_n作为vex_m的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == vex<span class="number">-1</span>)<span class="comment">//当count达到顶点数-1，说明最小树已经生成，退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vex - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)%d\n&quot;</span>, MST[i].start, MST[i].end, MST[i].weight);   <span class="comment">//打印最小生成树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ini_gragh</span><span class="params">(<span class="type">int</span>&amp; vex, <span class="type">int</span>&amp; edge, Edge* gragh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入连通网顶点数：&quot;</span>;</span><br><span class="line">cin &gt;&gt; vex;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入连通网边数： &quot;</span>;</span><br><span class="line">cin &gt;&gt; edge;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;依次输入各边的起点，终点和权重(空格隔开)：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; gragh[i].start &gt;&gt; gragh[i].end &gt;&gt; gragh[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_edge</span><span class="params">(Edge* edges_arr,<span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Edge temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; edge - i - <span class="number">1</span>; k++)<span class="comment">//冒泡排序，注意这里要减1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (edges_arr[k].weight &gt; edges_arr[k + <span class="number">1</span>].weight)</span><br><span class="line">&#123;</span><br><span class="line">temp = edges_arr[k];</span><br><span class="line">edges_arr[k] = edges_arr[k + <span class="number">1</span>];</span><br><span class="line">edges_arr[k + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> roots[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (roots[n] &gt; <span class="number">-1</span>)  <span class="comment">//迭代寻找根节点</span></span><br><span class="line">n = roots[n];</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2022/img/20220618230100.png" alt="img" style="zoom: 50%;" /><hr><p>以上便是关于克鲁斯卡尔算法的剖析，有不对之处烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 图结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11模板可变参数扩展包</title>
      <link href="/2022/06/18/%E6%A8%A1%E6%9D%BF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E5%8C%85/"/>
      <url>/2022/06/18/%E6%A8%A1%E6%9D%BF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文不详细讲解如何在模板中使用可变参数，只浅谈对其中扩展包的理解。<br>看本文前建议先学习如何使用可变参数，推荐链接：<br><a href="http://c.biancheng.net/view/vip_8692.html">C++11在函数模板和类模板中使用可变参数 </a></p></blockquote><h2 id="一-对代码格式的理解">一.对代码格式的理解</h2><ul><li><p>为方便起见，直接把理解写在注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...args&gt;<span class="comment">// ... 旨在说明args是个参数包类型（模板参数包）。  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(T args, args... argv)</span><span class="comment">//... 也旨在说明argv是参数包。</span></span></span><br><span class="line"><span class="function"></span>&#123;                                 <span class="comment">//也就是说，上面两个 ... 相当于类型说明符，告诉编译器这是参数包。</span></span><br><span class="line">    cout&lt;&lt;argc&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">vir_fun</span>(argv...);<span class="comment">//而此处的...与上面的...作用不一样了！此处的...是在扩展参数包（即把包拆开），再依次传参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何理解args与argv？<br>args的作用和T一样，是一种类型，由此可推出 <strong><font color='red'>args是指(模板)参数包类型</font></strong> 。那么就可以顺利推出：第9行的 <strong><font color='red'>1argv就是(函数)参数包类型</font></strong> 。</p></li><li><p>有人可能会问，第二行的函数原型要求至少需要向函数传两个参数，而第12行却只传入了一个参数,似乎有问题？<br>==这就是理解参数包的关键之处==，见下。</p></li></ul><h2 id="二-对参数包的理解">二.对参数包的理解</h2><ul><li><p>参数包实际上是元素+参数包递归组成的，类似于俄罗斯套娃。比如我们向vir_fun()传入这几个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">12</span>, <span class="string">&quot;aha&quot;</span>, <span class="number">12.34</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的函数模板定义，12 应该是argc，后面的三个参数整体则是参数包argv 。<br>而参数包argv是由如下方式组成的：</p><img src="https://img-blog.csdnimg.cn/7793cc15e78d4efabe526fb2001f09df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55So5pe26Ze05Y675rKJ5reA,size_17,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" /></li><li><p>由上图知,第一次递归调用vir_fun()函数时,传入的argv…(见第12行)应该为&quot;haa&quot;+(12.34+10)<br>注意！(12.34+10)仍为参数包！如此，每次递归调用都拆成一个元素+一个参数包</p></li><li><p>读者可能会因为忘记加 … 而出现这样的报错：</p><p><img src="/2022/img/20220618215511.png" alt="img" style="zoom:50%;" />(第13行argv后未加…)</p><p>那么什么叫做<code>扩展参数包</code>？由我们之前的分析，很容易知道扩展参数包就是把参数包拆解为 <strong><font color=#FF00FF>元素+参数包</font></strong> 的形式，拿图1解释，扩展argv参数包就是将其拆为<code>&quot;haa&quot;+argv1</code>参数包的形式！</p></li><li><p>可以用sizeof求参数包个数来验证以上解释：</p><img src="/2022/img/20220618215702.png" alt="img" style="zoom:50%;" /><p>结果为：</p><img src="/2022/img/20220618215815.png" alt="img" style="zoom:80%;" /><p>恰好符合我们图1中的推断。</p></li></ul><hr><p>以上便是笔者个人对参数包的理解，且仅代表个人理解，如有不足或错误，烦请读者指出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门笔记</title>
      <link href="/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/16/Linux%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><font color='red'>Linux笔记</font></h1><h2 id="font-color-orange-1-Linux学前须知-font"><font color='orange'>1.Linux学前须知</font></h2><h3 id="font-color-gree-1-1-Linux一切皆文件-font"><font color='gree'>1.1 Linux一切皆文件</font></h3><ol><li>Linux 中所有内容都是以文件的形式保存和管理的。普通文件，目录，硬件设备，套接字和网络通信等都是文件。</li></ol><blockquote><p>Linux中，文件具体可分为以下类型：</p><ul><li><code>普通文件</code>：如：mp3，pdf，html等可以直接拿来用的文件。</li><li><code>目录文件</code>：Linux系统中，<font color='red'>目录文件包含了此目录中各个文件的文件名以及指向这些文件的指针</font>，打开目录等同于打开目录文件，只要有权限，可以随意访问目录中的任何文件。目录文件的访问权限，同普通文件的执行权限，是一个意思。</li><li><code>字符设备文件和块设备文件</code>:磁盘光驱属于块设备文件，串口设备则属于字符设备文件.</li><li><code>套接字文件</code>：用于网络通信</li><li><code>符号链接文件</code>：类似与 Windows 中的快捷方式，是指向另一文件的简介指针（也就是软链接）。</li><li><code>管道文件</code>：主要用于进程间通信。</li></ul></blockquote><ol start="2"><li>文件化的利弊</li></ol><blockquote><p>好处：开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。比如，Linux 中几乎所有读（读文件，读系统状态，读 socket，读 PIPE）的操作都可以用 read 函数来进行；几乎所有更改（更改文件，更改系统参数，写 socket，写 PIPE）的操作都可以用 write 函数来进行。</p><p>坏处：使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。Linux 本身具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</p></blockquote><hr><h3 id="font-color-gree-1-2-挂载-font"><font color='gree'>1.2 挂载</font></h3><p>​Linux系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。同样，<font color='red'>任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）</font>。当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。若不挂载，通过Linux系统中的图形界面系统可查看找到硬件设备，但命令行方式无法找到。</p><blockquote><p>当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件，但无法通过此目录直接访问 U 盘数据，此目录只会提供此设备的一些基本信息（比如容量）。</p></blockquote><p>​<font color='red'>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</font></p><blockquote><p>并不是根目录下任何一个目录都可以作为挂载点!由于<font color='red'>挂载操作会使得原有目录中文件被隐藏</font>，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃。</p></blockquote><hr><h3 id="font-color-gree-1-3-注意事项-font"><font color='gree'>1.3 注意事项</font></h3><ul><li><p>不同于Windows，Linux严格区分大小写。</p></li><li><p>Windows下的程序无法直接在Linux下使用</p></li><li><p>Linux不靠扩展名区分文件类型</p><blockquote><p>Linux系统通过权限位标识来确定文件类型。虽然Linux 中的一些特殊文件还是要求写 “扩展名” 的，但并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型，如：</p><ul><li>压缩包：Linux 下常见的压缩文件名有 <em>.gz、</em>.bz2、<em>.zip、</em>.tar.gz、<em>.tar.bz2、</em>.tgz 等。如果不写清楚扩展名，那么管理员不容易判断压缩包的格式。即使不写扩展名，在 Linux 中一样可以解压缩，不影响使用。</li><li>二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用&quot;.rpm&quot;扩展名结尾，目的同样是让管理员一目了然。</li><li>程序文件：Shell 脚本一般用 “.sh” 扩展名结尾，其他还有用 “.c” 扩展名结尾的 C 语言文件等。</li></ul></blockquote><p>.gz等扩展名不属于后缀，而成为了文件名的一部分！</p></li><li><p>Linux中所有内容(包括硬件)皆以文件保存</p><blockquote><p>Linux与Windows完全不同，后者通过设备管理器来管理硬件。</p></blockquote></li><li><p>Linux中所有储存设备必须在挂载之后才能使用</p></li></ul><hr><h3 id="font-color-gree-1-4-shell与bash-font"><font color='gree'>1.4 shell与bash</font></h3><ul><li><p>Shell就是一个<code>命令行解释器</code>，其作用是按固定语法将输入的命令加以解释并传给系统。它为用户提供了一个向Linux发送请求以便运行程序的接口系统级程序</p><blockquote><p>Shell相当于是一个翻译，把我们在计算机上的操作或我们的命令，翻译为计算机可识别的二进制命令，传递给内核，以便调用计算机硬件执行相关的操作；同时，计算机执行完命令后，再通过Shell翻译成自然语言，呈现在我们面前。</p></blockquote><p>其他的shell还有：sh、bash、ksh、rsh、csh等。Ubuntu系统常用的是bash，Bio-linux系统是基于ubuntu定制的，但是却使用了zsh。</p><p>sh的全名是Bourne Shell。名字中的玻恩就是这个Shell的作者。</p><p>而bash的全名是Bourne Again Shell。最开始在Unix系统中流行的是sh，而bash作为sh的改进版本，提供了更加丰富的功能。</p><blockquote><p>如何查看当前系统中shell的类型？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure></blockquote></li><li><p>shell命令可以分为以下三类：</p><ul><li>内建函数 (built-in function)：shell自带的功能（内部命令）。</li><li>可执行文件 (executable file)：保存在shell之外的脚本，包括外部命令。</li><li>别名(alias) ：给某个命令的简称</li></ul></li></ul><h2 id="font-color-orange-2-Linux文件和目录管理-font"><font color='orange'>2.Linux文件和目录管理</font></h2><h3 id="font-color-gree-2-1-FHS标准-font"><font color='gree'>2.1 FHS标准</font></h3><p>​FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p><blockquote><p>一级目录和二级目录的用途有严格限制，不能按自己的想法划分各目录的用途。一，二级目录中各个文件的名字不能更改！</p></blockquote><h3 id="font-color-gree-2-2-根目录-font"><font color='gree'>2.2 根目录(/)</font></h3><p>​Linux 系统的根目录（/）最为重要，因为：</p><ol><li>所有目录都是由根目录衍生出来的；</li><li>根目录与系统的开机、修复、还原密切相关；</li></ol><p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件，如下：</p><table><thead><tr><th>一级目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/bin/</td><td>存放系统命令对应的可执行程序文件，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</td></tr><tr><td>/boot/</td><td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td></tr><tr><td>/dev/</td><td>设备文件保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td></tr><tr><td>/home/</td><td>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置</td></tr><tr><td>/media/</td><td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td></tr><tr><td>/mnt/</td><td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td></tr><tr><td>/misc/</td><td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。</td></tr><tr><td>/opt/</td><td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。</td></tr><tr><td>/root/</td><td>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</td></tr><tr><td>/sbin/</td><td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td></tr><tr><td>/srv/</td><td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td></tr><tr><td>/tmp/</td><td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。</td></tr><tr><td>/lost+found/</td><td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录</td></tr><tr><td>/proc/</td><td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的</td></tr><tr><td>/sys/</td><td>虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td></tr><tr><td>/usr/</td><td>全称为 Unix Software Resource，此目录用于存储系统软件资源。开发者应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。</td></tr><tr><td>/var/</td><td>/var/目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。</td></tr></tbody></table><p>FHS 建议，/usr 和 /var 目录应具备如下所示的子目录。</p><table><thead><tr><th>/usr/子目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/usr/bin/</td><td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td></tr><tr><td>/usr/sbin/</td><td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td></tr><tr><td>/usr/lib/</td><td>应用程序调用的函数库保存位置</td></tr><tr><td>/usr/XllR6/</td><td>图形界面系统保存位置</td></tr><tr><td>/usr/local/</td><td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td></tr><tr><td>/usr/share/</td><td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td></tr><tr><td>/usr/src/</td><td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中</td></tr><tr><td>/usr/include</td><td>C/C++ 等编程语言头文件的放置目录</td></tr></tbody></table><table><thead><tr><th>/var子目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/var/lib/</td><td>程序运行中需要调用或改变的数据保存位置。如 <a href="http://c.biancheng.net/mysql/">MySQL</a> 的数据库保存在 /var/lib/mysql/ 目录中</td></tr><tr><td>/var/log/</td><td>登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。</td></tr><tr><td>/var/run/</td><td>一些服务和程序运行后，它们的 PID（进程 ID）保存位置</td></tr><tr><td>/var/spool/</td><td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。</td></tr><tr><td>/var/www/</td><td>RPM 包安装的 Apache 的网页主目录</td></tr><tr><td>/var/nis和/var/yp</td><td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td></tr><tr><td>/var/tmp</td><td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td></tr></tbody></table><h3 id="font-color-gree-2-3-绝对路径与相对路径-font"><font color='gree'>2.3 绝对路径与相对路径</font></h3><ul><li><p>绝对路径：绝对路径一定是由根目录 / 开始写起。通过绝对路径可以从某个目录中直接跳转到其他任意目录。</p><blockquote><p>比如可以直接从/var目录直接跳到/bin目录：/bin 或 …/bin</p><p>'.‘表示本目录，’…'表示上级目录</p></blockquote></li><li><p>相对路径：相对路径不是从根目录 / 开始写起，而是从当前所在的工作目录开始写起。使用相对路径表明某文件的存储位置时，经常会用到当前目录（用 . 表示）和父目录（用 … 表示）。</p><blockquote><p>从/root路径切换到/usr路径：</p><p>​绝对路径：cd /usr</p><p>​相对路径：cd …/usr</p><p>从/var目录进入子目录/temp：</p><p>​绝对路径：cd /var/temp</p><p>​相对路径：cd temp 或 cd ./temp</p></blockquote><p>进入本目录下的其他目录时，可以不用加’.'，直接 cd 文件名 就行。</p></li></ul><h3 id="font-color-gree-2-4-文件-目录-命名规则-font"><font color='gree'>2.4 文件(目录)命名规则</font></h3><ol><li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，不建议使用特殊字符，如&lt;、&gt;、？、* 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li><li>目录名或文件名的长度不能超过 255 个字符。</li><li>目录名或文件名是区分大小写的。但使用字符大小写来区分不同的文件或目录是不明智的。</li><li>Linux 系统并不以文件的扩展名开分区文件类型。例如，<font color='red'>dog.exe 只是一个文件，其扩展名 .exe 并不代表此文件就一定是可执行文件</font>。</li></ol><h3 id="font-color-gree-2-5-Linux命令行识别文件类型-font"><font color='gree'>2.5 Linux命令行识别文件类型</font></h3><ul><li><p>一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p><blockquote><p>1、蓝色代表目录<br>2、白色代表一般性文件，如文本文件、配置文件、源码文件等<br>3、绿色代表可执行文件<br>4、浅蓝(绿)色代表链接文件<br>5、黄色代表设备文件<br>6、红色代表压缩文件<br>7、灰色代表其他文件</p></blockquote><p>颜色并不能准确表示文件属性！</p></li><li><p>通过 ls -l 命令，可以查看当前目录下所有文件和目录各自的准确属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MyFirstVM /]# ls -l</span><br><span class="line">lrwxrwxrwx.   1 root root     7 5月  17 20:10 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   6 root root  4096 5月  17 20:21 boot</span><br><span class="line">drwxr-xr-x.  19 root root  3320 5月  20 22:58 dev</span><br><span class="line">drwxr-xr-x. 144 root root 12288 5月  21 10:23 etc</span><br><span class="line">drwxr-xr-x.   5 root root  4096 5月  20 16:36 home</span><br><span class="line">lrwxrwxrwx.   1 root root     7 5月  17 20:10 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root     9 5月  17 20:10 lib64 -&gt; usr/lib64</span><br></pre></td></tr></table></figure><p>每行第一个字符表示的就是文件的类型，其可能的取值以及表示的文件类型，如下表所示。</p><table><thead><tr><th>第一个字符</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>普通文件，包括纯文本文件、二进制文件、<code>硬链接</code>，各种压缩文件等。</td></tr><tr><td>d</td><td>目录，类似 Windows 系统中的文件夹。</td></tr><tr><td>b</td><td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td></tr><tr><td>c</td><td>字符设备文件，例如键盘、鼠标等。</td></tr><tr><td>s</td><td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td></tr><tr><td>p</td><td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td></tr><tr><td>l</td><td>软链接文件，类似 Windows 系统中的快捷方式。</td></tr></tbody></table><p>上面7列(时间算一列)的含义：</p><table><thead><tr><th>第1列</th><th>规定了不同的用户对文件所拥有的权限</th></tr></thead><tbody><tr><td>第2列</td><td>引用计数，文件的引用计数代表该文件的 硬链接个数 ，而目录的引用计数代表该目录有多少个一级子目录。</td></tr><tr><td>第3列</td><td>所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</td></tr><tr><td>第4列</td><td>所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</td></tr><tr><td>第5列</td><td>大小，默认单位是字节。</td></tr><tr><td>第6列</td><td>文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</td></tr><tr><td>第7列</td><td>文件名或目录名。</td></tr></tbody></table></li></ul><h3 id="font-color-gree-2-6-Linux命令基本格式-font"><font color='gree'>2.6 Linux命令基本格式</font></h3><ul><li><p>命令提示符：</p><blockquote><p><code>[root@localhost ~]#</code></p><ul><li>[]：这是提示符的分隔符号，没有特殊含义。</li><li>root：显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li><li>@：分隔符号，没有特殊含义。</li><li>localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。</li><li>~：代表用户当前所在的目录，<code>~</code>代表当前所在的目录是家目录<a href="%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%B6%E7%9B%AE%E5%BD%95%EF%BC%9A/root,%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%B6%E7%9B%AE%E5%BD%95%EF%BC%9A/home/%E7%94%A8%E6%88%B7%E5%90%8D%E3%80%82">^1</a>。</li><li>#：用户提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是 $。</li></ul></blockquote></li><li><p>命令的基本格式</p><blockquote><p><code>[root@localhost ~]# 命令 -[选项] [参数]</code></p><p>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</p></blockquote></li></ul><h3 id="font-color-gree-2-7-常见相关命令-font"><font color='gree'>2.7 常见相关命令</font></h3><h4 id="font-color-purple-2-7-1-切换目录-cd-font"><font color='purple'>2.7.1 切换目录(cd)</font></h4><ul><li><p>cd 命令，是 Change Directory 的缩写。cd 命令是 Shell 内置命令，没有执行文件所在路径。</p></li><li><table><thead><tr><th>特殊符号</th><th>作 用</th></tr></thead><tbody><tr><td>~</td><td>代表当前登录用户的主目录</td></tr><tr><td>~用户名</td><td>表示切换至指定用户的主目录</td></tr><tr><td>-</td><td>代表上次所在目录</td></tr><tr><td>.</td><td>代表当前目录</td></tr><tr><td>…</td><td>代表上级目录</td></tr></tbody></table></li></ul><h4 id="font-color-purple-2-7-2-显示当前路径-pwd-font"><font color='purple'>2.7.2 显示当前路径(pwd)</font></h4><ul><li><p>pwd 命令 ，是 print working directory 的缩写。</p></li><li><p>pwd 用于确定当前所在的目录，且以 绝对路径 的格式打印。</p><blockquote><p>虽然命令提示符<code>[root@localhost aha]#</code>中的<code>aha</code>可以提示所在位置，但不同目录下的目录和文件可以相同，所有这个<code>aha</code>的位置也是不确定的，可能在其他地方还要<code>aha</code>。</p><p>[demo@localhost aha]# pwd<br>/var/aha</p></blockquote></li></ul><h4 id="font-color-purple-2-7-3-创建空目录-mkdir-font"><font color='purple'>2.7.3 创建空目录(mkdir)</font></h4><blockquote><p><code>[root@localhost ~]# mkdir -[m\p] 目录名</code></p><ul><li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。如<code>[root@localhost ~]# mkdir -m 711 test2</code>，711为权限值。</li><li>-p 选项递归创建所有目录，以创建 /home/test/demo 为例，在默认情况下，需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 /home、/home/test 以及 /home/test/demo。</li></ul></blockquote><h4 id="font-color-purple-2-7-4-删除空目录-rmdir-font"><font color='purple'>2.7.4 删除空目录(rmdir)</font></h4><blockquote><p><code>[root@localhost ~]# rmdir -[p] 目录名</code></p><ul><li>-p用于递归删除空目录，如<code>[root@localhost ~]# rmdir -p lm/movie/jp/cangls</code>，先从/cangs删起，再删/jp，向上递推。<font color='red'>前提是空目录才能删除！</font></li><li>此命令并不常用。rm 命令不但可以删除目录，还可以删除文件，更方便</li></ul></blockquote><h4 id="font-color-purple-2-7-5-创建文件及修改文件时间戳-touch-font"><font color='purple'>2.7.5 创建文件及修改文件时间戳(touch)</font></h4><ul><li><p>touch 命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。</p><blockquote><p>Linux中，每个文件主要拥有如下3个时间参数（通过 stat 命令进行查看）：</p><ul><li>访问时间（Access Time，简称 atime）：只要文件的内容被读取，访问时间就会更新。使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li><li>数据修改时间（Modify Time，简称 mtime）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li><li>状态修改时间（Change Time，简称 ctime）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li></ul></blockquote></li><li><p>注意touch是创建文件，而不是目录！</p></li><li><blockquote><p><code>[root@localhost ~]# touch -[选项] 文件名</code></p><p>选项：</p><ul><li><p>a：只修改文件的访问时间；</p></li><li><p>c：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。</p></li><li><p>d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</p></li><li><p>m：只修改文件的数据修改时间。</p></li><li><p>t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 <code>“YY-MM-DD hh:mm</code>,如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#touch</span> -d&quot;<span class="number">2017</span>-<span class="number">05</span>-<span class="number">04</span> <span class="number">15</span>:<span class="number">33</span><span class="string">&quot; aha</span></span><br><span class="line"><span class="string">[root@localhost ~]#stat aha</span></span><br><span class="line"><span class="string">最近访问：2017-05-04 15:33:00.000000000 +0800</span></span><br><span class="line"><span class="string">最近更改：2017-05-04 15:33:00.000000000 +0800</span></span><br><span class="line"><span class="string">最近改动：2022-05-21 20:06:53.251283783 +0800 //即状态时间，无法单独改动</span></span><br></pre></td></tr></table></figure></li></ul><p><font color='cornflowerblue'>注意：touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变。</font></p></blockquote></li></ul><h4 id="font-color-purple-2-7-6-查看目录内容-ls-font"><font color='purple'>2.7.6 查看目录内容(ls)</font></h4><ul><li>ls 命令常用选项及功能：</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。</td></tr><tr><td>-A</td><td>显示全部的文件，连同隐藏文件，但不包括 . 与 … 这两个目录。</td></tr><tr><td>-d</td><td>仅列出目录本身，而不是列出目录内的文件数据。</td></tr><tr><td>-f</td><td>ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。</td></tr><tr><td>-F</td><td>在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 <a href="http://c.biancheng.net/socket/">socket</a> 文件，| 代表 FIFO 文件。</td></tr><tr><td>-h</td><td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td></tr><tr><td>-i</td><td>显示 inode 节点信息。</td></tr><tr><td>-l</td><td>使用长格式列出文件和目录信息。“ll&quot;等同于&quot;ls -l”</td></tr><tr><td>-n</td><td>以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td></tr><tr><td>-r</td><td>将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td></tr><tr><td>-R</td><td>连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td></tr><tr><td>-S</td><td>以文件容量大小排序，而不是以文件名排序。</td></tr><tr><td>-t</td><td>以时间排序，而不是以文件名排序。</td></tr><tr><td>–color=never --color=always --color=auto</td><td>never 表示不依据文件特性给予颜色显示。 always 表示显示颜色，ls 默认采用这种方式。 auto 表示让系统自行依据配置来判断是否给予颜色。</td></tr><tr><td>–full-time</td><td>以完整时间模式 （包含年、月、日、时、分）输出</td></tr><tr><td>–time={atime,ctime}</td><td>输出 access 时间或改变权限属性时间（ctime），而不是内容变更时间。</td></tr></tbody></table><ul><li><p>上表中的a和l还可以组合使用，既列出了详细信息，又包含’.‘和’…'两个隐藏文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM home]</span># ls -al</span><br><span class="line">总用量 <span class="number">20</span></span><br><span class="line">drwxr-xr-x.  <span class="number">5</span> root root <span class="number">4096</span> <span class="number">5</span>月  <span class="number">20</span> <span class="number">16</span>:<span class="number">36</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4096</span> <span class="number">5</span>月  <span class="number">17</span> <span class="number">20</span>:<span class="number">20</span> ..</span><br><span class="line">drwx------.  <span class="number">5</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">4096</span> <span class="number">5</span>月  <span class="number">20</span> <span class="number">16</span>:<span class="number">47</span> milan</span><br><span class="line">drwx------.  <span class="number">4</span> fuck fuck <span class="number">4096</span> <span class="number">5</span>月  <span class="number">21</span> <span class="number">19</span>:<span class="number">38</span> test</span><br><span class="line">drwx------. <span class="number">15</span> xuan xuan <span class="number">4096</span> <span class="number">5</span>月  <span class="number">21</span> <span class="number">12</span>:<span class="number">59</span> xuan</span><br></pre></td></tr></table></figure><p>其他组合用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -ld /root/</span><br><span class="line">dr-xr-x---.<span class="number">2</span> root root <span class="number">4096</span> <span class="number">1</span> 月 <span class="number">20</span> <span class="number">12</span>:<span class="number">30</span> /root/</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -lh</span><br><span class="line">总用量<span class="number">44</span>K</span><br><span class="line">-rw-------.<span class="number">1</span> root root <span class="number">1.2</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">18</span> anaconda-ks.cfg</span><br><span class="line">-rw-r-r--.<span class="number">1</span> root root <span class="number">25</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">17</span> install.log</span><br><span class="line">-rw-r-r--.<span class="number">1</span> root root <span class="number">7.6</span>K <span class="number">1</span> 月 <span class="number">14</span> <span class="number">18</span>:<span class="number">17</span> install.log.syslog   #-l 显示的是字节大小，而-lh显示的是kb，mb，gb...</span><br></pre></td></tr></table></figure></li></ul><h4 id="font-color-purple-2-7-7-建立软-硬链接-ln-font"><font color='purple'>2.7.7 建立软/硬链接(ln)</font></h4><ul><li><p>ext4文件系统：</p><blockquote><p>ext4 文件系统会把分区主要分为三大部分：super block, inode , block。</p><ul><li><p>super block：储存inode，block的总量，使用量，剩余量，以及文件系统的格式和相关信息。</p></li><li><p>inode：默认大小为 128 Byte，用来记录文件的权限、<a href="http://c.biancheng.net/view/752.html">文件的所有者和属组</a>、文件大小、文件的时间参数、对应的 block 编号。每个文件需要占用一个 inode。inode中不记录文件名，而记录在文件所在目录的 block 中。<em><strong>inode即是（目录、档案）文件在一个文件系统中的唯一标识</strong></em>，需要访问这个文件的时候必须先找到并读取这个文件的 inode</p></li><li><p>block 的大小默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。若存放某文件数据最后一个 block 不能占满，但也不能再放入其他文件的数据。<strong>存放同一个文件的多个 block 有可能是连续的，也有可能是分散的</strong>。</p><blockquote><p>通过以上两点可以得到：</p><ol><li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li><li>如果想要读取文件内容，<em><strong>就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块</strong></em>；</li></ol></blockquote></li></ul></blockquote></li><li><p>软连接/硬链接(符号链接)：</p><blockquote><ul><li>硬链接：文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li><li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li></ul></blockquote></li><li><p>建立硬链接/软连接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln <span class="selector-attr">[选项]</span> 源文件 目标文件</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件；</li><li>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li></ul><p>创建硬链接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch cangls</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln /root/cangls /tmp</span><br><span class="line">#建立硬链接文件，目标文件没有写文件名，会和原名一致</span><br><span class="line">#也就是/tmp/cangls 是硬链接文件</span><br></pre></td></tr></table></figure><p>创建软连接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch bols</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># In -s /root/bols /tmp</span><br><span class="line">#建立软链接文件</span><br></pre></td></tr></table></figure><p>注意：软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求），否则软链接文件会报错！</p></li></ul><h4 id="font-color-purple-2-7-8-剖析软-硬链接-font"><font color='purple'>2.7.8 剖析软/硬链接</font></h4><p><em><strong>硬链接剖析：</strong></em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch test    </span><br><span class="line">#建立源文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ln /root/test /tmp/test-hard</span><br><span class="line">#给源文件建立硬链接文件 /tmp/test-hard</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -<span class="selector-tag">i</span> /root/test /tmp/test-hard</span><br><span class="line"><span class="number">262147</span> -rw-r<span class="attr">--r--</span> <span class="number">2</span> root root <span class="number">0</span> <span class="number">6</span>月 <span class="number">19</span> <span class="number">10</span>:<span class="number">06</span> /root/test</span><br><span class="line"><span class="number">262147</span> -rw-r--r-- <span class="number">2</span> root root <span class="number">0</span> <span class="number">6</span>月 <span class="number">19</span> <span class="number">10</span>:<span class="number">06</span> /tmp/test-hard</span><br><span class="line">     ##查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，<span class="string">&quot;ll&quot;</span>等同于<span class="string">&quot;ls -l&quot;</span>。</span><br></pre></td></tr></table></figure><p>硬链接示意图：</p><img src="/2022/img/20220610214746.png" alt="image-20220522201246373" style="zoom:50%;" /><p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中，目录的 block 中记录的是此目录下一级子文件和子目录名及对应的inode；而文件的 block 中记录的才是文件实际的数据。</p><blockquote><p>当我们查找一个文件，比如 /root/test 时，要经过以下步骤：</p><ol><li>首先找到根目录的 inode（根目录的 inode 是系统已知的，inode 号是 2），然后判断用户是否有权限访问根目录的 block。</li><li>如果有权限，则可以在根目录的 block 中访问到 /root 的文件名及对应的 inode 号。</li><li>通过 /root/ 目录的 inode 号，可以查找到 /root/ 目录的 inode 信息，接着判断用户是否有权限访问 /root/ 目录的 block。</li><li>如果有权限，则可以从 /root/ 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li><li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li><li>如果有权限，则可以读取 block 中的数据，这样就完成了 /root/test 文件的读取与访问。</li></ol></blockquote><p>硬链接的特点如下：</p><ul><li>不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变。</li><li><strong>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问。只有删除源文件及所有对应的硬链接文件，文件实体才会被删除。文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</strong></li><li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li><li>硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的。11</li><li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li></ul><p><code>目录下的'.'和'..'就是硬链接</code></p><p><em><strong>软连接剖析：</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch check</span></span><br><span class="line"><span class="comment">#建立源文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /root/check  /tmp/check-soft</span></span><br><span class="line"><span class="comment">#建立软链接文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -id /root/check  /tmp/check-soft</span></span><br><span class="line">262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check</span><br><span class="line">917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -&gt; /root/check</span><br><span class="line"><span class="comment">#软链接和源文件的 inode 号不一致，软链接通过 -&gt; 明显地标识出源文件的位置</span></span><br><span class="line"><span class="comment">#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件</span></span><br></pre></td></tr></table></figure><p>软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用</p><p><strong>软链接示意图：</strong></p><img src="/2022/img/20220610214754.png" alt="image-20220522201204473" style="zoom:50%;" /><blockquote><p>软链接和硬链接在原理上最主要的不同在于：硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p></blockquote><p>软链接的特点（ Windows 中的快捷方式完全一致）。</p><ul><li>不论是修改源文件（check），还是修改硬链接文件（check-soft)，另一个文件中的数据都会发生改变。</li><li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。软链接就是Windows中的快捷方式</li><li><strong>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</strong></li><li>软链接可以链接目录。</li><li>软链接可以跨分区。</li></ul><hr><h4 id="font-color-purple-2-7-9-复制文件-目录-cp-font"><font color='purple'>2.7.9 复制文件/目录(cp)</font></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp <span class="selector-attr">[选项]</span> 源文件 目标文件</span><br></pre></td></tr></table></figure><blockquote><p>选项：</p><ul><li>-a：相当于 -d、-p、-r 选项的集合</li><li>-d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；</li><li>-i：询问，如果目标文件已经存在，则会询问是否覆盖；</li><li>-l：把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li><li>-s：把目标文件建立为源文件的软链接文件，而不是复制源文件；</li><li>-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；</li><li>-r：递归复制，用于复制目录；</li><li>-u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li></ul><p><code>无论是复制软链接还是硬链接，都不是复制源文件</code></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#建立源文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch cangls</span><br><span class="line">#把源文件不改名复制到 /tmp/ 目录下</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls  /tmp/</span><br><span class="line">###########################################</span><br><span class="line">#改名复制</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls  /tmp/bols</span><br></pre></td></tr></table></figure><ul><li>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为<code>cp 命令默认执行的是“cp -i”的别名</code>，例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp cangls /tmp/</span><br><span class="line">cp:是否覆盖<span class="string">&quot;/tmp/cangls&quot;</span>?y</span><br><span class="line">#目标位置有同名文件，所以会提示是否覆盖</span><br></pre></td></tr></table></figure><ul><li><p><code>如果在复制软链接文件时不使用 &quot;-d&quot; 选项，则 cp 命令复制的是源文件，而不是软链接文件；只有加入了 &quot;-d&quot; 选项，才会复制软链接文件。</code>注意，“-d” 选项对硬链接是无效的，对硬链接需要使用&quot;-l&quot;</p></li><li><p>一般而言，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span>  /tmp/</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span></span><br><span class="line">-rw-r-----<span class="number">1</span> root slocate <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span>/var/lib/mlocate/mlocate.db</span><br><span class="line">\#注意源文件的时间和所属组</span><br><span class="line">[root@localhost ~]#ll /tmp/mlocate.db</span><br><span class="line">-rw-r----- <span class="number">1</span> root root <span class="number">6</span> 月 <span class="number">14</span> <span class="number">06</span>:<span class="number">05</span>/tmp/mlocate.db</span><br><span class="line">\#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span><br></pre></td></tr></table></figure><p>而当执行备份时，这些文件的时间可能是一个重要的参数，这就需执行 “-p” 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp -<span class="selector-tag">p</span> /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span> /tmp/mlocate<span class="selector-class">.db_2</span></span><br><span class="line">\#使用&quot;-<span class="selector-tag">p</span>&quot;选项</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /<span class="selector-tag">var</span>/lib/mlocate/mlocate<span class="selector-class">.db</span> /tmp/mlocate<span class="selector-class">.db_2</span></span><br><span class="line">-rw-r----- root slocate <span class="number">2328027</span> <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span> /tmp/mlocate.db_2</span><br><span class="line">-rw-r----- root slocate <span class="number">2328027</span> <span class="number">6</span>月 <span class="number">14</span> <span class="number">02</span>:<span class="number">08</span> /var/lib/mlocate/mlocate.db</span><br><span class="line">\#源文件和目标文件的所有属性都一致，包括时间</span><br></pre></td></tr></table></figure></li><li><p><code>&quot;-a&quot; 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 &quot;-a&quot; 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。</code></p></li><li><p>如果使用 “-l” 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 “-s” 选项，则目标文件会被建立为源文件的软链接。</p><p>这两个选项和 “-d” 选项是不同的，“d” 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 “-l” 和 “-s” 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接</p></li></ul><hr><h4 id="font-color-purple-2-7-10-删除文件-目录-rm-font"><font color='purple'>2.7.10 删除文件/目录(rm)</font></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm  -<span class="selector-attr">[选项]</span> 文件或目录</span><br></pre></td></tr></table></figure><blockquote><p>选项：</p><ul><li>f：强制删除（force），和 i 选项相反，使用 f，系统将不再询问，而是直接删除目标文件或目录。</li><li>i：和 f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 i 可以有效防止不小心删除有用的文件或目录。</li><li>r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li></ul></blockquote><p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir -<span class="selector-tag">p</span> /test/lm/movie/jp</span><br><span class="line">\#重新建立测试目录</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /test</span><br><span class="line">\#强制删除，一了百了</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span><span class="selector-id">#rm</span> -rf *</span><br><span class="line">#删除/tmp/目录中的所有数据</span><br></pre></td></tr></table></figure><p><code>但是需要注意，数据强制删除之后无法恢复</code></p><p>虽然 “-rf” 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 “-rf” 选项。</p><hr><h4 id="font-color-purple-2-7-11-移动和重命名文件或目录-mv-font"><font color='purple'>2.7.11 移动和重命名文件或目录(mv)</font></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv 【选项】 源文件 目标文件</span><br></pre></td></tr></table></figure><blockquote><p>选项：</p><ul><li>-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li><li>-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）；</li><li>-n：如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li><li>-v：显示文件或目录的移动过程；</li><li>-u：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li></ul></blockquote><p><code>如果源文件和目标文件在同一目录中，那就是改名</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv bols lmls</span><br><span class="line">\#把 bols 改名为 lmls</span><br></pre></td></tr></table></figure><p>目录也可以按照同样的方法改名。</p><hr><h4 id="font-color-purple-2-7-12-命令自动补全功能-font"><font color='purple'>2.7.12 命令自动补全功能</font></h4><ul><li><p>当输入的前缀唯一时，按下Tab即可自动补全</p></li><li><p>当输入的前缀不唯一时，连续按下两次Tab，会立即显示所有同前缀的文件和目录。</p></li><li><p>shell中的通配符：</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配0或任意个字符</td></tr><tr><td>？</td><td>匹配任意 一个 字符</td></tr><tr><td>[-]</td><td>匹配中括号的字符。例如[a-b]，匹配小写字母，只会匹配集合中的 一个</td></tr><tr><td>[^]</td><td>匹配除了中括号的 一个 字符。例如<code>[^0-9]</code>，匹配除了数字的字符，只会匹配集合中的一个</td></tr><tr><td>{ab,ba}</td><td>匹配其中 一个 字符串。例如匹配ab或ba</td></tr></tbody></table></li></ul><p>举例说明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-tag">a</span>* &lt;--匹配所有以 <span class="selector-tag">a</span> 字符开头的文件名</span><br><span class="line">apple</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls g*t &lt;--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span><br><span class="line">grapefruit</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls *e* &lt;--匹配所有包含 e 字符的文件名</span><br><span class="line">apple grape grapefruit watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls *n* &lt;--匹配所有包含 n 字符的文件名</span><br><span class="line">banana watermelon</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls ????e</span><br><span class="line">apple grape</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls g???e*</span><br><span class="line">grape grapefruit</span><br></pre></td></tr></table></figure><p><code>注意，一个？只能代表一个字符！</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[abw]</span>*</span><br><span class="line">apple banana watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[agw]</span>*<span class="selector-attr">[ne]</span></span><br><span class="line">apple grape watermelon</span><br><span class="line"><span class="selector-attr">[root@localhost test]</span># ls <span class="selector-attr">[a-g]</span>*</span><br><span class="line">apple banana grape grapefruit</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-2-8-Linux命令执行过程与别名-font"><font color='gree'>2.8 Linux命令执行过程与别名</font></h3><p><strong>1）判断路径</strong></p><p>判断用户是否以绝对路径或相对路径的方式输入命令（如 /bin/ls），如果是的话直接执行。</p><p><strong>2）检查别名</strong></p><p>Linux 系统会检查用户输入的命令是否为“别名命令”。通过 alias 命令可以给现有命令自定义别名。</p><blockquote><p>例如，我们经常使用的 rm 命令，其实就是 rm -i 这个整体的别名：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#显示rm的别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># alias rm</span><br><span class="line">alias rm=&#x27;rm -<span class="selector-tag">i</span>&#x27;</span><br><span class="line">    </span><br><span class="line">#删除rm的别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># unalias rm</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm <span class="selector-tag">a</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span>#  &lt;--直接删除，不再询问</span><br><span class="line">    </span><br><span class="line">#添加别名</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># alias rm=&#x27;rm -<span class="selector-tag">i</span>&#x27;  注意单引号</span><br></pre></td></tr></table></figure></blockquote><p><strong>3）判断是外部还是内部命令</strong></p><p>Linux命令行解释器（又称为 Shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。</p><blockquote><p><strong>判断一个命令属于内部命令还是外部命令，可以使用 type 命令实现。例如：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># type pwd</span><br><span class="line">pwd is <span class="selector-tag">a</span> shell builtin &lt;-- pwd是内部命令</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># type <span class="attribute">top</span></span><br><span class="line"><span class="attribute">top</span> is /usr/bin/<span class="attribute">top</span> &lt;-- <span class="attribute">top</span>是外部命令</span><br></pre></td></tr></table></figure></blockquote><p><strong>4）查找外部命令对应的可执行文件</strong></p><p>当用户执行的是 外部命令 时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找 ，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p><blockquote><p>PATH 环境变量的改变，会直接影响 Shell 查找 Linux 命令的过程。</p></blockquote><hr><h3 id="font-color-gree-2-9-Linux环境变量-font"><font color='gree'>2.9 Linux环境变量</font></h3><ul><li><p><strong>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数</strong>，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。 环境变量一般大写</p><p><code>当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到 PATH 中指定的路径去找。</code></p></li><li><p>可以使用 <code>env</code> 命令来查看到 Linux 系统中所有的环境变量，执行命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># env</span><br><span class="line">ORBIT_SOCKETDIR=/tmp/orbit-root</span><br><span class="line">HOSTNAME=livecd<span class="selector-class">.centos</span></span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE_PID=<span class="number">2065</span></span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>可使用<code>echo</code>命令来查看 HOME 变量在不同用户身份下都有哪些值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo $HOME</span><br><span class="line">/root</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># su - user1  &lt;--切换到 user1 用户身份</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ echo $HOME</span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure></li><li><p>Linux中重要的环境变量：</p><table><thead><tr><th>环境变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（也称家目录）</td></tr><tr><td>SHELL</td><td>用户使用的 Shell 解释器名称</td></tr><tr><td>PATH</td><td>定义命令行解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本解释器</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr></tbody></table></li><li><p>环境变量由固定的变量名与用户或系统设置的变量值两部分组成，可自行创建环境变量来满足工作需求。例如，设置一个名称为 WORKDIR 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir /home/work1</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># WORKDIR=/home/work1</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure><p>需要注意，上面自定义的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost work1]</span># su user1  &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ echo $WORKDIR</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ exit &lt;--退出user1身份</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># export WORKDIR</span><br><span class="line"><span class="selector-attr">[root@localhost work1]</span># su user1</span><br><span class="line"><span class="selector-attr">[user1@localhost ~]</span>$ cd $WORKDIR</span><br><span class="line"><span class="selector-attr">[user1@localhost work1]</span>$ pwd</span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure></li><li><p>Linux PATH环境变量</p><p>首先了解一下 which 命令，它用于<code>查找某个命令</code>所在的绝对路径。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># which rm</span><br><span class="line">/bin/rm</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># which rmdir</span><br><span class="line">/bin/rmdir</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># which ls</span><br><span class="line">alias ls=&#x27;ls <span class="attr">--color</span>=auto&#x27;</span><br><span class="line">        /bin/ls</span><br></pre></td></tr></table></figure><p>由上可见命令所在的路径。那么为什么在使用 rm、rmdir、ls 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？这便是 PATH 环境变量在起作用。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin</span><br></pre></td></tr></table></figure><p>echo 命令用来输出 PATH 环境变量的值（这里的 $ 是 PATH 的前缀符号），PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开 。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻(根据用户权限)该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。</p></blockquote><p>如果将 ls 命令移动到 /root 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 ls 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 No such file or directory，示例命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv /bin/ls /root</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">bash: /bin/ls: No such file or directory</span><br></pre></td></tr></table></figure><p>此时，如果仍想使用 ls 命令，有 2 种方法， 一种是直接将 /root 添加到 PATH 环境变量中 ，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># PATH=$PATH:/root</span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install.org Templates</span><br></pre></td></tr></table></figure><blockquote><p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，$PATH 就恢复成了默认值。</p></blockquote><p>另一种方法是 以绝对路径的方式使用此命令 ，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># /root/ls</span><br><span class="line">Desktop    Downloads    Music    post-install     Public    Videos</span><br><span class="line">Documents  ls           Pictures post-install<span class="selector-class">.org</span> Templates</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="font-color-orange-3-Linux打包和压缩-font"><font color='orange'>3. Linux打包和压缩</font></h2><h3 id="font-color-gree-3-1-打包命令-tar-font"><font color='gree'>3.1 打包命令(tar)</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#tar</span> <span class="selector-attr">[选项]</span>  包名  源文件或目录</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>将多个文件或目录进行打包。</td></tr><tr><td>-A</td><td>追加 tar 文件到归档文件。</td></tr><tr><td>-f 包名</td><td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td></tr><tr><td>-v</td><td>显示(解)打包文件过程；</td></tr><tr><td>-z</td><td>压缩和解压缩 “.tar.gz” 格式；</td></tr><tr><td>-j</td><td>压缩和解压缩 &quot;.tar.bz2&quot;格式。</td></tr><tr><td>-x</td><td>对 tar 包做解打包操作。</td></tr><tr><td>-t</td><td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td></tr><tr><td>-C 目录名</td><td>指定解打包位置。</td></tr></tbody></table><p>使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># tar -cvf test<span class="selector-class">.tar</span> ship shit</span><br><span class="line">ship/</span><br><span class="line">shit/</span><br><span class="line">shit/wuwu/</span><br></pre></td></tr></table></figure><p>选项 “-cvf” 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 “.tar” 作为扩展名。打包目录也是如此：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -zcvf tmp<span class="selector-class">.tar</span><span class="selector-class">.gz</span>  /tmp/</span><br><span class="line">#把/temp/目录直接打包压缩为&quot;<span class="selector-class">.tar</span><span class="selector-class">.gz</span>&quot;格式</span><br></pre></td></tr></table></figure><blockquote><p>除了直接用tar命令进行打包压缩，也可先用tar打包，在用命令<code>gzip</code>进行压缩。 但这样的话，就不能直接对目录进行压缩，须先打包再压缩.</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -xvf anaconda-ks<span class="selector-class">.cfg</span><span class="selector-class">.tar</span> </span><br><span class="line">#解打包到当前目录下</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tar -xvf test<span class="selector-class">.tar</span> -C /tmp</span><br><span class="line">#把文件包test<span class="selector-class">.tar</span>解打包到/tmp/目录下</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-purple-3-2-解压-压缩zip文件-font"><font color='purple'>3.2 解压/压缩zip文件</font></h3><ul><li><p>压缩</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#zip</span> <span class="selector-attr">[选项]</span> 压缩包名 源文件或源目录列表</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td>-m</td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td>-v</td><td>显示详细的压缩过程信息。</td></tr><tr><td>-q</td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td>-压缩级别</td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td>-u</td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zip ana<span class="selector-class">.zip</span> anaconda-ks<span class="selector-class">.cfg</span></span><br><span class="line">adding: anaconda-ks.cfg (deflated <span class="number">37%</span>)</span><br><span class="line">#单个文件压缩</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zip test<span class="selector-class">.zip</span> install<span class="selector-class">.log</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line">adding: install.log (deflated <span class="number">72%</span>)</span><br><span class="line">adding: install.log.syslog (deflated <span class="number">85%</span>)</span><br><span class="line">#同时压缩多个文件到test.zip压缩包中</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># unzip <span class="selector-attr">[选项]</span> 压缩包名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d 目录名</td><td>将压缩文件解压到指定目录下。</td></tr><tr><td>-n</td><td>解压时并不覆盖已经存在的文件。</td></tr><tr><td>-o</td><td>解压时覆盖已经存在的文件，并且无需用户确认。</td></tr><tr><td>-v</td><td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td></tr><tr><td>-t</td><td>测试压缩文件有无损坏，但并不解压。</td></tr><tr><td>-x 文件列表</td><td>解压文件，但不包含文件列表中指定的文件。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># unzip -d /tmp/ ana<span class="selector-class">.zip</span></span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line">#把压缩包解压到指定位置</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="font-color-purple-3-3-解压-压缩gzip文件-font"><font color='purple'>3.3 解压/压缩gzip文件</font></h3><ul><li><p>&quot;gzip&quot;中的’g’代表&quot;gnu&quot;中的’g’。</p></li><li><p>gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。</p></li><li><p><strong>压缩文件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>将压缩数据输出到标准输出中，并保留源文件。</td></tr><tr><td>-d</td><td>对压缩文件进行解压缩。</td></tr><tr><td>-r</td><td>递归压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td>-v</td><td>对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td></tr><tr><td>-l</td><td>对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。</td></tr><tr><td>-数字</td><td>用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip install<span class="selector-class">.log</span></span><br><span class="line">#压缩instal<span class="selector-class">.log</span> 文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">anaconda-ks<span class="selector-class">.cfg</span> install<span class="selector-class">.log</span><span class="selector-class">.gz</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line">#压缩文件生成，但是源文件也消失了</span><br></pre></td></tr></table></figure><p>在使用 gzip 命令直接压缩文件时，源文件会消失，从而生成压缩文件。用<code>-c</code>可重定向，以保留源文件 ，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-attr">[root@localhost ~]</span># gzip -c test &gt; test<span class="selector-class">.gz</span></span><br><span class="line">  \#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span><br></pre></td></tr></table></figure><p><font color='red'>注意：<code>gzip</code>命令不能将多个文件压缩到一个.gz文件中！</font>Linux中很多压缩程序只能针对一个文件进行压缩，所以当要压缩一大堆文件时，得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩。 所以一定要区分压缩和打包两个概念</p></li><li><p><strong>解压缩</strong></p><p>对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gunzip <span class="selector-attr">[选项]</span> 文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>递归处理，解压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td>-c</td><td>把解压缩后的文件输出到标准输出设备。</td></tr><tr><td>-f</td><td>强制解压缩文件，不理会文件是否已存在等情况。</td></tr><tr><td>-l</td><td>列出压缩文件内容。</td></tr><tr><td>-v</td><td>显示命令执行过程。</td></tr><tr><td>-t</td><td>测试压缩文件是否正常，但不对其做解压缩操作。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gunzip install<span class="selector-class">.log</span><span class="selector-class">.gz</span></span><br><span class="line">#解压一个文件</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># ls </span><br><span class="line">aha<span class="selector-class">.gz</span>  wuwu<span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># gunzip -r .</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM test0]</span># ls</span><br><span class="line">aha  wuwu</span><br></pre></td></tr></table></figure><p><font color='red'>注意：-r 是对目标目录中的所有.gz文件进行解压。每个.gz文件都只包含一个文件！</font></p><p>除了<code>gunzip</code>命令，<code>gzip-d</code>也可以对g.gzip文件进行解压：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gzip -d test<span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用 <code>zcat</code> 命令在不解压缩的情况下查看这个文本文件中的内容。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># zcat anaconda-ks<span class="selector-class">.cfg</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="font-color-gree-3-4-压缩-解压缩bzip2文件-font"><font color='gree'>3.4 压缩/解压缩bzip2文件</font></h3><ul><li><p>压缩</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bzip2 <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。</td></tr><tr><td>-k</td><td>bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。</td></tr><tr><td>-f</td><td>bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。</td></tr><tr><td>-t</td><td>测试压缩包文件的完整性。</td></tr><tr><td>-v</td><td>压缩或解压缩文件时，显示详细信息。</td></tr><tr><td>-数字</td><td>这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高</td></tr></tbody></table><p>注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。</p></li><li><p>解压</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bunzip2 <span class="selector-attr">[选项]</span> 源文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-k</td><td>解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。</td></tr><tr><td>-f</td><td>解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。</td></tr><tr><td>-v</td><td>显示命令执行过程。</td></tr><tr><td>-L</td><td>列出压缩文件内容。</td></tr></tbody></table><p>“.bz2” 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># bzcat install<span class="selector-class">.log</span><span class="selector-class">.syslog</span><span class="selector-class">.bz2</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="font-color-orange-4-vim编辑器-font"><font color='orange'>4. vim编辑器</font></h2><h3 id="font-color-gree-4-1-vim的三种模式-font"><font color='gree'>4.1 vim的三种模式</font></h3><ul><li><p><code>命令模式</code></p><p>使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。</p></li><li><p><code>输入模式</code></p><p>进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令，当编辑文件完成后按 Esc 键即可返回命令模式。</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>i</td><td>在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动</td></tr><tr><td>I</td><td>在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令</td></tr><tr><td>o</td><td>在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本</td></tr><tr><td>O</td><td>在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本</td></tr><tr><td>a</td><td>在当前光标所在位置之后插入随后输入的文本</td></tr><tr><td>A</td><td>在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令</td></tr></tbody></table></li><li><p><code>编辑模式</code></p><p>编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。</p><blockquote><p>指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。</p></blockquote></li></ul><hr><h3 id="font-color-gree-4-2-vim的基本操作-font"><font color='gree'>4.2 vim的基本操作</font></h3><ul><li><p>vim打开文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@itxdl ~]</span># vim /test/vi<span class="selector-class">.test</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Vi 使用的选项</th><th>说 明</th></tr></thead><tbody><tr><td>vim filename</td><td>打开或新建一个文件，并将光标置于第一行的首部</td></tr><tr><td>vim -r filename</td><td>恢复上次 vim 打开时崩溃的文件</td></tr><tr><td>vim -R filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>vim + filename</td><td>打开文件，并将光标置于最后一行的首部</td></tr><tr><td>vi +n filename</td><td>打开文件，并将光标置于第 n 行的首部</td></tr><tr><td>vi +/pattern filename</td><td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td></tr><tr><td>vi -c command filename</td><td>在对文件进行编辑前，先执行指定的命令</td></tr></tbody></table></li><li><p>vim查找文本</p><table><thead><tr><th>/abc</th><th>从前往后查找字符串abc</th></tr></thead><tbody><tr><td>/^abc</td><td>查找以 abc 为行首的行</td></tr><tr><td>/abc$</td><td>查找以 abc 为行尾的行</td></tr><tr><td>?abc</td><td>从后往前查找字符串abc</td></tr><tr><td>n</td><td>向同一方向继续查找下一个</td></tr><tr><td>N</td><td>向相反方向继续查找上一个</td></tr></tbody></table><p>注意：是在命令模式下输入’:'后再输入以上命令。</p><p>如果想忽略大小写，则输入命令 “:set ic”；调整回来输入&quot;:set noic&quot;。</p><p><code>如果在字符串中出现特殊符号，则需要加上转义字符 &quot;\&quot;。常见的特殊符号有 \、*、?、$ 等。如果出现这些字符，例如，要查找字符串 &quot;10$&quot;，则需要在命令模式中输入 &quot;/10\$&quot;。</code></p><p><font color='red'>查找完后，要取消高亮显示，使用命令<code>:noh</code>即可</font></p></li><li><p>vim替换文本</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>r</td><td>替换光标所在位置的字符</td></tr><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td>:s/a1/a2/g</td><td>将当前光标所在行中的所有 a1 用 a2 替换</td></tr><tr><td>:$s/a1/a2/g或:%s/a1/a2/g</td><td>将文件中所有的 a1 都用 a2 替换</td></tr><tr><td>:n1,n2 s/a1/a2/g</td><td>将文件中n1到n2行中所有a1都用a2替换</td></tr></tbody></table></li><li><p>vim删除文本</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>x</td><td>删除光标所在位置的字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除当前行（包括此行）后 n 行文本</td></tr><tr><td>dG</td><td>删除光标所在行一直到文件末尾的所有内容</td></tr><tr><td>D</td><td>删除光标位置到行尾的内容</td></tr><tr><td>:a1,a2d</td><td>函数从 a1 行到 a2 行的文本内容</td></tr></tbody></table><p>被删除的内容存在剪切板中</p></li><li><p>复制文本</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>p</td><td>将剪贴板中的内容粘贴到光标后</td></tr><tr><td>P（大写）</td><td>将剪贴板中的内容粘贴到光标前</td></tr><tr><td>y</td><td>复制已选中的文本到剪贴板</td></tr><tr><td>yy</td><td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td></tr><tr><td>yw</td><td>将光标位置的单词复制到剪贴板</td></tr></tbody></table></li><li><p>退出并保存</p><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出 Vim 编辑器</td></tr><tr><td>:wq!</td><td>保存并强制退出 Vim 编辑器</td></tr><tr><td>:q</td><td>不保存就退出 Vim 编辑器</td></tr><tr><td>:q!</td><td>不保存，且强制退出 Vim 编辑器</td></tr><tr><td>:w</td><td>保存但是不退出 Vim 编辑器</td></tr><tr><td>:w!</td><td>强制保存文本</td></tr><tr><td>:w filename</td><td>另存到 filename 文件</td></tr><tr><td>:x！</td><td>保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令</td></tr><tr><td>ZZ</td><td>直接退出 Vim 编辑器</td></tr></tbody></table></li><li><p>光标移动快捷键汇总</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>h</td><td>光标向左移动一位</td></tr><tr><td>j</td><td>光标向下移动一行（以回车为换行符），也就是光标向下移动</td></tr><tr><td>k</td><td>光标向上移动一行（也就是向上移动）</td></tr><tr><td>l</td><td>光标向右移动一位</td></tr></tbody></table><table><thead><tr><th>w 或 W</th><th>光标移动至下一个单词的单词首</th></tr></thead><tbody><tr><td>b 或 B</td><td>光标移动至上一个单词的单词首</td></tr><tr><td>e 或 E</td><td>光标移动至下一个单词的单词尾</td></tr><tr><td>nw 或 nW</td><td>n 为数字，表示光标向右移动 n 个单词</td></tr><tr><td>nb 或 nB</td><td>n 为数字，表示光标向左移动 n 个单词</td></tr></tbody></table><table><thead><tr><th>快捷键</th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>0 或 ^</td><td>光标移动至当前行的行首</td></tr><tr><td>$</td><td>光标移动至当前行的行尾</td></tr><tr><td>n$</td><td>光标移动至当前行只有 n 行的行尾，n为数字</td></tr></tbody></table><table><thead><tr><th>fx</th><th>光标移动至当前行中下一个 x 字符处</th></tr></thead><tbody><tr><td>Fx</td><td>光标移动至当前行中下一个 x 字符处</td></tr></tbody></table><table><thead><tr><th>gg</th><th>光标移动到文件开头</th></tr></thead><tbody><tr><td>G</td><td>光标移动至文件末尾</td></tr><tr><td>nG</td><td>光标移动到第 n 行，n 为数字</td></tr><tr><td>:n</td><td>编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首</td></tr></tbody></table><table><thead><tr><th>%</th><th>当光标位置在一对{}中的一个半括号时，按%键可以瞬间跳到另一个半括号上</th></tr></thead></table><table><thead><tr><th>u（小写）</th><th>undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。</th></tr></thead><tbody><tr><td>Ctrl+R</td><td>Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。</td></tr><tr><td>U（大写）</td><td>第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。</td></tr></tbody></table></li></ul><hr><h3 id="font-color-gree-4-3-vim可视化模式-font"><font color='gree'>4.3 vim可视化模式</font></h3><p>在 Vim 中，如果想选中目标文本，就需要调整 Vim 进入可视化模式</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>v（小写）</td><td>又称字符可视化模式，此模式下目标文本的选择是以字符为单位的，也就是说，该模式下要一个字符一个字符的选中要操作的文本。</td></tr><tr><td>V（大写）</td><td>又称行可视化模式，此模式化目标文本的选择是以行为单位的，也就是说，该模式化可以一行一行的选中要操作的文本。</td></tr><tr><td>Ctrl+v（组合键）</td><td>又称块可视化模式，该模式下可以选中文本中的一个矩形区域作为目标文本，以按下 Ctrl+v 位置作为矩形的一角，光标移动的终点位置作为它的对角。</td></tr></tbody></table><p>可视化模式支持使用的命令</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>d</td><td>删除选中的部分文本。</td></tr><tr><td>D</td><td>删除选中部分所在的行，和 d 不同之处在于，即使选中文本中有些字符所在的行没有都选中，删除时也会一并删除。</td></tr><tr><td>y</td><td>将选中部分复制到剪贴板中。</td></tr><tr><td>p（小写）</td><td>将剪贴板中的内容粘贴到光标之后。</td></tr><tr><td>P（大写）</td><td>将剪贴板中的内容粘贴到光标之前。</td></tr><tr><td>u（小写）</td><td>将选中部分中的大写字符全部改为小写字符。</td></tr><tr><td>U（大写）</td><td>将选中部分中的小写字符全部改为大写字符。</td></tr><tr><td>&gt;</td><td>将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td></tr><tr><td>&lt;</td><td>将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）。</td></tr></tbody></table><h3 id="font-color-gree-4-4-vim多窗口编辑模式-font"><font color='gree'>4.4 vim多窗口编辑模式</font></h3><p>可以使用 Vim 同时打开两个文件，每个文件分别占用一个窗口。</p><ol><li>先使用 Vim 打开第一个文件，接着输入命 令 <code>:sp/xx/xx</code> 水平切分窗口，然后按回车键；如果想垂直切分窗口则可以输入 <code>:vs/xx/xx</code>;</li><li>可以直接执行命令<code>vim -o</code> 第一个文件名 第二个文件名&quot;，也就是 “vim-o /etc/passwd /etc/shadow”。2</li></ol><p><code>切换到另一个文件窗口，可以按 &quot;Ctrl+WW&quot; 快捷键。</code></p><p><code>如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 &quot;:r 被复制的文件名&quot;，即可将导入文件的全部内容复制到当前光标所在行下面。</code></p><hr><h3 id="font-color-gree-4-5-vim批量注释和自定义注释快捷键-font"><font color='gree'>4.5 vim批量注释和自定义注释快捷键</font></h3><ul><li><p><code>:m,n s/^/#/g</code>表示在m~n行的行首加字符#进行注释，^表示行首。</p><p><code>:m,n s/^/\/\//g</code>表示在m~n行的行首加字符<code>\\</code>进行注释，由于\是特殊字符，所以需要转移。</p></li><li><p>上述方法只能用于删除连续的行，而对于非连续的行，就可以采用以下自定义快捷键的方式：</p><p><code>:map 快捷键 执行命令</code></p><blockquote><p>如定义快捷键 “Ctrl+P” 为在行首添加 “#” 注释，可以执行 <code>:map^P I#&lt;Esc&gt;</code>。其中 “^P” 为定义快捷键 “Ctrl+P”。 注意：必须同时按 “Ctrl+V+P” 快捷键生成 “^P” 方可有效，直接输入 “^P” 是无效的。</p><p>“I#<Esc>” 就是此快捷键要触发的动作，“I” 为在光标所在行行首插入(a表示当前字符之后)，“#” 为要输入的字符，“<Esc>” 表示退回命令模式。“<Esc>” 要逐个字符输入，不可直接按键盘上的 Esc 键。</p><p>设置成功后，直接在任意需要注释的行上按 “Ctrl+P” 快捷键，就会自动在行首加上 “#” 注释。取消此快捷键定义，输入 “:unmap^P” 即可。</p><p>有时我们写完脚本等文件，需要在末尾注释中加入自己的邮箱，则可以直接定义每次按快捷键 “Ctrl+E” 实现插入邮箱，定义方法为 “:map^E <a href="mailto:asamlee@itxdl.net">asamlee@itxdl.net</a><Esc>”。</p></blockquote></li></ul><hr><h3 id="font-color-gree-4-6-vim显示行号-font"><font color='gree'>4.6 vim显示行号</font></h3><p>在命令模式下输入<code>:set nu</code>即可显示行号，输入<code>set nonu</code>即可删除行号。</p><p>如果希望每次打开文件都默认显示行号，则可以编辑 Vim 的配置文件。每次使用 Vim 打开文件时，Vim 都会到当前 登录用户 的宿主目录中读取 <code>.vimrc</code> 文件，此文件可以对 Vim 进行一些默认配置设定。</p><p>如果 .vimrc 文件存在，就先读取其中对 Vim 的设置；否则就采取默认配置。在默认情况下，用户宿主目录中是没有此文件的，需要在当前用户的宿主目录中手工建立，如<code>vim ~/.vimrc&quot;</code>&quot;~“代表宿主目录。可以直接使用 Vim 编辑生成此文件，并在此文件中添加一行&quot;set nu”，保存并退出。之后此用户登录，每次 Vim 打开文件时，都会默认显示行号。</p><hr><h3 id="font-color-gree-4-7-vim配置文件-vimrc-font"><font color='gree'>4.7 vim配置文件(.vimrc)</font></h3><p>Vim 配置文件分为系统配置文件和用户配置文件：</p><ul><li>系统配置文件位于 Vim 的安装目录（默认路径为 /etc/.vimrc）；</li><li>用户配置文件位于主目录 ~/.vimrc，即通过执行 <code>vim ~/.vimrc</code> 命令即可对此配置文件进行合理修改。通常情况下，Vim 用户配置文件需要自己手动创建。</li></ul><p><code>注意，Vim 用户配置文件比系统配置文件的优先级高，换句话说，Vim 启动时，会优先读取 Vim 用户配置文件（位于主目录中的）！！！所以我们只需要修改用户配置文件即可（不建议直接修改系统配置文件）。</code></p><p>可在vim编辑器命令模式中输入<code>:set all</code>来查询vim提供的环境配置参数。</p><p>通过以上方式，可以对用户配置文件（~/.vimrc）进行编辑，进而实现对 Vim 的 永久自定义 。</p><hr><h3 id="font-color-gree-4-8-在vim中执行Linux命令-font"><font color='gree'>4.8 在vim中执行Linux命令</font></h3><p>在命令模式下，按下<code>!!</code>（不要按<code>:</code>），这时在窗口的左下角会出现<code>:.!</code>的提示信息，这就表明我们可以输入 Linux 命令了。</p><p>窗口左下角的<code>:.!</code>表示操作文本的范围，其中<code>.</code>表示从光标所在行开始,<code>!</code>表示后续会执行 Linux 命令，整体表示命令的执行结果将插入到光标所在行的位置，因此， 如果光标所在位置处有数据，就会被命令的执行结果直接覆盖掉 。</p><table><thead><tr><th>格式</th><th>功能</th></tr></thead><tbody><tr><td>:!命令</td><td>直接运行一个 Linux 命令，运行完毕之后，即可返回到 Vim 中。</td></tr><tr><td>:w!命令</td><td>将 Vim 中所有的文本内容作为指定命令的输入。但命令的执行结果不会写入到当前文件中。</td></tr><tr><td>:r!命令</td><td>将命令执行的结果写入到当前 Vim 中，例如 :!ls 表示将 ls 的执行结果输入到 Vim 中。</td></tr><tr><td>:nr!命令</td><td>其中 n 为数字，表示将命令的执行结果写入到 Vim 第 n 行的位置。例如，:3r!date 表示将 date 命令的执行结果写入到第 3 行文本处。</td></tr><tr><td>:n,m!命令</td><td>其中 n 表示起始行号，m为结束行号，功能是将 Vim 中指定的部分文本作为某个命令的输入，同时将命令的输出也插入到当前指定的位置。</td></tr><tr><td>:n,m w!命令</td><td>其中 n 表示起始行号，m为结束行号，其功能是 Vim 中指定的部分文本作为某个命令的输入，但命令的执行结果不会写入到文件中。</td></tr><tr><td>!!date</td><td>向 Vim 中插入当前时间。</td></tr></tbody></table><h2 id="font-color-orange-5-文本处理-font"><font color='orange'>5. 文本处理</font></h2><h3 id="font-color-gree-5-1-连接文件并打印-cat命令-font"><font color='gree'>5.1 连接文件并打印(cat命令)</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cat <span class="selector-attr">[选项]</span> 文件名   </span><br><span class="line">#用于显示文件内容</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cat 文件<span class="number">1</span> 文件<span class="number">2</span> &gt; 文件<span class="number">3</span></span><br><span class="line">#用于连接两个文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-A</td><td>相当于 -vET 选项的整合，用于列出所有隐藏符号(换行符$等)；</td></tr><tr><td>-E</td><td>列出每行结尾的回车符 $；</td></tr><tr><td>-n</td><td>打印行号</td></tr><tr><td>-b</td><td>同 -n 不同，此选项表示只对非空行进行编号。</td></tr><tr><td>-T</td><td>把 Tab 键 ^I 显示出来；</td></tr><tr><td>-V</td><td>列出特殊字符；</td></tr><tr><td>-s</td><td>当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。</td></tr></tbody></table><hr><h3 id="font-color-gree-5-2-分屏显示文件内容-more命令-font"><font color='gree'>5.2 分屏显示文件内容(more命令)</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># more <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>计算行数时，以实际的行数，而不是自动换行过后的行数。</td></tr><tr><td>-p</td><td>不以卷动的方式显示每一页，而是先清除屏幕后再显示内容。</td></tr><tr><td>-c</td><td>跟 -p 选项相似，不同的是先显示内容再清除其他旧资料。</td></tr><tr><td>-s</td><td>当遇到有连续两行以上的空白行时，就替换为一行的空白行。</td></tr><tr><td>-u</td><td>不显示下引号（根据环境变量 TERM 指定的终端而有所不同）。</td></tr><tr><td>+n</td><td>从第 n 行开始显示文件内容，n 代表数字。</td></tr><tr><td>-n</td><td>一次显示的行数，n 代表数字。</td></tr></tbody></table><table><thead><tr><th>交互指令</th><th>功能</th></tr></thead><tbody><tr><td>h 或 ？</td><td>显示 more 命令交互命令帮助。</td></tr><tr><td>q 或 Q</td><td>退出 more。</td></tr><tr><td>v</td><td>在当前行启动一个编辑器。</td></tr><tr><td>:f</td><td>显示当前文件的文件名和行号。</td></tr><tr><td>!&lt;命令&gt; 或 :!&lt;命令&gt;</td><td>在子Shell中执行指定命令。</td></tr><tr><td>回车键</td><td>向下移动一行。</td></tr><tr><td>空格键</td><td>向下移动一页。</td></tr><tr><td>Ctrl+l</td><td>刷新屏幕。</td></tr><tr><td>=</td><td>显示当前行的行号。</td></tr><tr><td>’</td><td>转到上一次搜索开始的地方。</td></tr><tr><td>Ctrf+f</td><td>向下滚动一页。</td></tr><tr><td>.</td><td>重复上次输入的命令。</td></tr><tr><td>/ 字符串</td><td>搜索指定的字符串。</td></tr><tr><td>d</td><td>向下移动半页。</td></tr><tr><td>b</td><td>向上移动一页。</td></tr></tbody></table><p>显示文件 anaconda-ks.cfg 的内容，每 10 行显示一屏，同时清楚屏幕，使用以下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># more -c -<span class="number">10</span> anaconda-ks<span class="selector-class">.cfg</span></span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-5-3-显示文件开头内容-head命令-font"><font color='gree'>5.3 显示文件开头内容(head命令)</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># head <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n K</td><td>这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 “-K” 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。</td></tr><tr><td>-c K</td><td>这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 “-K”，则表示除了文件最后 K 字节的内容，显示剩余全部内容。</td></tr><tr><td>-v</td><td>显示文件名；</td></tr></tbody></table><p>注意，如不设置显示的具体行数，则默认显示 10 行的文本数据。</p><hr><h3 id="font-color-gree-5-4-显示文件内容-less命令-font"><font color='gree'>5.4 显示文件内容(less命令)</font></h3><p>与 more 命令浏览文件内容时，只能不断向后翻看，而使用 less 命令浏览，既可以向后翻看，也可以向前翻看。</p><p>为了方面用户浏览文本内容，less 命令还提供了以下几个功能：</p><ul><li>使用光标键可以在文本文件中前后（左后）滚屏；</li><li>用行号或百分比作为书签浏览文件；</li><li>提供更加友好的检索、高亮显示等操作；</li><li>兼容常用的字处理程序（如 Vim、Emacs）的键盘操作；</li><li>阅读到文件结束时，less 命令不会退出；</li><li>屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># less <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>选项含义</th></tr></thead><tbody><tr><td>-N</td><td>显示每行的行号。</td></tr><tr><td>-S</td><td>行过长时将超出部分舍弃。</td></tr><tr><td>-e</td><td>当文件显示结束后，自动离开。</td></tr><tr><td>-g</td><td>只标志最后搜索到的关键同。</td></tr><tr><td>-Q</td><td>不使用警告音。</td></tr><tr><td>-i</td><td>忽略搜索时的大小写。</td></tr><tr><td>-m</td><td>显示类似 more 命令的百分比。</td></tr><tr><td>-f</td><td>强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td></tr><tr><td>-s</td><td>显示连续空行为一行。</td></tr><tr><td>-b &lt;缓冲区大小&gt;</td><td>设置缓冲区的大小。</td></tr><tr><td>-o &lt;文件名&gt;</td><td>将 less 输出的内容保存到指定文件中。</td></tr><tr><td>-x &lt;数字&gt;</td><td>将【Tab】键显示为规定的数字空格。</td></tr></tbody></table><table><thead><tr><th>交互指令</th><th>功能</th></tr></thead><tbody><tr><td>/字符串</td><td>向下搜索“字符串”的功能。</td></tr><tr><td>?字符串</td><td>向上搜索“字符串”的功能。</td></tr><tr><td>n</td><td>重复*前一个搜索（与 / 成 ? 有关）。</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 / 或 ? 有关）。</td></tr><tr><td>b</td><td>向上移动一页。</td></tr><tr><td>d</td><td>向下移动半页。</td></tr><tr><td>h 或 H</td><td>显示帮助界面。</td></tr><tr><td>q 或 Q</td><td>退出 less 命令。</td></tr><tr><td>y</td><td>向上移动一行。</td></tr><tr><td>空格键</td><td>向下移动一页。</td></tr><tr><td>回车键</td><td>向下移动一行。</td></tr><tr><td>【PgDn】键</td><td>向下移动一页。</td></tr><tr><td>【PgUp】键</td><td>向上移动一页。</td></tr><tr><td>Ctrl+f</td><td>向下移动一页。</td></tr><tr><td>Ctrl+b</td><td>向上移动一页。</td></tr><tr><td>Ctrl+d</td><td>向下移动一页。</td></tr><tr><td>Ctrl+u</td><td>向上移动半页。</td></tr><tr><td>j</td><td>向下移动一行。</td></tr><tr><td>k</td><td>向上移动一行。</td></tr><tr><td>G</td><td>移动至最后一行。</td></tr><tr><td>g</td><td>移动到第一行。</td></tr><tr><td>ZZ</td><td>退出 less 命令。</td></tr><tr><td>v</td><td>使用配置的编辑器编辑当前文件。</td></tr><tr><td>[</td><td>移动到本文档的上一个节点。</td></tr><tr><td>]</td><td>移动到本文档的下一个节点。</td></tr><tr><td>p</td><td>移动到同级的上一个节点。</td></tr><tr><td>u</td><td>向上移动半页。</td></tr></tbody></table><hr><h3 id="font-color-gree-5-5-显示文件结尾-tail-font"><font color='gree'>5.5 显示文件结尾(tail)</font></h3><p>tail 命令和 head 命令正好相反，它用来查看文件末尾的数据，其基本格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># tail <span class="selector-attr">[选项]</span> 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n K</td><td>这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。</td></tr><tr><td>-c K</td><td>这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。</td></tr><tr><td>-f</td><td>输出文件变化后新增加的数据。</td></tr></tbody></table><hr><h3 id="font-color-gree-5-6-Linux重定向-font"><font color='gree'>5.6 Linux重定向</font></h3><p>输入重定向：</p><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><p>一般用输出重定向较多</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ls &lt; /tmp &gt; aha</span><br><span class="line">#/tmp 的内容输出到aha文件中</span><br></pre></td></tr></table></figure><p>输出重定向：</p><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2&gt;&amp;1 是一体的，可以认为是固定写法。</td></tr></tbody></table><p>输出重定向还可以细分为标准输出重定向和错误输出重定向两种技术。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch demo1<span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -l demo1<span class="selector-class">.txt</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> root root <span class="number">0</span> Oct <span class="number">12</span> <span class="number">15</span>:<span class="number">02</span> demo1.txt   &lt;--标准输出信息</span><br><span class="line">[root@localhost ~]# ls -l demo2.txt    &lt;-- 不存在的文件</span><br><span class="line">ls: cannot access demo2.txt: No such file or directory  &lt;--错误输出信息</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-5-7-grep命令和正则表达式-font"><font color='gree'>5.7 grep命令和正则表达式</font></h3><blockquote><p><font color='red'>正则表达式</font></p><p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取<code>@</code>前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p><p>正则表达式是一种用来 =匹配字符串 的强有力的武器。它的设计思想是用一种 描述性的语言 来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p></blockquote><p>grep命令能够在一个或多个文件中，搜索 某一特定的字符模式 （也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p><p><strong>正则表达式的通配符</strong></p><table><thead><tr><th>通配符</th><th>功能</th></tr></thead><tbody><tr><td>c*</td><td>将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td></tr><tr><td>.</td><td>将匹配任何一个字符，且只能是一个字符。</td></tr><tr><td>[xyz]</td><td>匹配方括号中的任意一个字符。</td></tr><tr><td>[^xyz]</td><td>匹配除方括号中字符外的所有字符。</td></tr><tr><td>^</td><td>锁定行的开头。</td></tr><tr><td>$</td><td>锁定行的结尾。</td></tr></tbody></table><p><code>需要注意的是，在基本正则表达式中，如通配符 *、+、&#123;、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 \*、\+、\&#123;、\|、\( 和 \)。</code></p><p><strong>grep 命令的基本格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep <span class="selector-attr">[选项]</span> 模式 文件名</span><br></pre></td></tr></table></figure><blockquote><p>这里的模式，要么是字符（串），要么是正则表达式。</p></blockquote><p>详细见<a href="https://linux.cn/article-6941-1.html">grep与正则表达式</a>和<a href="https://www.runoob.com/regexp/regexp-tutorial.html">菜鸟教程-正则表达式</a></p><hr><h3 id="font-color-gree-5-8-sed命令-font"><font color='gree'>5.8 sed命令</font></h3><h2 id="font-color-orange-6-Linux软件安装-font"><font color='orange'>6. Linux软件安装</font></h2><h3 id="font-color-gree-6-1-Linux软件包-font"><font color='gree'>6.1 Linux软件包</font></h3><p>Linux下的软件包可细分为两种，分别是 源码包 和 二进制包 。</p><ul><li><p><strong>源码包</strong></p><p>源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。而因为软件是编译安装的，所以更加适合自己的系统，更加稳定，效率也高。</p><blockquote><p>源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理，Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为Tarball。</p><p>Tarball 是 Linux 系统的一款打包工具，可以对源码包进行打包压缩处理，人们习惯上将最终得到的打包压缩文件称为 Tarball 文件。</p><p>包中通常包含以下内容：</p><ul><li>源代码文件。</li><li>配置和检测程序（如 configure 或 config 等）。</li><li>软件安装说明和软件说明（如 INSTALL 或 README）。</li></ul></blockquote></li><li><p><strong>二进制包</strong></p><p>由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快，且安装过程报错几率大大减小。</p><p>二进制包是 Linux 下默认的软件安装包 。目前主要有以下 2 大主流的二进制包管理系统：</p><ul><li>RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。</li><li>DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。</li></ul></li></ul><hr><h3 id="font-color-gree-6-2-RPM包统一命名规则-font"><font color='gree'>6.2 RPM包统一命名规则</font></h3><p><strong>RPM(RedHat Package Manager)一种通过资料库管理的方式将所需要的软件安装到主机上的管理程序。</strong> RPM(Red hat Package Manage) 是事实的业界标准，是red hat开发的标准，优点是管理软件方便简单,类似于DEB包(debain组织的宝管理方式)。</p><p>Linux是通过rpm来管理和实现软件的安装、查看、删除的。</p><p>RPM 二进制包命名的一般格式如下：</p><p>包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名</p><blockquote><p>比如：<code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code></p><ul><li>注意，<code>httpd</code>是包名，而以上所有是<code>全包名</code>。包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名</li><li>2.2.15：包的版本号，版本号的格式通常为<code>主版本号.次版本号.修正号</code></li><li>15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。</li><li>el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。</li><li>centos：表示此包适用于 CentOS 系统。</li><li>i686：表示此包使用的硬件平台</li><li>rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用<code>rpm</code>命令直接安装。此外，还有以<code>src.rpm</code>作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。</li></ul></blockquote><hr><h3 id="font-color-gree-6-3-RPM包安装、卸载和升级（rpm命令）-font"><font color='gree'>6.3 RPM包安装、卸载和升级（rpm命令）</font></h3><p><em><strong>安装</strong></em></p><p>RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到如下所示的目录中。</p><table><thead><tr><th>安装路径</th><th>含 义</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，<strong>所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别）</strong></p><blockquote><p>与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 /usr/local/ 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。</p></blockquote><p>安装 RPM 的命令格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -ivh 包全名    #注意是全包名！</span><br></pre></td></tr></table></figure><p>此命令中各选项参数的含义为：</p><ul><li><code>-i</code>：安装（install）;</li><li><code>-v</code>：显示更详细的信息（verbose）;</li><li><code>-h</code>：打印 #，显示安装进度（hash）;</li></ul><blockquote><p>例如，使用此命令安装 apache 软件包，如下所示：</p><p>[root@localhost ~]# rpm -ivh <br>/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm<br>Preparing…<br>####################<br>[100%]<br>1:httpd<br>####################<br>[100%]</p><p>注意， 直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作 。</p></blockquote><p>其他安装要求（比如强制安装某软件而不管它是否有依赖性），可以通过以下选项进行调整：</p><ul><li><code>-nodeps</code>：不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强制安装，则可以使用这个选项。<font color='red'>注意，这样不检测依赖性安装的软件基本上是不能使用的</font>，所以不建议这样做。</li><li><code>-replacefiles</code>：替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报&quot;某个文件已经存在&quot;的错误，从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装。</li><li><code>-replacepkgs</code>：替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍。</li><li><code>-force</code>：强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合。</li><li><code>-test</code>：测试安装。不会实际安装，只是检测一下依赖性。</li><li><code>-prefix</code>：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。</li></ul><p><em><strong>升级</strong></em></p><p>使用如下命令即可实现 RPM 包的升级：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Uvh 包全名       #注意是全包名！</span><br></pre></td></tr></table></figure><p><code>-U</code>选项的含义是：如果该软件安装过则直接升级；若安装过则直接安装最新版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Fvh 包全名       #注意是全包名！</span><br></pre></td></tr></table></figure><p><code>-F</code>选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。</p><p><em><strong>卸载</strong></em></p><p><font color='red'>RPM 软件包的卸载要考虑包之间的依赖性</font>。例如，若先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。</p><p>如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误</p><p>卸载使用如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -e 包名         #注意是包名！</span><br></pre></td></tr></table></figure><p><code>-e</code> 选项表示卸载，也就是 erase 的首字母。</p><p>RPM 软件包的卸载命令支持使用<code>-nocteps</code>选项，即可以不检测依赖性直接卸载，但此方式不推荐使用，因为此操作很可能导致其他软件也无法使用。</p><hr><h3 id="font-color-gree-6-4-rpm命令查询软件包-font"><font color='gree'>6.4 rpm命令查询软件包</font></h3><p>rpm 命令还可用来对 RPM 软件包做查询操作，具体包括：</p><ul><li>查询软件包是否已安装；</li><li>查询系统中所有已安装的软件包；</li><li>查看软件包的详细信息；</li><li>查询软件包的文件列表；</li><li>查询某系统文件具体属于哪个 RPM 包;</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm 选项 查询对象</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li><p>查询软件包是否安装</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -<span class="selector-tag">q</span> 包名</span><br></pre></td></tr></table></figure><p>-q 表示查询，是 query 的首字母。</p><p>注意是包名！已安装的软件包只需给出包名！</p></li><li><p>查询所以已安装的软件包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa 包名</span><br></pre></td></tr></table></figure><p>还可以使用管道符查找出需要的内容，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa | grep httpd</span><br><span class="line">httpd-devel-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br><span class="line">httpd-tools-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br><span class="line">httpd-manual-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.noarch</span></span><br><span class="line">httpd-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">15</span><span class="selector-class">.el6</span><span class="selector-class">.centos</span>.<span class="number">1</span><span class="selector-class">.i686</span></span><br></pre></td></tr></table></figure><p>相比<code>rpm -q 包名</code>命令，采用这种方式可以找到含有包名的所有软件包。</p></li><li><p>查询软件包的详细信息</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qi 包名</span><br></pre></td></tr></table></figure></li><li><p>查询软件包的文件列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -ql 包名</span><br></pre></td></tr></table></figure><blockquote><p>rpm 软件包采用默认路径安装，各安装文件会分门别类安放在适当的目录文件下。使用 rpm 命令可以查询到已安装软件包中包含的所有文件及各自安装路径</p></blockquote><p>rpm 命令还可以查询未安装软件包中包含的所有文件以及打算安装的路径，命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qlp 包全名</span><br></pre></td></tr></table></figure><p>-p 选项表示查询未安装的软件包信息，是 package 的首字母。</p><p>注意，由于软件包还未安装，因此需要使用<code>“绝对路径+包全名”</code>的方式才能确定包。</p></li><li><p>查询系统文件属于哪个RPM包</p><p>rpm -ql 命令是通过软件包查询所含文件的安装路径，rpm 还支持反向查询，即查询某系统文件所属哪个 RPM 软件包。其命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qf 系统文件名</span><br></pre></td></tr></table></figure><p>比如查询命令<code>ls</code>所属的软件包：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># rpm -qf /bin/ls</span><br><span class="line">coreutils-<span class="number">8.22</span>-<span class="number">23</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure></li><li><p>查询软件包依赖关系</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qR 包名</span><br></pre></td></tr></table></figure><p>-R（大写）选项的含义是查询软件包的依赖性，是 requires 的首字母。</p><p>在此命令的基础上增加 -p 选项，即可实现查找未安装软件包的依赖性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qRp 包全名</span><br></pre></td></tr></table></figure><p>由于软件包还未安装，因此也需要使用<code>“绝对路径+包全名”</code>的方式才能确定包，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qRp /mnt/cdrom/Packages/bind-<span class="number">9.8</span>.<span class="number">2</span>-<span class="number">0.10</span><span class="selector-class">.rc1</span><span class="selector-class">.el6</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="font-color-gree-6-5-RPM包验证和数字证书-font"><font color='gree'>6.5 RPM包验证和数字证书</font></h3><p>执行 <code>rpm -qa</code> 命令可以看到，Linux 系统中装有大量的 RPM 包，且每个包都含有大量的安装文件。因此， 为了能够及时发现文件误删、误修改文件数据、恶意篡改文件内容等问题 ，Linux 提供了以下两种监控（检测）方式：</p><ul><li>RPM 包校验：其实就是 将已安装文件和 /var/lib/rpm/ 目录下的数据库内容 进行比较，确定文件内容是否被修改。</li><li>RPM 包数字证书校验：用来校验 RPM 包本身是否被修改。</li></ul><p><strong>RPM包校验</strong>：</p><p>RPM 包校验可用来判断已安装的软件包（或文件）是否被修改，此方式可使用的命令格式分为以下 3 种。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Va</span><br></pre></td></tr></table></figure><p>-Va 选项表示校验系统中已安装的所有软件包。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -V 已安装的包名</span><br></pre></td></tr></table></figure><p>-V 选项表示校验指定 RPM 包中的文件，是 verity 的首字母。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure><p>-Vf 选项表示校验某个系统文件是否被修改。</p><p>执行后无任何提示信息，表明所有用 apache 软件包安装的文件均未改动过，还和从原软件包安装的文件一样。</p><p>如果出现以下信息，则表示被修改过：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -V httpd</span><br><span class="line">S.<span class="number">5</span>...<span class="selector-class">.T</span>. c /etc/httpd/conf/httpd<span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure><blockquote><p>结果显示了文件被修改的信息。该信息可分为以下 3 部分：</p><ol><li>最前面的 8 个字符 （S.5…T）都属于验证信息，各字符的具体含义如下：</li></ol><ul><li>S：文件大小是否改变。</li><li>M：文件的类型或文件的权限（rwx）是否改变。</li><li>5：3。</li><li>D：设备的主从代码是否改变。</li><li>L：文件路径是否改变。</li><li>U：文件的属主（所有者）是否改变。</li><li>G：文件的属组是否改变。</li><li>T：文件的修改时间是否改变。</li><li>.：若相关项没发生改变，用 . 表示。</li></ul><ol start="2"><li>第九个字符属于被修改文件类型，大致可分为以下几类：<ul><li>c：配置文件（configuration file）。</li><li>d：普通文档（documentation）。</li><li>g：&quot;鬼&quot;文件（ghost file），很少见，就是该文件不应该被这个 RPM 包包含。</li><li>l：授权文件（license file）。</li><li>r：描述文件（read me）。</li></ul></li><li>被修改文件所在绝对路径（包含文件名）。</li></ol><blockquote><p>由此，S.5…T. c S.5…T. c /etc/httpd/conf/httpd.conf 表达的完整含义是：配置文件 httpd.conf 的大小、内容、修改时间被人为修改过。</p></blockquote></blockquote><p><strong>RPM数字整数验证</strong></p><p><strong>RPM 包校验方法只能用来校验已安装的 RPM 包及其安装文件，如果 RPM 包本身就被动过手脚，此方法将无法解决问题，需要使用 RPM 数字证书验证方法。</strong></p><blockquote><p>简单的理解，RPM 包校验其实就是将现有安装文件与最初使用 RPM 包安装时的初始文件进行对比，如果有改动则提示给用户，因此这种方式无法验证 RPM 包本身被修改的情况。</p></blockquote><p><font color='gree'>数字证书</font>，又称数字签名，由软件开发商直接发布。Linux 系统安装数字证书后，<font color='red'>若 RPM 包做了修改，此包携带的数字证书也会改变，将无法与系统成功匹配，软件无法安装。</font></p><p>使用数字证书验证 RPM 包的方法具有如下 2 个特点：</p><ol><li>必须找到原厂的公钥文件，然后才能进行安装。</li><li>安装 RPM 包会提取 RPM 包中的证书信息，然后和本机安装的原厂证书进行验证。如果验证通过，则允许安装；如果验证不通过，则不允许安装并发出警告。</li></ol><p>安装数字证书的命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm <span class="attr">--import</span> /efc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-<span class="number">6</span></span><br></pre></td></tr></table></figure><p>–import表示导入数字证书</p><p>数字证书安装完成后，可使用如下命令进行验证：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qa|grep gpg-pubkey</span><br><span class="line">gpg-pubkey-c105b9de-<span class="number">4</span>e0fd3a3</span><br></pre></td></tr></table></figure><p>可以看到，数字证书已成功安装。 在装有数字证书的系统上安装 RPM 包时，系统会自动验证包的数字证书，验证通过则可以安装，反之将无法安装（系统会报错） 。</p><p>数字证书本身也是一个 RPM 包 ，因此可以用 rpm 命令查询数字证书的详细信息，也可以将其卸载。</p><hr><h3 id="font-color-gree-6-6-提取RPM包-cpio-font"><font color='gree'>6.6 提取RPM包(cpio)</font></h3><p>cpio 命令用于从归档包中存入和读取文件。</p><blockquote><p>归档包，也可称为文件库，其实就是 cpio 或 tar 格式的文件，该文件中包含其他文件以及一些相关信息（文件名、访问权限等）。归档包既可以是磁盘中的文件，也可以是磁带或管道。</p></blockquote><p>cpio 命令可以看做是备份或还原命令，因为它可以将数据（文件）备份到 cpio 归档库，也可以利用 cpio 文档库对数据进行恢复。</p><p>使用 cpio 命令备份或恢复数据，需注意以下几点：</p><ul><li>使用 cpio 备份数据时如果使用的是绝对路径，那么还原数据时会自动恢复到绝对路径下并覆盖原有数据！；同理，如果备份数据使用的是相对路径，那么数据会还原到相对路径下。最好使用相对路径。</li><li>cpio 命令无法自行指定备份（或还原）的文件，需要目标文件（或目录）的完整路径才能成功读取，因此此命令常与 find 命令配合使用。</li><li>cpio 命令恢复数据时不会自动覆盖同名文件，也不会创建目录（直接解压到当前文件夹）。</li></ul><p>cpio 命令主要有以下 3 种基本模式：</p><ol><li>“-o” 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &gt; <span class="selector-attr">[文件丨设备]</span></span><br></pre></td></tr></table></figure><p>各选项含义如下：</p><ul><li>-o：copy-out模式，备份；</li><li>-v：显示备份过程；</li><li>-c：使用较新的portable format存储方式；</li><li>-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#find</span> /etc -print | cpio -ocvB &gt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">#利用find命令指定要备份/etc/目录，使用&gt;导出到etc<span class="selector-class">.cpio</span>文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># II -h etc<span class="selector-class">.cpio</span></span><br><span class="line">-rw<span class="attr">--r--r--</span>.<span class="number">1</span> root root <span class="number">21</span>M <span class="number">6</span>月<span class="number">5</span> <span class="number">12</span>:<span class="number">29</span> etc.cpio</span><br><span class="line">#etc.cpio文件生成</span><br></pre></td></tr></table></figure><ol><li><p><code>-o</code> 模式：指的是 copy-out 模式，就是把数据备份到文件库中，命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &gt; <span class="selector-attr">[文件丨设备]</span></span><br></pre></td></tr></table></figure><p>各选项含义如下：</p><ul><li>-o：copy-out模式，备份；</li><li>-v：显示备份过程；</li><li>-c：使用较新的portable format存储方式；</li><li>-B：设定输入/输出块为 5120Bytes，而不是模式的 512Bytes；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#find</span> /etc -print | cpio -ocvB &gt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">\#利用find命令指定要备份/etc/目录，使用&gt;导出到etc<span class="selector-class">.cpio</span>文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># II -h etc<span class="selector-class">.cpio</span></span><br><span class="line">-rw<span class="attr">--r--r--</span>.<span class="number">1</span> root root <span class="number">21</span>M <span class="number">6</span>月<span class="number">5</span> <span class="number">12</span>:<span class="number">29</span> etc.cpio</span><br><span class="line">\#etc.cpio文件生成</span><br></pre></td></tr></table></figure></li><li><p><code>-i</code> 模式：指的是 copy-in 模式，就是把数据从文件库中恢复，命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio 选项 &lt; <span class="selector-attr">[文件|设备]</span></span><br></pre></td></tr></table></figure><p>各选项的含义为：</p><ul><li>-i：copy-in 模式，还原；</li><li>-v：显示还原过程；</li><li>-c：较新的 portable format 存储方式；</li><li>-d：还原时自动新建目录；</li><li>-u：自动使用较新的文件覆盖较旧的文件；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cpio -idvcu &lt; /root/etc<span class="selector-class">.cpio</span></span><br><span class="line">\#还原etc的备份</span><br></pre></td></tr></table></figure><p><font color='red'>\査看一下当前目录/root/，就会发现没有生成/etc/目录。这是因为备份时/etc/目录使用的是绝对路径，所以数据直接恢复到/etc/系统目录中，而没有生成在/root/etc/目录中</font></p></li><li><p><code>-p</code> 模式：指的是复制模式，使用 -p 模式可以从某个目录读取所有文件，但并不将其备份到 cpio 库中，而是直接复制为其他文件。</p><p>例如，使用 -p 将 /boot/ 复制到 /test/boot 目录中可以执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="selector-attr">[root@localhost ~]</span># cd /tmp/</span><br><span class="line">   \#进入/tmp/目录</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span><span class="selector-id">#rm</span> -rf *</span><br><span class="line">   \#删除/tmp/目录中的所有数据</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># mkdir test</span><br><span class="line">   \#建立备份目录</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># find /boot/ -print | cpio -<span class="selector-tag">p</span> /tmp/test</span><br><span class="line">   \#备份/boot/目录到/tmp/test/目录中</span><br><span class="line">   <span class="selector-attr">[root@localhost tmp]</span># ls test/boot</span><br><span class="line">   \#在/tmp/test/目录中备份出了/boot/目录</span><br></pre></td></tr></table></figure></li></ol><p><em><strong>使用 cpio 命令提取 RPM 包中指定文件</strong></em></p><p>在服务器使用过程，如果系统文件被误修改或误删除，<strong>可以考虑使用 cpio 命令提取出原 RPM 包中所需的系统文件，从而修复被误操作的源文件</strong>。</p><p>RPM 包允许逐个提取包中文件，使用的命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm2cpio 包全名|cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure><blockquote><p>该命令中，rpm2cpio 就是将 RPM 包转换为 cpio 格式（rpm to(two) cpio）的命令，通过 cpio 命令即可从 cpio 文件库中提取出指定文件。</p></blockquote><p>举个例子，假设我们不小心把 /bin/ls 命令删除了，通常有以下 2 种方式修复：</p><ol><li>将 coreutils-8.4-19.el6.i686 包（包含 ls 命令的 RPM 包）通过 -f 选项再安装一遍；</li><li>使用 cpio 命令从 coreutils-8.4-19.el6.i686 包中提取出 /bin/ls 文件，然后将其复制到相应位置；</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -qf /bin/ls</span><br><span class="line">coreutils-<span class="number">8.4</span>-<span class="number">19</span><span class="selector-class">.el6</span><span class="selector-class">.i686</span></span><br><span class="line">#查看ls文件属于哪个软件包</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># mv /bin/ls /root/</span><br><span class="line">#把/bin/ls命令移动到/root/目录下，造成误删除的假象</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls</span><br><span class="line">-bash: ls: command not found</span><br><span class="line">#这时执行ls命令，系统会报<span class="string">&quot;命令没有找到&quot;</span>错误</span><br><span class="line">[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-<span class="number">8.4</span>-<span class="number">19</span>.el6.i686.rpm</span><br><span class="line">|cpio -idv ./bin/ls</span><br><span class="line">#提取ls命令文件到当前目录下</span><br><span class="line">[root@localhost ~]# cp /root/bin/ls /bin/</span><br><span class="line">#把提取出来的ls命令文件复制到/bin/目录下</span><br><span class="line">[root@localhost ~]#ls</span><br><span class="line">anaconda-ks.cfg bin inittab install.log install.log.syslog ls</span><br><span class="line">#可以看到，ls命令又可以正常使用了</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-6-7-SRPM源码包-font"><font color='gree'>6.7 SRPM源码包</font></h3><p>SRPM 包中不再是经过编译的二进制文件，都是源代码文件。</p><p>RPM 包与 SRPM 包的几点不同：</p><table><thead><tr><th>文件格式</th><th>文件名格式</th><th>直接安装与否</th><th>内含程序类型</th><th>可否修改参数并编译</th></tr></thead><tbody><tr><td>RPM</td><td>xxx.rpm</td><td>可</td><td>已编译</td><td>不可</td></tr><tr><td>SRPM</td><td>xxx.src.rpm</td><td>不可</td><td>未编译的源代码</td><td>可</td></tr></tbody></table><p>SRPM 包是未经编译的源码包，无法直接用来安装软件，需要经过以下 2 步：</p><ol><li>将 SRPM 包编译成二进制的 RPM 包；</li><li>使用编译完成的 RPM 包安装软件；</li></ol><p>而使用 SRPM 包安装软件（编译 SRPM 包）的方式有以下 2 种：</p><ol><li><p>利用 <code>rpmbuild</code> 命令可以直接使用 SRPM 包安装软件，也可以先将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</p><blockquote><p><code>rpmbuild</code>命令需要安装才能使用</p></blockquote></li><li><p>利用 *.spec 文件可实现将 SRPM 包编译成 RPM 包，再使用 RPM 包安装软件；</p></li></ol><p><strong>利用rpmbuilt命令安装：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpmbuild <span class="selector-attr">[选项]</span> 包全名</span><br></pre></td></tr></table></figure><p>可使用如下 2 个选项：</p><ul><li>-rebuild：编译 SRPM 包生成 RPM 二进制包；</li><li>-recompile：编译 SRPM 包，同时安装。</li></ul><p>注意，SRPM 本质上仍属于 RPM 包，所以安装时仍需考虑包之间的依赖性，要先安装它的依赖包，才能正确安装。</p><p><font color='cornflowerblue'>SRPM 包编译完成后，会在当前目录生成 rpmbuild 目录，整个编译过程生成的文件（软件包）都存在这里。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls /root/rpmbuild/</span><br><span class="line">BUILD RPMS SOURCES SPECS SRPMS</span><br></pre></td></tr></table></figure><table><thead><tr><th>文件名</th><th>文件内容</th></tr></thead><tbody><tr><td>BUILD</td><td>编译过程中产生的数据保存位置</td></tr><tr><td>RPMS</td><td>编译成功后，生成的 RPM 包保存位置</td></tr><tr><td>SOURCES</td><td>从 SRPM 包中解压出来的源码包（*.tar.gz）保存位置</td></tr><tr><td>SPECS</td><td>生成的设置文件的安装位置。第二种安装方法就是利用这个文件进行安装的</td></tr><tr><td>SRPMS</td><td>放置 SRPM 包的位置</td></tr></tbody></table><p>实际上，使用 rpmbuild命令编译 SRPM 包经历了以下 3 个过程：</p><ol><li>先把 SRPM 包解开，得到源码包；</li><li>对源码包进行编译，生成二进制文件；</li><li>把二进制文件重新打包生成 RPM 包。</li></ol><p><em><em>利用</em>.spec文件安装：</em>*</p><p>想利用 .spec 文件安装软件，需先将 SRPM 包解开。当然，我们可以使用 rpmbuild 命令解开 SRPM 包，但这里选择另一种方式，即使用 <code>rpm -i</code> 命令，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpm -<span class="selector-tag">i</span> httpd-<span class="number">2.2</span>.<span class="number">15</span>-<span class="number">5</span><span class="selector-class">.el6</span><span class="selector-class">.src</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><p><font color='red'>-i 选项用于安装 rpm 包时表示安装，但对于 SRPM 包的安装来说，这里只会将 .src.rpm 包解开后将个文件放置在当前目录下的 rpmbuild 目录中，并不涉及安装操作。</font></p><p><font color='red'>通过此命令，也可以在当前目录下生成 rpmbuild 目录，但与rpmrebuild命令不同，此 rpmbuild 目录中仅有 SOURCES 和 SPECS 两个子目录。其中，SOURCES 目录中放置的是源码，SPECS 目录中放置的是设置文件。</font></p><p>然后使用 SPECS 目录中的设置文件生成 RPM 包，命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rpmbuild -ba /root/rpmbuild/SPECS/httpd<span class="selector-class">.spec</span></span><br></pre></td></tr></table></figure><p>其中，-ba 选项的含义是编译，会同时生成 RPM 二进制包和 SRPM 源码包。还可以使用 -bb 选项用来仅生成 RPM 二进制包。</p><p>命令执行完成，会在 /root/rpmbuild/ 目录下生成 BUILD、RPMS和 SRPMS 目录，RPM 包放在 RPMS 目录中，SRPM 包生成在 SRPMS 目录中。</p><hr><h3 id="font-color-gree-6-8-重建RPM数据库-font"><font color='gree'>6.8 重建RPM数据库</font></h3><p><font color='red'>安装到系统中的各 RPM 包，其必要信息都会保存到 RPM 数据库中，以便用户使用 rpm 命令对软件包执行查询、安装和卸载等操作。</font></p><p>若RPM包在升级过程被强行退出、RPM 包安装意外中断等误操作，都可能使 RPM 数据库出现故障，后果是当安装、删除、査询软件包时，请求无法执行。</p><p>这时就需要重建 RPM 数据库，执行如下 2 步操作：</p><ol><li><p>删除当前系统中已损坏的RPM数据库，执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -f /<span class="selector-tag">var</span>/lib/rpm/_db.*</span><br></pre></td></tr></table></figure></li><li><p>重建 RPM 数据库，执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost -]</span># rpm -rebuilddb</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="font-color-gree-6-9-RPM包的依赖性及其解决方案-font"><font color='gree'>6.9 RPM包的依赖性及其解决方案</font></h3><p>Linux 系统中，RPM 包之间的依赖关系大致可分为以下 3 种：</p><ol><li>树形依赖（A-B-C-D） ：要想安装软件 A，必须先安装 B，而安装 B 需要先安装 C…….解决此类型依赖的方法是从后往前安装，即先安装 D，再安装 C，然后安装 B，最后安装软件 A。</li><li>环形依赖（A-B-C-D-A） ：各个软件安装的依赖关系构成“环状”。解决此类型依赖的方法是用一条命令同时安装所有软件包，即使用 <code>rpm -ivh 软件包A 软件包B ...</code>。</li><li>模型依赖 ：软件包的安装需要借助其他软件包的某些文件（比如库文件），解决模块依赖最直接的方式是通过 <a href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站找到包含此文件的软件包，安装即可。</li></ol><p>以上 3 种 RPM 包的依赖关系，给出的解决方案都是手动安装，比较麻烦。一般使用yum 命令进行查询、安装、升级和卸载软件包</p><blockquote><p>yum，全称&quot;Yellow dog Updater,Modified&quot;，CentOS 系统上的软件包管理器，它能够自动下载 RPM 包并安装，更重要的是，它可以自动处理软件包之间的依赖性关系，一次性安装所有依赖的软件包，无需一个个安装。</p></blockquote><hr><h3 id="6-10-font-color-gree-yum原配置-font">6.10 <font color='gree'>yum原配置</font></h3><p>使用 SRPM 源码包和 RPM 二进制包来安装软件都比较繁琐，需要手动解决包之间具有依赖性的问题，尤其是库文件依赖，需要自行去 <a href="http://www.rpmfind.net/">http://www.rpmfind.net</a> 网站上查找相关的 RPM 包。而yum可以自动解决以上问题。</p><p><code>yum</code>，全称“Yellow dog Updater, Modified”， 是一个专门为了解决包的依赖关系而存在的软件包管理器 。就好像 Windows 系统上可以通过软件管家实现软件的一键安装、升级和卸载，Linux 系统也提供有这样的工具，就是 yum。</p><p>yum是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。<font color='orange'>yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。</font>1</p><p>使用 yum 安装软件包之前，需指定好 yum 下载 RPM 包的位置，此位置称为 yum 源。换句话说，yum 源指的就是软件安装包的来源 。</p><p>使用 yum 安装软件时至少需要一个 yum 源。yum 源既可以使用 网络 yum 源 ，也可以将 本地光盘作为 yum 源 。</p><hr><p>###<font color='gree'>6.11 yum命令</font></p><ul><li><p><strong>查询命令</strong></p><ul><li><code>yum list</code>：查询所有已安装和可安装的软件包</li><li><code>yum list 包名</code>：查询执行软件包的安装情况</li><li><code>yum search 关键字</code>：从 yum 源服务器上查找与关键字相关的所有软件包。</li><li><code>yum info 包名</code>：查询执行软件包的详细信息。</li></ul></li><li><p><strong>安装命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost yum.repos.d]</span># yum -y install 包名</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>install：表示安装软件包。</li><li>-y：自动回答 yes。如果不加 -y，那么每个安装的软件都需要手工回答 yes；</li></ul></li><li><p><strong>升级命令</strong></p><p>使用 yum 升级软件包，需确保 yum 源服务器中软件包的版本比本机安装的软件包版本高。</p><ul><li><code>yum -y update</code>：升级所有软件包。不过考虑到服务器强调稳定性，因此该命令并不常用。</li><li><code>yum -y update 包名</code>：升级特定的软件包。</li></ul></li><li><p><strong>卸载命令</strong></p><p>*** 使用 yum 卸载软件包时，会同时卸载所有与该包有依赖关系的其他软件包，即便有依赖包属于系统运行必备文件，也会被 yum 无情卸载，带来的直接后果就是使系统崩溃。 ***</p><p>除非能确定卸载此包以及它的所有依赖包不会对系统产生影响，否则不要使用 yum 卸载软件包。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost yum.repos.d]</span># yum remove 包名</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="font-color-gree-6-12-yum管理软件组-font"><font color='gree'>6.12 yum管理软件组</font></h3><p>软件组指功能相对集中的软件包集合。例如，Linux图形界面软件组（X Window System 和 Desktop）。</p><ul><li><p>查询软件组包含的软件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> groupinfo &quot;软件组名&quot;</span><br></pre></td></tr></table></figure><p>注意，软件组名需要加引号！</p></li><li><p>安装软件组：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> groupinstall &quot;软件组名&quot;</span><br></pre></td></tr></table></figure></li><li><p>查询软件组：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#yum</span> grouplist</span><br></pre></td></tr></table></figure></li><li><p>卸载软件组：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># yum groupremove &quot;软件组名&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="font-color-gree-6-13-源码包安装和卸载-font"><font color='gree'>6.13 源码包安装和卸载</font></h3><p><em><strong>注意，本节使用的源码包，指的是<font color='red'>软件所有源代码的压缩包</font>，其后缀名为 “.tar.gz” 或 “.tar.bz2”；而 SRPM 源码包本质上属于 RPM 包，也就是源码的RPM包，其文件后缀为 “.src.rpm”。虽然都叫源码包，但不是一码事。</strong></em></p><p>Linux 系统中，绝大多数软件的源代码都是用 C 语言编写的，少部分用C++编写。因此要想安装源码包，必须安装 gcc 编译器。</p><p>除了安装编译器，还需要安装 make 编译命令。Linux编译源码包不像编译一个 hello.c 文件那样轻松，包中含大量的源码文件，且文件之间有着非常复杂的关联，直接决定着各文件编译的先后顺序，因此手动编译费时费力，而使用 make 命令可以完成对源码包的自动编译。</p><p><strong>源码包安装流程(以apache为例)：</strong></p><ol><li><p>下载源码包（tarball）。得到的源码包格式为压缩包（ “.tar.gz” 或 “.tar.bz2” ）。</p><blockquote><p>将各种文件分门别类保存在对应的目录中，应该成为合格 Linux 管理员约定俗成的习惯。Linux 系统中用于保存源代码的位置主要有 2 个，分别是 “/usr/src” 和 “/usr/local/src”， <font color='red'>其中 “/usr/src” 用来保存内核源代码，“/usr/local/src” 用来保存用户下载的源代码。</font></p></blockquote></li><li><p>将源码包进行解压缩，使用命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#tar</span> -zxvf httpd-<span class="number">2.2</span>.<span class="number">9</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>|more</span><br></pre></td></tr></table></figure></li><li><p>进入解压目录，执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls </span><br><span class="line">anaconda-ks<span class="selector-class">.cfg</span> httpd-<span class="number">2.2</span>.<span class="number">9</span> httpd-<span class="number">2.2</span>.<span class="number">9</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span> install<span class="selector-class">.log</span> install<span class="selector-class">.log</span><span class="selector-class">.syslog</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd httpd-<span class="number">2.2</span>.<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>./configure 软件配置与检查。这一步主要完成以下 3 项任务：</p><ul><li><p>检测系统环境是否符合安装要求。</p></li><li><p>定义需要的功能选项。通过 <code>./configure--prefix=安装路径</code> 可以指定安装路径。注意， <code>configure </code>不是系统命令，而是源码包软件自带的一个脚本程序 ，所以必须采用 <code>./configure</code> 方式执行。</p><p><code>./configure</code> 支持的功能选项较多，可执行 <code>./configure--help</code> 命令查询其支持的功能，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span>#./configure <span class="attr">--help</span>|more</span><br><span class="line">#查询apache支持的选项功能（不是必需步骤）</span><br></pre></td></tr></table></figure><p>把系统环境的检测结果和定义好的功能选项写入 Makefile 文件，因为后续的编译和安装需要依赖这个文件的内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># ./configure <span class="attr">--prefix</span>=/usr/local/apache2</span><br><span class="line">checking for chosen layout..<span class="selector-class">.Apache</span></span><br><span class="line">checking for working mkdir -<span class="selector-tag">p</span>…yes</span><br><span class="line">checking build system type..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">checking host system type..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">checking target system typa..<span class="selector-class">.i686-pc-linux-gnu</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>–prefix 选项的含义为指定安装目录。</p><p>此命令没有加载其他功能，只是指定安装目录。需要说明的是，“/usr/local/apache2” 目录不需要手工建立，安装完成后会自动建立（这个目录是否生成也是检测软件是否正确安装的重要标志）。</p></li><li><p>make 编译。make 会调用 gcc 编译器，并读取 Makefile 文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被 Linux 识别的可执行文件，这些可执行文件保存在当前目录下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make install</span><br></pre></td></tr></table></figure><p>注意，如果在 “./configure” 或 “make” 编译中报错，则在重新执行命令前一定要执行 <code>make clean</code> 命令，它会清空 Makefile 文件或编译产生的 “.o” 头文件。</p></li><li><p>卸载</p><p>源码包的卸载，只需要找到软件的安装位置，直接删除所在目录即可，不会遗留任何垃圾文件。执行如下命令即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /usr/local/apache2/</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="font-color-gree-6-14-源码包升级与补丁-font"><font color='gree'>6.14 源码包升级与补丁</font></h3><p>Linux 系统中更新用源码包安装的软件，除了卸载重装外，还可以下载补丁文件更新源码包，用新的源码包重新编译安装软件。</p><blockquote><p>使用补丁文件更新源码包，省去了用 <code>./configured</code> 生成新的 Makefile 文件，还省去了大量的编译工作，因此效率更高。学完本节会对比有更深入的理解。</p></blockquote><p><strong>Linux补丁文件的生成和使用</strong></p><p>diff 命令基本格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># diff 选项 old new</span><br></pre></td></tr></table></figure><p>#比较old和new文件的不同</p><p>此命令中可使用如下几个选项：</p><ul><li>-a：将任何文档当作文本文档处理；</li><li>-b：忽略空格造成的不同；</li><li>-B：忽略空白行造成的不同；</li><li>-I：忽略大小写造成的不同；</li><li>-N：当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件；</li><li>-r：当比较目录时，递归比较子目录；</li><li>-u：使用同一输出格式；</li></ul><ol><li><pre><code class="language-css">[root@localhost test]# diff -Naur /root/test/old.txt  /root/test/new.txt  &gt; txt. patch<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```css</span><br><span class="line">   [root@localhost test]# patch -pn &lt; 补丁文件</span><br></pre></td></tr></table></figure>&gt; -pn 选项中，n 为数字（例如 p1、p2、p3 等），pn 表示按照补丁文件中的路径，指定更新文件的位置。&gt;&gt; 这里对 -pn 选项的使用做一下额外说明。我们知道，补丁文件是要打入旧文件的，但是当前所在目录和补丁文件中记录的目录不一定是匹配的，需要 &quot;-pn&quot; 选项来同步两个目录。&gt;&gt; 例如，当前位于 &quot;/root/test/&quot; 目录下（要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为 &quot;/root/test/dd.txt&quot;，如果写入 &quot;-p1&quot;（在补丁文件目录中取消一级目录），那么补丁文件会打入 &quot;root/test/root/test/old.txt&quot; 文件中，这显然是不对的；如果写入的是 &quot;-p2&quot;（在补丁文件目录中取消二级目录），补丁文件会打入 &quot;/root/test/test/old.txt&quot; 文件中，这显然也不对。如果写入的是 &quot;-p3&quot;（在补丁文件目录中取消三级目录），补丁文件会打入 &quot;/root/test/old.txt&quot; 文件中，old.txt 文件就在这个目录下，所以应该用 &quot;-p3&quot; 选项。&gt;&gt; 如果当前所在目录是 &quot;/root/&quot; 目录呢？因为补丁文件中记录的文件目录为 &quot;/root/test/old.txt&quot;，所以这里就应该用 &quot;-p2&quot; 选项（代表取消两级目录），补丁打在当前目录下的 &quot;test/old.txt&quot; 文件上。&gt;&gt; 因此，-pn 选项可以这样理解， 即想要在补丁文件中所记录的目录中取消几个 &quot;/&quot; ，n 就是几。去掉目录的目的是和当前所在目录匹配。</code></pre></li><li><pre><code class="language-css">[root@localhost test]# patch -p3 &lt; txt.patch<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &lt;font color=&#x27;red&#x27;&gt;打补丁需要注意：&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">   1. 给旧文件打补丁依赖的不是新文件，而是补丁文件，所以即使新文件被删除也没有关系。</span><br><span class="line">   2. 补丁文件中记录的目录和当前所在目录需要通过 &quot;-pn&quot; 选项实现同步，否则更新可能失败。</span><br><span class="line"></span><br><span class="line">4. 重新编译 apache 源码包，执行如下命令：</span><br><span class="line"></span><br><span class="line">   ```css</span><br><span class="line">   [root@localhost httpd-2.2.9]# make</span><br></pre></td></tr></table></figure></code></pre></li><li><p>安装 apache，执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost httpd-2.2.9]</span># make install</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="font-color-gree-6-15-Linux函数库（静态函数库和动态函数库-font"><font color='gree'>6.15  Linux函数库（静态函数库和动态函数库)</font></h3><p>Linux 系统中存在大量的函数库。函数库中的函数并不是以源代码的形式存在的，而是经过编译后生成的二进制文件，，只有链接到我们编写的程序中才可以运行。</p><p>Linux 系统中的函数库分为 2 种，分别是 静态函数库（简称静态库） 和 动态函数库 （也称为共享函数库，简称动态库或共享库），两者的主要区别在于，程序调用函数时，将函数整合到程序中的时机不同：</p><ul><li>静态函数库在程序编译时就会整合到程序中。这样做的好处是程序运行时不再需要调用外部函数库，可直接执行；缺点也很明显，所有内容都整合到程序中，编译文件会比较大，且一旦静态函数库改变，程序就需要重新编译。</li><li>动态函数库在程序运行时才被加载，程序中只保存对函数库的指向（程序编译仅对其做简单的引用）。使用动态函数库的好处是，程序生成的可执行程序体积比较小，且升级函数库时无需对整个程序重新编译；缺点是，如果程序执行时函数库出现问题，则程序将不能正确运行。</li></ul><blockquote><p>Linux 系统中，<font color='red'>静态函数库文件扩展名是 “.a”</font>，文件通常命令为 libxxx.a（xxx 为文件名）；<font color='red'>动态函数库扩展名为 “.so”</font>，文件通常命令为 libxxx.so.major.minor（xxx 为文件名，major 为主版本号，minor 为副版本号）。</p></blockquote><p>Linux <font color='orange'>系统中大多数都是动态函数库（主要考虑到软件的升级方便）</font>，其中被系统程序调用的函数库主要存放在 “/usr/lib” 和 “/lib” 中；Linux 内核所调用的函数库主要存放在 “/lib/modules” 中。</p><ul><li><p>安装函数库：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装 curses 函数库命令如下：</span><br><span class="line"><span class="selector-attr">[root@Linux ~]</span># yum install ncurses-devel</span><br></pre></td></tr></table></figure></li><li><p>查看可执行程序调用了哪些函数库:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldd -v 可执行文件名</span><br></pre></td></tr></table></figure><p>-v 选项的含义是显示详细版本信息（非必须）</p></li><li><p>如果函数库安装后仍无法使用，这时就需要对函数库的配置文件进行手动调整，需进行如下操作：</p><ol><li>将函数库文件放入指定位置（通常放在 “/usr/lib” 或 “/lib” 中），然后把函数库所在目录写入 “/etc/ld.so.conf” 文件 。例如：</li></ol>   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp  *<span class="selector-class">.so</span>  /usr/lib/</span><br><span class="line">\#把函数库复制到/usr/lib/目录中</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># vi /etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span></span><br><span class="line">\#修改函数库配置文件</span><br><span class="line">include ld<span class="selector-class">.so</span><span class="selector-class">.conf</span><span class="selector-class">.d</span><span class="comment">/*.conf</span></span><br><span class="line"><span class="comment">/usr/lib</span></span><br><span class="line"><span class="comment">#写入函数库所在目录（其实/usr/lib/目录默认已经被识别）</span></span><br></pre></td></tr></table></figure><p>注意，这里写入的是函数库所在的目录，而不单单是函数库的文件名。另外，如果自己在其他目录中创建了函数库文件，这里也可以直接在 “/etc/ld.so.conf” 文件中写入函数库文件所在的完整目录。</p><ol start="2"><li><p>使用 <code>ldconfig</code> 命令重新读取 /etc/ld.so.conf 文件，把新函数库读入缓存。命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldconfig</span><br><span class="line">#从/etc/ld<span class="selector-class">.so</span><span class="selector-class">.conf</span>文件中把函数库读入缓存</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ldconfig -<span class="selector-tag">p</span></span><br><span class="line">#列出系统缓存中所有识别的函数库</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h2 id="font-color-orange-7-用户和用户组管理-font"><font color='orange'>7. 用户和用户组管理</font></h2><h3 id="font-color-gree-7-1-UID和GID-font"><font color='gree'>7. 1 UID和GID</font></h3><p>Linux 并不认识你的用户名称，<font color='red'>它只认识用户名对应的 ID 号</font>。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 /etc/passwd 文件中。</p><p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（UID）和组 ID（GID），这与文件有拥有者和拥有群组两种属性相对应。</p><blockquote><p>既然 Linux 系统不认识用户名，文件是如何判别和显示它的拥有者名称和群组名称的呢？</p><p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 /etc/passwd 和 /etc/group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来。</p></blockquote><p>使用 root 账号登陆并 Vim /etc/passwd，在该文件中找到xuan账户并将其 UID 随意改一个数字，这时当你查看普通账户拥有的文件时，你会发现所有文件的拥有者不再是xuan，而是数字。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@livecd ~]</span><span class="selector-id">#grep</span> &#x27;xuan&#x27; /etc/passwd</span><br><span class="line">xuan:x:<span class="number">500</span>:<span class="number">500</span>:xuan:/home/centoslive:/bin/bash</span><br><span class="line">[root@livecd ~]#ll -d /home/centoslive</span><br><span class="line">drwx------. <span class="number">23</span> c.xuan centoslive <span class="number">4096</span> Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">37</span> /home/centoslive</span><br><span class="line">[root@livecd ~]#vim /etc.passwd</span><br><span class="line">#修改xuan账户中的UID（第一个 <span class="number">500</span>）为 <span class="number">2000</span></span><br><span class="line">[root@livecd ~]#ll -d /home/centoslive</span><br><span class="line">drwx------. <span class="number">23</span> <span class="number">500</span> centoslive <span class="number">4096</span> Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">37</span> /home/centoslive</span><br><span class="line">#可以看到，之前的 xuan 变为了 <span class="number">500</span>，因为修改了UID，导致 <span class="number">500</span> 找不到对应的账号，因此显示数字</span><br><span class="line">#记得最后将其再手动改正过来</span><br><span class="line">[root@livecd ~]#vim /etc.passwd</span><br><span class="line">#修改xuan账户中的UID从 <span class="number">2000</span> 改为 <span class="number">500</span></span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-7-2-etc-passwd内容详解-font"><font color='gree'>7.2 /etc/passwd内容详解</font></h3><p>/etc/passwd目录中，绝大多数的<font color='gree'>系统用户</font>(伪用户)。<font color='red'>系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</font></p><p>每行用户信息都以 “：” 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><ul><li><p>**用户名：**用户名仅是为了方便用户记忆，Linux是通过 UID 来识别用户身份，分配用户权限的。/etc/passwd 文件中就定义了用户名和 UID 之间的对应关系。</p></li><li><p><strong>密码：</strong>“x” 表示此用户设有密码，但不是真正的密码，真正的密码保存在 /etc/shadow 文件中。</p></li><li><p><strong>UID:</strong> UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份.</p><table><thead><tr><th>UID 范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了.</td></tr><tr><td>1~499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1~99 用于系统自行创建的账号；100~499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500~65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 2^32^ 个 UID 了。</td></tr></tbody></table></li><li><p>**GID:**全称“Group ID”，表示用户初始组的组 ID 号。</p><ul><li><p>初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。</p></li><li><p>附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p></li></ul><p>举例来说，lamp 用户除属于初始组 lamp 外，又把它加入了 users 组，那么 lamp 用户同时属于 lamp 组和 users 组，其中 lamp 是初始组，users 是附加组。</p><blockquote><p>当然，初始组和附加组的身份是可以修改的，但是我们在工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-u UID</td><td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td></tr><tr><td>-d 主目录</td><td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td></tr><tr><td>-c 用户说明</td><td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td></tr><tr><td>-g 组名</td><td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td></tr><tr><td>-G 组名</td><td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td></tr><tr><td>-s shell</td><td>手工指定用户的登录 Shell，默认是 /bin/bash；</td></tr><tr><td>-e 曰期</td><td>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</td></tr><tr><td>-o</td><td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td></tr><tr><td>-m</td><td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td></tr><tr><td>-r</td><td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td></tr></tbody></table><p>需要注意的是，<font color='red'>在 /etc/passwd 文件的第四个字段中看到的 ID 是这个用户的初始组。</font></p></blockquote></li><li><p>**描述性信息：**没有什么大用处</p></li><li><p>**默认shell：**通常情况下，Linux 系统默认使用的命令解释器是 bash（/bin/bash），当然还有其他命令解释器，例如 sh、csh 等。</p></li></ul><hr><h3 id="font-color-gree-7-3-etc-shadow文件-font"><font color='gree'>7.3 /etc/shadow文件</font></h3><p>/etc/shadow 文件，用于存储 Linux 系统中用户的密码信息.</p><p>/etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p><blockquote><p><font color='red'>注意，如果这个文件的权限发生了改变，则需要注意是否是恶意攻击。</font></p></blockquote><p>同 /etc/passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br><span class="line">root:$<span class="number">6</span>$jEbqPBcV$AgML24pnFYJZmc6kTNenqNT0w6.COYDcI6/yXjzuU0Hf2CNuqvxUW6trscC.zy69rAWaZcdVaabEHvp2R5/<span class="number">9</span>a.:<span class="number">19132</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br></pre></td></tr></table></figure><ul><li><p>**加密密码：**目前 Linux 的密码采用的是 SHA512 散列加密算法。所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的</p></li><li><p>**最后修改时间：**Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间。显示 15775 天则表示此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。</p><blockquote><p>可以使用如下命令进行换算：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># date -d &quot;<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">15775</span> days&quot;</span><br><span class="line"><span class="number">2013</span>年<span class="number">03</span>月<span class="number">11</span>日 星期一 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST</span><br></pre></td></tr></table></figure></blockquote></li><li><p>**最小修改密码时间间隔：**如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p></li><li><p>**密码有效期：**Linux用户密码需要经常更改才能最大限度地保证安全。管理服务器时，通过这个字段强制用户定期修改密码。</p></li><li><p>**密码过期后的宽限天数：**若此字段是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效</p></li><li><p>**密码变更前的警告天数：**该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p></li><li><p>**账号失效时间：**该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！该字段通常被使用在具有收费服务的系统中。</p></li><li><p>**保留：**待使用的字段</p></li></ul><hr><h3 id="font-color-gree-7-4-etc-group-font"><font color='gree'>7.4 /etc/group</font></h3><p>/ect/group 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。此文件是记录组 ID（GID）和组名相对应的文件。</p><p>各用户组中，还是以 “：” 作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组名：密码：GID：组用户</span><br><span class="line">root: x : <span class="number">0</span> :</span><br></pre></td></tr></table></figure><ul><li><p>**组密码：**和 /etc/passwd 文件一样，这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 /etc/gshadow 文件中</p><blockquote><p>用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。</p></blockquote></li><li><p>**组ID：**Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。/etc/passwd 文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p></li><li><p>**组用户：**此字段列出每个群组包含的所有用户。<font color='red'>如果该用户组是这个用户的初始组，则该用户不会写入这个字段</font>，即：<font color='orange'>该字段显示的用户都是这个用户组的附加用户。</font></p><blockquote><p><font color='orange'>每个用户都可以加入多个附加组，但是只能属于一个初始组</font>。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让 lamp 也加入 root 这个群组，那么只需要在第一行的最后一个字段加入 lamp。</p><p>root 管理员使用 useradd 命令创建新用户时， 若未明确指定该命令所属的初始组，useradd 命令会默认创建一个同用户名相同的群组，作为该用户的初始组。</p></blockquote></li></ul><p>关系：先在 /etc/group 文件中查询用户组的 GID 和组名；然后在 /etc/passwd 文件中查找该 GID 是哪个用户的初始组，同时提取这个用户的用户名和 UID；最后通过 UID 到 /etc/shadow 文件中提取和这个用户相匹配的密码。</p><hr><h3 id="font-color-gree-7-5-etc-gshadow-font"><font color='gree'>7.5 /etc/gshadow</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root : : :</span><br><span class="line">组名：加密密码：组管理员：组附加用户列表</span><br></pre></td></tr></table></figure><ul><li><p>**组密码：**对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为 “!”，指的是该群组没有组密码，也不设有群组管理员。</p></li><li><p>**组管理员：**从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。那么，什么是群组管理员呢？</p><blockquote><p>考虑到 Linux 系统中账号太多，而超级管理员 root 可能比较忙碌，因此当有用户想要加入某群组时，root 或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦 root 了。不过，由于有 sudo 之类的工具，因此此功能已经很少使用了。</p></blockquote></li><li><p>**附加用户：**该字段显示这个用户组中有哪些附加用户，和 /etc/group 文件中附加组显示内容相同。</p></li></ul><hr><h3 id="font-color-gree-7-6-etc-login-defs-font"><font color='gree'>7.6 /etc/login.defs</font></h3><p><strong>/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。</strong></p><p><font color='red'>需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。</font></p><p>使用 <code>vim /etc/login.defs</code> 命令查看该文件中的内容</p><table><thead><tr><th>MAIL_DIR /var/spool/mail</th><th><font color='red'>创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是 /var/spool/mail/lamp。</font></th></tr></thead><tbody><tr><td>PASS_MAX_DAYS 99999</td><td>密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。</td></tr><tr><td>PASS_MIN_DAYS 0</td><td>表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。</td></tr><tr><td>PASS_MIN_LEN 5</td><td>指定密码的最小长度，默认不小于 5 位，<font color='red'>但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。</font></td></tr><tr><td>PASS_WARN_AGE 7</td><td>指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。</td></tr><tr><td>UID_MIN 500</td><td>指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的 UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID 没有使用。</td></tr><tr><td>UID_MAX 60000</td><td>指定用户最大的 UID 为 60000。</td></tr><tr><td>GID_MIN 500</td><td>指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。</td></tr><tr><td>GID_MAX 60000</td><td>用户 GID 最大为 60000。</td></tr><tr><td>CREATE_HOME yes</td><td>指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。</td></tr><tr><td>UMASK 077</td><td>用户主目录的权限默认设置为 077。</td></tr><tr><td>USERGROUPS_ENAB yes</td><td>指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。</td></tr><tr><td>ENCRYPT_METHOD SHA512</td><td>指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密</td></tr></tbody></table><hr><h3 id="font-color-gree-7-7-useradd命令-font"><font color='gree'>7.7 useradd命令</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#useradd</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-u UID</td><td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td></tr><tr><td>-d 主目录</td><td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td></tr><tr><td>-c 用户说明</td><td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td></tr><tr><td>-g 组名</td><td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td></tr><tr><td>-G 组名</td><td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td></tr><tr><td>-s shell</td><td>手工指定用户的登录 Shell，默认是 /bin/bash；</td></tr><tr><td>-e 曰期</td><td><font color='gree'>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</font></td></tr><tr><td>-o</td><td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td></tr><tr><td>-m</td><td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td></tr><tr><td>-r</td><td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td></tr></tbody></table><p><strong><font color='red'>创建用户lamp时进行的流程：</font></strong></p><ol><li><p>在 /etc/passwd 文件中创建一行与 lamp 用户相关的数据：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/passwd</span><br><span class="line">lamp:x:<span class="number">500</span>:<span class="number">500</span>::/home/lamp:/bin/bash</span><br></pre></td></tr></table></figure><p>可以看到，用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为 /home/lamp/，用户的登录 Shell 为 /bin/bash。</p></li><li><p>在 /etc/shadow 文件中新增了一行与 lamp 用户密码相关的数据：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/shadow</span><br><span class="line">lamp:!!:<span class="number">15710</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br></pre></td></tr></table></figure><p>当然，这个用户还没有设置密码，所以密码字段是 “!!”，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段，例如密码有效期有 99999 天，距离密码过期 7 天系统会提示用户“密码即将过期”等。</p></li><li><p>在 /etc/group 文件中创建一行与用户名一模一样的群组：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/group</span><br><span class="line">lamp:x:<span class="number">500</span>:</span><br></pre></td></tr></table></figure><p>该群组会作为新建用户的初始组。</p></li><li><p>在 /etc/gshadow 文件中新增一行与新增群组相关的密码信息：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;lamp&quot; /etc/gshadow</span><br><span class="line">lamp:!::</span><br></pre></td></tr></table></figure><p>当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</p></li><li><p>默认创建用户的主目录和邮箱：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#ll</span> -d /home/lamp/</span><br><span class="line">drwx------ <span class="number">3</span> lamp lamp <span class="number">4096</span> <span class="number">1</span>月<span class="number">6</span> <span class="number">00</span>:<span class="number">19</span> /home/lamp/</span><br><span class="line">[root@localhost ~]#ll /var/spod/mail/lamp</span><br><span class="line">-rw-rw---- <span class="number">1</span> lamp mail <span class="number">0</span> <span class="number">1</span>月<span class="number">6</span> <span class="number">00</span>:<span class="number">19</span> /var/spool/mail/lamp</span><br></pre></td></tr></table></figure><p>注意这两个文件的权限，都要让 lamp 用户拥有相应的权限。</p></li><li><p>将 /etc/skel 目录中的配置文件复制到新用户的主目录中</p></li></ol><p><font color='orange'>useradd 命令在添加用户时参考的默认值文件主要有两个，分别是<code>/etc/default/useradd</code>和<code>/etc/login.defs</code>。</font></p><p>后者在上节已做说明，下面对前者进行说明：</p><p><code>/etc/default/useradd</code>中的内容：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>GR0UP=100</td><td>这个选项用于建立用户的默认组，也就是说，在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组。<font color='red'>但 CentOS 并不是这样的，而是在添加用户时会自动建立和用户名相同的组作为此用户的初始组。也就是说这个选项并不会生效。</font>  Linux 中默认用户组有两种机制：<font color='orange'>一种是私有用户组机制，系统会创建一个和用户名相同的用户组作为用户的初始组；</font><font color='gree'>另一种是公共用户组机制，系统用 GID 是 100 的用户组作为所有新建用户的初始组</font>。目前我们采用的是私有用户组机制。</td></tr><tr><td>HOME=/home</td><td>指的是用户主目录的默认位置，所有新建用户的主目录默认都在 /home/下，刚刚新建的 lamp1 用户的主目录就为 /home/lamp1/。</td></tr><tr><td>INACTIVE=-1</td><td>指的是密码过期后的宽限天数，也就是 /etc/shadow 文件的第七个字段。<font color='pink'>这里默认值是 -1，代表所有新建立的用户密码永远不会失效。</font></td></tr><tr><td>EXPIRE=</td><td>表示密码失效时间，也就是 /etc/shadow 文件的第八个字段。默认值是空，代表所有新建用户没有失效时间，永久有效。</td></tr><tr><td>SHELL=/bin/bash</td><td>表示所有新建立的用户默认 Shell 都是 /bin/bash。</td></tr><tr><td>SKEL=/etc/skel</td><td>在创建一个新用户后，你会发现，该用户主目录并不是空目录，而是有 .bash_profile、.bashrc 等 隐藏 文件， 这些文件都是从 /etc/skel/ 目录中自动复制过来的。因此，更改 /etc/skel 目录下的内容就可以改变新建用户默认主目录中的配置文件信息。</td></tr><tr><td>CREATE_MAIL_SPOOL=yes</td><td>指的是给新建用户建立邮箱，默认是创建。也就是说，对于所有的新建用户，系统都会新建一个邮箱，放在 /var/spool/mail/ 目录下，和用户名相同。例如，lamp1 的邮箱位于 /var/spool/mail/lamp1。</td></tr></tbody></table><p>此文件中各选项值的修改方式有 2 种，一种是通过 Vim 文本编辑器手动修改，另一种是使用 useradd 命令。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -D <span class="selector-attr">[选项]</span> 参数</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项+参数</th><th>含义</th></tr></thead><tbody><tr><td>-b HOME</td><td>设置所创建的主目录所在的默认目录，只需用目录名替换 HOME 即可，例如 useradd -D -b /gargae。</td></tr><tr><td>-e EXPIRE</td><td>设置密码失效时间，EXPIRE 参数应使用 YYYY-MM-DD 格式，例如 useradd -D -e 2019-10-17。</td></tr><tr><td>-f INACTIVE</td><td>设置密码过期的宽限天数，例如 useradd -D -f 7。</td></tr><tr><td>-g GROUP</td><td>设置新用户所在的初始组，例如 useradd -D -g bear。</td></tr><tr><td>-s SHELL</td><td>设置新用户的默认 shell，SHELL 必须是完整路径，例如 useradd -D -s /usr/bin/csh。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># useradd -D -s /bin/csh</span><br></pre></td></tr></table></figure><p><em><strong>useradd 命令创建用户的过程是这样的:系统首先读取 /etc/login.defs 和 /etc/default/useradd，根据这两个配置文件中定义的规则添加用户，也就是向 /etc/passwd、/etc/group、/etc/shadow、/etc/gshadow 文件中添加用户数据，接着系统会自动在 /etc/default/useradd 文件设定的目录下建立用户主目录，最后复制 /etc/skel 目录中的所有文件到此主目录中，由此，一个新的用户就创建完成了。</strong></em></p><hr><h3 id="font-color-gree-7-8-passwd命令-font"><font color='gree'>7.8 passwd命令</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#passwd</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-S：查询用户密码的状态，也就是 /etc/shadow 文件中此用户密码的内容。仅 root 用户可用；</li><li>-l：暂时锁定用户，<font color='red'>该选项会在 /etc/shadow 文件中指定用户的加密密码串前添加 “!”，使密码失效。仅 root 用户可用；</font></li><li>-u：解锁用户，和 -l 选项相对应，也是只能 root 用户使用；</li><li>–stdin：可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用；</li><li>-n 天数：设置该用户修改密码后，多长时间不能再次修改密码，也就是修改 /etc/shadow 文件中各行密码的第 4 个字段；</li><li>-x 天数：设置该用户的密码有效期，对应 /etc/shadow 文件中各行密码的第 5 个字段；</li><li>-w 天数：设置用户密码过期前的警告天数，对于 /etc/shadow 文件中各行密码的第 6 个字段；</li><li>-i 日期：设置用户密码失效日期，对应 /etc/shadow 文件中各行密码的第 7 个字段。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># passwd -l yuhan</span><br><span class="line">Locking password for user yuhan.</span><br><span class="line">passwd: Success</span><br><span class="line">[root@MyFirstVM ~]# grep <span class="string">&quot;yuhan&quot;</span> /etc/shadow</span><br><span class="line">yuhan:!!$<span class="number">6</span>$YV/txtAo$<span class="number">4</span>zJ8yJM/dhu9DG4FYT2lXewiKxYdGIE5sis4hIJoevAy7XRxZ0dlnXPTFb3ov1ewwnYuAhCS60Nk1:<span class="number">19140</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">9</span>:::</span><br><span class="line">#!!说明密码已经被锁定，无法登入</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#调用管道符，给 lamp 用户设置密码 &quot;<span class="number">123</span>&quot;</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># echo &quot;<span class="number">123</span>&quot; | passwd <span class="attr">--stdin</span> lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>使用此方式批量给用户设置初始密码，方便快捷，<font color='red'>但需要注意的是，这样设定的密码会把密码明文保存在历史命令中，如果系统被攻破，别人可以在 /root/.bash_history 中找到设置密码的这个命令，存在安全隐患。</font></p><hr><h3 id="font-color-gree-7-9-usermod命令-font"><font color='gree'>7.9 usermod命令</font></h3><p>修改用户的信息，办法有两个，一个是使用 Vim 文本编辑器手动修改涉及用户信息的相关文件（/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow），另一个方法就是使用本节介绍了 usermod 命令，该命令专门用于修改用户信息。</p><p>这里一定要分清 useradd 命令和 usermod 命令的区别，前者用于添加用户。</p><p>usermod 命令的基本格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#usermod</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure><ul><li>-c 用户说明：修改用户的说明信息，即修改 /etc/passwd 文件目标用户信息的第 5 个字段；</li><li>-d 主目录：修改用户的主目录，即修改 /etc/passwd 文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径；</li><li>-e 日期：修改用户的失效曰期，格式为 “YYYY-MM-DD”，即修改 /etc/shadow 文件目标用户密码信息的第 8 个字段；</li><li>-g 组名：修改用户的初始组，即修改 /etc/passwd 文件目标用户信息的第 4 个字段（GID）；</li><li>-u UID：修改用户的UID，即修改 /etc/passwd 文件目标用户信息的第 3 个字段（UID）；</li><li>-G 组名：修改用户的附加组，其实就是把用户加入其他用户组，即修改 /etc/group 文件；</li><li>-l 用户名：修改用户名称；</li><li>-L：临时锁定用户（Lock）；</li><li>-U：解锁用户（Unlock），和 -L 对应；</li><li>-s shell：修改用户的登录 Shell，默认是 /bin/bash。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># usermod -G root lamp</span><br><span class="line">#把用户加入root组</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-7-10-chage命令-font"><font color='gree'>7.10 chage命令</font></h3><p>chage 命令可以显示更加详细的用户密码信息，并且和 passwd 命令一样，提供了修改用户密码信息的功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chage</span> <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure><ul><li>-l：列出用户的详细密码状态;</li><li>-d 日期：修改 /etc/shadow 文件中指定用户密码信息的第 3 个字段，也就是最后一次修改密码的日期，格式为 YYYY-MM-DD；</li><li>-m 天数：修改密码最短保留的天数，也就是 /etc/shadow 文件中的第 4 个字段；</li><li>-M 天数：修改密码的有效期，也就是 /etc/shadow 文件中的第 5 个字段；</li><li>-W 天数：修改密码到期前的警告天数，也就是 /etc/shadow 文件中的第 6 个字段；</li><li>-i 天数：修改密码过期后的宽限天数，也就是 /etc/shadow 文件中的第 7 个字段；</li><li>-E 日期：修改账号失效日期，格式为 YYYY-MM-DD，也就是 /etc/shadow 文件中的第 8 个字段。</li></ul><p><font color='red'> chage 命令除了修改密码信息的功能外，还可以强制用户在第一次登录后，必须先修改密码，并利用新密码重新登陆系统，此用户才能正常使用。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建新用户 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#useradd</span> lamp</span><br><span class="line">#设置用户初始密码为 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#echo</span> &quot;lamp&quot; | passwd <span class="attr">--stdin</span> lamp</span><br><span class="line">#通过chage命令设置此账号密码创建的日期为 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日（<span class="number">0</span> 就表示这一天），这样用户登陆后就必须修改密码</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chage</span> -d <span class="number">0</span> lamp</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-7-11-userdel命令-font"><font color='gree'>7.11 userdel命令</font></h3><p>userdel 用来删除用户的相关数据。<font color='orange'>此命令只有 root 用户才能使用。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># userdel -r 用户名</span><br><span class="line">-r 选项表示在删除用户的同时删除用户的家目录。</span><br></pre></td></tr></table></figure><p><font color='red'>注意，在删除用户的同时如果不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。但一般而言，删除用户时不会直接删除其家目录，因为其家目录中可能存在重要数据！</font></p><p>删除用户可以很方便地用userdel，也可以删除之前叙述的相关文件中的相关信息来彻底删除某个用户。</p><ul><li>/etc/passwd</li><li>/etc/shadow</li><li>/etc/group</li><li>/etc/gshadow</li><li>/var/spool/mail/username</li><li>/home/username</li></ul><hr><h3 id="font-color-gree-7-12-id命令-font"><font color='gree'>7.12 id命令</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id 命令可以查询用户的UID、GID 和附加组的信息。命令比较简单，格式如下：</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># id 用户名</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1007</span>(shanbi)</span><br><span class="line"><span class="selector-id">#yuhan</span>的初始组为root，附加组为root和shanbi</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># usermod -G sonofhan  yuhan</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1007</span>(shanbi),<span class="number">1013</span>(sonofhan)</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-7-13-临时切换用户-su-font"><font color='gree'>7.13 临时切换用户 su</font></h3><blockquote><p>普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># su <span class="selector-attr">[选项]</span> 用户名</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-：当前用户不仅切换为指定用户的身份，<font color='orange'>同时所用的工作环境也切换为此用户的环境（包括 PATH 变量、MAIL 变量等）</font>，使用 - 选项可省略用户名，默认会切换为 root 用户。</li><li>-l：同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。</li><li>-p：表示切换为指定用户的身份，<font color='red'>但不改变当前的工作环境（不使用切换用户的配置文件）。</font></li><li>-m：和 -p 一样；</li><li>-c 命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</li></ul><p><font color='red'>注意，su 和 -su有很大区别！</font></p><blockquote><p>举个例子，普通用户 lamp 通过 su 命令切换成 root 用户，但没有使用 - 选项，这样情况下，虽然看似是 root 用户，但系统中的 PATH 环境变量依然是 lamp 的（而不是 root 的），因此当前工作环境中，并不包含 /sbin、/usr/sbin等超级用户命令的保存路径，这就导致很多管理员命令根本无法使用。不仅如此，当 root 用户接受邮件时，会发现收到的是 lamp 用户的邮件，因为环境变量 $MAIL 也没有切换。</p></blockquote><hr><h3 id="font-color-gree-7-14-whoami-和who-am-i-font"><font color='gree'>7.14 whoami 和who am i</font></h3><p>whoami 命令和 who am i 命令是不同的 2 个命令，<font color='orange'>前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># whoami</span><br><span class="line">root</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM ~]</span># who am <span class="selector-tag">i</span></span><br><span class="line">root     pts/<span class="number">2</span>        <span class="number">2022</span>-<span class="number">05</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span> (<span class="number">192.168</span>.<span class="number">232.1</span>)</span><br><span class="line">[root@MyFirstVM ~]# su yuhan</span><br><span class="line">[yuhan@MyFirstVM root]$ whoami</span><br><span class="line">yuhan</span><br><span class="line">[yuhan@MyFirstVM root]$ who am i</span><br><span class="line">root     pts/<span class="number">2</span>        <span class="number">2022</span>-<span class="number">05</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span> (<span class="number">192.168</span>.<span class="number">232.1</span>)</span><br></pre></td></tr></table></figure><p>也就是说，使用 su 或者 sudo 命令切换用户身份，骗得过 whoami，但骗不过 who am i。要解释这背后的运行机制，需要搞清楚什么是<code>实际用户（UID）</code>和<code>有效用户（EUID)</code>(即 Effective UID）。</p><p>所谓实际用户，指的是登陆 Linux 系统时所使用的用户，因此在整个登陆会话过程中，实际用户是不会发生变化的；而有效用户，指的是当前执行操作的用户，也就是说真正决定权限高低的用户，这个是能够利用 su 或者 sudo 命令进行任意切换的。</p><hr><h3 id="font-color-gree-7-15-groupadd命令-font"><font color='gree'>7.15 groupadd命令</font></h3><p>添加用户组的命令是 groupadd，命令格式如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd <span class="selector-attr">[选项]</span> 组名</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-g GID：指定组 ID；</li><li>-r：创建系统群组。<br>使用 groupadd 命令创建新群组非常简单，例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group1</span><br><span class="line">\#添加group1组</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;group1&quot; /etc/group</span><br><span class="line">/etc/group:group1:x:<span class="number">502</span>:</span><br><span class="line">/etc/gshadow:group1:!::</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-7-16-groupmod命令-font"><font color='gree'>7.16 groupmod命令</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupmod <span class="selector-attr">[选现]</span> 组名</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-g GID：修改组 ID；</li><li>-n 新组名：修改组名；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupmod -n testgrp group1</span><br><span class="line">#把组名group1修改为testgrp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;testgrp&quot; /etc/group</span><br><span class="line">testgrp:x:<span class="number">502</span>:</span><br><span class="line">#注意GID还是<span class="number">502</span>，但是组名已经改变</span><br></pre></td></tr></table></figure><blockquote><p>用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</p></blockquote><hr><h3 id="font-color-gree-7-17-groupdel命令-font"><font color='gree'>7.17 groupdel命令</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#groupdel</span> 组名</span><br></pre></td></tr></table></figure><p>使用 groupdel 命令删除群组，其实就是删除 /etc/gourp 文件和 /etc/gshadow 文件中有关目标群组的数据信息。</p><p><font color='red'>注意，不能使用 groupdel 命令随意删除群组。此命令仅适用于删除那些 “不是任何用户初始组” 的群组，</font>换句话说，如果有群组还是某用户的初始群组，则无法使用 groupdel 命令成功删除。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># useradd temp</span><br><span class="line">#运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 <span class="number">505</span>）</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;temp&quot; /etc/passwd /etc/group /etc/gshadow</span><br><span class="line">/etc/passwd:temp:x:<span class="number">505</span>:<span class="number">505</span>::/home/temp:/bin/bash</span><br><span class="line">/etc/group:temp:x:<span class="number">505</span>:</span><br><span class="line">/etc/gshadow:temp:!::</span><br><span class="line">#下面尝试删除 temp 群组</span><br><span class="line">[root@localhost ~]# groupdel temp</span><br><span class="line">groupdel:cannot remove the primary group of user <span class="string">&#x27;temp&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，groupdel 命令删除 temp 群组失败，且提示“不能删除 temp 用户的初始组”。如果一定要删除 temp 群组，要么修改 temp 用户的 GID，也就是将其初始组改为其他群组，要么先删除 temp 用户。</p></blockquote><p>胡乱地删除群组可能会给其他用户造成不小的麻烦，因此更改文件数据要格外慎重。</p><hr><h3 id="font-color-gree-7-18-gpasswd命令-font"><font color='gree'>7.18 gpasswd命令</font></h3><p>为了避免系统管理员（root）太忙碌，无法及时管理群组，可以使用 <code>gpasswd</code> 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。</p><p>gpasswd 命令的基本格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># gpasswd 选项 组名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td></td><td>选项为空时，表示给群组设置密码，仅 root 用户可用。</td></tr><tr><td>-A user1,…</td><td>将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员，仅 root 用户可用。</td></tr><tr><td>-M user1,…</td><td>将 user1,… 加入到此群组中，仅 root 用户可用。</td></tr><tr><td>-r</td><td>移除群组的密码，仅 root 用户可用。</td></tr><tr><td>-R</td><td>让群组的密码失效，仅 root 用户可用。</td></tr><tr><td>-a user</td><td>将 user 用户加入到群组中。</td></tr><tr><td>-d user</td><td>将 user 用户从群组中移除。</td></tr></tbody></table><p><font color='red'>非本用户组的用户想切换到本用户组身份时，可以通过密码保证安全性。如果没有设置组密码，则只有属于本用户组的用户能够切换到本用户组的身份。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建新群组 group1，并将群组交给 lamp 管理</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group1  &lt;-- 创建群组</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># gpasswd group1   &lt;-- 设置密码</span><br><span class="line">Changing the password for group group1</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">[root@localhost ~]# gpasswd -A lamp group1  &lt;加入群组管理员为 lamp</span><br><span class="line">[root@localhost ~]# grep <span class="string">&quot;group1&quot;</span> /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:<span class="number">506</span>:</span><br><span class="line">/etc/gshadow:group1:$<span class="number">1</span>$I5ukIY1.$o5fmW.cOsc8.K.FHAFLWg0:lamp:</span><br></pre></td></tr></table></figure><p><font color='red'>使用 <code>usermod -G</code> 命令也可以将用户加入群组，但会产生一个问题，即使用此命令将用户加入到新的群组后，该用户之前加入的那些群组都将移除该用户。例如：</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#新创建一个群组group2</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># groupadd group2</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># usermod -G group2 lamp</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># grep &quot;group2&quot; /etc/group</span><br><span class="line">group2:x:<span class="number">509</span>:lamp</span><br><span class="line">[root@localhost ~]# grep <span class="string">&quot;group1&quot;</span> /etc/group</span><br><span class="line">group1:x:<span class="number">506</span>:lamp1</span><br></pre></td></tr></table></figure><p>可以发现，虽然使用 usermod 命令成功地将 lamp 用户加入在 group2 群组中，但 lamp 用户原本在 group1 群组中，此时却被移出，这就是使用 usermod 命令造成的。因此，将用户加入或移出群组，最好使用 gpasswd 命令。</p><hr><h3 id="font-color-gree-7-19-newgrp命令-font"><font color='gree'>7.19 newgrp命令</font></h3><p>每个用户可以属于一个初始组，也可以属于多个附加组。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？</p><p><font color='red'>当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份</font>。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。</p><p>命令<code>newgrp</code>能改变用户的初始组。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># newgrp 组名</span><br></pre></td></tr></table></figure><p>使用 newgrp 命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是 newgrp 所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[yuhan@MyFirstVM tmp]</span>$ touch fuckme</span><br><span class="line"><span class="selector-attr">[yuhan@MyFirstVM tmp]</span>$ ll fuckme</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> yuhan root <span class="number">0</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">11</span> fuckme</span><br><span class="line">[yuhan@MyFirstVM tmp]$ id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1013</span>(sonofhan),<span class="number">1007</span>(shanbi)</span><br><span class="line">[yuhan@MyFirstVM tmp]$ newgrp shanbi</span><br><span class="line">[yuhan@MyFirstVM tmp]$ touch shitbro</span><br><span class="line">[yuhan@MyFirstVM tmp]$ ll shitbro</span><br><span class="line">-rw-r--r--. <span class="number">1</span> yuhan shanbi <span class="number">0</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">12</span> shitbro</span><br><span class="line">[yuhan@MyFirstVM tmp]$ id yuhan</span><br><span class="line">uid=<span class="number">1010</span>(yuhan) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1013</span>(sonofhan),<span class="number">1007</span>(shanbi)</span><br></pre></td></tr></table></figure><p><font color='red'>注意，<code>newgrp</code>不会真正改变初始组，只是在执行命令(如创建文件)时以new group的身份创建，从上面代码就可以看出。</font>1</p><p><font color='orange'>newgrp的原理：其实，newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。</font></p><p>通过添加 shell 内置命令 <code>echo $$</code> 就可以发现，每次使用 <code>newgrp</code> 命令，都会切换到一个新的进程。如果你想回到原本的环境，需要通过 <code>exit</code> 命令不断回退到当前进程的父进程，最终才能回到初始组为 group1 时的 user1 运行的 shell 中。</p><hr><h2 id="font-color-orange-8-Linux权限管理-font"><font color='orange'>8. Linux权限管理</font></h2><h3 id="font-color-gree-8-1-chgrp命令-font"><font color='gree'>8.1 chgrp命令</font></h3><p>chgrp 命令用于修改文件（或目录）的所属组。</p><p>基本格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chgrp -R 所属组 文件名（目录名）</span><br></pre></td></tr></table></figure><p>-R（注意是大写）选项表示更改连同子目录中所有文件的所属组信息。</p><hr><h3 id="font-color-gree-8-2-chown命令-font"><font color='gree'>8.2 chown命令</font></h3><p><code>chown</code> 命令主要用于修改文件（或目录）的所有者，也可以修改文件（或目录）的所属组。</p><p>当只需要修改所有者时，可使用如下 chown 命令的基本格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chown -R 所有者 文件或目录</span><br><span class="line"><span class="selector-id">#-R</span>（注意大写）选项表示连同子目录中的所有文件，都更改所有者。</span><br></pre></td></tr></table></figure><p>如果需要同时更改所有者和所属组，chown 命令的基本格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chown -R 所有者:所属组 文件或目录</span><br></pre></td></tr></table></figure><blockquote><p>chown 命令也支持单纯的修改文件或目录的所属组，例如 <code>chown :group install.log</code> 就表示修改 install.log 文件的所属组，但修改所属组通常使用 chgrp 命令，因此并不推荐大家使用 chown 命令。</p></blockquote><p><strong>通过修改文件的所有者，用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</strong></p><hr><h3 id="font-color-gree-8-3-Linux权限位-font"><font color='gree'>8.3 Linux权限位</font></h3><p>Linux常见的文件权限有 3 种，即对文件的读（r）、写（w）和执行（x，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 ll 命令即可看到。</p><blockquote><p>除此之外，<font color='red'>s（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）和 t（针对目录，任何用户都可以在此目录中创建文件，但只能删除自己的文件）</font>，文件设置 s 和 t 权限，会占用 x 权限的位置。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll readme</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> shanbi shanbi <span class="number">5</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">47</span> readme</span><br><span class="line">    </span><br><span class="line">[root@MyFirstVM tmp]# ll /bin/ls</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">117681</span> May <span class="number">26</span> <span class="number">11</span>:<span class="number">39</span> /bin/ls</span><br></pre></td></tr></table></figure><p>每行的第一大列表示的就是各文件针对不同用户设定的权限，一共  11 位 ，<strong>但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理</strong></p><p>因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符。</p><p>各权限位的含义如图：</p><p><img src="/2022/img/20220610214832.gif" alt="文件权限位"></p><p><font color='red'>Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。</font></p><p>从此图可看出，文件所有者拥有对文件的读和写权限，但是没有执行权限(对可执行文件才有执行权限)；所属群组中的用户只拥有读权限，也就是说，这部分用户只能读取文件内容，无法修改文件；其他人也是只能读取文件。</p><p><strong>rwx对文件的作用：</strong></p><table><thead><tr><th>rwx 权限</th><th>对文件的作用</th></tr></thead><tbody><tr><td>r</td><td>表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。</td></tr><tr><td>w</td><td>表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。</td></tr><tr><td>x</td><td>表示该文件具有被系统执行的权限。在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。</td></tr></tbody></table><p><font color='gree'>对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。</font></p><p><font color='cornflowerbl'>对目录来说，如果只赋予 r 权限，则此目录是无法使用的。只有 r 权限的目录，用户只能查看目录结构(查看目录中有什么文件)，无法进入目录（需要用 x 权限），更不用说使用了。</font>如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll -d /tmp</span><br><span class="line">drwxrwxrwt. <span class="number">10</span> root root <span class="number">4096</span> May <span class="number">29</span> <span class="number">09</span>:<span class="number">47</span> /tmp</span><br></pre></td></tr></table></figure><p>因此，对于目录来说，常用来设定目录的权限其实只有 0（—）、5（r-x）、7（rwx）这 3 种。</p><h3 id="font-color-gree-8-4-修改文件或目录权限（chmod）-font"><font color='gree'>8.4 修改文件或目录权限（chmod）</font></h3><p>chmod 命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。</p><p><strong>使用数字修改权限：</strong></p><p>各个权限与数字的对应关系如下：</p><p><font color='red'>r --&gt; 4   w --&gt; 2    x --&gt; 1</font></p><p>由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），<strong>通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</strong></p><blockquote><p>以 <code>rwxrw-r-x</code> 为例，所有者、所属组和其他人分别对应的权限值为：</p><p>所有者 = rwx = 4+2+1 = 7<br>所属组 = rw- = 4+2 = 6<br>其他人 = r-x = 4+1 = 5</p><p><font color='red'>所以，此权限对应的权限值就是 765。</font></p></blockquote><p>使用数字修改文件权限的 chmod 命令基本格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod -R 权限值 文件名</span><br></pre></td></tr></table></figure><p>-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p><p>例如，使用如下命令，即可完成对 .bashrc 目录文件的权限修改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod <span class="number">777</span> <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rwxrwxrwx. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br></pre></td></tr></table></figure><p><strong>使用字母修改权限：</strong></p><p><font color='red'>chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）</font>。chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。</p><p>格式：</p><p><img src="/2022/img/20220610214841.gif" alt="chmod 命令基本格式"></p><p>如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u=rwx,go=rx <span class="selector-class">.bashrc</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -al <span class="selector-class">.bashrc</span></span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">176</span> Sep <span class="number">22</span> <span class="number">2004</span> <span class="selector-class">.bashrc</span></span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-5-默认权限（umask）-font"><font color='gree'>8.5 默认权限（umask）</font></h3><p>Windows 中，新建的文件和目录时通过继承上级目录的权限获得的初始权限，而Linux是通过使用 <code>umask</code> 默认权限来给所有新建的文件和目录赋予初始权限的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0022</span></span><br></pre></td></tr></table></figure><p><em><strong><font color='red'>root用户默认是0022，普通用户默认是 0002</font></strong></em></p><p><font color='red'> umask 默认权限确实由 4 个八进制数组成，但第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）。也就是说，后 3 位数字 “022” 才是真正要用到的 umask 权限值，将其转变为字母形式为 — -w- -w-。</font></p><p><strong>虽然 umask 默认权限是用来设定文件或目录的初始权限，但并不是直接将 umask 默认权限作为文件或目录的初始权限，还要对其进行 “再加工”。</strong></p><p>文件和目录的真正初始权限，可通过以下的计算得到：</p><p><code>文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</code></p><blockquote><p><font color='orange'>按照官方的标准算法，需要将 umask 默认权限使用二进制并经过逻辑与和逻辑非运算后，才能得到最终文件或目录的初始权限，计算过程比较复杂，且容易出错，用上面的计算更方便</font></p><p>以二进制方式换算：</p><p>先将最大默认权限（目录777，文件666）和umask值都转换为2进制，然后对umask取反，再将两个二进制值做与运算，得到的二进制值再转换十进制，即为权限，</p></blockquote><p><strong>最大默认权限：</strong></p><p>在 Linux 系统中，文件和目录的最大默认权限是不一样的：</p><ul><li><font color='orange'>对文件来讲，其可拥有的最大默认权限是 666</font>，即 rw-rw-rw-。也就是说，使用文件的任何用户都没有执行（x）权限。原因很简单，<font color='red'>执行权限是文件的最高权限</font>，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。</li><li><font color='orange'>对目录来讲，其可拥有的最大默认权限是 777</font>，即 rwxrwxrwx。</li></ul><p>以 umask 值为 022 为例，分别计算新建文件和目录的初始权限：</p><ul><li><p><font color='red'>文件的最大默认权限是 666</font>，<font color='orange'>换算成字母</font>就是 “-rw-rw-rw-”，umask 的值是 022，换算成字母为 “-----w–w-”。把两个字母权限相减，得到 (-rw-rw-rw-) - (-----w–w-) = (-rw-r–r–)，这就是新建文件的初始权限。我们测试一下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0022</span></span><br><span class="line">\#默认umask的值是<span class="number">0022</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch file &lt;--新建file空文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -d file</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">0</span> Apr <span class="number">18</span> <span class="number">02</span>:<span class="number">36</span> file</span><br></pre></td></tr></table></figure></li><li><p><font color='red'>目录的默认权限最大可以是 777</font>，<font color='orange'>换算成字母</font>就是 “drwxrwxrwx”，umask 的值是 022，也就是 “-----w–w-”。把两个字母权限相减，得到的就是新建目录的默认权限，即 (drwxrwxrwx) - (-----w–w-) = (drwxr-xr-x)。我们再来测试一下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line">  <span class="number">0022</span></span><br><span class="line">  <span class="selector-attr">[root@localhost ~]</span># mkdir catalog &lt;--新建catalog目录</span><br><span class="line">  <span class="selector-attr">[root@localhost ~]</span># ll -d catalog</span><br><span class="line">  drwxr-xr-x. <span class="number">2</span> root root <span class="number">4096</span> Apr <span class="number">18</span> <span class="number">02</span>:<span class="number">36</span> catalog</span><br></pre></td></tr></table></figure></li></ul><p><em><strong><font color='red'>注意！必须要换算成字母再相减！！</font></strong></em></p><blockquote><p>例如，若 umask 默认权限的值为 033，按照数字形式计算文件的初始权限，666-033=633，但我们按照字母的形式计算会得到 （rw-rw-rw-) - (----wx-wx) = (rw-r–r–)，换算成数字形式是 644。</p></blockquote><blockquote><p>这里的减法，其实是“遮盖”的意思，也就是说，最大默认权限中和 umask 权限公共的部分，通过减法运算会被遮盖掉，最终剩下的“最大默认权限”，才是最终赋予文件或目录的初始权限。</p></blockquote><p><strong>修改umask：</strong></p><p>可以通过如下命令直接修改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask <span class="number">002</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0002</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask <span class="number">033</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># umask</span><br><span class="line"><span class="number">0033</span></span><br></pre></td></tr></table></figure><p>不过，这种方式只是临时有效，一旦重启或重新登陆系统，就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件 /etc/profile。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># vim /etc/profile</span><br><span class="line">...省略部分内容...</span><br><span class="line">if <span class="selector-attr">[ $UID -gt 199]</span>&amp;&amp;<span class="selector-attr">[ <span class="string">&quot;&#x27;id -gn&#x27;&quot;</span> = <span class="string">&quot;&#x27;id -un&#x27;&quot;</span> ]</span>; then</span><br><span class="line">  umask <span class="number">002</span></span><br><span class="line">  \#如果UID大于<span class="number">199</span>（普通用户），则使用此umask值</span><br><span class="line">else</span><br><span class="line">  umask <span class="number">022</span></span><br><span class="line">  \#如果UID小于<span class="number">199</span>（超级用户），则使用此umask值</span><br><span class="line">fi</span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-6-ACL权限-font"><font color='gree'>8.6 ACL权限</font></h3><p><strong><font color='red'>ACL，是 Access Control List（访问控制列表）的缩写，在 Linux 系统中， ACL 可实现对单一用户设定访问文件的权限。</font></strong></p><blockquote><p>若有一个 /project 目录，这是班级的项目目录。班级中的每个学员都可以访问和修改这个目录，老师需要拥有对该目录的最高权限，其他班级的学员当然不能访问这个目录。</p><p>可如此划分权限：老师使用 root 用户，作为这个目录的属主，权限为 rwx；班级所有的学员都加入 tgroup 组，使 tgroup 组作为 /project 目录的属组，权限是 rwx；其他人的权限设定为 0（也就是 —）。</p><p>有一天，班里来了一位试听的学员 st，她必须能够访问 /project 目录，所以必须对这个目录拥有 r 和 x 权限；但是她又没有学习过以前的课程，所以不能赋予她 w 权限，怕她改错了目录中的内容，所以学员 st 的权限就是 r-x。可是如何分配她的身份呢？变为属主？当然不行，要不 root 该放哪里？加入 tgroup 组？也不行，因为 tgroup 组的权限是 rwx，而我们要求学员 st 的权限是 r-x。如果把其他人的权限改为 r-x 呢？这样一来，其他班级的所有学员都可以访问 /project 目录了。</p><p>显然，普通权限的三种身份不够用了，无法实现对某个单独的用户设定访问权限，这种情况下，就需要使用 ACL 访问控制权限。</p></blockquote><p><strong>开启ACL权限：</strong></p><p>CentOS 6.x 系统中，ACL 权限默认处于开启状态，无需手工开启。但如果你的操作系统不是 CentOS 6.x，可以通过如下方式查看ACL权限是否开启：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># mount</span><br><span class="line">/dev/sda1 on /boot type ext4 (rw)</span><br><span class="line">/dev/sda3 on <span class="selector-tag">I</span> type ext4 (rw)</span><br><span class="line">…省略部分输出…</span><br><span class="line">\<span class="selector-id">#dumpe2fs</span>是查询指定分区文件系统详细信息的命令</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># dumpe2fs -h /dev/sda3</span><br><span class="line">…省略部分输出…</span><br><span class="line">Default mount options: user_xattr acl</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><p>可以看到，ACL 权限是 /dev/sda3 分区的默认挂载选项，所以不需要手工挂载。</p><p>如果 Linux 系统如果没有默认挂载，可以执行如下命令实现手动挂载：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mount -o remount,acl /</span><br><span class="line">\#重新挂载根分区，并加入ACL权限</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-7-设定ACL权限-font"><font color='gree'>8.7 设定ACL权限</font></h3><p>设定 ACl 权限，常用命令有 2 个，分别是 <code>setfacl</code> 和 <code>getfacl</code> 命令，前者用于给指定文件或目录设定 ACL 权限，后者用于查看是否配置成功。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># getfacl 文件名</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># setfacl 选项 文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-m</td><td>设定 ACL 权限。如果是给予用户 ACL 权限，参数则使用 <code>u:用户名:权限</code> 的格式，例如 <code>setfacl -m u:st:rx /project</code> 表示设定 st 用户对 project 目录具有 rx 权限；如果是给予组 ACL 权限，参数则使用 “g:组名:权限” 格式，例如 <code>setfacl -m g:tgroup:rx /project</code> 表示设定群组 tgroup 对 project 目录具有 rx 权限；<code>setfacl -m m:rx /project</code>表示设定mask值为r-x</td></tr><tr><td>-x</td><td>删除指定用户（参数使用 <code>u:用户名</code>）或群组（参数使用 <code>g:群组名</code>）的 ACL 权限，例如 <code>setfacl -x u:st /project</code> 表示删除 st 用户对 project 目录的 ACL 权限。</td></tr><tr><td>-b</td><td>删除所有的 ACL 权限，例如 <code>setfacl -b /project</code> 表示删除有关 project 目录的所有 ACL 权限。</td></tr><tr><td>-d</td><td>设定默认 ACL 权限，命令格式为 “<code>setfacl -m d:u:用户名:权限 文件名</code>”（如果是群组，则使用 <code>d:g:群组名:权限</code>），只对目录生效，指目录中新建立的文件拥有此默认权限，例如 <code>setfacl -m d:u:st:rx /project</code> 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。</td></tr><tr><td>-R</td><td>递归设定 ACL 权限，指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 “<code>setfacl -m u:用户名:权限 -R 文件名</code>”（群组使用 g:群组名:权限），例如 <code>setfacl -m u:st:rx -R /project</code> 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。</td></tr><tr><td>-k</td><td>删除默认 ACL 权限。</td></tr></tbody></table><p>给用户组设置ACL权限：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># touch textbook</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll textbook</span><br><span class="line">-rw-r<span class="attr">--r--</span>. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">15</span>:<span class="number">55</span> textbook</span><br><span class="line">[root@MyFirstVM tmp]# setfacl -m g:myson:rwx /tmp/textbook</span><br><span class="line">[root@MyFirstVM tmp]# ll textbook</span><br><span class="line">-rw-rwxr--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">15</span>:<span class="number">55</span> textbook</span><br><span class="line">#查询时会发现，在权限位后面多了一个<span class="string">&quot;+&quot;</span>，表示此目录拥有ACL权限</span><br></pre></td></tr></table></figure><p>给用户设置ACL权限：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m u:myson:r-x /tmp/textbook</span><br><span class="line">[root@MyFirstVM tmp]# getfacl textbook</span><br><span class="line"># file: textbook</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">user:myson:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:myson:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><p><strong>默认ACL权限：</strong></p><p>若对某个目录设定了 ACL 权限，那么，如果在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？执行以下命令进行验证：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#假设已经对project目录设定了ACL权限</span><br><span class="line"><span class="selector-attr">[root@localhost /]</span># cd project</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span># touch abc</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span># mkdir d1</span><br><span class="line">\#在/project目录中新建了abc文件和d1目录</span><br><span class="line"><span class="selector-attr">[root@localhost project]</span><span class="selector-id">#ll</span></span><br><span class="line">总用量<span class="number">4</span></span><br><span class="line">-rw-r<span class="attr">--r--</span> <span class="number">1</span> root root <span class="number">01</span>月<span class="number">19</span> <span class="number">05</span>:<span class="number">20</span> abc</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root <span class="number">4096</span> <span class="number">1</span>月<span class="number">19</span> <span class="number">05</span>:<span class="number">20</span> d1</span><br></pre></td></tr></table></figure><p>可以看到，这两个新建立的文件权限位后面并没有 “+”，表示它们没有继承 ACL 权限。这说明，后建立的子文件或子目录，并不会继承父目录的 ACL 权限。</p><p><strong>默认 ACL 权限的作用是，如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。<font color='red'>需要注意的是，默认 ACL 权限只对目录生效。</font></strong></p><p>如下设置默认ACL权限：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># mkdir demo</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m d:u:myson:rwx demo  #别忘了u之前还有d:</span><br><span class="line">[root@MyFirstVM tmp]# touch ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll ./demo/pro</span><br><span class="line">-rw-rw-r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> ./demo/pro</span><br></pre></td></tr></table></figure><p>可见，demo目录下的pro文件也对用户myson有ACL权限</p><p><strong>递归设置ACL权限 ：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># mkdir aha</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># touch ./aha/shit</span><br><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m u:myson:rwx -R /tmp/aha/</span><br><span class="line">[root@MyFirstVM tmp]# ll ./aha/shit</span><br><span class="line">-rw-rwxr--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">23</span> ./aha/shit</span><br></pre></td></tr></table></figure><p><strong>先创建aha目录，接着在aha中创建shit文件，然后再修改aha目录的ACL权限，发现shit也具有了ACL权限。设置默认ACL权限不同于设置递归ACL权限，前者是先设置了目录的ACL权限后，而后在其中创建的文件也具有相应权限；而后者是目录和文件都已经建好后再设置ACL权限</strong></p><p><strong>删除指定的ACL权限 -x：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setfacl -x u:myson ./aha/shit</span><br><span class="line">[root@MyFirstVM tmp]# ll  ./aha/shit</span><br><span class="line">-rw-r--r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">23</span> ./aha/shit</span><br><span class="line">[root@MyFirstVM tmp]# getfacl ./aha/shit</span><br><span class="line"># file: aha/shit</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><p><strong>删除指定文件的所有ACL权限 -b：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># ll demo/pro</span><br><span class="line">-rw-rw-r--+ <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# setfacl -b ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll demo/pro</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# ll demo</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">0</span> May <span class="number">29</span> <span class="number">16</span>:<span class="number">13</span> pro</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-8-mask有效权限-font"><font color='gree'>8.8 mask有效权限</font></h3><p><strong>mask 权限，指的是用户或群组能拥有的最大 ACL 权限，也就是说，给用户或群组设定的 ACL 权限不能超过 mask 规定的权限范围，超出部分做无效处理。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost /]</span># getfacl project</span><br><span class="line"><span class="selector-id">#file</span>: project  &lt;-文件名</span><br><span class="line">#owner: root    &lt;-文件的属主</span><br><span class="line">#group: tgroup  &lt;-文件的属组</span><br><span class="line">user::rwx       &lt;-用户名栏是空的，说明是所有者的权限</span><br><span class="line">group::rwx      &lt;-组名栏是空的，说明是所属组的权限</span><br><span class="line">other::---      &lt;-其他人的权限</span><br><span class="line">[root@localhost ~]# setfacl -m u:st:rx /project</span><br><span class="line">#给用户st设定针对project目录的rx权限</span><br><span class="line">[root@localhost /]# getfacl project</span><br><span class="line">#file: project </span><br><span class="line">#owner: root</span><br><span class="line">#group: tgroup </span><br><span class="line">user::rwx </span><br><span class="line">user:st:r-x     #&lt;-用户 st 的权限</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx       #&lt;-mask 权限</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><p>对比添加 ACL 权限前后 getfacl 命令的输出信息，后者多了 2 行信息，一行是我们对 st 用户设定的 r-x 权限，另一行就是 mask 权限。</p><p><font color='gree'>给 st 用户赋予访问 project 目录的 r-x 权限，此时并不能说明 st 用户就拥有了对该目录的读和访问权限，还需要和 mask 权限对比，r-x 确实是在 rwx 范围内，这时才能说 st 用户拥有 r-x 权限。</font></p><blockquote><p>需要注意的是，这里将权限进行对比的过程，实则是将两权限做“按位相与”运算，最终得出的值，即为 st 用户有效的 ACL 权限。这里以读（r）权限为例，做相<font color='red'>与</font>操作的结果如下所示：</p><table><thead><tr><th>A</th><th>B</th><th>and</th></tr></thead><tbody><tr><td>r</td><td>r</td><td>r</td></tr><tr><td>r</td><td>-</td><td>-</td></tr><tr><td>-</td><td>r</td><td>-</td></tr><tr><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>其实是进行掩码运算，mask翻译过来就是掩码。</p></blockquote><p>但是，如果把 mask 权限改为 r–，再和 st 用户的权限 r-x 比对（r-- 和 r-w 做与运算），由于 r-w 超出 r-- 的权限范围，因此 st 用户最终只有 r 权限，手动赋予的 w 权限无效。这就是在设定 ACL 权限时 mask 权限的作用。</p><p>mask 权限可以使用 setfacl 命令手动更改，比如，更改 project 目录 mask 权限值为 r-x，可执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># setfacl -m m:rx /project</span><br><span class="line">#设定mask权限为r-x，使用<span class="string">&quot;m:权限&quot;</span>格式</span><br><span class="line">[root@localhost ~]# getfacl /project</span><br><span class="line">#file：project</span><br><span class="line">#owner：root</span><br><span class="line">#group：tgroup</span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::r-x &lt;--mask权限变为r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><blockquote><p>不过，我们一般不更改 mask 权限，只要赋予 mask 最大权限（也就是 rwx），则给用户或群组设定的 ACL 权限本身就是有效的。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@MyFirstVM tmp]</span># setfacl -m m:rw ./demo/pro</span><br><span class="line">[root@MyFirstVM tmp]# getfacl ./demo/pro</span><br><span class="line"># file: demo/pro</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">user:myson:rwx#effective:rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><p>虽然user:myson的权限还是rwx，但其后的<code>effective:rw-</code>才表示myson的实际权限。</p><hr><h3 id="font-color-gree-8-9-SetUID-SUID-font"><font color='gree'>8.9 SetUID(SUID)</font></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root <span class="number">22984</span> Jan <span class="number">7</span> <span class="number">2007</span> /usr/bin/passwd</span><br></pre></td></tr></table></figure><p>可以看到，原本表示文件 所有者 权限中的 x 权限位，却出现了 s 权限，此种权限通常称为 SetUID，简称 SUID 特殊权限。</p><p><font color='orange'>SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。</font></p><p>Linux 系统中所有用户的密码数据都记录在 /etc/shadow 这个文件中，通过 ll /etc/shadow 命令可以看到，此文件的权限是 0（---------），也就是说，普通用户对此文件没有任何操作权限。</p><p>这就会产生一个问题，为什么普通用户可以使用 passwd 命令修改自己的密码呢？</p><p>本节开头已经显示了 passwd 命令的权限配置，可以看到，此命令拥有 SUID 特殊权限，而且其他人对此文件也有执行权限，<font color='red'>这就意味着，任何一个用户都可以用文件所有者，也就是 root 的身份去执行 passwd 命令。</font></p><p>换句话说，<font color='red'>当普通用户使用 passwd 命令尝试更改自己的密码时，实际上是在以 root 的身份执行passwd命令，正因为 root 可以将密码写入 /etc/shadow 文件，所以普通用户也能做到。只不过，一旦命令执行完成，普通用户所具有的 root身份也随之消失。</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u-s /usr/bin/passwd</span><br><span class="line">#属主取消SetUID权限</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/passwd</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root <span class="number">30768</span> Feb <span class="number">22</span> <span class="number">2012</span> /usr/bin/passwd</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># su - lamp</span><br><span class="line"><span class="selector-attr">[lamp@localhost ~]</span>$ passwd</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">Changing password for user.</span><br><span class="line">(current) UNIX password:</span><br><span class="line">#看起来没有什么问题</span><br><span class="line">New passwor:</span><br><span class="line">Retype new password:</span><br><span class="line">password:Authentication token manipulation error  &lt;--鉴定令牌操作错误</span><br><span class="line">#最后密码没有生效</span><br></pre></td></tr></table></figure><p>显然，虽然用户有执行 passwd 命令的权限，但无修改 /etc/shadow 文件的权限，因此最终密码修改失败。</p><p>由此，我们可以总结出，SUID 特殊权限具有如下特点：</p><ul><li>只有可执行文件才能设定 SetUID 权限，对目录设定 SUID，是无效的。</li><li>用户要对该文件拥有 x（执行）权限。</li><li>用户在执行该文件时，会以文件所有者的身份执行。</li><li>SetUID 权限只在文件执行过程中有效，一旦执行完毕，身份的切换也随之消失。</li></ul><p><font color='red'>SetUID权限设置不当，会给 Linux 系统造成重大安全隐患</font></p><p>如果我们手动给默认无 SetUID 权限的系统命令赋予 SetUID 权限，会出现什么情况呢？</p><p>尝试给 Vim 赋予 SetUID 权限：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chmod u+s /usr/bin/vim</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/vim</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root <span class="number">1847752</span> Apr <span class="number">5</span> <span class="number">2012</span> /usr/bin/vim</span><br></pre></td></tr></table></figure><p>此时你会发现，即便是普通用户使用 vim 命令，都会暂时获得 root 的身份和权限，例如，很多原本普通用户不能查看和修改的文件，竟然可以查看了，以 /etc/passwd 和 /etc/shadow 文件为例，普通用户也可以将自己的 UID 手动修改为 0，这意味着，此用户升级成为了超级用户。除此之外，普通用户还可以修改例如 /etc/inittab 和 /etc/fstab 这样重要的系统文件，可以轻易地使系统瘫痪。</p><hr><h3 id="font-color-gree-8-10-SetGID-SGID-font"><font color='gree'>8.10 SetGID(SGID)</font></h3><p>当 s 权限位于所属组的 x 权限位时，就被称为 SetGID，简称 SGID 特殊权限。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll /usr/bin/locate</span><br><span class="line">-rwx<span class="attr">--s--x</span>. <span class="number">1</span> root slocate <span class="number">35612</span> <span class="number">8</span>月<span class="number">24</span> <span class="number">2010</span> /usr/bin/locate</span><br></pre></td></tr></table></figure><p>与 SUID 不同的是，SGID 既可以对文件进行配置，也可以对目录进行配置。</p><p><strong>SGID对文件的作用：</strong></p><p>同 SUID 类似，对于文件来说，SGID 具有如下几个特点：</p><ul><li><font color='red'>SGID 只针对可执行文件有效</font></li><li>用户需要对此可执行文件有 x 权限；</li><li>用户在执行具有 SGID 权限的可执行文件时，用户的群组身份会变为文件所属群组；</li><li>SGID 权限赋予用户改变组身份的效果，只在可执行文件运行过程中有效；</li></ul><blockquote><p>其实，SGID 和 SUID 的不同之处就在于，SUID 赋予用户的是文件所有者的权限，而 SGID 赋予用户的是文件所属组的权限</p></blockquote><p><strong>SGID对目录的作用：</strong></p><p><font color='red'>当一个目录被赋予 SGID 权限后，进入此目录的普通用户，其有效群组会变为该目录的所属组，会就使得用户在创建文件（或目录）时，该文件（或目录）的所属组将不再是用户的所属组，而使用的是目录的所属组。</font></p><p>也就是说，只有当普通用户对具有 SGID 权限的目录有 rwx 权限时，SGID 的功能才能完全发挥。比如说，如果用户对该目录仅有 rx 权限，则用户进入此目录后，虽然其有效群组变为此目录的所属组，但由于没有 w 权限，用户无法在目录中创建文件或目录，SGID 权限也就无法发挥它的作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># cd /tmp</span><br><span class="line">#进入临时目录做此实验。因为只有临时目录才允许普通用户修改</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># mkdir dtest</span><br><span class="line">#建立测试目录</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># chmod g+s dtest</span><br><span class="line">#给测试目录赋予SetGID权限</span><br><span class="line"><span class="selector-attr">[root@localhost tmp]</span># ll -d dtest</span><br><span class="line">drwxr-sr-x <span class="number">2</span> root root <span class="number">4096</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">04</span> dtest</span><br><span class="line">#SetGID权限已经生效</span><br><span class="line">[root@localhost tmp]# chmod <span class="number">777</span> dtest</span><br><span class="line">#给测试目录赋予<span class="number">777</span>权限，让普通用户可以写</span><br><span class="line">[root@localhost tmp]# su - lamp</span><br><span class="line">[lamp@localhost ~]# grep lamp /etc/passwd /etc/group</span><br><span class="line">/etc/passwd:lamp:x:<span class="number">501</span>:<span class="number">501</span>::/home/lamp:/bin/bash</span><br><span class="line">/etc/group:lamp:x:<span class="number">501</span>:</span><br><span class="line">#切换成普通用户lamp，此用户的所属群组为 lamp</span><br><span class="line">[lamp@localhost ~]$ cd /tmp/dtest/</span><br><span class="line">#普通用户进入测试目录</span><br><span class="line">[lamp@localhost dtest]$ touch abc</span><br><span class="line">[lamp@localhost dtest]$ mkdir zimulu</span><br><span class="line">#在此目录中创建新的文件 abc 和子目录 zimulu</span><br><span class="line">[lamp@localhost dtest]$ ll</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> lamp root <span class="number">0</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">07</span> abc</span><br><span class="line">drwxrwsr-x. <span class="number">2</span> lamp root <span class="number">40</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">07</span> zimulu</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-11-Stick-BIT（SBIT）-font"><font color='gree'>8.11 Stick BIT（SBIT）</font></h3><p><strong>SBIT 权限仅对目录有效，一旦目录设定了 SBIT 权限，则用户在此目录下创建的文件或目录，就只有自己和 root 才有权利修改或删除该文件。</strong></p><p>Linux 系统中，<font color='orange'>存储临时文件的 /tmp 目录就设定有 SBIT 权限：</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll -d /tmp</span><br><span class="line">drwxrwxrwt. <span class="number">4</span> root root <span class="number">4096</span> Apr <span class="number">19</span> <span class="number">06</span>:<span class="number">17</span> /tmp</span><br></pre></td></tr></table></figure><hr><h3 id="font-color-gree-8-12-特殊权限的值与设置-font"><font color='gree'>8.12 特殊权限的值与设置</font></h3><p>给文件或目录设定特殊权限，只需在这 3 个数字之前增加一个数字位，用来放置给文件或目录设定的特殊权限</p><p>SUID、SGID、SBIT 分别对应的数字，如下所示：</p><p>4 --&gt; SUID<br>2 --&gt; SGID<br>1 --&gt; SBIT</p><p>如果要将一个文件权限设置为 <code>-rwsr-xr-x</code>，怎么办呢？此文件的普通权限为 755，另外，此文件还有 SUID 权限，因此只需在 755 的前面，加上 SUID 对应的数字 4 即可。也就是说，只需执行<code>chmod 4755 文件名</code>命令，就完成了<code>-rwsr-xr-x</code> 权限的设定。</p><blockquote><p>关于 -rwsr-xr-x 的普通权限是 755，你可以这样理解，标记有 s 和 t 的权限位，隐藏有 x 权限</p></blockquote><p>同样的道理，如果某文件拥有 SUID 和 SGID 权限，则只需要给 chmod 命令传递 6—（- 表示数字）即可；如果某目录拥有 SGID 和 SBIT，只需要给 chmod 命令传递 3— 即可。</p><p>注意，不同的特殊权限，作用的对象是不同的，<font color='red'>SUID 只对可执行文件有效；SGID 对可执行文件和目录都有效；SBIT 只对目录有效。</font></p><p>除了赋予 chmod 命令 4 个数字设定特殊权限，还可以使用字母的形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span><span class="selector-id">#chmod</span> u+s, g+s, o+t ftest</span><br><span class="line">\#设置特殊权限</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># ll ftest</span><br><span class="line">-rwsr-sr-t. <span class="number">1</span> root root Apr <span class="number">19</span> <span class="number">23</span>:<span class="number">54</span> ftest</span><br><span class="line">[root@localhost ~]# chmod u-s, g-s, o-t ftest</span><br><span class="line">\#取消特殊权限</span><br><span class="line">[root@localhost ~]# ll ftest</span><br><span class="line">-rwxr-xr-x. <span class="number">1</span> root root Apr <span class="number">19</span> <span class="number">23</span>:<span class="number">54</span> ftest</span><br></pre></td></tr></table></figure><p>使用 chmod 命令给文件或目录赋予特殊权限时，原文件或目录中存在的 x 权限会被替换成 s 或 t，而当我们使用 chmod 命令消除文件或目录的特殊权限时，原本消失的 x 权限又会显现出来。<font color='red'>这是因为，无论是 SUID、SGID 还是 SBIT，它们只针对具有 x 权限的文件或目录有效</font>。没有 x 权限的文件或目录，即便赋予特殊权限，也无法发挥它们的功能，没有任何意义。</p><hr><h3 id="font-color-gree-8-13-修改文件系统的权限属性chattr-font"><font color='gree'>8.13 修改文件系统的权限属性chattr</font></h3><p>chattr 命令，专门用来修改文件或目录的隐藏属性，<font color='red'>只有 root 用户可以使用</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr <span class="selector-attr">[+-=]</span> <span class="selector-attr">[属性]</span> 文件或目录名</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性选项</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># touch ftest</span><br><span class="line">\#建立测试文件</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr +<span class="selector-tag">i</span> ftest</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf ftest</span><br><span class="line">rm:cannot remove <span class="string">&#x27;ftest&#x27;</span>:Operation not permitted</span><br><span class="line">\#无法删除<span class="string">&quot;ftesr&quot;</span>，操作不允许</span><br><span class="line">\#被赋予i属性后，root不能删除</span><br><span class="line">[root@localhost ~]# echo <span class="number">111</span>&gt;&gt;ftest</span><br><span class="line">bash:ftest:Permission denied</span><br><span class="line">\#权限不够，不能修改文件中的数据</span><br></pre></td></tr></table></figure><p>可以看到，设置有 i 属性的文件，即便是 root 用户，也无法删除和修改数据。</p><p>演示 a 属性的作用。假设有这样一种应用，我们每天自动实现把服务器的日志备份到指定目录，备份目录可设置 a 属性，变为只可创建文件而不可删除。命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># mkdir -<span class="selector-tag">p</span> /back/log</span><br><span class="line">\#建立备份目录</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># chattr +<span class="selector-tag">a</span> /back/log</span><br><span class="line">\#赋予<span class="selector-tag">a</span>属性</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># cp /<span class="selector-tag">var</span>/log/messages /back/log</span><br><span class="line">\#可以复制文件和新建文件到指定目录中</span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># rm -rf /back/log/messages</span><br><span class="line">rm: cannot remove <span class="string">&#x27;/back/log/messages&#x27;</span>: Permission denied</span><br><span class="line">\#无法删除 /back/log/messages，操作不允许</span><br></pre></td></tr></table></figure><p>注意，通常情况下，不要使用 chattr 命令修改 /、/dev/、/tmp/、/var/ 等目录的隐藏属性，很容易导致系统无法启动。另外，chatrr 命令常与 lsattr 命令合用，前者修改文件或目录的隐藏属性，后者用于查看是否修改成功。</p><hr><h3 id="font-color-gree-8-14-查看文件系统属性lasttr-font"><font color='gree'>8.14 查看文件系统属性lasttr</font></h3><p>使用 chattr 命令配置文件或目录的隐藏属性后，可以使用 lsattr 命令查看。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># lsattr <span class="selector-attr">[选项]</span> 文件或目录名</span><br></pre></td></tr></table></figure><p>常用选项有以下 3 种：</p><ul><li>-a：后面不带文件或目录名，表示显示所有文件和目录（包括隐藏文件和目录）</li><li>-d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息；</li><li>-R：和 -d 恰好相反，作用于目录时，会连同子目录的隐藏信息数据也一并显示出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
